---
title: 阻塞队列的低版本实现
date: 2017-12-28 20:14:00
updated: 2017-12-28 20:14:00
comments: true
tags:
  - 阻塞队列
categories: 
  - [技术总结, java拾遗]
comments: true
permalink: current/1.html    
---

在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  

```java
public class SimulateBlockingQueue {

    // 底层队列
    private LinkedList list = new LinkedList();

    // 队列数据的上下限
    private final int minSize = 0;
    private final int maxSize;

    public SimulateBlockingQueue(int size) {
        this.maxSize = size - 1;
    }

    private Object lock = new Object();

    /**
     * 存数据
     * @param obj
     */
    public void put(Object obj) {
        synchronized (lock) {
            while (list.size() == this.maxSize) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            list.add(obj);
            lock.notify();
        }
    }

    /**
     * 取数据
     * @return
     */
    public Object get() {
        Object result = null;
        synchronized (lock) {
            while (list.size() == this.minSize) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            result = list.removeFirst();
            lock.notify();
        }
        return result;
    }

    public int getSize() {
        return list.size();
    }

    public static void main(String[] args) throws InterruptedException {
        final SimulateBlockingQueue mq = new SimulateBlockingQueue(5);

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    mq.put(i);
                    System.out.println("++增加：" + i);
                }
            }
        }, "t1");
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    System.out.println("移除：" + mq.get());
                }
            }
        }, "t2");
        t2.start();

        TimeUnit.SECONDS.sleep(2);
    }

}
```

最后发现不是 list.size() 的问题，是打印的问题，代码改为如下：

```java
public class SimulateBlockingQueue {

    // 底层队列
    private LinkedList list = new LinkedList();
    // 原子性
    private AtomicInteger count = new AtomicInteger(0);

    // 队列数据的上下限
    private final int minSize = 0;
    private final int maxSize;


    public SimulateBlockingQueue(int size) {
        this.maxSize = size;
    }

    private Object lock = new Object();

    /**
     * 存数据
     * @param obj
     */
    public void put(Object obj) {
        synchronized (lock) {
            while (list.size() == this.maxSize) {  // 对比可以使用count
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("++++增加：" + obj);
            list.add(obj);
            count.incrementAndGet();
            lock.notify();
        }
    }

    /**
     * 取数据
     * @return
     */
    public Object get() {
        Object result;
        synchronized (lock) {
            while (list.size() == this.minSize) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            result = list.removeFirst();
            System.out.println("--移除：" + result);
            count.decrementAndGet();
            lock.notify();
        }
        return result;
    }

    public int getSize() {
        return list.size();
    }

    public static void main(String[] args) throws InterruptedException {
        final SimulateBlockingQueue mq = new SimulateBlockingQueue(5);

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    mq.put(i);
                }
            }
        }, "t1");
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    mq.get();
                }
            }
        }, "t2");
        t2.start();

        TimeUnit.SECONDS.sleep(2);
    }

}
```

思路来源：https://www.jianshu.com/p/99b7ef411988
