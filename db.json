{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"9e354be53476f1fbf4d5c54a83078088472299c0","modified":1510061204000},{"_id":"source/CNAME","hash":"d49ded439c8fabfd7ed19d0e56263eca19fd118b","modified":1510061050000},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1541037363000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1541037363000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1541037363000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1541037363000},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1541037363000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1541037363000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1541037363000},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1541037363000},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1541037363000},{"_id":"themes/next/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1541037363000},{"_id":"themes/next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1541037363000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1541037363000},{"_id":"themes/next/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1541037363000},{"_id":"themes/next/_config.yml","hash":"858a8c120b353745252469cbfe23b6ef9e9ecfdc","modified":1542651139843},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1541037363000},{"_id":"source/_posts/.DS_Store","hash":"8bccfc93edee1568aba3512cdee6f4f82a695c3a","modified":1510664156000},{"_id":"source/about/index.md","hash":"a02a541e41067e3b082f59e983f7db38844ae944","modified":1529329206728},{"_id":"source/categories/index.md","hash":"0db94b600dcd8a14496185aa7d2a3e3ffb1aeb7e","modified":1510056192000},{"_id":"source/images/favicon.ico","hash":"644430fb12f363b263e68dee20d44ce4ac15b2f0","modified":1542639709489},{"_id":"source/images/avatar.gif","hash":"27e387f550419bc4978675f50725b9a9801c08c1","modified":1542639709489},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1541037363000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1541037363000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1541037363000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1541037363000},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1541037363000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1541037363000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1541037363000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1541037363000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1541037363000},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1541037363000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1541037363000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1541037363000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1541037363000},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1541037363000},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1541037363000},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1541037363000},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1541037363000},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1541037363000},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1541037363000},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1541037363000},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1541037363000},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1541037363000},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1541037363000},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1541037363000},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1541037363000},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1541037363000},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1541037363000},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1541037363000},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1541037363000},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1541037363000},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1541037363000},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1541037363000},{"_id":"themes/next/layout/_layout.swig","hash":"85de0662a1b136277a72f8d8b4b1425a006f377e","modified":1541037363000},{"_id":"themes/next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1541037363000},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1541037363000},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1541037363000},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1541037363000},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1541037363000},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1541037363000},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1541037363000},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1541037363000},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1541037363000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1541037363000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1541037363000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1541037363000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1541037363000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"source/_posts/Java 并发编程的艺术/第五章 Java中的锁.md","hash":"447aaa8d21621f3d7663c7a7800ec093f06567d6","modified":1542643829871},{"_id":"source/_posts/Java 并发编程的艺术/第八章 Java中的并发工具类.md","hash":"417b5d646121cca4b86120647a8879eb10314fe3","modified":1542643845704},{"_id":"source/_posts/Java 并发编程的艺术/第六章 Java并发容器和框架.md","hash":"3318cbd684d707c31f86ff5f76c03193c486a998","modified":1542643850028},{"_id":"source/_posts/Java 并发编程的艺术/第四章 Java并发编程基础.md","hash":"742d19881480ad7e4586eb2440f1c94a990e365b","modified":1542644092099},{"_id":"source/_posts/Java性能权威指南/第九章 线程与同步的性能.md","hash":"cd68d4c944e30c4de6a985d4bed0f16206332057","modified":1516294769642},{"_id":"source/_posts/Java性能权威指南/第三_四章 Java 性能调优工具箱.md","hash":"acb916271841c60971ee42d92fac2fccfd872793","modified":1515753587806},{"_id":"source/_posts/Java性能权威指南/第二章 性能测试方法.md","hash":"d0c9402692ecba6df31b31ebc62c91a70a80bd06","modified":1515510630261},{"_id":"source/_posts/Java性能权威指南/第五章 垃圾收集入门.md","hash":"d7d5cdee1663925f1f39bfbccc6b7dd2724f8282","modified":1516121377874},{"_id":"source/_posts/Linux命令行与shell脚本编程大全/第一部分 bash shell 命令.md","hash":"520236ca7bca02070b33317b572df43b841da2ae","modified":1526484414416},{"_id":"source/_posts/Linux命令行与shell脚本编程大全/第二部分 shell 脚本.md","hash":"84ee8361e5a327d8b87b32edec1366dcb8121487","modified":1526484021816},{"_id":"source/_posts/Java 拾遗/1_ConcurrentHashMap.md","hash":"c990597afb4ef44fafd29e8d5ae0dec68f436fc9","modified":1523555188141},{"_id":"source/_posts/Java 拾遗/2_Servlet_Filter_Listener.md","hash":"c95591e273ea4e7822bb795fdda31f9b5531566d","modified":1523555191862},{"_id":"source/_posts/Java 拾遗/3_ThreadLocal.md","hash":"f6abebbdb3370af84782f60a17799d1ed7fc130b","modified":1526484189347},{"_id":"source/_posts/Netty实战/Netty实战笔记.md","hash":"1531e31f63a7c561dd17132f0f51a9f047a1d012","modified":1514392203736},{"_id":"source/_posts/Java 拾遗/4_JVM_1.md","hash":"9d4d0c9011f8709fbc6d9ad11ab5b0dbca600fab","modified":1526484191056},{"_id":"source/_posts/Java 拾遗/5_Spring_1.md","hash":"92ad48271e3586bba1064e165f72c7d809ed6098","modified":1526484192874},{"_id":"source/_posts/分布式服务框架原理与实践/第七章 集群容错.md","hash":"6247ff465ef69635b090f046ab4d5e299db8f5b6","modified":1542644197962},{"_id":"source/_posts/分布式服务框架原理与实践/第一章 应用框架演进.md","hash":"b84a4b1105eda910767c971c8f94374c0d4b6b85","modified":1542644200525},{"_id":"source/_posts/分布式服务框架原理与实践/第九章 服务注册中心.md","hash":"4ae5e58b41cc32c8f682233a7bbcd2aedba26db4","modified":1542644192852},{"_id":"source/_posts/分布式服务框架原理与实践/第三章 通信框架.1.md","hash":"144dbc7da254e434d4ff2c28fadb3747684a8dbd","modified":1542644195511},{"_id":"source/_posts/分布式服务框架原理与实践/第二十一章 服务化最佳实践.md","hash":"388dcf03ef22ff6c2e363031c0179eb9577a8fa9","modified":1542644189058},{"_id":"source/_posts/分布式服务框架原理与实践/第八章 服务调用.md","hash":"137534e60d5ad5b6db9c48d6788f2e0942af9711","modified":1542644178490},{"_id":"source/_posts/分布式服务框架原理与实践/第二十章 微服务架构.md","hash":"32bfeedd804c1c4a9c9aa2a84ea8bab36f0e5ed0","modified":1542644186154},{"_id":"source/_posts/分布式服务框架原理与实践/第二章 分布式服务框架入门.md","hash":"6087cb417c9057eef1927076dc73b89f8fdb1821","modified":1542644183320},{"_id":"source/_posts/分布式服务框架原理与实践/第五章 协议栈.md","hash":"8f132da3acb49acef7daeca380678ab7b51eb599","modified":1542644180958},{"_id":"source/_posts/分布式服务框架原理与实践/第十一章 服务灰度发布.md","hash":"1406cf75a52e8488cdfec9b120a6b71ca94dab44","modified":1542644173532},{"_id":"source/_posts/分布式服务框架原理与实践/第六章 服务路由.md","hash":"098b73c9bda62b228434cef76b038955487b863d","modified":1542644176015},{"_id":"source/_posts/分布式服务框架原理与实践/第十七章 服务治理.md","hash":"b3ebf69a5834083bfc6761d7451124a4dcd8f108","modified":1542644171077},{"_id":"source/_posts/分布式服务框架原理与实践/第十三章 服务多版本.md","hash":"35da8daffb08b74f2393057b6168e33d831851d7","modified":1542644168390},{"_id":"source/_posts/分布式服务框架原理与实践/第十九章 可靠性设计.md","hash":"a7d57525e87c42f3c0c5ee45e6f190f8835779d6","modified":1542644166173},{"_id":"source/_posts/分布式服务框架原理与实践/第十二章 参数传递.md","hash":"dc75fbccbd4d2ec5a0df541623387b5b849b9133","modified":1542644163773},{"_id":"source/_posts/分布式服务框架原理与实践/第十八章 分布式消息跟踪.md","hash":"39da5f5df70b7f7937bf7f77a0afdb30477aa9ef","modified":1542644156709},{"_id":"source/_posts/分布式服务框架原理与实践/第十五章 服务降级.md","hash":"e1c1f7ef9b90d8fce6fdf4a82a3caeb9506e90df","modified":1542644159360},{"_id":"source/_posts/分布式服务框架原理与实践/第十六章 服务优先级调度.md","hash":"0a7d3b4eba93b9668c4f607d456e3ee4eca579a8","modified":1542644153589},{"_id":"source/_posts/分布式服务框架原理与实践/第十四章 流量控制.md","hash":"646252b48ad0e48b64c24da288aed5f09570dd51","modified":1542644151093},{"_id":"source/_posts/图解密码技术/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1510851974000},{"_id":"source/_posts/分布式服务框架原理与实践/第十章 服务发布和引用.md","hash":"b5f74dbe7db1b9343b665fb0befcf469f496677c","modified":1542644148645},{"_id":"source/_posts/分布式服务框架原理与实践/阅读总结.md","hash":"2b0b63b021bfb2182557fa7327980172fa941a86","modified":1542644142887},{"_id":"source/_posts/分布式服务框架原理与实践/第四章 序列化和反序列化.md","hash":"35b28ba14dcbf7f01a7bdd840c1378a32c59ce34","modified":1542644146065},{"_id":"source/_posts/图解密码技术/第一章 环游密码世界.md","hash":"fc4bc685816e2105732dfd6cf5b508706b52c3e2","modified":1542644139764},{"_id":"source/_posts/图解密码技术/第七章 单向散列函数.md","hash":"4b8ab75af4c8cab97d16b8cd1f88def3c80f2ef0","modified":1511104146000},{"_id":"source/_posts/图解密码技术/第九章 数字签名.md","hash":"1092ebfa653310c16deb620c9282ad78edd12b02","modified":1512623658000},{"_id":"source/_posts/图解密码技术/第三章 对称密码.md","hash":"6fe29673a13692664ca7774eb1ad682052d467e7","modified":1542644135794},{"_id":"source/_posts/图解密码技术/第二章 历史上的密码，写一篇别人看不懂的文章.md","hash":"087f19b38094ff19a8ae2748225b09677dabb4b0","modified":1542644131456},{"_id":"source/_posts/图解密码技术/第六章 混合密码系统.md","hash":"e6034e850ef70612fa46dfa65323737412af20a7","modified":1510995810000},{"_id":"source/_posts/图解密码技术/第十一章 秘钥.md","hash":"3ff93e2266812cd28ba508d0744d38ecac9ae2b1","modified":1512396897000},{"_id":"source/_posts/图解密码技术/第五章 公钥密码.md","hash":"29b7177d1bba0b9f48b4972441dbc089b30296f0","modified":1510943663000},{"_id":"source/_posts/图解密码技术/第八章 消息认证码.md","hash":"450fab03fe73278082009ef4ba8f88c3ca21b180","modified":1511356804000},{"_id":"source/_posts/图解密码技术/第十三章 PGP.md","hash":"e11bce3ed6f7b2fc12e011e80eb4e2ef6e19b55e","modified":1512736488000},{"_id":"source/_posts/图解密码技术/第十章 证书.md","hash":"9db815d0c836120787781f4bc892fef530e9ff02","modified":1511442526000},{"_id":"source/_posts/图解密码技术/第十四章 SSL_TLS.md","hash":"fda1a85db17036649580bfc9648eb29b7a034737","modified":1512574850000},{"_id":"source/_posts/图解密码技术/第十二章 随机数.md","hash":"bbad48aedacefc36a28c936047c1ae5a82d01cb0","modified":1512661462000},{"_id":"source/_posts/图解密码技术/阅读总结.md","hash":"c8d8c7ae1684855ba8884ce8fab9aebb0ee71b9c","modified":1542644120981},{"_id":"source/_posts/技术小结/Jboot1.md","hash":"e8b965c8c46d154e1642ea9df728ee29353bce6f","modified":1523555525912},{"_id":"source/_posts/技术小结/Jboot2_启动.md","hash":"977dd7d5bb27c02d742637d312bd376604c37177","modified":1523555537439},{"_id":"source/_posts/技术小结/ZK分布式锁.md","hash":"59f473aabf0ea515b662f63ac7c943b414cec629","modified":1529329496217},{"_id":"source/_posts/技术小结/mybatis0to1.md","hash":"b02b656308475953e0712aa9cb4ce18e1f9ab13b","modified":1513606277197},{"_id":"source/_posts/技术小结/threadLocal1.md","hash":"033775eff770cdbec72887eaf8347954b7a31f53","modified":1513877121320},{"_id":"source/_posts/闲聊/Decentralization.md","hash":"cfb2cc51d4d23d16b2669c98eb0c467371de64e3","modified":1513606259588},{"_id":"source/_posts/技术小结/面经.md","hash":"295bd6288c7c3a2731ce4c38b30ce0303d944d7d","modified":1526483515592},{"_id":"source/_posts/闲聊/True Romance.md","hash":"99b80324bdab5cd5ef59627754c784790e253be5","modified":1542644232840},{"_id":"source/_posts/闲聊/En Man Som Heter Ove.md","hash":"2183bfdaac2da1cc18a6aa0141c8a0864fa65829","modified":1542644218930},{"_id":"source/_posts/闲聊/Paddington Bear.md","hash":"ffcf30d36e863538357896fe1b96ef887e105371","modified":1542644229833},{"_id":"source/_posts/闲聊/Mind.md","hash":"a6bd53272463cb6aefc1894c819317e1c12f994c","modified":1514995245760},{"_id":"source/_posts/闲聊/聚会.md","hash":"92c6f5b229c92422bfaa61ccd452b4d0a12a70e9","modified":1527864955353},{"_id":"source/_posts/闲聊/阻塞队列的低版本实现.md","hash":"ee084da3343fa72f5976e8f479b462d2b5dce809","modified":1514518174103},{"_id":"source/images/avatar.jpg","hash":"675b09c402f41df68550e13121183bbf27e6f28b","modified":1542641495981},{"_id":"source/_posts/高性能 MySQL/第五章 创建高性能的索引.md","hash":"090c315a50ea5cb7caa60d0a62a5e7cd00fb76e3","modified":1514623097808},{"_id":"source/_posts/高性能 MySQL/第四章 Schema 与数据类型优化.md","hash":"0788dbc88863cb803b73d77de5d98d81cc27fb03","modified":1514392367753},{"_id":"source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1542643151902},{"_id":"source/lib/canvas-ribbon/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1542643151902},{"_id":"source/lib/canvas-ribbon/README.md","hash":"07e86d67c508a3f974c45ff61cd0760d79bcebc5","modified":1542643151902},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1541037363000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1541037363000},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1541037363000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1541037363000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1541037363000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1541037363000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541037363000},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1541037363000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541037363000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1541037363000},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1541037363000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1541037363000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1541037363000},{"_id":"themes/next/layout/_macro/post.swig","hash":"5767eccaf3951151e01c61189016932e9516c8b9","modified":1541037363000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1541037363000},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1541037363000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1541037363000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d15a983de60d4c0bdd23cd31cd49de876ed2310c","modified":1541037363000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1541037363000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1541037363000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1541037363000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1541037363000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1541037363000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1541037363000},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1541037363000},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1541037363000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1541037363000},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1541037363000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1541037363000},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1541037363000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1541037363000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1541037363000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1541037363000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1541037363000},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1541037363000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1541037363000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1541037363000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1541037363000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1541037363000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1541037363000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1541037363000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1541037363000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1541037363000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1541037363000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1541037363000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1541037363000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1541037363000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541037363000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541037363000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1541037363000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1541037363000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1541037363000},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1541037363000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1541037363000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1541037363000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1541037363000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1541037363000},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1541037363000},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1541037363000},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1541037363000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1541037363000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"source/lib/canvas-ribbon/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1542643151895},{"_id":"source/lib/canvas-ribbon/.git/config","hash":"f79e33176f8d3e893553102df6eb347a74fd078f","modified":1542643151897},{"_id":"source/lib/canvas-ribbon/.git/index","hash":"85017ee28aa8095767000df3a374bdbe31036cd2","modified":1542644236974},{"_id":"source/lib/canvas-ribbon/.git/packed-refs","hash":"975a1826f3b571a4519516fcc6057abca0f24db1","modified":1542643151893},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1541037363000},{"_id":"source/lib/canvas-ribbon/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1542643149544},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1541037363000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1541037363000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1541037363000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1541037363000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1541037363000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1541037363000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1541037363000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1541037363000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1541037363000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1541037363000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1541037363000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1541037363000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1541037363000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1541037363000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1541037363000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1541037363000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1541037363000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1541037363000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1541037363000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1541037363000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1541037363000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1541037363000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1541037363000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1541037363000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1541037363000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1541037363000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1541037363000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1541037363000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1541037363000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1541037363000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1541037363000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1541037363000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1541037363000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1541037363000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1541037363000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1541037363000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1541037363000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1541037363000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1541037363000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1541037363000},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1541037363000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1541037363000},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1541037363000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1541037363000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1541037363000},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1541037363000},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1541037363000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1541037363000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1541037363000},{"_id":"themes/next/source/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1541037363000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1541037363000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1541037363000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1541037363000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1541037363000},{"_id":"source/lib/canvas-ribbon/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1542643149545},{"_id":"source/lib/canvas-ribbon/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1542643149545},{"_id":"source/lib/canvas-ribbon/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1542643149546},{"_id":"source/lib/canvas-ribbon/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1542643149546},{"_id":"source/lib/canvas-ribbon/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1542643149546},{"_id":"source/lib/canvas-ribbon/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1542643149545},{"_id":"source/lib/canvas-ribbon/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1542643149546},{"_id":"source/lib/canvas-ribbon/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1542643149545},{"_id":"source/lib/canvas-ribbon/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1542643149544},{"_id":"source/lib/canvas-ribbon/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1542643149546},{"_id":"source/lib/canvas-ribbon/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1542643149547},{"_id":"source/lib/canvas-ribbon/.git/logs/HEAD","hash":"0992c1037847a7aa46ac8ff66af6f7b56a49dea9","modified":1542643151896},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1541037363000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1541037363000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1541037363000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1541037363000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1541037363000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1541037363000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1541037363000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1541037363000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1541037363000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1541037363000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1541037363000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1541037363000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1541037363000},{"_id":"source/lib/canvas-ribbon/.git/objects/15/9cfb8a3050111dfb3e6635e3f37fe68de2ab30","hash":"f4e1752896135edd6c9a36164b45893a59839548","modified":1542643151878},{"_id":"source/lib/canvas-ribbon/.git/objects/02/5cf882fc75a324b1d71b0921eb52ea427387fd","hash":"4a0f15d00f50c629f01c2274e26ef05b3779b6c6","modified":1542643151876},{"_id":"source/lib/canvas-ribbon/.git/objects/6c/34e310dd41c6bfa8db842190388ab83e6d4fa2","hash":"b327c0ce763240a6a8bd2f3fb55ace6b9e3df671","modified":1542643151878},{"_id":"source/lib/canvas-ribbon/.git/objects/20/47d8728f7950fcc2276c339ee199302805838d","hash":"813e7f6c3b8954c40b250e6ba592d6bac7874397","modified":1542643151882},{"_id":"source/lib/canvas-ribbon/.git/objects/57/6d268825c6e7b3892828b61b9b408600faa1f2","hash":"2ca9617d2459b9e010e71b3b221fec42d76cae32","modified":1542643151879},{"_id":"source/lib/canvas-ribbon/.git/objects/56/4913335d11e112ac80e8d550c8347016007f6d","hash":"50e9db730ceac6b2d0c8e8d5a3fec450290fdd8e","modified":1542643151881},{"_id":"source/lib/canvas-ribbon/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1542643151880},{"_id":"source/lib/canvas-ribbon/.git/objects/b9/07949515b208cc605b513ff9d5b8153cbe2fe1","hash":"8fb6e8f2e6b4df8787239335ef9777a6c888d3c0","modified":1542643151883},{"_id":"source/lib/canvas-ribbon/.git/objects/ab/2197a6f5baffdd1d2895c169f4777921cc4027","hash":"81a75ca40bcfd278d6a9d67dedc8d61d959e2baa","modified":1542643151879},{"_id":"source/lib/canvas-ribbon/.git/refs/heads/master","hash":"6c198187e9ce9589dc0c44efb29b1bdcc9afa0c0","modified":1542643151896},{"_id":"source/lib/canvas-ribbon/.git/objects/7e/871dba93cad35ffcec76a936259ae9a3641bc7","hash":"957e9e7db09ee72fc49ca852d3cc67242567fa45","modified":1542643151884},{"_id":"source/lib/canvas-ribbon/.git/objects/c6/d0381e6cd08086561110f76b5f921bf81a6f87","hash":"be98eb9329c91132e90d942a44d05a41c78b4470","modified":1542643151877},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1541037363000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541037363000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541037363000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1541037363000},{"_id":"source/lib/canvas-ribbon/.git/logs/refs/heads/master","hash":"0992c1037847a7aa46ac8ff66af6f7b56a49dea9","modified":1542643151896},{"_id":"source/lib/canvas-ribbon/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1542643151895},{"_id":"source/lib/canvas-ribbon/.git/logs/refs/remotes/origin/HEAD","hash":"0992c1037847a7aa46ac8ff66af6f7b56a49dea9","modified":1542643151894},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1542645951398},{"_id":"public/about/index.html","hash":"086c1a8d4e6b9e680f6146bd49f01fe91d3d93b3","modified":1542651180804},{"_id":"public/archives/2017/page/4/index.html","hash":"3a16a6c7cd61cf644682741d6df4f97b215ce5cd","modified":1542651180806},{"_id":"public/archives/2017/01/index.html","hash":"134773daebef7893fc6335690465b1954905d797","modified":1542651180806},{"_id":"public/archives/2017/12/page/2/index.html","hash":"429831966284ebce9d30884aa5bb47beaa0a37d8","modified":1542651180806},{"_id":"public/archives/2018/page/4/index.html","hash":"54a97dc201520e4033f4122e9fe661dbe86f4768","modified":1542651180806},{"_id":"public/archives/2018/01/index.html","hash":"f7639f010de30b2009992ab142488d4d08732793","modified":1542651180806},{"_id":"public/archives/2018/04/index.html","hash":"642534f49b88e2d1900f5b78caedff07d83535dc","modified":1542651180806},{"_id":"public/archives/2018/05/page/2/index.html","hash":"59f68eccbd48de2237b884372ee81c4b487c6248","modified":1542651180806},{"_id":"public/categories/读书笔记/Java-性能权威指南/index.html","hash":"a61fa9c9b4135c6a33e528ba4026bf46c84bf853","modified":1542651180804},{"_id":"public/categories/读书笔记/Java并发编程的艺术/index.html","hash":"35f51bf7f4ea97a0b74ee57a310c4fabbad87c15","modified":1542651180804},{"_id":"public/categories/读书笔记/Linux命令行与shell脚本编程大全/index.html","hash":"625eeda6c85fd3902982276540b0461247446ecd","modified":1542651180804},{"_id":"public/categories/Java-拾遗/index.html","hash":"16803afdfeb21cb3eeef1fb768ee1e3aafb7988d","modified":1542651180805},{"_id":"public/categories/读书笔记/Netty实战/index.html","hash":"2d16a015285bb1b88c2e25514f4514af7312eb0d","modified":1542651180805},{"_id":"public/categories/读书笔记/分布式服务框架原理与实践/page/3/index.html","hash":"58b231e173f81b09dbb7600a002aed3434fd82aa","modified":1542651180805},{"_id":"public/categories/读书笔记/图解密码技术/page/2/index.html","hash":"54e189347d9812975ad49d1f3a6b39724775b5c9","modified":1542651180805},{"_id":"public/categories/小结/index.html","hash":"5a07a6b627a0fc67833557caa3a4f4f5d387c899","modified":1542651180805},{"_id":"public/categories/闲聊/index.html","hash":"c5b08b533d21bd8f9de9d3144e13266b0a1adf69","modified":1542651180805},{"_id":"public/categories/读书笔记/并发/index.html","hash":"1c825c53b021895122e6491bb46849135b9c1ff7","modified":1542651180805},{"_id":"public/categories/读书笔记/高性能MySQL/index.html","hash":"e0b39d3cfa7b509d23bb579efa455789cafb76a1","modified":1542651180805},{"_id":"public/categories/读书笔记/分布式服务框架原理与实践/如何阅读一本书/index.html","hash":"db2860aaff82a209cda938fc88c841f89e485d97","modified":1542651180805},{"_id":"public/categories/读书笔记/图解密码技术/如何阅读一本书/index.html","hash":"74f01b2ac7d5af1d2e28a8028b99bd5a79faa253","modified":1542651180805},{"_id":"public/lib/canvas-ribbon/README.html","hash":"0214b6e555c30aa00ad95023660c128c8212b5b9","modified":1542645951472},{"_id":"public/categories/index.html","hash":"8897516c7c095b1dab0c1d674017f3c215d7da37","modified":1542651180806},{"_id":"public/2018/06/22/distributed_principle_prictice/21.html/index.html","hash":"4ab1f9ab62e0e63bc20253240a14de1d77f698c2","modified":1542651180806},{"_id":"public/2018/06/21/distributed_principle_prictice/20.html/index.html","hash":"9f0ddfb89f86c579c1541ecdf1188be6551a4c98","modified":1542651180806},{"_id":"public/2018/06/20/distributed_principle_prictice/19.html/index.html","hash":"a8b6735e745833b6e2fb709cc90f5e686fc75526","modified":1542651180807},{"_id":"public/2018/06/15/tech/zk_distribute_lock.html/index.html","hash":"de4d345fc8b1f26402979f70afe3b3596cd2629d","modified":1542651180807},{"_id":"public/2018/06/15/distributed_principle_prictice/18.html/index.html","hash":"4137c175d8ed0427670dffa8b3dda7f1eb858c61","modified":1542651180807},{"_id":"public/2018/06/14/distributed_principle_prictice/17.html/index.html","hash":"78bc503a8056b016121be1cabbdb75c7122ade9a","modified":1542651180807},{"_id":"public/2018/06/11/graphic2cryptography/0.html/index.html","hash":"66d7c2d87f69f94a7dcbc150b9bc8a2dc4e645be","modified":1542651180807},{"_id":"public/2018/06/11/distributed_principle_prictice/0.html/index.html","hash":"256b1ae33f3f817ce3e93532a72783acd4dae306","modified":1542651180807},{"_id":"public/2018/06/11/distributed_principle_prictice/16.html/index.html","hash":"90789a1d0f206f7e97fde7029443385cd346dd6f","modified":1542651180807},{"_id":"public/2018/06/11/distributed_principle_prictice/15.html/index.html","hash":"9f694c2ef1ed483d658a84f612d37398cd7a0b21","modified":1542651180807},{"_id":"public/2018/06/07/distributed_principle_prictice/14.html/index.html","hash":"ba9f274b1c3b0087f80d67f86de93b3a6632142b","modified":1542651180807},{"_id":"public/2018/06/06/distributed_principle_prictice/13.html/index.html","hash":"e0e372acad4cf3f1e819fea8100f7bf9156ffd97","modified":1542651180807},{"_id":"public/2018/06/05/distributed_principle_prictice/12.html/index.html","hash":"e12606a440cc629ae551d82c9132eb362da9bee2","modified":1542651180807},{"_id":"public/2018/06/04/distributed_principle_prictice/11.html/index.html","hash":"ad01e5611329b62cd696b9e84c58bf02b6cad1ba","modified":1542651180807},{"_id":"public/2018/06/03/distributed_principle_prictice/10.html/index.html","hash":"1d5138185dbabe739591d2851f06cf3a8d24b82e","modified":1542651180807},{"_id":"public/2018/06/02/distributed_principle_prictice/9.html/index.html","hash":"7241aa939e5c73e590c62798bd8fbe262eb18797","modified":1542651180808},{"_id":"public/2018/06/01/talker/schoolmate01.html/index.html","hash":"d197384af316cf4c0da75678a3a9e60434a50fd6","modified":1542651180808},{"_id":"public/2018/05/31/distributed_principle_prictice/8.html/index.html","hash":"0466fb6841f4b6d72041fa0b3e4f422d92a7ad2b","modified":1542651180808},{"_id":"public/2018/05/30/distributed_principle_prictice/7.html/index.html","hash":"3d11555a0d6d8c461da63019eddba51bd88f03c3","modified":1542651180808},{"_id":"public/2018/05/29/distributed_principle_prictice/6.html/index.html","hash":"530a62ee522507a2a38f64ca7dd6e331854221db","modified":1542651180808},{"_id":"public/2018/05/27/distributed_principle_prictice/5.html/index.html","hash":"ed315f80d3bb24e6eacdf099c40cd7749b7543fd","modified":1542651180808},{"_id":"public/2018/05/22/distributed_principle_prictice/4.html/index.html","hash":"896ea52ae56454304dff3a02eec688198f70f706","modified":1542651180808},{"_id":"public/2018/05/20/distributed_principle_prictice/3.html/index.html","hash":"9d5a1ae6574ab670bb61445a25e650dbc59112ae","modified":1542651180808},{"_id":"public/2018/05/19/distributed_principle_prictice/2.html/index.html","hash":"823a189b14a43edb10902c0526c2b1fca9cd6dec","modified":1542651180808},{"_id":"public/2018/05/18/distributed_principle_prictice/1.html/index.html","hash":"55bee275fa68f99406369fa7ac0f2beaa6369944","modified":1542651180808},{"_id":"public/2018/05/16/linux_cli_shell/1.html/index.html","hash":"3f14bc0901ac26c3551e5ae79acac17be0afde70","modified":1542651180809},{"_id":"public/2018/05/16/linux_cli_shell/2.html/index.html","hash":"d014b0f00edea3e588c8f27a7fb151533bbc35d2","modified":1542651180809},{"_id":"public/2018/05/08/tech/learn_what_how_why.html/index.html","hash":"0ca544af2dd237e6f6dd0065fa39fffd7c0d4512","modified":1542651180809},{"_id":"public/2018/04/13/A2B_Java/3_ThreadLocal.html/index.html","hash":"0be5a8d4a34135914c5e17d037619fd836ddcbd0","modified":1542651180809},{"_id":"public/2018/04/13/A2B_Java/5_Spring_1.html/index.html","hash":"926b041f03c42a43e0ead31c262b2a162905b29b","modified":1542651180809},{"_id":"public/2018/04/13/A2B_Java/4_JVM_Memory.html/index.html","hash":"f1f217c8eba54fe47030f870e19bd5d9c66c6b4e","modified":1542651180809},{"_id":"public/2018/04/12/A2B_Java/1_ConcurrentHashMap.html/index.html","hash":"70857568522207f571e8fc6ce4abff7ed2e7b56f","modified":1542651180809},{"_id":"public/2018/04/12/A2B_Java/2_Servlet_Filter_Listener.html/index.html","hash":"e769091ac025d317fb146ed34172ed83c04693d4","modified":1542651180809},{"_id":"public/2018/01/10/tech/Jboot_2.html/index.html","hash":"280db92db0dd723656831370e024e88687222420","modified":1542651180809},{"_id":"public/2018/01/10/tech/Jboot_1.html/index.html","hash":"eab12fbaee6216e6cc8a2efa53aa3f8a405e5e32","modified":1542651180809},{"_id":"public/2017/12/31/talker/mind_1.html/index.html","hash":"4f3b9e01a19a3b17023464ac50ba764d9017f059","modified":1542651180810},{"_id":"public/2017/12/28/current/1.html/index.html","hash":"ff144cc4dab083d205f8ec1f27f4cdb8fbcd1f95","modified":1542651180810},{"_id":"public/2017/12/28/high_performance_MySQL/5.html/index.html","hash":"dfce52e795f0d41291470e93caa4777e20fb5d90","modified":1542651180810},{"_id":"public/2017/12/26/netty_in_action/1.html/index.html","hash":"adb148b4e6fa9f70113255a84e1579094a548f83","modified":1542651180810},{"_id":"public/2017/12/25/high_performance_MySQL/4.html/index.html","hash":"a3d92e80b0398bf5e54d473e1cfcf893e98fe6fc","modified":1542651180810},{"_id":"public/2017/12/22/tech/threadlocal_1.html/index.html","hash":"c7ae984cda8e1ca849f3b084f5f6f396e810bb1f","modified":1542651180810},{"_id":"public/2017/12/18/tech/mybatis0to1.html/index.html","hash":"4dc8b3b065f3646a5fc6b4d4cc29cf02746e9054","modified":1542651180810},{"_id":"public/2017/12/13/talker/paddington.html/index.html","hash":"b5a1addde0c615bedd724db250a95b394793c518","modified":1542651180810},{"_id":"public/2017/12/07/graphic2cryptography/13.html/index.html","hash":"5f6c16ee4c8fda2ccdb642c2d4409a2631cf10a3","modified":1542651180810},{"_id":"public/2017/12/06/graphic2cryptography/12.html/index.html","hash":"92fcf52c2dc4236b271d1711d88cbb2e6bd8fe2f","modified":1542651180810},{"_id":"public/2017/12/05/talker/decentralization_1.html/index.html","hash":"7ae9d88c83a4f6f04acab557ce045266cbb254db","modified":1542651180810},{"_id":"public/2017/12/04/graphic2cryptography/14.html/index.html","hash":"aa72ca67377c614f0f3ca7912349e68d351f2b96","modified":1542651180810},{"_id":"public/2017/11/23/graphic2cryptography/10.html/index.html","hash":"390bd0e049843898e11dcc372341b2747ff49eb2","modified":1542651180811},{"_id":"public/2017/11/23/talker/2.html/index.html","hash":"3519da33af4e163c40ed9d64687306e901b264f8","modified":1542651180811},{"_id":"public/2017/11/22/graphic2cryptography/10.html/index.html","hash":"b763bb739ead0712bb5aaf18188c1b7902d1e121","modified":1542651180811},{"_id":"public/2017/11/21/graphic2cryptography/9.html/index.html","hash":"913168093596e50308728ea42802ed2d1b4da2ba","modified":1542651180811},{"_id":"public/2017/11/19/graphic2cryptography/8.html/index.html","hash":"dc7107a40600b6ad0ad611ddc8fdf1a3d7869d08","modified":1542651180811},{"_id":"public/2017/11/19/graphic2cryptography/7.html/index.html","hash":"662ca575aa1b78565eac132187d5c71c6a74eb3d","modified":1542651180811},{"_id":"public/2017/11/18/graphic2cryptography/6.html/index.html","hash":"47d33465b955ee2f8aef65dad2b6f41cd7bb1c59","modified":1542651180811},{"_id":"public/2017/11/15/graphic2cryptography/5.html/index.html","hash":"02502f00ef9f208f89ccc91a337a902bb81a0ac6","modified":1542651180811},{"_id":"public/2017/11/15/talker/1.html/index.html","hash":"5d1827eb889c50faea9133e29cf6aa372085da02","modified":1542651180811},{"_id":"public/2017/11/12/graphic2cryptography/3.html/index.html","hash":"5aaf6c6804b37bbc930250ed189ad51dd47d8fb6","modified":1542651180811},{"_id":"public/2017/11/11/graphic2cryptography/2.html/index.html","hash":"bc31d8fb0ce6158c9263ab9df38ebe512c3d3635","modified":1542651180811},{"_id":"public/2017/11/10/graphic2cryptography/1.html/index.html","hash":"d509b46b12bd77d4316566d758bf4176cc2eb3ca","modified":1542651180811},{"_id":"public/2017/11/07/concurrent-art/4.html/index.html","hash":"bb05805a2a20b039e0415aa9b47158c210456233","modified":1542651180811},{"_id":"public/2017/11/07/concurrent-art/5.html/index.html","hash":"e876f888b864c27e1464c623fba2b377166e0fba","modified":1542651180812},{"_id":"public/2017/11/07/concurrent-art/8.html/index.html","hash":"fb31fa4e62aa7cf52b788d2012164c639c08d934","modified":1542651180812},{"_id":"public/2017/11/07/concurrent-art/6.html/index.html","hash":"2c343f0fa2a91287a55876884665ed4b9779b899","modified":1542651180812},{"_id":"public/2017/01/18/java_performance_the_definitive_guide/9.html/index.html","hash":"f02b7137a090ac5369e5b32c4857db15524113de","modified":1542651180812},{"_id":"public/2017/01/10/java_performance_the_definitive_guide/3_4.html/index.html","hash":"5914e6e4240c91e4c93d9abe3dbc70841bb93bd6","modified":1542651180812},{"_id":"public/2017/01/10/java_performance_the_definitive_guide/5.html/index.html","hash":"cdc7bd37ed1b0dc45189182c950910b54c10755c","modified":1542651180812},{"_id":"public/2017/01/01/java_performance_the_definitive_guide/2.html/index.html","hash":"89bacbff45709f9e50dd5df163ecc3ef7064eb62","modified":1542651180812},{"_id":"public/archives/index.html","hash":"41738e7abb4967f9e9c43f4584997d7d14d57e68","modified":1542651180814},{"_id":"public/archives/page/2/index.html","hash":"6826d386cba1eefff8b6354064ce1dc981282bef","modified":1542651180814},{"_id":"public/archives/page/3/index.html","hash":"6c456c9373cc8ec2fe11f778d907f2c93443bef8","modified":1542651180814},{"_id":"public/archives/page/4/index.html","hash":"ee381aa6ee28097cc3de9d3bea8a4a3b7cd781b4","modified":1542651180814},{"_id":"public/archives/page/5/index.html","hash":"3988e40930755d1e1c4643b9f5d781c7a7a536ba","modified":1542651180814},{"_id":"public/archives/page/6/index.html","hash":"96e17b85111980d61b592dcf6cadaad314c1dd18","modified":1542651180814},{"_id":"public/archives/page/7/index.html","hash":"140b64c3ba8291190126d1693d91a44d5fb84520","modified":1542651180814},{"_id":"public/archives/2017/index.html","hash":"2217f2a27609da76528c8874c676895bf21116a5","modified":1542651180814},{"_id":"public/archives/2017/page/2/index.html","hash":"a94e1ae2688411a04d9eca47ea84804f67fbdf7a","modified":1542651180814},{"_id":"public/archives/2017/page/3/index.html","hash":"f10dcae8f21b0aa2fa4a5d61b85695bae97b72cb","modified":1542651180815},{"_id":"public/archives/2017/11/index.html","hash":"8a5c52519207f35de5ad3f23ea5456f1207e60e5","modified":1542651180815},{"_id":"public/archives/2017/11/page/2/index.html","hash":"e8acc0d9bd64290562138302610c94d6b3569b2b","modified":1542651180815},{"_id":"public/archives/2017/12/index.html","hash":"7bda00b4af375648fc03c6006ffd5b4e68d9d3b6","modified":1542651180815},{"_id":"public/archives/2018/index.html","hash":"38829b554c17ed59d1042edd312e350dc649f2d5","modified":1542651180815},{"_id":"public/archives/2018/page/2/index.html","hash":"ae01fcaa9951792074844de40998c3587008e33a","modified":1542651180815},{"_id":"public/archives/2018/page/3/index.html","hash":"009645d878ffdade1fd165820db79327c60ab106","modified":1542651180815},{"_id":"public/archives/2018/05/index.html","hash":"442947b96a1cc5507b3bf863c7383213534c546b","modified":1542651180815},{"_id":"public/archives/2018/06/index.html","hash":"c73a39e0fb67879f535e504b643092632b23dcf9","modified":1542651180815},{"_id":"public/archives/2018/06/page/2/index.html","hash":"a3b328aae5b2d4a386e253e8a5b71acf4da02b91","modified":1542651180815},{"_id":"public/index.html","hash":"11f5dfb3b20e6ca6c8e69cb3addadc2b1cb001ab","modified":1542651180813},{"_id":"public/page/2/index.html","hash":"f844e554672e2e5b7bcb752c04bd0af7728fa319","modified":1542651180813},{"_id":"public/page/3/index.html","hash":"7e819432244864d780a97650f5fe68c2304a81b7","modified":1542651180813},{"_id":"public/page/4/index.html","hash":"9c31aa5a6f6658bdcfea0c93a04ca97cd7ab36dd","modified":1542651180813},{"_id":"public/page/5/index.html","hash":"b9cc19b955f0c13030f098e3c97598e1f15d04b5","modified":1542651180813},{"_id":"public/page/6/index.html","hash":"daeb08baffdc9332cead90ee2b178f6404409f54","modified":1542651180813},{"_id":"public/page/7/index.html","hash":"41c3337681afee28f79cfe73ac28441ccf5424dc","modified":1542651180814},{"_id":"public/categories/读书笔记/index.html","hash":"9dd2f080acd3790ff7d16ab9a49fbd6f1d136564","modified":1542651180812},{"_id":"public/categories/读书笔记/page/2/index.html","hash":"3195d762637cb072c1897d0681ebc9d703391ca4","modified":1542651180812},{"_id":"public/categories/读书笔记/page/3/index.html","hash":"b0e06b180976fdfcf16664fdea43bd6e6145ad01","modified":1542651180812},{"_id":"public/categories/读书笔记/page/4/index.html","hash":"0986ae944ed904c735ea17a9495147f6d35b55d1","modified":1542651180812},{"_id":"public/categories/读书笔记/page/5/index.html","hash":"3bb5b1e907131a7390cb71f8e21923aabe1e3923","modified":1542651180813},{"_id":"public/categories/读书笔记/分布式服务框架原理与实践/index.html","hash":"f8708bf206393b803f31235c6e90236cfe9dd09d","modified":1542651180813},{"_id":"public/categories/读书笔记/分布式服务框架原理与实践/page/2/index.html","hash":"7923832f6a21b6c1e3a6a3f3d37c1bb4f7bb6361","modified":1542651180813},{"_id":"public/categories/读书笔记/图解密码技术/index.html","hash":"7dc35215e83d3c092c9b76e1ef8ec545a0bea4e6","modified":1542651180813},{"_id":"public/README.md","hash":"9e354be53476f1fbf4d5c54a83078088472299c0","modified":1542645951485},{"_id":"public/images/favicon.ico","hash":"644430fb12f363b263e68dee20d44ce4ac15b2f0","modified":1542645951485},{"_id":"public/CNAME","hash":"d49ded439c8fabfd7ed19d0e56263eca19fd118b","modified":1542645951486},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1542645951486},{"_id":"public/lib/canvas-ribbon/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1542645951486},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1542645951486},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1542645951486},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1542645951486},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1542645951486},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1542645951486},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1542645951486},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1542645951486},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1542645951486},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1542645951486},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1542645951486},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1542645951486},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1542645951486},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542645951486},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542645951486},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1542645951486},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1542645951486},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1542645951486},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1542645951486},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1542645951487},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1542645951979},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1542645951983},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1542645951989},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1542645951989},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1542645951989},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1542645951989},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1542645951989},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1542645951989},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1542645951990},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1542645951990},{"_id":"public/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1542645951990},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1542645951990},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1542645951990},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1542645951990},{"_id":"public/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1542645951990},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1542645951990},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1542645951990},{"_id":"public/css/main.css","hash":"cbfa69a05adf8220adfcb04b80cc1ffb7d4270b1","modified":1542645951990},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1542645951990},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1542645951990},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1542645951991},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1542645951991},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1542645951991},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1542645951991},{"_id":"public/images/avatar.jpg","hash":"675b09c402f41df68550e13121183bbf27e6f28b","modified":1542645951991},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1542645951991},{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542649656150}],"Category":[{"name":"读书笔记","_id":"cjoojkaul0004axs6utinuvdd"},{"name":"Java 性能权威指南","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkauw000eaxs64jmdclzz"},{"name":"Java并发编程的艺术","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkauy000haxs6z4go3xmk"},{"name":"Linux命令行与shell脚本编程大全","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavc001eaxs68ckdsrvd"},{"name":"Java 拾遗","_id":"cjoojkavf001kaxs6ifixia88"},{"name":"Netty实战","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavn0023axs6b2229bqa"},{"name":"分布式服务框架原理与实践","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavr002baxs6843vh09t"},{"name":"图解密码技术","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawo004xaxs67pzykmjr"},{"name":"小结","_id":"cjoojkaww005vaxs6aa1jmjo5"},{"name":"闲聊","_id":"cjoojkax0006aaxs6p86t4sh2"},{"name":"并发","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkax7006paxs6q0run3l1"},{"name":"高性能MySQL","parent":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkax8006saxs65lwc5tet"},{"name":"如何阅读一本书","parent":"cjoojkavr002baxs6843vh09t","_id":"cjoojkax9006waxs6oytld147"},{"name":"如何阅读一本书","parent":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkax90070axs6ab02nxtp"}],"Data":[],"Page":[{"title":"关于","date":"2017-11-20T17:46:00.000Z","type":"about","comments":0,"_content":"\n2018-05~至今    上海万间信息 `Java 开发`  \n2017-07~2018-05 \b武汉万江龙 `Java 开发`   \n2017-02~2017-06 武汉\b\b万江龙 `Java 实习`  \n2016-06~2016-09 南京某小公司（后来破产了）`Android 实习`  \n本科毕业于南京某学校三本。  \n\n---\n\nStay hungry. Stay foolish.  \n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-11-21 01:46:00\ntype: \"about\"\ncomments: false\n---\n\n2018-05~至今    上海万间信息 `Java 开发`  \n2017-07~2018-05 \b武汉万江龙 `Java 开发`   \n2017-02~2017-06 武汉\b\b万江龙 `Java 实习`  \n2016-06~2016-09 南京某小公司（后来破产了）`Android 实习`  \n本科毕业于南京某学校三本。  \n\n---\n\nStay hungry. Stay foolish.  \n","updated":"2018-06-18T13:40:06.728Z","path":"about/index.html","layout":"page","_id":"cjoojkanz0000axs6eytgsonh","content":"<p>2018-05~至今    上海万间信息 <code>Java 开发</code><br>2017-07~2018-05 \b武汉万江龙 <code>Java 开发</code><br>2017-02~2017-06 武汉\b\b万江龙 <code>Java 实习</code><br>2016-06~2016-09 南京某小公司（后来破产了）<code>Android 实习</code><br>本科毕业于南京某学校三本。  </p>\n<hr>\n<p>Stay hungry. Stay foolish.  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>2018-05~至今    上海万间信息 <code>Java 开发</code><br>2017-07~2018-05 \b武汉万江龙 <code>Java 开发</code><br>2017-02~2017-06 武汉\b\b万江龙 <code>Java 实习</code><br>2016-06~2016-09 南京某小公司（后来破产了）<code>Android 实习</code><br>本科毕业于南京某学校三本。  </p>\n<hr>\n<p>Stay hungry. Stay foolish.  </p>\n"},{"title":"分类","date":"2017-11-07T12:02:24.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-11-07 20:02:24\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-11-07T12:03:12.000Z","path":"categories/index.html","layout":"page","_id":"cjoojkao00001axs6ekhhft3r","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"五、Java中的锁","date":"2017-11-07T12:07:00.000Z","updated":"2017-11-07T12:07:00.000Z","comments":1,"_content":"\n# 1 Lock 接口\n\n# 2. 队列同步器\n\n队列同步器 AbstractQueueSynchronizer （简称同步器），是用来构建锁或者其它同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，\n通过内置的 FIFO 队列完成资源获取线程的排队工作。  \n  \n## 2.1 队列同步器的接口与示例\n\n同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，\n它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。\n锁和同步器很好地隔离了使用者和实现者所需关注的领域。  \n  \n只有掌握了同步器的工作原理才能更加深入地理解并发包中其它的并发组件，所以下面通过一个独占锁的实例来深入了解一下同步器的工作原理。  \n  \n独占锁就是在同一时刻只能由一个线程获取到锁，而其它获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁，代码5-2如下：  \n```java\npublic class Mutex implements Lock{\n    // 静态内部类，自定义同步器\n    private static class Sync extends AbstractQueuedSynchronizer {\n\n        // 是否处于占用状态\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n\n        @Override\n        public boolean tryAcquire(int acquires) {\n            if (compareAndSetState(0, 1)) {\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected boolean tryRelease(int releases) {\n            if (getState() == 0) throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        Condition newCondition() {\n            return new ConditionObject();\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    @Override\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    @Override\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n\n    @Override\n    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(time));\n    }\n\n    @Override\n    public void unlock() {\n        sync.release(1);\n    }\n\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n\n    public boolean hasQueuedThreads(){\n        return sync.hasQueuedThreads();\n    }\n\n    @Override\n    public void lockInterruptibly() throws InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n\n    @Override\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n}\n```\n\n## 2.2 队列同步器的实现分析\n\n分析同步器如何完成线程同步的，包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模块方法。\n\n### 2.2.1 同步队列\n\n当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点 （Node） 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，\n会把首节点中的线程唤醒，使其再次尝试获取同步状态。  \n![][1]  \n试想，当一个线程成功地获取了同步状态（锁），其它线程将无法获取到同步状态，转而被构造称为节点并加入到同步队列中，而这个加入队列的过程必须要\n保证线程安全，因此同步器提供了一个基于 CAS 线程的设置尾节点的方法： `compareAndSetTail(Node expect, Node update)` ，它需要传递当前“认为”\n的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。  \n![][2]  \n首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点：\n![][3]  \n设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证。\n\n### 2.2.2 独占式同步状态获取与释放\n\n通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程\n进行中断操作时，线程不会从同步队列中移出，源码如下：\n```java\npublic final void acquire(int arg) {\n    if(!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n# 3 重入锁\n\nReenTrantLock，支持重入的锁。\n\n## 3.1 实现重进入\n\n这个特性需要解决两个问题：\n1. 线程再次获取锁。锁需要去识别获取锁额线程是否为当前占据锁的线程，如果是，则再次成功获取。\n2. 锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放锁后，其它线程能够获取到锁。要求对获取进行计数自增，释放时计数自减。  \n  \n获取锁源码：\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n释放锁源码：\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n## 3.2 公平与非公平获取锁的区别\n\n如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。  \n源码如下：\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n其中相对于非公平锁的获取，多了一个 `hasQueuedPredecessors()` 判断，判断是否当前节点是否有前驱节点的判断。  \n  \n如果有 n 个线程争夺锁。对于公平锁来说，保证了每个线程都可以获取锁，即有 n 次线程切换。而对于非公平锁来说，有可能有的线程能获取多次锁，\n有的线程根本获取不到锁，线程切换次数是小于 n 的。因此减去上下文的切换时间，非公平锁的效率更高，所以 `ReentrantLock` 默认为非公平锁。 \n\n# 4 读写锁\n\n在没有读写锁支持的时候（Java5之前），使用 Java 的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并行通知后，\n所有等待的读操作才能继续执行（写操作之间依靠 synchronized 关键字进行同步）。  \n  \n一般来说，读写锁的性能都会比排他锁好（ReentrantLock 也是一种排他锁），因为大多数场景读是多于写的。Java并发包提供读写锁的实现是 `ReentrantReadWriteLock`。\n\n## 4.1 读写锁的接口与示例\n\n通过缓存示例说明读写锁的使用方式，代码5-16：\n```java\npublic class Cache {\n\n    static Map<String, Object> map = new HashMap<>();\n\n    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n\n    static Lock r = rwl.readLock();\n\n    static Lock w = rwl.writeLock();\n\n    public static final Object get(String key) {\n        r.lock();\n        try {\n            return map.get(key);\n        } finally {\n            r.unlock();\n        }\n    }\n    \n    public static final Object put(String key, String value) {\n        w.lock();\n        try {\n            return map.put(key, value);\n        } finally {\n            w.unlock();\n        }\n    }\n    \n    public static final void clear() {\n        w.lock();\n        try {\n            map.clear();\n        } finally {\n            w.unlock();\n        }\n    }\n}\n```\n使用非线程安全的 `HashMap` 作为缓存的实现。使用读写锁提升读操作的并发性，并简化了编程方式。\n\n## 4.2 读写锁的实现分析\n\n### 4.2.1 读写状态的设计\n\n读写锁依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态\n（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。  \n  \n如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。  \n![][4]  \n当前图的同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。\n假设当前同步状态值为 S ，写状态等于 S&0x0000FFFF（将高16位全部抹去），读状态等于 S>>>16（无符号补0右移16位）。当写状态增加1时，等于S+1,，\n当读状态增加1时，等于S+(1<<16)，也就是S+0x00010000。  \n  \n根据状态的划分能得出一个推论：S不等于0时，当写状态（S&0x0000FFFF）等于0时，则读状态（S>>>16）大于0，即读锁已被获取。\n\n### 4.2.2 写锁的获取与释放\n\n写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，\n则当前线程进入等待状态，获取锁的源码如下：\n```java\nprotected final boolean tryAcquire(int acquires) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    int w = exclusiveCount(c);\n    if (c != 0) {\n        // 存在读锁或者当前获取线程不是已经获取写锁的线程\n        if (w == 0 || current != getExclusiveOwnerThread())\n            return false;\n        if (w + exclusiveCount(acquires) > MAX_COUNT)\n            throw new Error(\"Maximum lock count exceeded\");\n        // Reentrant acquire\n        setState(c + acquires);\n        return true;\n    }\n    if (writerShouldBlock() ||\n        !compareAndSetState(c, c + acquires))\n        return false;\n    setExclusiveOwnerThread(current);\n    return true;\n}\n```\n\n### 4.2.3 读锁的获取与释放\n\n读锁是一个支持重进入的共享锁，能被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。\n如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如\n`getReadHoldCount()` 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的综合，而每个线程各自获取读锁的次数只能选择\n保存在 `ThreadLocal` 中，由线程自身维护，这使得获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分：\n```java\nprotected final int tryAcquireShared(int unused) {\n    for (;;) {\n        int c = getState();\n        int nextc = c + (1 << 16);\n        if (nextc < c)\n            throw new Error(\"Maximum lock count exceeded\");\n        if (exclusiveCount(c) != 0 && owner != Thread.currentThread())\n            return -1;\n        if (compareAndSetState(c, nextc))\n            return 1;\n    }\n}\n```\n如果其它线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，成功获取读锁。\n\n### 4.2.4 锁降级\n\n锁降级指的是写锁降级称为读锁。获取写锁-释放写锁-获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指：获取写锁-获取读锁-释放写锁。\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_4.png\n\n\n","source":"_posts/Java 并发编程的艺术/第五章 Java中的锁.md","raw":"---\ntitle: 五、Java中的锁\ndate: 2017-11-07 20:07:00\nupdated: 2017-11-07 20:07:00\ncomments: true\ncategories: \n- 读书笔记\n- Java并发编程的艺术\npermalink: concurrent-art/5.html    \n---\n\n# 1 Lock 接口\n\n# 2. 队列同步器\n\n队列同步器 AbstractQueueSynchronizer （简称同步器），是用来构建锁或者其它同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，\n通过内置的 FIFO 队列完成资源获取线程的排队工作。  \n  \n## 2.1 队列同步器的接口与示例\n\n同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，\n它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。\n锁和同步器很好地隔离了使用者和实现者所需关注的领域。  \n  \n只有掌握了同步器的工作原理才能更加深入地理解并发包中其它的并发组件，所以下面通过一个独占锁的实例来深入了解一下同步器的工作原理。  \n  \n独占锁就是在同一时刻只能由一个线程获取到锁，而其它获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁，代码5-2如下：  \n```java\npublic class Mutex implements Lock{\n    // 静态内部类，自定义同步器\n    private static class Sync extends AbstractQueuedSynchronizer {\n\n        // 是否处于占用状态\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n\n        @Override\n        public boolean tryAcquire(int acquires) {\n            if (compareAndSetState(0, 1)) {\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected boolean tryRelease(int releases) {\n            if (getState() == 0) throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        Condition newCondition() {\n            return new ConditionObject();\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    @Override\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    @Override\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n\n    @Override\n    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(time));\n    }\n\n    @Override\n    public void unlock() {\n        sync.release(1);\n    }\n\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n\n    public boolean hasQueuedThreads(){\n        return sync.hasQueuedThreads();\n    }\n\n    @Override\n    public void lockInterruptibly() throws InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n\n    @Override\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n}\n```\n\n## 2.2 队列同步器的实现分析\n\n分析同步器如何完成线程同步的，包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模块方法。\n\n### 2.2.1 同步队列\n\n当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点 （Node） 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，\n会把首节点中的线程唤醒，使其再次尝试获取同步状态。  \n![][1]  \n试想，当一个线程成功地获取了同步状态（锁），其它线程将无法获取到同步状态，转而被构造称为节点并加入到同步队列中，而这个加入队列的过程必须要\n保证线程安全，因此同步器提供了一个基于 CAS 线程的设置尾节点的方法： `compareAndSetTail(Node expect, Node update)` ，它需要传递当前“认为”\n的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。  \n![][2]  \n首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点：\n![][3]  \n设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证。\n\n### 2.2.2 独占式同步状态获取与释放\n\n通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程\n进行中断操作时，线程不会从同步队列中移出，源码如下：\n```java\npublic final void acquire(int arg) {\n    if(!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n# 3 重入锁\n\nReenTrantLock，支持重入的锁。\n\n## 3.1 实现重进入\n\n这个特性需要解决两个问题：\n1. 线程再次获取锁。锁需要去识别获取锁额线程是否为当前占据锁的线程，如果是，则再次成功获取。\n2. 锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放锁后，其它线程能够获取到锁。要求对获取进行计数自增，释放时计数自减。  \n  \n获取锁源码：\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n释放锁源码：\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n## 3.2 公平与非公平获取锁的区别\n\n如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。  \n源码如下：\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n其中相对于非公平锁的获取，多了一个 `hasQueuedPredecessors()` 判断，判断是否当前节点是否有前驱节点的判断。  \n  \n如果有 n 个线程争夺锁。对于公平锁来说，保证了每个线程都可以获取锁，即有 n 次线程切换。而对于非公平锁来说，有可能有的线程能获取多次锁，\n有的线程根本获取不到锁，线程切换次数是小于 n 的。因此减去上下文的切换时间，非公平锁的效率更高，所以 `ReentrantLock` 默认为非公平锁。 \n\n# 4 读写锁\n\n在没有读写锁支持的时候（Java5之前），使用 Java 的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并行通知后，\n所有等待的读操作才能继续执行（写操作之间依靠 synchronized 关键字进行同步）。  \n  \n一般来说，读写锁的性能都会比排他锁好（ReentrantLock 也是一种排他锁），因为大多数场景读是多于写的。Java并发包提供读写锁的实现是 `ReentrantReadWriteLock`。\n\n## 4.1 读写锁的接口与示例\n\n通过缓存示例说明读写锁的使用方式，代码5-16：\n```java\npublic class Cache {\n\n    static Map<String, Object> map = new HashMap<>();\n\n    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n\n    static Lock r = rwl.readLock();\n\n    static Lock w = rwl.writeLock();\n\n    public static final Object get(String key) {\n        r.lock();\n        try {\n            return map.get(key);\n        } finally {\n            r.unlock();\n        }\n    }\n    \n    public static final Object put(String key, String value) {\n        w.lock();\n        try {\n            return map.put(key, value);\n        } finally {\n            w.unlock();\n        }\n    }\n    \n    public static final void clear() {\n        w.lock();\n        try {\n            map.clear();\n        } finally {\n            w.unlock();\n        }\n    }\n}\n```\n使用非线程安全的 `HashMap` 作为缓存的实现。使用读写锁提升读操作的并发性，并简化了编程方式。\n\n## 4.2 读写锁的实现分析\n\n### 4.2.1 读写状态的设计\n\n读写锁依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态\n（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。  \n  \n如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。  \n![][4]  \n当前图的同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。\n假设当前同步状态值为 S ，写状态等于 S&0x0000FFFF（将高16位全部抹去），读状态等于 S>>>16（无符号补0右移16位）。当写状态增加1时，等于S+1,，\n当读状态增加1时，等于S+(1<<16)，也就是S+0x00010000。  \n  \n根据状态的划分能得出一个推论：S不等于0时，当写状态（S&0x0000FFFF）等于0时，则读状态（S>>>16）大于0，即读锁已被获取。\n\n### 4.2.2 写锁的获取与释放\n\n写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，\n则当前线程进入等待状态，获取锁的源码如下：\n```java\nprotected final boolean tryAcquire(int acquires) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    int w = exclusiveCount(c);\n    if (c != 0) {\n        // 存在读锁或者当前获取线程不是已经获取写锁的线程\n        if (w == 0 || current != getExclusiveOwnerThread())\n            return false;\n        if (w + exclusiveCount(acquires) > MAX_COUNT)\n            throw new Error(\"Maximum lock count exceeded\");\n        // Reentrant acquire\n        setState(c + acquires);\n        return true;\n    }\n    if (writerShouldBlock() ||\n        !compareAndSetState(c, c + acquires))\n        return false;\n    setExclusiveOwnerThread(current);\n    return true;\n}\n```\n\n### 4.2.3 读锁的获取与释放\n\n读锁是一个支持重进入的共享锁，能被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。\n如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如\n`getReadHoldCount()` 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的综合，而每个线程各自获取读锁的次数只能选择\n保存在 `ThreadLocal` 中，由线程自身维护，这使得获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分：\n```java\nprotected final int tryAcquireShared(int unused) {\n    for (;;) {\n        int c = getState();\n        int nextc = c + (1 << 16);\n        if (nextc < c)\n            throw new Error(\"Maximum lock count exceeded\");\n        if (exclusiveCount(c) != 0 && owner != Thread.currentThread())\n            return -1;\n        if (compareAndSetState(c, nextc))\n            return 1;\n    }\n}\n```\n如果其它线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，成功获取读锁。\n\n### 4.2.4 锁降级\n\n锁降级指的是写锁降级称为读锁。获取写锁-释放写锁-获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指：获取写锁-获取读锁-释放写锁。\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_4.png\n\n\n","slug":"concurrent-art/5.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauh0002axs6fr8vxgul","content":"<h1 id=\"1-Lock-接口\"><a href=\"#1-Lock-接口\" class=\"headerlink\" title=\"1 Lock 接口\"></a>1 Lock 接口</h1><h1 id=\"2-队列同步器\"><a href=\"#2-队列同步器\" class=\"headerlink\" title=\"2. 队列同步器\"></a>2. 队列同步器</h1><p>队列同步器 AbstractQueueSynchronizer （简称同步器），是用来构建锁或者其它同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，<br>通过内置的 FIFO 队列完成资源获取线程的排队工作。  </p>\n<h2 id=\"2-1-队列同步器的接口与示例\"><a href=\"#2-1-队列同步器的接口与示例\" class=\"headerlink\" title=\"2.1 队列同步器的接口与示例\"></a>2.1 队列同步器的接口与示例</h2><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，<br>它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。<br>锁和同步器很好地隔离了使用者和实现者所需关注的领域。  </p>\n<p>只有掌握了同步器的工作原理才能更加深入地理解并发包中其它的并发组件，所以下面通过一个独占锁的实例来深入了解一下同步器的工作原理。  </p>\n<p>独占锁就是在同一时刻只能由一个线程获取到锁，而其它获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁，代码5-2如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mutex</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态内部类，自定义同步器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 是否处于占用状态</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getState() == <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getState() == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">            setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync.acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.tryAcquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.tryAcquireNanos(<span class=\"number\">1</span>, unit.toNanos(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.isHeldExclusively();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedThreads</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.hasQueuedThreads();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        sync.acquireInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.newCondition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-队列同步器的实现分析\"><a href=\"#2-2-队列同步器的实现分析\" class=\"headerlink\" title=\"2.2 队列同步器的实现分析\"></a>2.2 队列同步器的实现分析</h2><p>分析同步器如何完成线程同步的，包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模块方法。</p>\n<h3 id=\"2-2-1-同步队列\"><a href=\"#2-2-1-同步队列\" class=\"headerlink\" title=\"2.2.1 同步队列\"></a>2.2.1 同步队列</h3><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点 （Node） 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，<br>会把首节点中的线程唤醒，使其再次尝试获取同步状态。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_1.png\" alt=\"\"><br>试想，当一个线程成功地获取了同步状态（锁），其它线程将无法获取到同步状态，转而被构造称为节点并加入到同步队列中，而这个加入队列的过程必须要<br>保证线程安全，因此同步器提供了一个基于 CAS 线程的设置尾节点的方法： <code>compareAndSetTail(Node expect, Node update)</code> ，它需要传递当前“认为”<br>的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_2.png\" alt=\"\"><br>首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_3.png\" alt=\"\"><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证。</p>\n<h3 id=\"2-2-2-独占式同步状态获取与释放\"><a href=\"#2-2-2-独占式同步状态获取与释放\" class=\"headerlink\" title=\"2.2.2 独占式同步状态获取与释放\"></a>2.2.2 独占式同步状态获取与释放</h3><p>通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程<br>进行中断操作时，线程不会从同步队列中移出，源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-重入锁\"><a href=\"#3-重入锁\" class=\"headerlink\" title=\"3 重入锁\"></a>3 重入锁</h1><p>ReenTrantLock，支持重入的锁。</p>\n<h2 id=\"3-1-实现重进入\"><a href=\"#3-1-实现重进入\" class=\"headerlink\" title=\"3.1 实现重进入\"></a>3.1 实现重进入</h2><p>这个特性需要解决两个问题：</p>\n<ol>\n<li>线程再次获取锁。锁需要去识别获取锁额线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>\n<li>锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放锁后，其它线程能够获取到锁。要求对获取进行计数自增，释放时计数自减。  </li>\n</ol>\n<p>获取锁源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>释放锁源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-2-公平与非公平获取锁的区别\"><a href=\"#3-2-公平与非公平获取锁的区别\" class=\"headerlink\" title=\"3.2 公平与非公平获取锁的区别\"></a>3.2 公平与非公平获取锁的区别</h2><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">            compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中相对于非公平锁的获取，多了一个 <code>hasQueuedPredecessors()</code> 判断，判断是否当前节点是否有前驱节点的判断。  </p>\n<p>如果有 n 个线程争夺锁。对于公平锁来说，保证了每个线程都可以获取锁，即有 n 次线程切换。而对于非公平锁来说，有可能有的线程能获取多次锁，<br>有的线程根本获取不到锁，线程切换次数是小于 n 的。因此减去上下文的切换时间，非公平锁的效率更高，所以 <code>ReentrantLock</code> 默认为非公平锁。 </p>\n<h1 id=\"4-读写锁\"><a href=\"#4-读写锁\" class=\"headerlink\" title=\"4 读写锁\"></a>4 读写锁</h1><p>在没有读写锁支持的时候（Java5之前），使用 Java 的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并行通知后，<br>所有等待的读操作才能继续执行（写操作之间依靠 synchronized 关键字进行同步）。  </p>\n<p>一般来说，读写锁的性能都会比排他锁好（ReentrantLock 也是一种排他锁），因为大多数场景读是多于写的。Java并发包提供读写锁的实现是 <code>ReentrantReadWriteLock</code>。</p>\n<h2 id=\"4-1-读写锁的接口与示例\"><a href=\"#4-1-读写锁的接口与示例\" class=\"headerlink\" title=\"4.1 读写锁的接口与示例\"></a>4.1 读写锁的接口与示例</h2><p>通过缓存示例说明读写锁的使用方式，代码5-16：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> ReentrantReadWriteLock rwl = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Lock r = rwl.readLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Lock w = rwl.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        r.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            r.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title\">put</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">        w.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.put(key, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            w.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        w.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            map.clear();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            w.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用非线程安全的 <code>HashMap</code> 作为缓存的实现。使用读写锁提升读操作的并发性，并简化了编程方式。</p>\n<h2 id=\"4-2-读写锁的实现分析\"><a href=\"#4-2-读写锁的实现分析\" class=\"headerlink\" title=\"4.2 读写锁的实现分析\"></a>4.2 读写锁的实现分析</h2><h3 id=\"4-2-1-读写状态的设计\"><a href=\"#4-2-1-读写状态的设计\" class=\"headerlink\" title=\"4.2.1 读写状态的设计\"></a>4.2.1 读写状态的设计</h3><p>读写锁依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态<br>（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。  </p>\n<p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_4.png\" alt=\"\"><br>当前图的同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。<br>假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF（将高16位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1,，<br>当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。  </p>\n<p>根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p>\n<h3 id=\"4-2-2-写锁的获取与释放\"><a href=\"#4-2-2-写锁的获取与释放\" class=\"headerlink\" title=\"4.2.2 写锁的获取与释放\"></a>4.2.2 写锁的获取与释放</h3><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，<br>则当前线程进入等待状态，获取锁的源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = exclusiveCount(c);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w == <span class=\"number\">0</span> || current != getExclusiveOwnerThread())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Reentrant acquire</span></span><br><span class=\"line\">        setState(c + acquires);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (writerShouldBlock() ||</span><br><span class=\"line\">        !compareAndSetState(c, c + acquires))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    setExclusiveOwnerThread(current);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-3-读锁的获取与释放\"><a href=\"#4-2-3-读锁的获取与释放\" class=\"headerlink\" title=\"4.2.3 读锁的获取与释放\"></a>4.2.3 读锁的获取与释放</h3><p>读锁是一个支持重进入的共享锁，能被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。<br>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如<br><code>getReadHoldCount()</code> 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的综合，而每个线程各自获取读锁的次数只能选择<br>保存在 <code>ThreadLocal</code> 中，由线程自身维护，这使得获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; c)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果其它线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，成功获取读锁。</p>\n<h3 id=\"4-2-4-锁降级\"><a href=\"#4-2-4-锁降级\" class=\"headerlink\" title=\"4.2.4 锁降级\"></a>4.2.4 锁降级</h3><p>锁降级指的是写锁降级称为读锁。获取写锁-释放写锁-获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指：获取写锁-获取读锁-释放写锁。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-Lock-接口\"><a href=\"#1-Lock-接口\" class=\"headerlink\" title=\"1 Lock 接口\"></a>1 Lock 接口</h1><h1 id=\"2-队列同步器\"><a href=\"#2-队列同步器\" class=\"headerlink\" title=\"2. 队列同步器\"></a>2. 队列同步器</h1><p>队列同步器 AbstractQueueSynchronizer （简称同步器），是用来构建锁或者其它同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，<br>通过内置的 FIFO 队列完成资源获取线程的排队工作。  </p>\n<h2 id=\"2-1-队列同步器的接口与示例\"><a href=\"#2-1-队列同步器的接口与示例\" class=\"headerlink\" title=\"2.1 队列同步器的接口与示例\"></a>2.1 队列同步器的接口与示例</h2><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，<br>它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。<br>锁和同步器很好地隔离了使用者和实现者所需关注的领域。  </p>\n<p>只有掌握了同步器的工作原理才能更加深入地理解并发包中其它的并发组件，所以下面通过一个独占锁的实例来深入了解一下同步器的工作原理。  </p>\n<p>独占锁就是在同一时刻只能由一个线程获取到锁，而其它获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁，代码5-2如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mutex</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态内部类，自定义同步器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 是否处于占用状态</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getState() == <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getState() == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">            setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync.acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.tryAcquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.tryAcquireNanos(<span class=\"number\">1</span>, unit.toNanos(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.isHeldExclusively();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedThreads</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.hasQueuedThreads();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        sync.acquireInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.newCondition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-队列同步器的实现分析\"><a href=\"#2-2-队列同步器的实现分析\" class=\"headerlink\" title=\"2.2 队列同步器的实现分析\"></a>2.2 队列同步器的实现分析</h2><p>分析同步器如何完成线程同步的，包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模块方法。</p>\n<h3 id=\"2-2-1-同步队列\"><a href=\"#2-2-1-同步队列\" class=\"headerlink\" title=\"2.2.1 同步队列\"></a>2.2.1 同步队列</h3><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点 （Node） 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，<br>会把首节点中的线程唤醒，使其再次尝试获取同步状态。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_1.png\" alt=\"\"><br>试想，当一个线程成功地获取了同步状态（锁），其它线程将无法获取到同步状态，转而被构造称为节点并加入到同步队列中，而这个加入队列的过程必须要<br>保证线程安全，因此同步器提供了一个基于 CAS 线程的设置尾节点的方法： <code>compareAndSetTail(Node expect, Node update)</code> ，它需要传递当前“认为”<br>的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_2.png\" alt=\"\"><br>首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_3.png\" alt=\"\"><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证。</p>\n<h3 id=\"2-2-2-独占式同步状态获取与释放\"><a href=\"#2-2-2-独占式同步状态获取与释放\" class=\"headerlink\" title=\"2.2.2 独占式同步状态获取与释放\"></a>2.2.2 独占式同步状态获取与释放</h3><p>通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程<br>进行中断操作时，线程不会从同步队列中移出，源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-重入锁\"><a href=\"#3-重入锁\" class=\"headerlink\" title=\"3 重入锁\"></a>3 重入锁</h1><p>ReenTrantLock，支持重入的锁。</p>\n<h2 id=\"3-1-实现重进入\"><a href=\"#3-1-实现重进入\" class=\"headerlink\" title=\"3.1 实现重进入\"></a>3.1 实现重进入</h2><p>这个特性需要解决两个问题：</p>\n<ol>\n<li>线程再次获取锁。锁需要去识别获取锁额线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>\n<li>锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放锁后，其它线程能够获取到锁。要求对获取进行计数自增，释放时计数自减。  </li>\n</ol>\n<p>获取锁源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>释放锁源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-2-公平与非公平获取锁的区别\"><a href=\"#3-2-公平与非公平获取锁的区别\" class=\"headerlink\" title=\"3.2 公平与非公平获取锁的区别\"></a>3.2 公平与非公平获取锁的区别</h2><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">            compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中相对于非公平锁的获取，多了一个 <code>hasQueuedPredecessors()</code> 判断，判断是否当前节点是否有前驱节点的判断。  </p>\n<p>如果有 n 个线程争夺锁。对于公平锁来说，保证了每个线程都可以获取锁，即有 n 次线程切换。而对于非公平锁来说，有可能有的线程能获取多次锁，<br>有的线程根本获取不到锁，线程切换次数是小于 n 的。因此减去上下文的切换时间，非公平锁的效率更高，所以 <code>ReentrantLock</code> 默认为非公平锁。 </p>\n<h1 id=\"4-读写锁\"><a href=\"#4-读写锁\" class=\"headerlink\" title=\"4 读写锁\"></a>4 读写锁</h1><p>在没有读写锁支持的时候（Java5之前），使用 Java 的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并行通知后，<br>所有等待的读操作才能继续执行（写操作之间依靠 synchronized 关键字进行同步）。  </p>\n<p>一般来说，读写锁的性能都会比排他锁好（ReentrantLock 也是一种排他锁），因为大多数场景读是多于写的。Java并发包提供读写锁的实现是 <code>ReentrantReadWriteLock</code>。</p>\n<h2 id=\"4-1-读写锁的接口与示例\"><a href=\"#4-1-读写锁的接口与示例\" class=\"headerlink\" title=\"4.1 读写锁的接口与示例\"></a>4.1 读写锁的接口与示例</h2><p>通过缓存示例说明读写锁的使用方式，代码5-16：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> ReentrantReadWriteLock rwl = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Lock r = rwl.readLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Lock w = rwl.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        r.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            r.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object <span class=\"title\">put</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">        w.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.put(key, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            w.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        w.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            map.clear();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            w.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用非线程安全的 <code>HashMap</code> 作为缓存的实现。使用读写锁提升读操作的并发性，并简化了编程方式。</p>\n<h2 id=\"4-2-读写锁的实现分析\"><a href=\"#4-2-读写锁的实现分析\" class=\"headerlink\" title=\"4.2 读写锁的实现分析\"></a>4.2 读写锁的实现分析</h2><h3 id=\"4-2-1-读写状态的设计\"><a href=\"#4-2-1-读写状态的设计\" class=\"headerlink\" title=\"4.2.1 读写状态的设计\"></a>4.2.1 读写状态的设计</h3><p>读写锁依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态<br>（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。  </p>\n<p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_4.png\" alt=\"\"><br>当前图的同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。<br>假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF（将高16位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1,，<br>当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。  </p>\n<p>根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p>\n<h3 id=\"4-2-2-写锁的获取与释放\"><a href=\"#4-2-2-写锁的获取与释放\" class=\"headerlink\" title=\"4.2.2 写锁的获取与释放\"></a>4.2.2 写锁的获取与释放</h3><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，<br>则当前线程进入等待状态，获取锁的源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = exclusiveCount(c);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w == <span class=\"number\">0</span> || current != getExclusiveOwnerThread())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Reentrant acquire</span></span><br><span class=\"line\">        setState(c + acquires);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (writerShouldBlock() ||</span><br><span class=\"line\">        !compareAndSetState(c, c + acquires))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    setExclusiveOwnerThread(current);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-3-读锁的获取与释放\"><a href=\"#4-2-3-读锁的获取与释放\" class=\"headerlink\" title=\"4.2.3 读锁的获取与释放\"></a>4.2.3 读锁的获取与释放</h3><p>读锁是一个支持重进入的共享锁，能被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。<br>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如<br><code>getReadHoldCount()</code> 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的综合，而每个线程各自获取读锁的次数只能选择<br>保存在 <code>ThreadLocal</code> 中，由线程自身维护，这使得获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; c)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果其它线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，成功获取读锁。</p>\n<h3 id=\"4-2-4-锁降级\"><a href=\"#4-2-4-锁降级\" class=\"headerlink\" title=\"4.2.4 锁降级\"></a>4.2.4 锁降级</h3><p>锁降级指的是写锁降级称为读锁。获取写锁-释放写锁-获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指：获取写锁-获取读锁-释放写锁。</p>\n"},{"title":"六、Java并发容器和框架","date":"2017-11-07T12:07:00.000Z","updated":"2017-11-07T12:07:00.000Z","comments":1,"_content":"\n# 1 ConcurrentHashMap 的实现原理与使用\n\n## 1.1 为什么要使用 ConcurrentHashMap\n\n1. 线程不安全的 HashMap ，在多线程下 HashMap 的 Entry 链表导致形成环形数据结构， Entry 的 next 节点永远不为空，就会产生死循环获取 Entry 。\n2. 效率低下的 HashTable ，使用 synchronized 保证线程安全。\n3. ConcurrentHashMap 的锁分段技术有效提升并发访问率。 HashTable 效率低下是因为所有访问 HashTable 的线程都必须竞争同一把锁，如果容器里\n有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程就不会存在锁竞争。\n\n## 1.2 ConcurrentHashMap 的结构\n\nConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁（ReentrantLock）， Segment的结构和 HashMap \n结构类似。  \n![][1]\n\n## 1.3 ConcurrentHashMap 的初始化\n\n1. 初始化 segments 数组\n2. 初始化 segmentShift 和 segmentMask。用于散列算法的一些值。\n3. 初始化每个 segment，包括容量以及负载因子。\n\n## 1.4 ConcurrentHashMap 的操作\n\n### 1.4.1 get 操作\n\nget 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。如何保证不加锁？原因在于它的 get 方法里将要使用的共享变量都\n定义成 volatile 类型，如用于统计当前 Segment 大小的 count 字段和用于存储值的 HashEntry 的 value 。但只能被单线程写（有一种情况可以被\n多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value ，所以不需要加锁。即使两个线程同时修改和获取\n volatile 变量， get 操作也能拿到最新的值，这是用 volatile 替换锁的经典应用场景。\n \n### 1.4.2 put 操作\n\n必须加锁。先定位到 Segment ，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对 Segment 里的 HashEntry 数组\n进行扩容，第二步定位添加元素的位置，然后将其放在 HashEntry 数组里。\n1. 是否需要扩容：插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量，如果超过阈值，则对数组进行扩容。\n2. 如何扩容：先创建一个容量是原来容量两倍的数组，然后将原数组里元素进行散列后插入到新的数组里。为了高效， 只会对某个 Segment 进行扩容。\n\n### 1.4.3 size 操作\n\n每个 Segment 的count 是 valatile 变量，但是累加过程中有可能 count 发生变化，最安全的做法是在统计 size 的时候把所有 Segment 的 put、\nremove 和 clean 方法全部锁住，但是非常低效。所以 ConcurrentHashMap 的做法是尝试 2 次通过不锁住 Segment 的方式来统计累和，如果 count\n发生变化，再采用加锁方式统计。如果判断count 发生变化呢？使用 modCount 变量。\n\n# 2 ConcurrentLinkedQueue\n\n实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。前者可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队\n用不同的锁）等方式实现。非阻塞的实现则可以使用循环 CAS 的方式来实现。\n\n## 2.1 ConcurrentLinkedQueue 的结构\n\n由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成。默认情况下 head 节点存储的元素为空，\ntail 节点等于 head 节点。\n\n## 2.2 入队列\n\n### 2.2.1 入队列的过程\n\n1. 添加元素1。队列更新 head 节点的 next 节点为元素1节点，又因为 tail 节点默认情况下等于 head 节点，所以它们的 next 节点都指向元素1节点。  \n2. 添加元素2。队列首先设置元素1节点的 next 节点为元素2节点，然后更新 tail 节点指向元素2节点。\n3. 添加元素3。设置 tail 节点的 next 节点为元素3节点。\n4. 添加元素4。设置元素3的 next 节点为元素4节点，然后将 tail 节点指向元素4节点。  \n![][2]  \n入队主要做两件事：一是将入队节点设置成当前队列尾节点的下一个节点；二是更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成\ntail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。  \n  \n在代码中，入队主要做两件事：一是定位出尾节点（通过 tail 的 next 是否为空）；二是使用 CAS 算法将入队队列设置成尾节点的 next 节点，如不成功则重试。\n（进行 tail 的 next 判断是否为空时，如果循环两次都不为空，则重新进行队列，因为肯定有别的线程加了尾）。源码如下：\n```java\npublic boolean offer(E e) {\n    if (e == null) throw new NullPointerException();\n    // 入队前，创建一个入队节点\n    Node<E> n = new Node<E>(e);\n    retry:\n    // 死循环，入队不成功反复入队。\n    for (;;) {\n        // 创建一个指向tail节点的引用\n        Node<E> t = tail;\n        // p用来表示队列的尾节点，默认情况下等于tail节点。\n        Node<E> p = t;\n        for (int hops = 0; ; hops++) {\n            // 获得p节点的下一个节点。\n            Node<E> next = succ(p);\n            // next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点\n            if (next != null) {\n                // 循环了两次及其以上，并且当前节点还是不等于尾节点\n                if (hops > HOPS && t != tail)\n                continue retry;\n                p = next;\n            }\n            // 如果p是尾节点，则设置p节点的next节点为入队节点。\n            else if (p.casNext(null, n)) {\n                /*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，\n                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/\n                if (hops >= HOPS)\n                    casTail(t, n); // 更新tail节点，允许失败\n                return true;\n            }\n            // p有next节点,表示p的next节点是尾节点，则重新设置p节点\n            else {\n                p = succ(p);\n            }\n        }\n    }\n}\n```\n\n### 2.2.2 定位尾节点\n\n通过判断 tail 节点和 tail 节点的 next 节点。\n\n### 2.2.3 HOPS 的设计意图\n\n用如下实现是否可行：\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    Node<E> n = new Node<E>(e);\n    for (;;) {\n        Node<E> t = tail;\n        if (t.casNext(null, n) && casTail(t, n)) {\n            return true;\n        }\n    }\n}\n```\n让 tail 节点永远作为队列的尾节点，这样实现代码量非常少。但是有个缺点是，每次都要更新 tail 节点为尾节点，而使用 HOPS 常量，进行判断，如果\n当 tail 节点和尾节点的距离大于等于常量 HOPS 的值（默认等于1）时才更新 tail 节点，来通过增加对 volatile 变量的读操作来减少对 volatile 变量\n的写操作，入队效率提升。\n\n## 2.3 出队列\n\n只有当 head 节点里没有元素时，出队操作才会更新 head 节点。这种做法也是通过 hops 变量来减少使用 CAS 更新 head 节点的消耗，从而提高出队效率。  \n![][3]\n\n# 3 Java 中的阻塞队列\n\n## 3.1 什么是阻塞队列\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。\n1. 支持阻塞的插入方法：意思当队列满时，队列会阻塞插入元素的线程，直到队列不满。\n2. 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。\n\n## 3.2 Java 里的阻塞队列\n|类名|描述|\n|:-----------------|:---------------------------|\n|ArrayBlockingQueue|一个由数组结构组成的有界阻塞队列|\n|LinkedBlockingQueue|一个由链表结构组成的有界阻塞队列|\n|PriorityBlockingQueue|支持优先级排序的无界阻塞队列|\n|DelayQueue|使用优先级队列实现的无界阻塞队列|\n|SynchronousQueue|不存储元素的阻塞队列|\n|LinkedTransferQueue|由链表结构组成的无界阻塞队列|\n|LinkedBlockingDeque|由链表结构组成的双向阻塞队列|\n\n## 3.3 阻塞队列的实现原理\n\n### 3.3.1 使用通知模式实现\n\n即当生产者往满的队列里添加元素时会阻塞住消费者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。\n\n# 4 Fork/Join 框架\n\n## 4.1 什么是 Fork/Join 框架\n\nFork 就是把一个大任务切分为若干子任务并行的执行， Join 就是合并这些子任务的执行结果。  \n![][4]\n\n## 4.2 工作窃取算法\n\n某个线程先把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理，这时候，完成任务的线程去做还有任务的线程的任务。  \n1. 优点：充分利用线程进行并行计算，减少线程间的竞争。\n2. 缺点：如果只有一个任务时，还是会有竞争。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。\n\n## 4.3 Fork/Join 框架的设计\n\n1. 分割任务：首先我们需要由一个 fork 类来把大任务分割成小任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。\n2. 执行任务并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，\n启动一个线程从队列里里拿数据，然后合并这些数据。  \n  \nFork/Join 使用两个类来完成以上两件事。  \n  \n1. ForkJoinTask：我们要使用 ForkJoin框架，必须首先创建一个 Fork/Join 任务。它提供在任务中执行 fork() 和 join() 操作的机制。通常情况下，\n我们只需要继承它的子类，而 Fork/Join 框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务； RecursiveTask：用于有返回结果的任务。  \n2. ForkJoinPool：ForkJoinTask 需要通过 ForkJoinPool 来执行：任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。\n当一个工作线程的队列里暂时没有任务时，它会随机从其它工作线程的队列的尾部 获取一个任务。\n\n## 4.4 使用 Fork/Join 框架\n\n需求：计算1+2+3+4的结果。  \n如果希望每个子任务最多执行两个数的相加，我们设置分割的阈值是2，由于是4个数字相加，所以fork成两个子任务，一个计算1+2，一个计算3+4，然后再join两个子任务。\n由于有结果的任务，因此继承 RecursiveTask。\n```java\npublic class CountTask extends RecursiveTask<Integer>{\n\n    private static final int THRESHOLD = 2; // 阈值\n    private int start;\n    private int end;\n\n    public CountTask(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Integer compute() {\n        int sum = 0;\n        boolean canCompute = (end - start) <= THRESHOLD;\n        // 如果任务足够小就计算任务\n        if (canCompute) {\n            for (int i = start; i <= end; i++) {\n                sum += i;\n            }\n        } else {\n            // 如果任务大于阈值，就分裂成两个子任务计算\n            int middle = (start + end) / 2;\n            CountTask leftTask = new CountTask(start, middle);\n            CountTask rightTask = new CountTask(middle + 1, end);\n            // 执行子任务\n            leftTask.fork();\n            rightTask.fork();\n            // 等待子任务执行完，并得到其结果\n            int leftResult = leftTask.join();\n            int rightResult = rightTask.join();\n            // 合并子任务\n            sum = leftResult + rightResult;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        // 生成一个计算任务，负责计算1+2+3+4\n        CountTask task = new CountTask(1, 4);\n\n        Future<Integer> result = forkJoinPool.submit(task);\n        try {\n            System.out.println(result.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 4.5 Fork/Join 框架的实现原理\n\nForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成， ForkJoinTask 数组负责将存放程序提交给 ForkJoinPool 的任务，\n而 ForkJoinWorkerThread 数组负责执行这些任务。\n\n### 4.5.1 ForkJoinTask 的 fork 方法实现原理\n\n使用 push 方法，把当前任务存放在 ForkJoinTask 数组队列中，再调用 ForkJoinPool 的 signalWork() 方法唤醒或创建一个工作线程来异步的执行这个任务，\n然后立即返回结果。\n```java\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n >= m)\n            growArray();\n    }\n}\n```\n\n### 4.5.2 ForkJoinTask 的 join 方法实现原理\n\nJoin 方法主要用于阻塞当前线程并等待获取结果。调用 doJoin() 方法，通过查看任务状态，如果执行完则直接返回任务状态；如果没执行完，\n则从任务数组里取出任务并执行。\n```java\n public final V join() {\n    int s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL)\n        reportException(s);\n    return getRawResult();\n}\n\nprivate void reportException(int s) {\n    if (s == CANCELLED)\n        throw new CancellationException();\n    if (s == EXCEPTIONAL)\n        rethrow(getThrowableException());\n}\nprivate int doJoin() {\n    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (w = (wt = (ForkJoinWorkerThread)t).workQueue).\n        tryUnpush(this) && (s = doExec()) < 0 ? s :\n        wt.pool.awaitJoin(w, this, 0L) :\n        externalAwaitDone();\n}\n\n```\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_4.png","source":"_posts/Java 并发编程的艺术/第六章 Java并发容器和框架.md","raw":"---\ntitle: 六、Java并发容器和框架\ndate: 2017-11-07 20:07:00\nupdated: 2017-11-07 20:07:00\ncomments: true\ncategories: \n- 读书笔记\n- Java并发编程的艺术\npermalink: concurrent-art/6.html    \n---\n\n# 1 ConcurrentHashMap 的实现原理与使用\n\n## 1.1 为什么要使用 ConcurrentHashMap\n\n1. 线程不安全的 HashMap ，在多线程下 HashMap 的 Entry 链表导致形成环形数据结构， Entry 的 next 节点永远不为空，就会产生死循环获取 Entry 。\n2. 效率低下的 HashTable ，使用 synchronized 保证线程安全。\n3. ConcurrentHashMap 的锁分段技术有效提升并发访问率。 HashTable 效率低下是因为所有访问 HashTable 的线程都必须竞争同一把锁，如果容器里\n有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程就不会存在锁竞争。\n\n## 1.2 ConcurrentHashMap 的结构\n\nConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁（ReentrantLock）， Segment的结构和 HashMap \n结构类似。  \n![][1]\n\n## 1.3 ConcurrentHashMap 的初始化\n\n1. 初始化 segments 数组\n2. 初始化 segmentShift 和 segmentMask。用于散列算法的一些值。\n3. 初始化每个 segment，包括容量以及负载因子。\n\n## 1.4 ConcurrentHashMap 的操作\n\n### 1.4.1 get 操作\n\nget 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。如何保证不加锁？原因在于它的 get 方法里将要使用的共享变量都\n定义成 volatile 类型，如用于统计当前 Segment 大小的 count 字段和用于存储值的 HashEntry 的 value 。但只能被单线程写（有一种情况可以被\n多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value ，所以不需要加锁。即使两个线程同时修改和获取\n volatile 变量， get 操作也能拿到最新的值，这是用 volatile 替换锁的经典应用场景。\n \n### 1.4.2 put 操作\n\n必须加锁。先定位到 Segment ，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对 Segment 里的 HashEntry 数组\n进行扩容，第二步定位添加元素的位置，然后将其放在 HashEntry 数组里。\n1. 是否需要扩容：插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量，如果超过阈值，则对数组进行扩容。\n2. 如何扩容：先创建一个容量是原来容量两倍的数组，然后将原数组里元素进行散列后插入到新的数组里。为了高效， 只会对某个 Segment 进行扩容。\n\n### 1.4.3 size 操作\n\n每个 Segment 的count 是 valatile 变量，但是累加过程中有可能 count 发生变化，最安全的做法是在统计 size 的时候把所有 Segment 的 put、\nremove 和 clean 方法全部锁住，但是非常低效。所以 ConcurrentHashMap 的做法是尝试 2 次通过不锁住 Segment 的方式来统计累和，如果 count\n发生变化，再采用加锁方式统计。如果判断count 发生变化呢？使用 modCount 变量。\n\n# 2 ConcurrentLinkedQueue\n\n实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。前者可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队\n用不同的锁）等方式实现。非阻塞的实现则可以使用循环 CAS 的方式来实现。\n\n## 2.1 ConcurrentLinkedQueue 的结构\n\n由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成。默认情况下 head 节点存储的元素为空，\ntail 节点等于 head 节点。\n\n## 2.2 入队列\n\n### 2.2.1 入队列的过程\n\n1. 添加元素1。队列更新 head 节点的 next 节点为元素1节点，又因为 tail 节点默认情况下等于 head 节点，所以它们的 next 节点都指向元素1节点。  \n2. 添加元素2。队列首先设置元素1节点的 next 节点为元素2节点，然后更新 tail 节点指向元素2节点。\n3. 添加元素3。设置 tail 节点的 next 节点为元素3节点。\n4. 添加元素4。设置元素3的 next 节点为元素4节点，然后将 tail 节点指向元素4节点。  \n![][2]  \n入队主要做两件事：一是将入队节点设置成当前队列尾节点的下一个节点；二是更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成\ntail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。  \n  \n在代码中，入队主要做两件事：一是定位出尾节点（通过 tail 的 next 是否为空）；二是使用 CAS 算法将入队队列设置成尾节点的 next 节点，如不成功则重试。\n（进行 tail 的 next 判断是否为空时，如果循环两次都不为空，则重新进行队列，因为肯定有别的线程加了尾）。源码如下：\n```java\npublic boolean offer(E e) {\n    if (e == null) throw new NullPointerException();\n    // 入队前，创建一个入队节点\n    Node<E> n = new Node<E>(e);\n    retry:\n    // 死循环，入队不成功反复入队。\n    for (;;) {\n        // 创建一个指向tail节点的引用\n        Node<E> t = tail;\n        // p用来表示队列的尾节点，默认情况下等于tail节点。\n        Node<E> p = t;\n        for (int hops = 0; ; hops++) {\n            // 获得p节点的下一个节点。\n            Node<E> next = succ(p);\n            // next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点\n            if (next != null) {\n                // 循环了两次及其以上，并且当前节点还是不等于尾节点\n                if (hops > HOPS && t != tail)\n                continue retry;\n                p = next;\n            }\n            // 如果p是尾节点，则设置p节点的next节点为入队节点。\n            else if (p.casNext(null, n)) {\n                /*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，\n                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/\n                if (hops >= HOPS)\n                    casTail(t, n); // 更新tail节点，允许失败\n                return true;\n            }\n            // p有next节点,表示p的next节点是尾节点，则重新设置p节点\n            else {\n                p = succ(p);\n            }\n        }\n    }\n}\n```\n\n### 2.2.2 定位尾节点\n\n通过判断 tail 节点和 tail 节点的 next 节点。\n\n### 2.2.3 HOPS 的设计意图\n\n用如下实现是否可行：\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    Node<E> n = new Node<E>(e);\n    for (;;) {\n        Node<E> t = tail;\n        if (t.casNext(null, n) && casTail(t, n)) {\n            return true;\n        }\n    }\n}\n```\n让 tail 节点永远作为队列的尾节点，这样实现代码量非常少。但是有个缺点是，每次都要更新 tail 节点为尾节点，而使用 HOPS 常量，进行判断，如果\n当 tail 节点和尾节点的距离大于等于常量 HOPS 的值（默认等于1）时才更新 tail 节点，来通过增加对 volatile 变量的读操作来减少对 volatile 变量\n的写操作，入队效率提升。\n\n## 2.3 出队列\n\n只有当 head 节点里没有元素时，出队操作才会更新 head 节点。这种做法也是通过 hops 变量来减少使用 CAS 更新 head 节点的消耗，从而提高出队效率。  \n![][3]\n\n# 3 Java 中的阻塞队列\n\n## 3.1 什么是阻塞队列\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。\n1. 支持阻塞的插入方法：意思当队列满时，队列会阻塞插入元素的线程，直到队列不满。\n2. 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。\n\n## 3.2 Java 里的阻塞队列\n|类名|描述|\n|:-----------------|:---------------------------|\n|ArrayBlockingQueue|一个由数组结构组成的有界阻塞队列|\n|LinkedBlockingQueue|一个由链表结构组成的有界阻塞队列|\n|PriorityBlockingQueue|支持优先级排序的无界阻塞队列|\n|DelayQueue|使用优先级队列实现的无界阻塞队列|\n|SynchronousQueue|不存储元素的阻塞队列|\n|LinkedTransferQueue|由链表结构组成的无界阻塞队列|\n|LinkedBlockingDeque|由链表结构组成的双向阻塞队列|\n\n## 3.3 阻塞队列的实现原理\n\n### 3.3.1 使用通知模式实现\n\n即当生产者往满的队列里添加元素时会阻塞住消费者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。\n\n# 4 Fork/Join 框架\n\n## 4.1 什么是 Fork/Join 框架\n\nFork 就是把一个大任务切分为若干子任务并行的执行， Join 就是合并这些子任务的执行结果。  \n![][4]\n\n## 4.2 工作窃取算法\n\n某个线程先把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理，这时候，完成任务的线程去做还有任务的线程的任务。  \n1. 优点：充分利用线程进行并行计算，减少线程间的竞争。\n2. 缺点：如果只有一个任务时，还是会有竞争。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。\n\n## 4.3 Fork/Join 框架的设计\n\n1. 分割任务：首先我们需要由一个 fork 类来把大任务分割成小任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。\n2. 执行任务并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，\n启动一个线程从队列里里拿数据，然后合并这些数据。  \n  \nFork/Join 使用两个类来完成以上两件事。  \n  \n1. ForkJoinTask：我们要使用 ForkJoin框架，必须首先创建一个 Fork/Join 任务。它提供在任务中执行 fork() 和 join() 操作的机制。通常情况下，\n我们只需要继承它的子类，而 Fork/Join 框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务； RecursiveTask：用于有返回结果的任务。  \n2. ForkJoinPool：ForkJoinTask 需要通过 ForkJoinPool 来执行：任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。\n当一个工作线程的队列里暂时没有任务时，它会随机从其它工作线程的队列的尾部 获取一个任务。\n\n## 4.4 使用 Fork/Join 框架\n\n需求：计算1+2+3+4的结果。  \n如果希望每个子任务最多执行两个数的相加，我们设置分割的阈值是2，由于是4个数字相加，所以fork成两个子任务，一个计算1+2，一个计算3+4，然后再join两个子任务。\n由于有结果的任务，因此继承 RecursiveTask。\n```java\npublic class CountTask extends RecursiveTask<Integer>{\n\n    private static final int THRESHOLD = 2; // 阈值\n    private int start;\n    private int end;\n\n    public CountTask(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Integer compute() {\n        int sum = 0;\n        boolean canCompute = (end - start) <= THRESHOLD;\n        // 如果任务足够小就计算任务\n        if (canCompute) {\n            for (int i = start; i <= end; i++) {\n                sum += i;\n            }\n        } else {\n            // 如果任务大于阈值，就分裂成两个子任务计算\n            int middle = (start + end) / 2;\n            CountTask leftTask = new CountTask(start, middle);\n            CountTask rightTask = new CountTask(middle + 1, end);\n            // 执行子任务\n            leftTask.fork();\n            rightTask.fork();\n            // 等待子任务执行完，并得到其结果\n            int leftResult = leftTask.join();\n            int rightResult = rightTask.join();\n            // 合并子任务\n            sum = leftResult + rightResult;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        // 生成一个计算任务，负责计算1+2+3+4\n        CountTask task = new CountTask(1, 4);\n\n        Future<Integer> result = forkJoinPool.submit(task);\n        try {\n            System.out.println(result.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 4.5 Fork/Join 框架的实现原理\n\nForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成， ForkJoinTask 数组负责将存放程序提交给 ForkJoinPool 的任务，\n而 ForkJoinWorkerThread 数组负责执行这些任务。\n\n### 4.5.1 ForkJoinTask 的 fork 方法实现原理\n\n使用 push 方法，把当前任务存放在 ForkJoinTask 数组队列中，再调用 ForkJoinPool 的 signalWork() 方法唤醒或创建一个工作线程来异步的执行这个任务，\n然后立即返回结果。\n```java\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n >= m)\n            growArray();\n    }\n}\n```\n\n### 4.5.2 ForkJoinTask 的 join 方法实现原理\n\nJoin 方法主要用于阻塞当前线程并等待获取结果。调用 doJoin() 方法，通过查看任务状态，如果执行完则直接返回任务状态；如果没执行完，\n则从任务数组里取出任务并执行。\n```java\n public final V join() {\n    int s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL)\n        reportException(s);\n    return getRawResult();\n}\n\nprivate void reportException(int s) {\n    if (s == CANCELLED)\n        throw new CancellationException();\n    if (s == EXCEPTIONAL)\n        rethrow(getThrowableException());\n}\nprivate int doJoin() {\n    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (w = (wt = (ForkJoinWorkerThread)t).workQueue).\n        tryUnpush(this) && (s = doExec()) < 0 ? s :\n        wt.pool.awaitJoin(w, this, 0L) :\n        externalAwaitDone();\n}\n\n```\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_4.png","slug":"concurrent-art/6.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauk0003axs6vz9vycay","content":"<h1 id=\"1-ConcurrentHashMap-的实现原理与使用\"><a href=\"#1-ConcurrentHashMap-的实现原理与使用\" class=\"headerlink\" title=\"1 ConcurrentHashMap 的实现原理与使用\"></a>1 ConcurrentHashMap 的实现原理与使用</h1><h2 id=\"1-1-为什么要使用-ConcurrentHashMap\"><a href=\"#1-1-为什么要使用-ConcurrentHashMap\" class=\"headerlink\" title=\"1.1 为什么要使用 ConcurrentHashMap\"></a>1.1 为什么要使用 ConcurrentHashMap</h2><ol>\n<li>线程不安全的 HashMap ，在多线程下 HashMap 的 Entry 链表导致形成环形数据结构， Entry 的 next 节点永远不为空，就会产生死循环获取 Entry 。</li>\n<li>效率低下的 HashTable ，使用 synchronized 保证线程安全。</li>\n<li>ConcurrentHashMap 的锁分段技术有效提升并发访问率。 HashTable 效率低下是因为所有访问 HashTable 的线程都必须竞争同一把锁，如果容器里<br>有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程就不会存在锁竞争。</li>\n</ol>\n<h2 id=\"1-2-ConcurrentHashMap-的结构\"><a href=\"#1-2-ConcurrentHashMap-的结构\" class=\"headerlink\" title=\"1.2 ConcurrentHashMap 的结构\"></a>1.2 ConcurrentHashMap 的结构</h2><p>ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁（ReentrantLock）， Segment的结构和 HashMap<br>结构类似。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_1.png\" alt=\"\"></p>\n<h2 id=\"1-3-ConcurrentHashMap-的初始化\"><a href=\"#1-3-ConcurrentHashMap-的初始化\" class=\"headerlink\" title=\"1.3 ConcurrentHashMap 的初始化\"></a>1.3 ConcurrentHashMap 的初始化</h2><ol>\n<li>初始化 segments 数组</li>\n<li>初始化 segmentShift 和 segmentMask。用于散列算法的一些值。</li>\n<li>初始化每个 segment，包括容量以及负载因子。</li>\n</ol>\n<h2 id=\"1-4-ConcurrentHashMap-的操作\"><a href=\"#1-4-ConcurrentHashMap-的操作\" class=\"headerlink\" title=\"1.4 ConcurrentHashMap 的操作\"></a>1.4 ConcurrentHashMap 的操作</h2><h3 id=\"1-4-1-get-操作\"><a href=\"#1-4-1-get-操作\" class=\"headerlink\" title=\"1.4.1 get 操作\"></a>1.4.1 get 操作</h3><p>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。如何保证不加锁？原因在于它的 get 方法里将要使用的共享变量都<br>定义成 volatile 类型，如用于统计当前 Segment 大小的 count 字段和用于存储值的 HashEntry 的 value 。但只能被单线程写（有一种情况可以被<br>多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value ，所以不需要加锁。即使两个线程同时修改和获取<br> volatile 变量， get 操作也能拿到最新的值，这是用 volatile 替换锁的经典应用场景。</p>\n<h3 id=\"1-4-2-put-操作\"><a href=\"#1-4-2-put-操作\" class=\"headerlink\" title=\"1.4.2 put 操作\"></a>1.4.2 put 操作</h3><p>必须加锁。先定位到 Segment ，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对 Segment 里的 HashEntry 数组<br>进行扩容，第二步定位添加元素的位置，然后将其放在 HashEntry 数组里。</p>\n<ol>\n<li>是否需要扩容：插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量，如果超过阈值，则对数组进行扩容。</li>\n<li>如何扩容：先创建一个容量是原来容量两倍的数组，然后将原数组里元素进行散列后插入到新的数组里。为了高效， 只会对某个 Segment 进行扩容。</li>\n</ol>\n<h3 id=\"1-4-3-size-操作\"><a href=\"#1-4-3-size-操作\" class=\"headerlink\" title=\"1.4.3 size 操作\"></a>1.4.3 size 操作</h3><p>每个 Segment 的count 是 valatile 变量，但是累加过程中有可能 count 发生变化，最安全的做法是在统计 size 的时候把所有 Segment 的 put、<br>remove 和 clean 方法全部锁住，但是非常低效。所以 ConcurrentHashMap 的做法是尝试 2 次通过不锁住 Segment 的方式来统计累和，如果 count<br>发生变化，再采用加锁方式统计。如果判断count 发生变化呢？使用 modCount 变量。</p>\n<h1 id=\"2-ConcurrentLinkedQueue\"><a href=\"#2-ConcurrentLinkedQueue\" class=\"headerlink\" title=\"2 ConcurrentLinkedQueue\"></a>2 ConcurrentLinkedQueue</h1><p>实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。前者可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队<br>用不同的锁）等方式实现。非阻塞的实现则可以使用循环 CAS 的方式来实现。</p>\n<h2 id=\"2-1-ConcurrentLinkedQueue-的结构\"><a href=\"#2-1-ConcurrentLinkedQueue-的结构\" class=\"headerlink\" title=\"2.1 ConcurrentLinkedQueue 的结构\"></a>2.1 ConcurrentLinkedQueue 的结构</h2><p>由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成。默认情况下 head 节点存储的元素为空，<br>tail 节点等于 head 节点。</p>\n<h2 id=\"2-2-入队列\"><a href=\"#2-2-入队列\" class=\"headerlink\" title=\"2.2 入队列\"></a>2.2 入队列</h2><h3 id=\"2-2-1-入队列的过程\"><a href=\"#2-2-1-入队列的过程\" class=\"headerlink\" title=\"2.2.1 入队列的过程\"></a>2.2.1 入队列的过程</h3><ol>\n<li>添加元素1。队列更新 head 节点的 next 节点为元素1节点，又因为 tail 节点默认情况下等于 head 节点，所以它们的 next 节点都指向元素1节点。  </li>\n<li>添加元素2。队列首先设置元素1节点的 next 节点为元素2节点，然后更新 tail 节点指向元素2节点。</li>\n<li>添加元素3。设置 tail 节点的 next 节点为元素3节点。</li>\n<li>添加元素4。设置元素3的 next 节点为元素4节点，然后将 tail 节点指向元素4节点。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_2.png\" alt=\"\"><br>入队主要做两件事：一是将入队节点设置成当前队列尾节点的下一个节点；二是更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成<br>tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。  </li>\n</ol>\n<p>在代码中，入队主要做两件事：一是定位出尾节点（通过 tail 的 next 是否为空）；二是使用 CAS 算法将入队队列设置成尾节点的 next 节点，如不成功则重试。<br>（进行 tail 的 next 判断是否为空时，如果循环两次都不为空，则重新进行队列，因为肯定有别的线程加了尾）。源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">// 入队前，创建一个入队节点</span></span><br><span class=\"line\">    Node&lt;E&gt; n = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"comment\">// 死循环，入队不成功反复入队。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个指向tail节点的引用</span></span><br><span class=\"line\">        Node&lt;E&gt; t = tail;</span><br><span class=\"line\">        <span class=\"comment\">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class=\"line\">        Node&lt;E&gt; p = t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> hops = <span class=\"number\">0</span>; ; hops++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得p节点的下一个节点。</span></span><br><span class=\"line\">            Node&lt;E&gt; next = succ(p);</span><br><span class=\"line\">            <span class=\"comment\">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.casNext(<span class=\"keyword\">null</span>, n)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class=\"line\"><span class=\"comment\">                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hops &gt;= HOPS)</span><br><span class=\"line\">                    casTail(t, n); <span class=\"comment\">// 更新tail节点，允许失败</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p = succ(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-2-定位尾节点\"><a href=\"#2-2-2-定位尾节点\" class=\"headerlink\" title=\"2.2.2 定位尾节点\"></a>2.2.2 定位尾节点</h3><p>通过判断 tail 节点和 tail 节点的 next 节点。</p>\n<h3 id=\"2-2-3-HOPS-的设计意图\"><a href=\"#2-2-3-HOPS-的设计意图\" class=\"headerlink\" title=\"2.2.3 HOPS 的设计意图\"></a>2.2.3 HOPS 的设计意图</h3><p>用如下实现是否可行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    Node&lt;E&gt; n = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.casNext(<span class=\"keyword\">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让 tail 节点永远作为队列的尾节点，这样实现代码量非常少。但是有个缺点是，每次都要更新 tail 节点为尾节点，而使用 HOPS 常量，进行判断，如果<br>当 tail 节点和尾节点的距离大于等于常量 HOPS 的值（默认等于1）时才更新 tail 节点，来通过增加对 volatile 变量的读操作来减少对 volatile 变量<br>的写操作，入队效率提升。</p>\n<h2 id=\"2-3-出队列\"><a href=\"#2-3-出队列\" class=\"headerlink\" title=\"2.3 出队列\"></a>2.3 出队列</h2><p>只有当 head 节点里没有元素时，出队操作才会更新 head 节点。这种做法也是通过 hops 变量来减少使用 CAS 更新 head 节点的消耗，从而提高出队效率。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_3.png\" alt=\"\"></p>\n<h1 id=\"3-Java-中的阻塞队列\"><a href=\"#3-Java-中的阻塞队列\" class=\"headerlink\" title=\"3 Java 中的阻塞队列\"></a>3 Java 中的阻塞队列</h1><h2 id=\"3-1-什么是阻塞队列\"><a href=\"#3-1-什么是阻塞队列\" class=\"headerlink\" title=\"3.1 什么是阻塞队列\"></a>3.1 什么是阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>\n<ol>\n<li>支持阻塞的插入方法：意思当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>\n<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</li>\n</ol>\n<h2 id=\"3-2-Java-里的阻塞队列\"><a href=\"#3-2-Java-里的阻塞队列\" class=\"headerlink\" title=\"3.2 Java 里的阻塞队列\"></a>3.2 Java 里的阻塞队列</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类名</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayBlockingQueue</td>\n<td style=\"text-align:left\">一个由数组结构组成的有界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingQueue</td>\n<td style=\"text-align:left\">一个由链表结构组成的有界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PriorityBlockingQueue</td>\n<td style=\"text-align:left\">支持优先级排序的无界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DelayQueue</td>\n<td style=\"text-align:left\">使用优先级队列实现的无界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SynchronousQueue</td>\n<td style=\"text-align:left\">不存储元素的阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedTransferQueue</td>\n<td style=\"text-align:left\">由链表结构组成的无界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingDeque</td>\n<td style=\"text-align:left\">由链表结构组成的双向阻塞队列</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-3-阻塞队列的实现原理\"><a href=\"#3-3-阻塞队列的实现原理\" class=\"headerlink\" title=\"3.3 阻塞队列的实现原理\"></a>3.3 阻塞队列的实现原理</h2><h3 id=\"3-3-1-使用通知模式实现\"><a href=\"#3-3-1-使用通知模式实现\" class=\"headerlink\" title=\"3.3.1 使用通知模式实现\"></a>3.3.1 使用通知模式实现</h3><p>即当生产者往满的队列里添加元素时会阻塞住消费者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>\n<h1 id=\"4-Fork-Join-框架\"><a href=\"#4-Fork-Join-框架\" class=\"headerlink\" title=\"4 Fork/Join 框架\"></a>4 Fork/Join 框架</h1><h2 id=\"4-1-什么是-Fork-Join-框架\"><a href=\"#4-1-什么是-Fork-Join-框架\" class=\"headerlink\" title=\"4.1 什么是 Fork/Join 框架\"></a>4.1 什么是 Fork/Join 框架</h2><p>Fork 就是把一个大任务切分为若干子任务并行的执行， Join 就是合并这些子任务的执行结果。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_4.png\" alt=\"\"></p>\n<h2 id=\"4-2-工作窃取算法\"><a href=\"#4-2-工作窃取算法\" class=\"headerlink\" title=\"4.2 工作窃取算法\"></a>4.2 工作窃取算法</h2><p>某个线程先把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理，这时候，完成任务的线程去做还有任务的线程的任务。  </p>\n<ol>\n<li>优点：充分利用线程进行并行计算，减少线程间的竞争。</li>\n<li>缺点：如果只有一个任务时，还是会有竞争。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</li>\n</ol>\n<h2 id=\"4-3-Fork-Join-框架的设计\"><a href=\"#4-3-Fork-Join-框架的设计\" class=\"headerlink\" title=\"4.3 Fork/Join 框架的设计\"></a>4.3 Fork/Join 框架的设计</h2><ol>\n<li>分割任务：首先我们需要由一个 fork 类来把大任务分割成小任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li>\n<li>执行任务并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，<br>启动一个线程从队列里里拿数据，然后合并这些数据。  </li>\n</ol>\n<p>Fork/Join 使用两个类来完成以上两件事。  </p>\n<ol>\n<li>ForkJoinTask：我们要使用 ForkJoin框架，必须首先创建一个 Fork/Join 任务。它提供在任务中执行 fork() 和 join() 操作的机制。通常情况下，<br>我们只需要继承它的子类，而 Fork/Join 框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务； RecursiveTask：用于有返回结果的任务。  </li>\n<li>ForkJoinPool：ForkJoinTask 需要通过 ForkJoinPool 来执行：任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。<br>当一个工作线程的队列里暂时没有任务时，它会随机从其它工作线程的队列的尾部 获取一个任务。</li>\n</ol>\n<h2 id=\"4-4-使用-Fork-Join-框架\"><a href=\"#4-4-使用-Fork-Join-框架\" class=\"headerlink\" title=\"4.4 使用 Fork/Join 框架\"></a>4.4 使用 Fork/Join 框架</h2><p>需求：计算1+2+3+4的结果。<br>如果希望每个子任务最多执行两个数的相加，我们设置分割的阈值是2，由于是4个数字相加，所以fork成两个子任务，一个计算1+2，一个计算3+4，然后再join两个子任务。<br>由于有结果的任务，因此继承 RecursiveTask。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THRESHOLD = <span class=\"number\">2</span>; <span class=\"comment\">// 阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountTask</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class=\"line\">        <span class=\"comment\">// 如果任务足够小就计算任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canCompute) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">                sum += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            CountTask leftTask = <span class=\"keyword\">new</span> CountTask(start, middle);</span><br><span class=\"line\">            CountTask rightTask = <span class=\"keyword\">new</span> CountTask(middle + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">            <span class=\"comment\">// 执行子任务</span></span><br><span class=\"line\">            leftTask.fork();</span><br><span class=\"line\">            rightTask.fork();</span><br><span class=\"line\">            <span class=\"comment\">// 等待子任务执行完，并得到其结果</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> leftResult = leftTask.join();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rightResult = rightTask.join();</span><br><span class=\"line\">            <span class=\"comment\">// 合并子任务</span></span><br><span class=\"line\">            sum = leftResult + rightResult;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ForkJoinPool forkJoinPool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">        <span class=\"comment\">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class=\"line\">        CountTask task = <span class=\"keyword\">new</span> CountTask(<span class=\"number\">1</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(result.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-5-Fork-Join-框架的实现原理\"><a href=\"#4-5-Fork-Join-框架的实现原理\" class=\"headerlink\" title=\"4.5 Fork/Join 框架的实现原理\"></a>4.5 Fork/Join 框架的实现原理</h2><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成， ForkJoinTask 数组负责将存放程序提交给 ForkJoinPool 的任务，<br>而 ForkJoinWorkerThread 数组负责执行这些任务。</p>\n<h3 id=\"4-5-1-ForkJoinTask-的-fork-方法实现原理\"><a href=\"#4-5-1-ForkJoinTask-的-fork-方法实现原理\" class=\"headerlink\" title=\"4.5.1 ForkJoinTask 的 fork 方法实现原理\"></a>4.5.1 ForkJoinTask 的 fork 方法实现原理</h3><p>使用 push 方法，把当前任务存放在 ForkJoinTask 数组队列中，再调用 ForkJoinPool 的 signalWork() 方法唤醒或创建一个工作线程来异步的执行这个任务，<br>然后立即返回结果。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ForkJoinTask&lt;V&gt; <span class=\"title\">fork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread)</span><br><span class=\"line\">        ((ForkJoinWorkerThread)t).workQueue.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ForkJoinPool.common.externalPush(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = base, s = top, n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a = array) != <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">// ignore if queue removed</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = a.length - <span class=\"number\">1</span>;     <span class=\"comment\">// fenced write for task visibility</span></span><br><span class=\"line\">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class=\"line\">        U.putOrderedInt(<span class=\"keyword\">this</span>, QTOP, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n = s - b) &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((p = pool) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                p.signalWork(p.workQueues, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt;= m)</span><br><span class=\"line\">            growArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-5-2-ForkJoinTask-的-join-方法实现原理\"><a href=\"#4-5-2-ForkJoinTask-的-join-方法实现原理\" class=\"headerlink\" title=\"4.5.2 ForkJoinTask 的 join 方法实现原理\"></a>4.5.2 ForkJoinTask 的 join 方法实现原理</h3><p>Join 方法主要用于阻塞当前线程并等待获取结果。调用 doJoin() 方法，通过查看任务状态，如果执行完则直接返回任务状态；如果没执行完，<br>则从任务数组里取出任务并执行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">join</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class=\"line\">        reportException(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRawResult();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportException</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == CANCELLED)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == EXCEPTIONAL)</span><br><span class=\"line\">        rethrow(getThrowableException());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">doJoin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (s = status) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class=\"line\">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class=\"line\">        tryUnpush(<span class=\"keyword\">this</span>) &amp;&amp; (s = doExec()) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        wt.pool.awaitJoin(w, <span class=\"keyword\">this</span>, <span class=\"number\">0L</span>) :</span><br><span class=\"line\">        externalAwaitDone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-ConcurrentHashMap-的实现原理与使用\"><a href=\"#1-ConcurrentHashMap-的实现原理与使用\" class=\"headerlink\" title=\"1 ConcurrentHashMap 的实现原理与使用\"></a>1 ConcurrentHashMap 的实现原理与使用</h1><h2 id=\"1-1-为什么要使用-ConcurrentHashMap\"><a href=\"#1-1-为什么要使用-ConcurrentHashMap\" class=\"headerlink\" title=\"1.1 为什么要使用 ConcurrentHashMap\"></a>1.1 为什么要使用 ConcurrentHashMap</h2><ol>\n<li>线程不安全的 HashMap ，在多线程下 HashMap 的 Entry 链表导致形成环形数据结构， Entry 的 next 节点永远不为空，就会产生死循环获取 Entry 。</li>\n<li>效率低下的 HashTable ，使用 synchronized 保证线程安全。</li>\n<li>ConcurrentHashMap 的锁分段技术有效提升并发访问率。 HashTable 效率低下是因为所有访问 HashTable 的线程都必须竞争同一把锁，如果容器里<br>有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程就不会存在锁竞争。</li>\n</ol>\n<h2 id=\"1-2-ConcurrentHashMap-的结构\"><a href=\"#1-2-ConcurrentHashMap-的结构\" class=\"headerlink\" title=\"1.2 ConcurrentHashMap 的结构\"></a>1.2 ConcurrentHashMap 的结构</h2><p>ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁（ReentrantLock）， Segment的结构和 HashMap<br>结构类似。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_1.png\" alt=\"\"></p>\n<h2 id=\"1-3-ConcurrentHashMap-的初始化\"><a href=\"#1-3-ConcurrentHashMap-的初始化\" class=\"headerlink\" title=\"1.3 ConcurrentHashMap 的初始化\"></a>1.3 ConcurrentHashMap 的初始化</h2><ol>\n<li>初始化 segments 数组</li>\n<li>初始化 segmentShift 和 segmentMask。用于散列算法的一些值。</li>\n<li>初始化每个 segment，包括容量以及负载因子。</li>\n</ol>\n<h2 id=\"1-4-ConcurrentHashMap-的操作\"><a href=\"#1-4-ConcurrentHashMap-的操作\" class=\"headerlink\" title=\"1.4 ConcurrentHashMap 的操作\"></a>1.4 ConcurrentHashMap 的操作</h2><h3 id=\"1-4-1-get-操作\"><a href=\"#1-4-1-get-操作\" class=\"headerlink\" title=\"1.4.1 get 操作\"></a>1.4.1 get 操作</h3><p>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。如何保证不加锁？原因在于它的 get 方法里将要使用的共享变量都<br>定义成 volatile 类型，如用于统计当前 Segment 大小的 count 字段和用于存储值的 HashEntry 的 value 。但只能被单线程写（有一种情况可以被<br>多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value ，所以不需要加锁。即使两个线程同时修改和获取<br> volatile 变量， get 操作也能拿到最新的值，这是用 volatile 替换锁的经典应用场景。</p>\n<h3 id=\"1-4-2-put-操作\"><a href=\"#1-4-2-put-操作\" class=\"headerlink\" title=\"1.4.2 put 操作\"></a>1.4.2 put 操作</h3><p>必须加锁。先定位到 Segment ，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对 Segment 里的 HashEntry 数组<br>进行扩容，第二步定位添加元素的位置，然后将其放在 HashEntry 数组里。</p>\n<ol>\n<li>是否需要扩容：插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量，如果超过阈值，则对数组进行扩容。</li>\n<li>如何扩容：先创建一个容量是原来容量两倍的数组，然后将原数组里元素进行散列后插入到新的数组里。为了高效， 只会对某个 Segment 进行扩容。</li>\n</ol>\n<h3 id=\"1-4-3-size-操作\"><a href=\"#1-4-3-size-操作\" class=\"headerlink\" title=\"1.4.3 size 操作\"></a>1.4.3 size 操作</h3><p>每个 Segment 的count 是 valatile 变量，但是累加过程中有可能 count 发生变化，最安全的做法是在统计 size 的时候把所有 Segment 的 put、<br>remove 和 clean 方法全部锁住，但是非常低效。所以 ConcurrentHashMap 的做法是尝试 2 次通过不锁住 Segment 的方式来统计累和，如果 count<br>发生变化，再采用加锁方式统计。如果判断count 发生变化呢？使用 modCount 变量。</p>\n<h1 id=\"2-ConcurrentLinkedQueue\"><a href=\"#2-ConcurrentLinkedQueue\" class=\"headerlink\" title=\"2 ConcurrentLinkedQueue\"></a>2 ConcurrentLinkedQueue</h1><p>实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。前者可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队<br>用不同的锁）等方式实现。非阻塞的实现则可以使用循环 CAS 的方式来实现。</p>\n<h2 id=\"2-1-ConcurrentLinkedQueue-的结构\"><a href=\"#2-1-ConcurrentLinkedQueue-的结构\" class=\"headerlink\" title=\"2.1 ConcurrentLinkedQueue 的结构\"></a>2.1 ConcurrentLinkedQueue 的结构</h2><p>由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成。默认情况下 head 节点存储的元素为空，<br>tail 节点等于 head 节点。</p>\n<h2 id=\"2-2-入队列\"><a href=\"#2-2-入队列\" class=\"headerlink\" title=\"2.2 入队列\"></a>2.2 入队列</h2><h3 id=\"2-2-1-入队列的过程\"><a href=\"#2-2-1-入队列的过程\" class=\"headerlink\" title=\"2.2.1 入队列的过程\"></a>2.2.1 入队列的过程</h3><ol>\n<li>添加元素1。队列更新 head 节点的 next 节点为元素1节点，又因为 tail 节点默认情况下等于 head 节点，所以它们的 next 节点都指向元素1节点。  </li>\n<li>添加元素2。队列首先设置元素1节点的 next 节点为元素2节点，然后更新 tail 节点指向元素2节点。</li>\n<li>添加元素3。设置 tail 节点的 next 节点为元素3节点。</li>\n<li>添加元素4。设置元素3的 next 节点为元素4节点，然后将 tail 节点指向元素4节点。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_2.png\" alt=\"\"><br>入队主要做两件事：一是将入队节点设置成当前队列尾节点的下一个节点；二是更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成<br>tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。  </li>\n</ol>\n<p>在代码中，入队主要做两件事：一是定位出尾节点（通过 tail 的 next 是否为空）；二是使用 CAS 算法将入队队列设置成尾节点的 next 节点，如不成功则重试。<br>（进行 tail 的 next 判断是否为空时，如果循环两次都不为空，则重新进行队列，因为肯定有别的线程加了尾）。源码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">// 入队前，创建一个入队节点</span></span><br><span class=\"line\">    Node&lt;E&gt; n = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"comment\">// 死循环，入队不成功反复入队。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个指向tail节点的引用</span></span><br><span class=\"line\">        Node&lt;E&gt; t = tail;</span><br><span class=\"line\">        <span class=\"comment\">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class=\"line\">        Node&lt;E&gt; p = t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> hops = <span class=\"number\">0</span>; ; hops++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得p节点的下一个节点。</span></span><br><span class=\"line\">            Node&lt;E&gt; next = succ(p);</span><br><span class=\"line\">            <span class=\"comment\">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.casNext(<span class=\"keyword\">null</span>, n)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class=\"line\"><span class=\"comment\">                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hops &gt;= HOPS)</span><br><span class=\"line\">                    casTail(t, n); <span class=\"comment\">// 更新tail节点，允许失败</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p = succ(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-2-定位尾节点\"><a href=\"#2-2-2-定位尾节点\" class=\"headerlink\" title=\"2.2.2 定位尾节点\"></a>2.2.2 定位尾节点</h3><p>通过判断 tail 节点和 tail 节点的 next 节点。</p>\n<h3 id=\"2-2-3-HOPS-的设计意图\"><a href=\"#2-2-3-HOPS-的设计意图\" class=\"headerlink\" title=\"2.2.3 HOPS 的设计意图\"></a>2.2.3 HOPS 的设计意图</h3><p>用如下实现是否可行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    Node&lt;E&gt; n = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.casNext(<span class=\"keyword\">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让 tail 节点永远作为队列的尾节点，这样实现代码量非常少。但是有个缺点是，每次都要更新 tail 节点为尾节点，而使用 HOPS 常量，进行判断，如果<br>当 tail 节点和尾节点的距离大于等于常量 HOPS 的值（默认等于1）时才更新 tail 节点，来通过增加对 volatile 变量的读操作来减少对 volatile 变量<br>的写操作，入队效率提升。</p>\n<h2 id=\"2-3-出队列\"><a href=\"#2-3-出队列\" class=\"headerlink\" title=\"2.3 出队列\"></a>2.3 出队列</h2><p>只有当 head 节点里没有元素时，出队操作才会更新 head 节点。这种做法也是通过 hops 变量来减少使用 CAS 更新 head 节点的消耗，从而提高出队效率。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_3.png\" alt=\"\"></p>\n<h1 id=\"3-Java-中的阻塞队列\"><a href=\"#3-Java-中的阻塞队列\" class=\"headerlink\" title=\"3 Java 中的阻塞队列\"></a>3 Java 中的阻塞队列</h1><h2 id=\"3-1-什么是阻塞队列\"><a href=\"#3-1-什么是阻塞队列\" class=\"headerlink\" title=\"3.1 什么是阻塞队列\"></a>3.1 什么是阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>\n<ol>\n<li>支持阻塞的插入方法：意思当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>\n<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</li>\n</ol>\n<h2 id=\"3-2-Java-里的阻塞队列\"><a href=\"#3-2-Java-里的阻塞队列\" class=\"headerlink\" title=\"3.2 Java 里的阻塞队列\"></a>3.2 Java 里的阻塞队列</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类名</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayBlockingQueue</td>\n<td style=\"text-align:left\">一个由数组结构组成的有界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingQueue</td>\n<td style=\"text-align:left\">一个由链表结构组成的有界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PriorityBlockingQueue</td>\n<td style=\"text-align:left\">支持优先级排序的无界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DelayQueue</td>\n<td style=\"text-align:left\">使用优先级队列实现的无界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SynchronousQueue</td>\n<td style=\"text-align:left\">不存储元素的阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedTransferQueue</td>\n<td style=\"text-align:left\">由链表结构组成的无界阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingDeque</td>\n<td style=\"text-align:left\">由链表结构组成的双向阻塞队列</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-3-阻塞队列的实现原理\"><a href=\"#3-3-阻塞队列的实现原理\" class=\"headerlink\" title=\"3.3 阻塞队列的实现原理\"></a>3.3 阻塞队列的实现原理</h2><h3 id=\"3-3-1-使用通知模式实现\"><a href=\"#3-3-1-使用通知模式实现\" class=\"headerlink\" title=\"3.3.1 使用通知模式实现\"></a>3.3.1 使用通知模式实现</h3><p>即当生产者往满的队列里添加元素时会阻塞住消费者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>\n<h1 id=\"4-Fork-Join-框架\"><a href=\"#4-Fork-Join-框架\" class=\"headerlink\" title=\"4 Fork/Join 框架\"></a>4 Fork/Join 框架</h1><h2 id=\"4-1-什么是-Fork-Join-框架\"><a href=\"#4-1-什么是-Fork-Join-框架\" class=\"headerlink\" title=\"4.1 什么是 Fork/Join 框架\"></a>4.1 什么是 Fork/Join 框架</h2><p>Fork 就是把一个大任务切分为若干子任务并行的执行， Join 就是合并这些子任务的执行结果。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_4.png\" alt=\"\"></p>\n<h2 id=\"4-2-工作窃取算法\"><a href=\"#4-2-工作窃取算法\" class=\"headerlink\" title=\"4.2 工作窃取算法\"></a>4.2 工作窃取算法</h2><p>某个线程先把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理，这时候，完成任务的线程去做还有任务的线程的任务。  </p>\n<ol>\n<li>优点：充分利用线程进行并行计算，减少线程间的竞争。</li>\n<li>缺点：如果只有一个任务时，还是会有竞争。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</li>\n</ol>\n<h2 id=\"4-3-Fork-Join-框架的设计\"><a href=\"#4-3-Fork-Join-框架的设计\" class=\"headerlink\" title=\"4.3 Fork/Join 框架的设计\"></a>4.3 Fork/Join 框架的设计</h2><ol>\n<li>分割任务：首先我们需要由一个 fork 类来把大任务分割成小任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li>\n<li>执行任务并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，<br>启动一个线程从队列里里拿数据，然后合并这些数据。  </li>\n</ol>\n<p>Fork/Join 使用两个类来完成以上两件事。  </p>\n<ol>\n<li>ForkJoinTask：我们要使用 ForkJoin框架，必须首先创建一个 Fork/Join 任务。它提供在任务中执行 fork() 和 join() 操作的机制。通常情况下，<br>我们只需要继承它的子类，而 Fork/Join 框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务； RecursiveTask：用于有返回结果的任务。  </li>\n<li>ForkJoinPool：ForkJoinTask 需要通过 ForkJoinPool 来执行：任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。<br>当一个工作线程的队列里暂时没有任务时，它会随机从其它工作线程的队列的尾部 获取一个任务。</li>\n</ol>\n<h2 id=\"4-4-使用-Fork-Join-框架\"><a href=\"#4-4-使用-Fork-Join-框架\" class=\"headerlink\" title=\"4.4 使用 Fork/Join 框架\"></a>4.4 使用 Fork/Join 框架</h2><p>需求：计算1+2+3+4的结果。<br>如果希望每个子任务最多执行两个数的相加，我们设置分割的阈值是2，由于是4个数字相加，所以fork成两个子任务，一个计算1+2，一个计算3+4，然后再join两个子任务。<br>由于有结果的任务，因此继承 RecursiveTask。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THRESHOLD = <span class=\"number\">2</span>; <span class=\"comment\">// 阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountTask</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class=\"line\">        <span class=\"comment\">// 如果任务足够小就计算任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canCompute) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">                sum += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> middle = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            CountTask leftTask = <span class=\"keyword\">new</span> CountTask(start, middle);</span><br><span class=\"line\">            CountTask rightTask = <span class=\"keyword\">new</span> CountTask(middle + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">            <span class=\"comment\">// 执行子任务</span></span><br><span class=\"line\">            leftTask.fork();</span><br><span class=\"line\">            rightTask.fork();</span><br><span class=\"line\">            <span class=\"comment\">// 等待子任务执行完，并得到其结果</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> leftResult = leftTask.join();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rightResult = rightTask.join();</span><br><span class=\"line\">            <span class=\"comment\">// 合并子任务</span></span><br><span class=\"line\">            sum = leftResult + rightResult;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ForkJoinPool forkJoinPool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">        <span class=\"comment\">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class=\"line\">        CountTask task = <span class=\"keyword\">new</span> CountTask(<span class=\"number\">1</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(result.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-5-Fork-Join-框架的实现原理\"><a href=\"#4-5-Fork-Join-框架的实现原理\" class=\"headerlink\" title=\"4.5 Fork/Join 框架的实现原理\"></a>4.5 Fork/Join 框架的实现原理</h2><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成， ForkJoinTask 数组负责将存放程序提交给 ForkJoinPool 的任务，<br>而 ForkJoinWorkerThread 数组负责执行这些任务。</p>\n<h3 id=\"4-5-1-ForkJoinTask-的-fork-方法实现原理\"><a href=\"#4-5-1-ForkJoinTask-的-fork-方法实现原理\" class=\"headerlink\" title=\"4.5.1 ForkJoinTask 的 fork 方法实现原理\"></a>4.5.1 ForkJoinTask 的 fork 方法实现原理</h3><p>使用 push 方法，把当前任务存放在 ForkJoinTask 数组队列中，再调用 ForkJoinPool 的 signalWork() 方法唤醒或创建一个工作线程来异步的执行这个任务，<br>然后立即返回结果。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ForkJoinTask&lt;V&gt; <span class=\"title\">fork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread)</span><br><span class=\"line\">        ((ForkJoinWorkerThread)t).workQueue.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ForkJoinPool.common.externalPush(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = base, s = top, n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a = array) != <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">// ignore if queue removed</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = a.length - <span class=\"number\">1</span>;     <span class=\"comment\">// fenced write for task visibility</span></span><br><span class=\"line\">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class=\"line\">        U.putOrderedInt(<span class=\"keyword\">this</span>, QTOP, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n = s - b) &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((p = pool) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                p.signalWork(p.workQueues, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt;= m)</span><br><span class=\"line\">            growArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-5-2-ForkJoinTask-的-join-方法实现原理\"><a href=\"#4-5-2-ForkJoinTask-的-join-方法实现原理\" class=\"headerlink\" title=\"4.5.2 ForkJoinTask 的 join 方法实现原理\"></a>4.5.2 ForkJoinTask 的 join 方法实现原理</h3><p>Join 方法主要用于阻塞当前线程并等待获取结果。调用 doJoin() 方法，通过查看任务状态，如果执行完则直接返回任务状态；如果没执行完，<br>则从任务数组里取出任务并执行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">join</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class=\"line\">        reportException(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRawResult();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportException</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == CANCELLED)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == EXCEPTIONAL)</span><br><span class=\"line\">        rethrow(getThrowableException());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">doJoin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (s = status) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class=\"line\">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class=\"line\">        tryUnpush(<span class=\"keyword\">this</span>) &amp;&amp; (s = doExec()) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        wt.pool.awaitJoin(w, <span class=\"keyword\">this</span>, <span class=\"number\">0L</span>) :</span><br><span class=\"line\">        externalAwaitDone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"八、Java中的并发工具类","date":"2017-11-07T12:07:00.000Z","updated":"2017-11-07T12:07:00.000Z","comments":1,"_content":"\n# 1 等待多线程完成的 CountDownLatch\n\n例如：解析一个 Excel 里多个 sheet 的数据，如果使用多线程，每个线程解析一个 sheet 里的数据，等到所有的 sheet 都解析完之后，程序提示解析完成。  \n  \n即，需要主线程等待所有线程完成 sheet 的解析操作，最简单的做法是使用 join() 方法，代码8-1：\n```java\npublic class JoinCountDownLatchTest {\n    public static void main(String[] args) throws Exception {\n        Thread parser1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"parser1 finish\");\n            }\n        });\n        Thread parser2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"parser2 finish\");\n            }\n        });\n        parser1.start();\n        parser2.start();\n        parser1.join();\n        parser2.join();\n        System.out.println(\"all parser finish\");\n    }\n}\n```\njoin 用于让当前执行线程等待 join 线程执行结束。其实现原理是不听检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。  \n  \nCountDownLacth 内部维护一个 int 类型的参数作为计数器，每次执行 countDown() 都会让计数器减1，await()只有当计数器为0的时候，才不会阻塞当前线程：\n```java\npublic class CountDownLatchTest {\n\n    static CountDownLatch c = new CountDownLatch(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(1);\n                c.countDown();\n            }\n        }).start();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(2);\n                c.countDown();\n            }\n        }).start();\n        c.await();\n        System.out.println(\"3\");\n    }\n```\n\n# 2 同步屏障 CyclicBarrier\n\n## 2.1 CyclicBarrier 简介\n\n字面意思：可循环使用（cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，\n屏障才会开门，所有被屏障拦截的线程才会继续运行。代码如下：\n```java\npublic class CyclicBarrierTest2 {\n    static CyclicBarrier c = new CyclicBarrier(2, new A());\n\n    public static void main(String[] args) {\n        Thread s = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                    Thread.sleep(1000); // 设置睡眠，输出：321，如果不设置，可能会是312\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(1);\n            }\n        });\n\n        s.start();\n\n        try {\n            c.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n        System.out.println(2);\n    }\n\n    static class A implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(3);\n        }\n    }\n}\n```\n\n## 2.2 CyclicBarrier 的应用场景\n\n用于多线程计算数据，最后合并计算结果的场景。例如，用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个账户近一年的每笔银行流水，\n现在需要统计用户的日均银行流水，先多线程处理每个 Sheet 的银行流水，都执行完之后，再用 barrierAction 计算线程结果。代码8-5如下：\n```java\npackage com.lwg.current_art;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.*;\n\npublic class BankWaterService implements Runnable{\n\n    /**\n     * 创建 4 个屏障，当运行了 4 个await()后，才会运行第二参数。\n     */\n    private CyclicBarrier c = new CyclicBarrier(4, this);\n\n    /**\n     * 4 个sheet，创建 4 个线程的线程池\n     */\n    private Executor executor = Executors.newFixedThreadPool(4);\n\n    /**\n     * 保存每个线程的结果\n     */\n    private Map<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<>();\n\n    private void count() {\n        for (int i = 0; i < 4; i++) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n                    System.out.println(\"size:\" + sheetBankWaterCount.size());\n                    try {\n                        c.await();\n                    } catch (InterruptedException | BrokenBarrierException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    public void run() {\n        int result = 0;\n        for (Map.Entry<String, Integer> sheet: sheetBankWaterCount.entrySet()){\n            result += sheet.getValue();\n        }\n        sheetBankWaterCount.put(\"result\", result);\n        System.out.println(result);\n    }\n\n    public static void main(String[] agrs) {\n        BankWaterService bankWaterService = new BankWaterService();\n        bankWaterService.count();\n    }\n}\n```\n\n##  2.3 CyclicBarrier 和 CountDownLatch 的区别\n\nCountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务。\n一些 API 用法如下代码8-6：\n```java\npublic class CyclicBarrierTest3 {\n\n    static CyclicBarrier c = new CyclicBarrier(2);\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        thread.start();\n        thread.interrupt();\n        try {\n            c.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            System.out.println(c.isBroken());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 2.3 控制并发线程数的 Semaphore\n\nSemaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。  \n  \n把 Semaphore 比作是控制流量的红绿灯。比如xx马路要限制流量，只允许同时有一百辆车在这条路上行驶，其它的都必须在路口等待，所以前一百辆车会看到绿灯，\n可以开进这条马路，后面的车会看到红灯，不能驶入xx马路，但是如果前一百辆中有5辆车已经离开了xx马路，那么后面就允许有5辆车驶入xx马路，\n即车就是线程，驶入马路就是线程执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞。\n\n### 2.3.1 应用场景\n\nSemaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假设有一个需求，要读取几万个文件的数据，因为都是IO密集型人物，\n我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，\n否则会报错无法获取数据库连接。这个时候可以使用 Semaphore 做流量控制，如下代码8-7：\n```java\npublic class SemaphoreTest {\n\n    private static final int THREAD_COUNT = 30;\n\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    private static Semaphore s = new Semaphore(10);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        s.acquire();\n                        System.out.println(\"save data\");\n                        s.release();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n        threadPool.shutdown();\n    }\n}\n```\n\n# 4 线程间交换数据的 Exchanger\n\nExchanger 提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。如果第一个线程执行 exchange() 方法，它就会一直等待第二个线程也执行 exchange 方法，\n当两个线程都到达同步点时，这时就可以交换数据。\n\n## 4.1 应用场景\n\n1. 遗传算法：选出两个人作为交配对象，交换两人的数据，并使用交叉规则得出2个交配结果。\n2. 校对工作：对两个人工录入的文件进行校对。\n```java\npublic class ExchangerTest {\n\n    private static final Exchanger<String> exgr = new Exchanger<>();\n\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) {\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String A = \"银行流水A\";\n                    exgr.exchange(A);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String B = \"银行流水B\";\n                    String A = exgr.exchange(B);\n                    System.out.println(\"A和B数据是否一致：\" + A.equals(B) + \".A录入的是：\" + A + \".B录入的是：\" + B);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        threadPool.shutdown();\n    }\n}\n```\n\n# 5 本章小结\n\n1. CountDownLatch->CyclicBarrier：都是等待某些运行到某个点后，才执行后面的方法，但是 CyclicBarrier提供的 API 更多适合更复杂的场景。\n2. Semaphore：控制并发数，即创建了30个线程，但是并发最多可以设置为10。\n3. Exchanger：线程间交换数据，在同步点处，A线程可以获得B线程的数据。\n\n\n\n","source":"_posts/Java 并发编程的艺术/第八章 Java中的并发工具类.md","raw":"---\ntitle: 八、Java中的并发工具类\ndate: 2017-11-07 20:07:00\nupdated: 2017-11-07 20:07:00\ncomments: true\ncategories: \n- 读书笔记\n- Java并发编程的艺术  \npermalink: concurrent-art/8.html    \n---\n\n# 1 等待多线程完成的 CountDownLatch\n\n例如：解析一个 Excel 里多个 sheet 的数据，如果使用多线程，每个线程解析一个 sheet 里的数据，等到所有的 sheet 都解析完之后，程序提示解析完成。  \n  \n即，需要主线程等待所有线程完成 sheet 的解析操作，最简单的做法是使用 join() 方法，代码8-1：\n```java\npublic class JoinCountDownLatchTest {\n    public static void main(String[] args) throws Exception {\n        Thread parser1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"parser1 finish\");\n            }\n        });\n        Thread parser2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"parser2 finish\");\n            }\n        });\n        parser1.start();\n        parser2.start();\n        parser1.join();\n        parser2.join();\n        System.out.println(\"all parser finish\");\n    }\n}\n```\njoin 用于让当前执行线程等待 join 线程执行结束。其实现原理是不听检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。  \n  \nCountDownLacth 内部维护一个 int 类型的参数作为计数器，每次执行 countDown() 都会让计数器减1，await()只有当计数器为0的时候，才不会阻塞当前线程：\n```java\npublic class CountDownLatchTest {\n\n    static CountDownLatch c = new CountDownLatch(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(1);\n                c.countDown();\n            }\n        }).start();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(2);\n                c.countDown();\n            }\n        }).start();\n        c.await();\n        System.out.println(\"3\");\n    }\n```\n\n# 2 同步屏障 CyclicBarrier\n\n## 2.1 CyclicBarrier 简介\n\n字面意思：可循环使用（cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，\n屏障才会开门，所有被屏障拦截的线程才会继续运行。代码如下：\n```java\npublic class CyclicBarrierTest2 {\n    static CyclicBarrier c = new CyclicBarrier(2, new A());\n\n    public static void main(String[] args) {\n        Thread s = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                    Thread.sleep(1000); // 设置睡眠，输出：321，如果不设置，可能会是312\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(1);\n            }\n        });\n\n        s.start();\n\n        try {\n            c.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n        System.out.println(2);\n    }\n\n    static class A implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(3);\n        }\n    }\n}\n```\n\n## 2.2 CyclicBarrier 的应用场景\n\n用于多线程计算数据，最后合并计算结果的场景。例如，用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个账户近一年的每笔银行流水，\n现在需要统计用户的日均银行流水，先多线程处理每个 Sheet 的银行流水，都执行完之后，再用 barrierAction 计算线程结果。代码8-5如下：\n```java\npackage com.lwg.current_art;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.*;\n\npublic class BankWaterService implements Runnable{\n\n    /**\n     * 创建 4 个屏障，当运行了 4 个await()后，才会运行第二参数。\n     */\n    private CyclicBarrier c = new CyclicBarrier(4, this);\n\n    /**\n     * 4 个sheet，创建 4 个线程的线程池\n     */\n    private Executor executor = Executors.newFixedThreadPool(4);\n\n    /**\n     * 保存每个线程的结果\n     */\n    private Map<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<>();\n\n    private void count() {\n        for (int i = 0; i < 4; i++) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n                    System.out.println(\"size:\" + sheetBankWaterCount.size());\n                    try {\n                        c.await();\n                    } catch (InterruptedException | BrokenBarrierException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    public void run() {\n        int result = 0;\n        for (Map.Entry<String, Integer> sheet: sheetBankWaterCount.entrySet()){\n            result += sheet.getValue();\n        }\n        sheetBankWaterCount.put(\"result\", result);\n        System.out.println(result);\n    }\n\n    public static void main(String[] agrs) {\n        BankWaterService bankWaterService = new BankWaterService();\n        bankWaterService.count();\n    }\n}\n```\n\n##  2.3 CyclicBarrier 和 CountDownLatch 的区别\n\nCountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务。\n一些 API 用法如下代码8-6：\n```java\npublic class CyclicBarrierTest3 {\n\n    static CyclicBarrier c = new CyclicBarrier(2);\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        thread.start();\n        thread.interrupt();\n        try {\n            c.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            System.out.println(c.isBroken());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 2.3 控制并发线程数的 Semaphore\n\nSemaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。  \n  \n把 Semaphore 比作是控制流量的红绿灯。比如xx马路要限制流量，只允许同时有一百辆车在这条路上行驶，其它的都必须在路口等待，所以前一百辆车会看到绿灯，\n可以开进这条马路，后面的车会看到红灯，不能驶入xx马路，但是如果前一百辆中有5辆车已经离开了xx马路，那么后面就允许有5辆车驶入xx马路，\n即车就是线程，驶入马路就是线程执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞。\n\n### 2.3.1 应用场景\n\nSemaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假设有一个需求，要读取几万个文件的数据，因为都是IO密集型人物，\n我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，\n否则会报错无法获取数据库连接。这个时候可以使用 Semaphore 做流量控制，如下代码8-7：\n```java\npublic class SemaphoreTest {\n\n    private static final int THREAD_COUNT = 30;\n\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    private static Semaphore s = new Semaphore(10);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        s.acquire();\n                        System.out.println(\"save data\");\n                        s.release();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n        threadPool.shutdown();\n    }\n}\n```\n\n# 4 线程间交换数据的 Exchanger\n\nExchanger 提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。如果第一个线程执行 exchange() 方法，它就会一直等待第二个线程也执行 exchange 方法，\n当两个线程都到达同步点时，这时就可以交换数据。\n\n## 4.1 应用场景\n\n1. 遗传算法：选出两个人作为交配对象，交换两人的数据，并使用交叉规则得出2个交配结果。\n2. 校对工作：对两个人工录入的文件进行校对。\n```java\npublic class ExchangerTest {\n\n    private static final Exchanger<String> exgr = new Exchanger<>();\n\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) {\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String A = \"银行流水A\";\n                    exgr.exchange(A);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String B = \"银行流水B\";\n                    String A = exgr.exchange(B);\n                    System.out.println(\"A和B数据是否一致：\" + A.equals(B) + \".A录入的是：\" + A + \".B录入的是：\" + B);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        threadPool.shutdown();\n    }\n}\n```\n\n# 5 本章小结\n\n1. CountDownLatch->CyclicBarrier：都是等待某些运行到某个点后，才执行后面的方法，但是 CyclicBarrier提供的 API 更多适合更复杂的场景。\n2. Semaphore：控制并发数，即创建了30个线程，但是并发最多可以设置为10。\n3. Exchanger：线程间交换数据，在同步点处，A线程可以获得B线程的数据。\n\n\n\n","slug":"concurrent-art/8.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaum0005axs6ppmrr420","content":"<h1 id=\"1-等待多线程完成的-CountDownLatch\"><a href=\"#1-等待多线程完成的-CountDownLatch\" class=\"headerlink\" title=\"1 等待多线程完成的 CountDownLatch\"></a>1 等待多线程完成的 CountDownLatch</h1><p>例如：解析一个 Excel 里多个 sheet 的数据，如果使用多线程，每个线程解析一个 sheet 里的数据，等到所有的 sheet 都解析完之后，程序提示解析完成。  </p>\n<p>即，需要主线程等待所有线程完成 sheet 的解析操作，最简单的做法是使用 join() 方法，代码8-1：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JoinCountDownLatchTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Thread parser1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"parser1 finish\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        Thread parser2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"parser2 finish\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        parser1.start();</span><br><span class=\"line\">        parser2.start();</span><br><span class=\"line\">        parser1.join();</span><br><span class=\"line\">        parser2.join();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"all parser finish\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>join 用于让当前执行线程等待 join 线程执行结束。其实现原理是不听检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。  </p>\n<p>CountDownLacth 内部维护一个 int 类型的参数作为计数器，每次执行 countDown() 都会让计数器减1，await()只有当计数器为0的时候，才不会阻塞当前线程：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch c = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">1</span>);</span><br><span class=\"line\">                c.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">2</span>);</span><br><span class=\"line\">                c.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        c.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-同步屏障-CyclicBarrier\"><a href=\"#2-同步屏障-CyclicBarrier\" class=\"headerlink\" title=\"2 同步屏障 CyclicBarrier\"></a>2 同步屏障 CyclicBarrier</h1><h2 id=\"2-1-CyclicBarrier-简介\"><a href=\"#2-1-CyclicBarrier-简介\" class=\"headerlink\" title=\"2.1 CyclicBarrier 简介\"></a>2.1 CyclicBarrier 简介</h2><p>字面意思：可循环使用（cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，<br>屏障才会开门，所有被屏障拦截的线程才会继续运行。代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierTest2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> CyclicBarrier c = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">2</span>, <span class=\"keyword\">new</span> A());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread s = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    c.await();</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 设置睡眠，输出：321，如果不设置，可能会是312</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        s.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            c.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-CyclicBarrier-的应用场景\"><a href=\"#2-2-CyclicBarrier-的应用场景\" class=\"headerlink\" title=\"2.2 CyclicBarrier 的应用场景\"></a>2.2 CyclicBarrier 的应用场景</h2><p>用于多线程计算数据，最后合并计算结果的场景。例如，用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个账户近一年的每笔银行流水，<br>现在需要统计用户的日均银行流水，先多线程处理每个 Sheet 的银行流水，都执行完之后，再用 barrierAction 计算线程结果。代码8-5如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.lwg.current_art;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankWaterService</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建 4 个屏障，当运行了 4 个await()后，才会运行第二参数。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CyclicBarrier c = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">4</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 4 个sheet，创建 4 个线程的线程池</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Executor executor = Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存每个线程的结果</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Integer&gt; sheetBankWaterCount = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    sheetBankWaterCount.put(Thread.currentThread().getName(), <span class=\"number\">1</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"size:\"</span> + sheetBankWaterCount.size());</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        c.await();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; sheet: sheetBankWaterCount.entrySet())&#123;</span><br><span class=\"line\">            result += sheet.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sheetBankWaterCount.put(<span class=\"string\">\"result\"</span>, result);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] agrs)</span> </span>&#123;</span><br><span class=\"line\">        BankWaterService bankWaterService = <span class=\"keyword\">new</span> BankWaterService();</span><br><span class=\"line\">        bankWaterService.count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-CyclicBarrier-和-CountDownLatch-的区别\"><a href=\"#2-3-CyclicBarrier-和-CountDownLatch-的区别\" class=\"headerlink\" title=\"2.3 CyclicBarrier 和 CountDownLatch 的区别\"></a>2.3 CyclicBarrier 和 CountDownLatch 的区别</h2><p>CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务。<br>一些 API 用法如下代码8-6：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierTest3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CyclicBarrier c = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    c.await();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.interrupt();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            c.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            System.out.println(c.isBroken());</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-控制并发线程数的-Semaphore\"><a href=\"#2-3-控制并发线程数的-Semaphore\" class=\"headerlink\" title=\"2.3 控制并发线程数的 Semaphore\"></a>2.3 控制并发线程数的 Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。  </p>\n<p>把 Semaphore 比作是控制流量的红绿灯。比如xx马路要限制流量，只允许同时有一百辆车在这条路上行驶，其它的都必须在路口等待，所以前一百辆车会看到绿灯，<br>可以开进这条马路，后面的车会看到红灯，不能驶入xx马路，但是如果前一百辆中有5辆车已经离开了xx马路，那么后面就允许有5辆车驶入xx马路，<br>即车就是线程，驶入马路就是线程执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞。</p>\n<h3 id=\"2-3-1-应用场景\"><a href=\"#2-3-1-应用场景\" class=\"headerlink\" title=\"2.3.1 应用场景\"></a>2.3.1 应用场景</h3><p>Semaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假设有一个需求，要读取几万个文件的数据，因为都是IO密集型人物，<br>我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，<br>否则会报错无法获取数据库连接。这个时候可以使用 Semaphore 做流量控制，如下代码8-7：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Semaphore s = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            threadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        s.acquire();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"save data\"</span>);</span><br><span class=\"line\">                        s.release();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-线程间交换数据的-Exchanger\"><a href=\"#4-线程间交换数据的-Exchanger\" class=\"headerlink\" title=\"4 线程间交换数据的 Exchanger\"></a>4 线程间交换数据的 Exchanger</h1><p>Exchanger 提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。如果第一个线程执行 exchange() 方法，它就会一直等待第二个线程也执行 exchange 方法，<br>当两个线程都到达同步点时，这时就可以交换数据。</p>\n<h2 id=\"4-1-应用场景\"><a href=\"#4-1-应用场景\" class=\"headerlink\" title=\"4.1 应用场景\"></a>4.1 应用场景</h2><ol>\n<li>遗传算法：选出两个人作为交配对象，交换两人的数据，并使用交叉规则得出2个交配结果。</li>\n<li>校对工作：对两个人工录入的文件进行校对。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Exchanger&lt;String&gt; exgr = <span class=\"keyword\">new</span> Exchanger&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        threadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String A = <span class=\"string\">\"银行流水A\"</span>;</span><br><span class=\"line\">                    exgr.exchange(A);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String B = <span class=\"string\">\"银行流水B\"</span>;</span><br><span class=\"line\">                    String A = exgr.exchange(B);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"A和B数据是否一致：\"</span> + A.equals(B) + <span class=\"string\">\".A录入的是：\"</span> + A + <span class=\"string\">\".B录入的是：\"</span> + B);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"5-本章小结\"><a href=\"#5-本章小结\" class=\"headerlink\" title=\"5 本章小结\"></a>5 本章小结</h1><ol>\n<li>CountDownLatch-&gt;CyclicBarrier：都是等待某些运行到某个点后，才执行后面的方法，但是 CyclicBarrier提供的 API 更多适合更复杂的场景。</li>\n<li>Semaphore：控制并发数，即创建了30个线程，但是并发最多可以设置为10。</li>\n<li>Exchanger：线程间交换数据，在同步点处，A线程可以获得B线程的数据。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-等待多线程完成的-CountDownLatch\"><a href=\"#1-等待多线程完成的-CountDownLatch\" class=\"headerlink\" title=\"1 等待多线程完成的 CountDownLatch\"></a>1 等待多线程完成的 CountDownLatch</h1><p>例如：解析一个 Excel 里多个 sheet 的数据，如果使用多线程，每个线程解析一个 sheet 里的数据，等到所有的 sheet 都解析完之后，程序提示解析完成。  </p>\n<p>即，需要主线程等待所有线程完成 sheet 的解析操作，最简单的做法是使用 join() 方法，代码8-1：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JoinCountDownLatchTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Thread parser1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"parser1 finish\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        Thread parser2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"parser2 finish\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        parser1.start();</span><br><span class=\"line\">        parser2.start();</span><br><span class=\"line\">        parser1.join();</span><br><span class=\"line\">        parser2.join();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"all parser finish\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>join 用于让当前执行线程等待 join 线程执行结束。其实现原理是不听检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。  </p>\n<p>CountDownLacth 内部维护一个 int 类型的参数作为计数器，每次执行 countDown() 都会让计数器减1，await()只有当计数器为0的时候，才不会阻塞当前线程：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CountDownLatch c = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">1</span>);</span><br><span class=\"line\">                c.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">2</span>);</span><br><span class=\"line\">                c.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        c.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-同步屏障-CyclicBarrier\"><a href=\"#2-同步屏障-CyclicBarrier\" class=\"headerlink\" title=\"2 同步屏障 CyclicBarrier\"></a>2 同步屏障 CyclicBarrier</h1><h2 id=\"2-1-CyclicBarrier-简介\"><a href=\"#2-1-CyclicBarrier-简介\" class=\"headerlink\" title=\"2.1 CyclicBarrier 简介\"></a>2.1 CyclicBarrier 简介</h2><p>字面意思：可循环使用（cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，<br>屏障才会开门，所有被屏障拦截的线程才会继续运行。代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierTest2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> CyclicBarrier c = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">2</span>, <span class=\"keyword\">new</span> A());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread s = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    c.await();</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 设置睡眠，输出：321，如果不设置，可能会是312</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        s.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            c.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-CyclicBarrier-的应用场景\"><a href=\"#2-2-CyclicBarrier-的应用场景\" class=\"headerlink\" title=\"2.2 CyclicBarrier 的应用场景\"></a>2.2 CyclicBarrier 的应用场景</h2><p>用于多线程计算数据，最后合并计算结果的场景。例如，用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个账户近一年的每笔银行流水，<br>现在需要统计用户的日均银行流水，先多线程处理每个 Sheet 的银行流水，都执行完之后，再用 barrierAction 计算线程结果。代码8-5如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.lwg.current_art;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankWaterService</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建 4 个屏障，当运行了 4 个await()后，才会运行第二参数。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CyclicBarrier c = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">4</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 4 个sheet，创建 4 个线程的线程池</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Executor executor = Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存每个线程的结果</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Integer&gt; sheetBankWaterCount = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    sheetBankWaterCount.put(Thread.currentThread().getName(), <span class=\"number\">1</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"size:\"</span> + sheetBankWaterCount.size());</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        c.await();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; sheet: sheetBankWaterCount.entrySet())&#123;</span><br><span class=\"line\">            result += sheet.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sheetBankWaterCount.put(<span class=\"string\">\"result\"</span>, result);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] agrs)</span> </span>&#123;</span><br><span class=\"line\">        BankWaterService bankWaterService = <span class=\"keyword\">new</span> BankWaterService();</span><br><span class=\"line\">        bankWaterService.count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-CyclicBarrier-和-CountDownLatch-的区别\"><a href=\"#2-3-CyclicBarrier-和-CountDownLatch-的区别\" class=\"headerlink\" title=\"2.3 CyclicBarrier 和 CountDownLatch 的区别\"></a>2.3 CyclicBarrier 和 CountDownLatch 的区别</h2><p>CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务。<br>一些 API 用法如下代码8-6：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierTest3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> CyclicBarrier c = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    c.await();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.interrupt();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            c.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            System.out.println(c.isBroken());</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-控制并发线程数的-Semaphore\"><a href=\"#2-3-控制并发线程数的-Semaphore\" class=\"headerlink\" title=\"2.3 控制并发线程数的 Semaphore\"></a>2.3 控制并发线程数的 Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。  </p>\n<p>把 Semaphore 比作是控制流量的红绿灯。比如xx马路要限制流量，只允许同时有一百辆车在这条路上行驶，其它的都必须在路口等待，所以前一百辆车会看到绿灯，<br>可以开进这条马路，后面的车会看到红灯，不能驶入xx马路，但是如果前一百辆中有5辆车已经离开了xx马路，那么后面就允许有5辆车驶入xx马路，<br>即车就是线程，驶入马路就是线程执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞。</p>\n<h3 id=\"2-3-1-应用场景\"><a href=\"#2-3-1-应用场景\" class=\"headerlink\" title=\"2.3.1 应用场景\"></a>2.3.1 应用场景</h3><p>Semaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假设有一个需求，要读取几万个文件的数据，因为都是IO密集型人物，<br>我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，<br>否则会报错无法获取数据库连接。这个时候可以使用 Semaphore 做流量控制，如下代码8-7：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THREAD_COUNT = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Semaphore s = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            threadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        s.acquire();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"save data\"</span>);</span><br><span class=\"line\">                        s.release();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-线程间交换数据的-Exchanger\"><a href=\"#4-线程间交换数据的-Exchanger\" class=\"headerlink\" title=\"4 线程间交换数据的 Exchanger\"></a>4 线程间交换数据的 Exchanger</h1><p>Exchanger 提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。如果第一个线程执行 exchange() 方法，它就会一直等待第二个线程也执行 exchange 方法，<br>当两个线程都到达同步点时，这时就可以交换数据。</p>\n<h2 id=\"4-1-应用场景\"><a href=\"#4-1-应用场景\" class=\"headerlink\" title=\"4.1 应用场景\"></a>4.1 应用场景</h2><ol>\n<li>遗传算法：选出两个人作为交配对象，交换两人的数据，并使用交叉规则得出2个交配结果。</li>\n<li>校对工作：对两个人工录入的文件进行校对。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Exchanger&lt;String&gt; exgr = <span class=\"keyword\">new</span> Exchanger&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        threadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String A = <span class=\"string\">\"银行流水A\"</span>;</span><br><span class=\"line\">                    exgr.exchange(A);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String B = <span class=\"string\">\"银行流水B\"</span>;</span><br><span class=\"line\">                    String A = exgr.exchange(B);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"A和B数据是否一致：\"</span> + A.equals(B) + <span class=\"string\">\".A录入的是：\"</span> + A + <span class=\"string\">\".B录入的是：\"</span> + B);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"5-本章小结\"><a href=\"#5-本章小结\" class=\"headerlink\" title=\"5 本章小结\"></a>5 本章小结</h1><ol>\n<li>CountDownLatch-&gt;CyclicBarrier：都是等待某些运行到某个点后，才执行后面的方法，但是 CyclicBarrier提供的 API 更多适合更复杂的场景。</li>\n<li>Semaphore：控制并发数，即创建了30个线程，但是并发最多可以设置为10。</li>\n<li>Exchanger：线程间交换数据，在同步点处，A线程可以获得B线程的数据。</li>\n</ol>\n"},{"title":"九、线程与同步的性能","date":"2017-01-18T14:01:00.000Z","updated":"2017-01-18T14:01:00.000Z","comments":1,"_content":"\n如何挖掘出 Java 线程和同步设施的最大性能\n\n---\n\n# 1 线程池与 ThreadPollExecutor\n\nJava EE 应用服务器就是围绕用一个或多个线程池处理请求这一概念构建的：对服务器上 Servlet 的每个调用都是通过池中的线程处理的（也有可能不同）。类似的，其它应用可以使用 Java 的 ThreadPoolExecutor 并行执行任务。  \n  \n所有线程池的工作方法本质是一样的：有一个队列，任务被提交到这个队列中。（可以有不止一个队列，概念是一样的。）一定数量的线程会从该队列中取任务，然后执行。任务的结果可以发回客户端（比如应用服务器的情况下），或保存到数据库中。但是在执行完任务后，这个线程会返回任务队列，检索另一个任务并执行（如果没有更多任务要执行，该线程会等待下一个任务）。  \n  \n线程池有最小线程数和最大线程数。池中会有最小数目的线程随时待命，等待任务指派给它们。因为创建线程的成本非常高昂，这样可以提高任务提交时的整体性能。另一方面，线程需要一些系统次元，包括栈所需的原生内存，如果空闲线程太多，就会消耗本来可以分配给其它金恒的资源。  \n>ThreadPoolExecutor 和相关的类将最小线程数称为核心池大小。\n\n# 2 ForkJoinPool\n\n# 3 线程同步\n\n# 4 JVM 线程调优\n\n# 5 监控线程与锁\n\n# 6 小结","source":"_posts/Java性能权威指南/第九章 线程与同步的性能.md","raw":"---\ntitle: 九、线程与同步的性能\ndate: 2017-01-18 22:01:00\nupdated: 2017-01-18 22:01:00\ncomments: true\ncategories: \n- 读书笔记\n- Java 性能权威指南\npermalink: java_performance_the_definitive_guide/9.html  \n---\n\n如何挖掘出 Java 线程和同步设施的最大性能\n\n---\n\n# 1 线程池与 ThreadPollExecutor\n\nJava EE 应用服务器就是围绕用一个或多个线程池处理请求这一概念构建的：对服务器上 Servlet 的每个调用都是通过池中的线程处理的（也有可能不同）。类似的，其它应用可以使用 Java 的 ThreadPoolExecutor 并行执行任务。  \n  \n所有线程池的工作方法本质是一样的：有一个队列，任务被提交到这个队列中。（可以有不止一个队列，概念是一样的。）一定数量的线程会从该队列中取任务，然后执行。任务的结果可以发回客户端（比如应用服务器的情况下），或保存到数据库中。但是在执行完任务后，这个线程会返回任务队列，检索另一个任务并执行（如果没有更多任务要执行，该线程会等待下一个任务）。  \n  \n线程池有最小线程数和最大线程数。池中会有最小数目的线程随时待命，等待任务指派给它们。因为创建线程的成本非常高昂，这样可以提高任务提交时的整体性能。另一方面，线程需要一些系统次元，包括栈所需的原生内存，如果空闲线程太多，就会消耗本来可以分配给其它金恒的资源。  \n>ThreadPoolExecutor 和相关的类将最小线程数称为核心池大小。\n\n# 2 ForkJoinPool\n\n# 3 线程同步\n\n# 4 JVM 线程调优\n\n# 5 监控线程与锁\n\n# 6 小结","slug":"java_performance_the_definitive_guide/9.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaun0006axs6r70bwbeb","content":"<p>如何挖掘出 Java 线程和同步设施的最大性能</p>\n<hr>\n<h1 id=\"1-线程池与-ThreadPollExecutor\"><a href=\"#1-线程池与-ThreadPollExecutor\" class=\"headerlink\" title=\"1 线程池与 ThreadPollExecutor\"></a>1 线程池与 ThreadPollExecutor</h1><p>Java EE 应用服务器就是围绕用一个或多个线程池处理请求这一概念构建的：对服务器上 Servlet 的每个调用都是通过池中的线程处理的（也有可能不同）。类似的，其它应用可以使用 Java 的 ThreadPoolExecutor 并行执行任务。  </p>\n<p>所有线程池的工作方法本质是一样的：有一个队列，任务被提交到这个队列中。（可以有不止一个队列，概念是一样的。）一定数量的线程会从该队列中取任务，然后执行。任务的结果可以发回客户端（比如应用服务器的情况下），或保存到数据库中。但是在执行完任务后，这个线程会返回任务队列，检索另一个任务并执行（如果没有更多任务要执行，该线程会等待下一个任务）。  </p>\n<p>线程池有最小线程数和最大线程数。池中会有最小数目的线程随时待命，等待任务指派给它们。因为创建线程的成本非常高昂，这样可以提高任务提交时的整体性能。另一方面，线程需要一些系统次元，包括栈所需的原生内存，如果空闲线程太多，就会消耗本来可以分配给其它金恒的资源。  </p>\n<blockquote>\n<p>ThreadPoolExecutor 和相关的类将最小线程数称为核心池大小。</p>\n</blockquote>\n<h1 id=\"2-ForkJoinPool\"><a href=\"#2-ForkJoinPool\" class=\"headerlink\" title=\"2 ForkJoinPool\"></a>2 ForkJoinPool</h1><h1 id=\"3-线程同步\"><a href=\"#3-线程同步\" class=\"headerlink\" title=\"3 线程同步\"></a>3 线程同步</h1><h1 id=\"4-JVM-线程调优\"><a href=\"#4-JVM-线程调优\" class=\"headerlink\" title=\"4 JVM 线程调优\"></a>4 JVM 线程调优</h1><h1 id=\"5-监控线程与锁\"><a href=\"#5-监控线程与锁\" class=\"headerlink\" title=\"5 监控线程与锁\"></a>5 监控线程与锁</h1><h1 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6 小结\"></a>6 小结</h1>","site":{"data":{}},"excerpt":"","more":"<p>如何挖掘出 Java 线程和同步设施的最大性能</p>\n<hr>\n<h1 id=\"1-线程池与-ThreadPollExecutor\"><a href=\"#1-线程池与-ThreadPollExecutor\" class=\"headerlink\" title=\"1 线程池与 ThreadPollExecutor\"></a>1 线程池与 ThreadPollExecutor</h1><p>Java EE 应用服务器就是围绕用一个或多个线程池处理请求这一概念构建的：对服务器上 Servlet 的每个调用都是通过池中的线程处理的（也有可能不同）。类似的，其它应用可以使用 Java 的 ThreadPoolExecutor 并行执行任务。  </p>\n<p>所有线程池的工作方法本质是一样的：有一个队列，任务被提交到这个队列中。（可以有不止一个队列，概念是一样的。）一定数量的线程会从该队列中取任务，然后执行。任务的结果可以发回客户端（比如应用服务器的情况下），或保存到数据库中。但是在执行完任务后，这个线程会返回任务队列，检索另一个任务并执行（如果没有更多任务要执行，该线程会等待下一个任务）。  </p>\n<p>线程池有最小线程数和最大线程数。池中会有最小数目的线程随时待命，等待任务指派给它们。因为创建线程的成本非常高昂，这样可以提高任务提交时的整体性能。另一方面，线程需要一些系统次元，包括栈所需的原生内存，如果空闲线程太多，就会消耗本来可以分配给其它金恒的资源。  </p>\n<blockquote>\n<p>ThreadPoolExecutor 和相关的类将最小线程数称为核心池大小。</p>\n</blockquote>\n<h1 id=\"2-ForkJoinPool\"><a href=\"#2-ForkJoinPool\" class=\"headerlink\" title=\"2 ForkJoinPool\"></a>2 ForkJoinPool</h1><h1 id=\"3-线程同步\"><a href=\"#3-线程同步\" class=\"headerlink\" title=\"3 线程同步\"></a>3 线程同步</h1><h1 id=\"4-JVM-线程调优\"><a href=\"#4-JVM-线程调优\" class=\"headerlink\" title=\"4 JVM 线程调优\"></a>4 JVM 线程调优</h1><h1 id=\"5-监控线程与锁\"><a href=\"#5-监控线程与锁\" class=\"headerlink\" title=\"5 监控线程与锁\"></a>5 监控线程与锁</h1><h1 id=\"6-小结\"><a href=\"#6-小结\" class=\"headerlink\" title=\"6 小结\"></a>6 小结</h1>"},{"title":"三四、Java 性能调优工具箱|JIT编译器：概述","date":"2017-01-10T04:00:00.000Z","updated":"2017-01-12T10:37:00.000Z","comments":1,"_content":"\n# 0 CPU 使用率\n\n使用 vmstat 命令查看 CPU 使用率，即 us\\sy\\id 三个参数，用户、系统、空闲使用 CPU 的时间。  \n>1. 检查应用性能时，首先应该审查 CPU 时间（尤其是多线程，CPU 的上下文切换报告）\n>2. 优化代码的目的是提升而不是降低（更短时间段内的）CPU 使用率。\n>3. 在试图深入优化应用前，应该先弄清楚为何 CPU 使用率低。\n\n# 1 JIT 编译器\n\njava文件->编译->class字节码文件->JVM编译解释成平台相关的二进制文件。  \n**而 JIT 编译器属于最后的 JVM 编译过程，也可以称为后端编译器，这样便于理解**。\nJava 应用汇被编译——但不是编译成特定 CPU 所专用的二进制代码，而是被编译成一种理想化的汇编语言（即 .class 字节码文件），它专用于 JVM 所执行。这个编译时在程序执行时进行的，即编译同时执行，（C 这种编译语言会先编译成 .o 或者 .obj 再执行），而 Java 是直接执行编译代码（JVM 执行）。Java 是一种半编译半解释语言（先编译成 .class，再让 JVM 解释成特定 CPU 的指令），而 Java 的表面直接执行其实内部 JVM 帮我们做了编译解释，不像 C 用户手动编译再执行，因为 C 的编译后的 .o 文件是针对特定的 CPU ，也许在下个 CPU 就需要重新编译了。参见：https://www.zhihu.com/question/21486706  \n  \n由于编译成 .class 这个行为是在程序执行的时候进行的，因为被称为“即时编译”（即JIT，just in time）。你也可以先 javac 编译后，再 java 命令 执行。\n\n## 1.热点编译\n\n官方的 java 实现是 Oracle 的 HotSpot JVM。HotSpot 的名字来与它看待代码编译的方式。对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行得越多就被认为是越热。  \n  \n因此 JVM 执行代码时，并不会立即编译代码。原因1：如果代码只执行一次，那编译完全就是浪费精力。对于只执行一次的代码，解释执行 Java 字节码比先编译然后执行的速度快。原因2：JVM 执行特定方法或者循环的次数越多，它就会越了解这段代码，使得 JVM 可以在编译代码时进行大量优化。  \n  \n例，`equals()` 方法，存在每个 Java 对象中，并且经常被子类重写。当解释器遇到 `b = obj1.equals(obj2)` 语句时，为了知道该执行哪个 `equals()` ，必须先查找 obj1 的类。这个动态查找的过程有点消耗时间。\n>寄存器和主内存：\n>```java\n>public class RegisterTest {\n>    private int sum;\n>    public void calculateSum(int n) {\n>        for(int i = 0; i < n; i++) {\n>            sum += i;\n>        }\n>    }\n>}\n>```\n>实例变量如果一直存在主内存中，但是从主内存获取数据是非常昂贵的操作，需要花费多个时钟周期才能完成，这样性能就会比较低，编译器就不会这么做，它会将 sum 的初始值装入寄存器，用寄存器中的值执行循环，然后（某个不确定时刻）将最终的结果从寄存器写回主内存。\n>使用寄存器是编译器普遍采用的优化方法，当开启逃逸分析（escape analysis）时，寄存器的使用更为频繁（详见本章尾）。\n\n比如，随着时间流逝， JVM 发现每次执行这条语句时，obj1 的类型都是 `java.lang.String`。于是 JVM 就可以生成直接调用 `String.equals()` 的编译代码。现在代码更快乐，不仅是因为被编译，也是因为跳过了查找该调用哪个方法的步骤。  \n不过没那么简单，下次执行代码时，obj1 完全有可能是别的类型而不是 `String` ，所以 JVM 必须生成编译代码处理这种可能，尽管如此，由于跳过了方法查找的步骤，这里的编译代码整体性能仍然要快（至少和 obj1 一直是 String时同样快）。这种优化只有在代码运行过一段时间观察它如何做之后才能使用：这是为何 JIT 编译器等待代码编译的第二个原因。\n\n# 2 调优入门：选择编译器类型（client/server或两者同用）\n\n有两种 JIT 编译器，client 和 server。两者编译器的最主要的差别在于编译代码的时机不同。  \nclient 编译器开启编译比 server 编译器要早。意味着在代码执行的开始阶段，client 编译器比 server 编译器要快，因为它编译代码相比 server 编译器而言要多。  \nserver 编译器等待编译的时候是否还能做更有价值的事：server 编译器在编译代码时可以更好地进行优化。最终，server 编译器生成的代码要比 client 编译器快。  \n此处的问题：为什么需要人来做这种选择？为什么 JVM 不能在启动用 client 编译器，然后随着代码变热使用 server 编译器？这种技术被称为**分层编译**。java7 的分层编译容易超出 JVM 代码缓存的大小，默认关闭。在 java8 分层编译默认为开启。  \n即时应用永远运行， server 编译器也不可能编译它的所有代码，但是任何程序都有一小部分代码很少执行，最好是编译这些代码——即便编译不是最好的方法——而不是以解释模式运行。\n>对于长时间运行的应用来说，应该一直使用 server 编译器，最好配合分层编译器。\n\n# 3 Java 和 JIT 编译器版本\n\nJIT 编译器有 3 种版本：  \n1. 32位 client 编译器（-client）\n2. 32位 server 编译器（-server）\n3. 64位 server 编译器（-d64）\n\n# 4 编译器中级调优\n\n## 1.调优代码缓存\n\nJVM 编译代码时，会在代码缓存中保存编译之后的汇编语言指令集。代码缓存一旦填满，JVM 就不能编译更多代码了（只能解释执行其余代码了）。  \n但是，如果设置过多，例如设置代码缓存为 1GB，JVM 就会保留 1GB 的本地内存空间。然后这部分内存在需要时才会分配，但它仍然是保留的，这意味着为了满足保留内存，你的机器必须有足够的虚拟内存。  \n此外，如果是 32位 JVM，则进程占用的总内存不能超过 4GB。这包括 Java堆、JVM 自身所有嗲吗占用的空间（包括它的本地库和线程栈）、分配给应用的本地内存（或者 NIO 库的直接内存），当然还有代码缓存。\n代码缓存： `-XX:ReservedCodeCacheSize=N` ，可以设置代码缓存的最大值。  \n![][1]\n\n## 2.编译阈值\n\n编译时基于两种 JVM 计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。  \nJVM 执行某个 Java 方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合就进入编译队列。被称为标准编译。  \n如果循环真的很长——或因包含所有程序逻辑而永远不退出，JVM 不等方法被调用就会编译循环。所以循环每完成一轮，回边计数器就会增加并被检测。如果循环的回边计数器超过阈值，那这个循环（不是整个方法）就可以被编译。被称为栈上替换（On-Stack Replacement，OSR）。  \n  \n标准编译由： `-XX:CompileThreshold=N` 标志触发。\n\n# 5 高级编译器调优\n\n前面说道，当方法（或循环）适合编译时，就会进入到编译队列。队列则由一个或多个后台线程处理。这是件好事，意味着编译过程是异步的，这使得即便是代码正在编译的时候，程序也能持续执行。如果是用标准编译所编译的方法，那下次调用该方法时就会执行编译后的方法；如果是用 OSR 编译的循环，那下次循环迭代时就会执行编译后的代码。  \n  \n编译队列并不严格遵守先进先出的原则：调用次数多的方法有更高的优先级（非公平更好使）。\n\n## 5.1 逃逸分析\n\n开启逃逸分析： `-XX:DoEscapeAnalysis`，默认为 true。server 编译器将会执行一些非常激进的优化措施，例如， for 循环中的新建变量，如果对象只在循环中引用，JVM 会毫不犹豫地对这个对象进行一系列优化。  \n包括，锁去除，值存储在寄存器而不是内存中，甚至不需要分配实际的对象，可以只追踪这个对象的个别字段。\n\n# 6 逆优化\n\n有两种逆优化的情形：代码状态分别为“made not entrant”（代码被丢弃）和“made zombie”（产生僵尸代码）时。  \n\n## 6.1 代码被丢弃\n\n当一个接口有多重实现，在使用switch 进行工厂模式的创建时，可能上次的编译器内联，在下次就必须使用解释执行了，因为对象变了，要开始新的编译，而上次的编译代码就属于丢弃代码。  \n另一种情况就是，分层编译。先使用 client 编译，再使用 server 编译，那么在第二次编译时，第一次编译的一些代码就要被丢弃，属于丢弃代码。\n\n## 6.2 逆优化僵尸代码\n\n1. 逆优化使得编译器可以回到之前版本的编译代码。  \n2. 先前的优化不再有效时（例，所设计的对象类型发生了更改），才会发生代码逆优化。\n3. 代码逆优化时，会对性能产生一些小而短暂的影响。\n\n# 7 小结\n\n1. 不用担心小方法，特别是 getter 和 setter ，因为它们很容易内联。编译器会修复这些问题。\n2. 需要编译的代码在编译队列中。队列中代码越多，程序达到最佳性能的时间越久。\n3. 虽然代码缓存的大小（也应该）调整，但它仍然是有限的资源。\n4. 代码越简单，优化越多。分析反馈和逃逸分析可以使代码更快，但复杂的循环结果和大方法限制了它的有效性。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/4_1.png\n","source":"_posts/Java性能权威指南/第三_四章 Java 性能调优工具箱.md","raw":"---\ntitle: 三四、Java 性能调优工具箱|JIT编译器：概述\ndate: 2017-01-10 12:00:00\nupdated: 2017-01-12 18:37:00\ncomments: true\ncategories: \n- 读书笔记\n- Java 性能权威指南\npermalink: java_performance_the_definitive_guide/3_4.html    \n---\n\n# 0 CPU 使用率\n\n使用 vmstat 命令查看 CPU 使用率，即 us\\sy\\id 三个参数，用户、系统、空闲使用 CPU 的时间。  \n>1. 检查应用性能时，首先应该审查 CPU 时间（尤其是多线程，CPU 的上下文切换报告）\n>2. 优化代码的目的是提升而不是降低（更短时间段内的）CPU 使用率。\n>3. 在试图深入优化应用前，应该先弄清楚为何 CPU 使用率低。\n\n# 1 JIT 编译器\n\njava文件->编译->class字节码文件->JVM编译解释成平台相关的二进制文件。  \n**而 JIT 编译器属于最后的 JVM 编译过程，也可以称为后端编译器，这样便于理解**。\nJava 应用汇被编译——但不是编译成特定 CPU 所专用的二进制代码，而是被编译成一种理想化的汇编语言（即 .class 字节码文件），它专用于 JVM 所执行。这个编译时在程序执行时进行的，即编译同时执行，（C 这种编译语言会先编译成 .o 或者 .obj 再执行），而 Java 是直接执行编译代码（JVM 执行）。Java 是一种半编译半解释语言（先编译成 .class，再让 JVM 解释成特定 CPU 的指令），而 Java 的表面直接执行其实内部 JVM 帮我们做了编译解释，不像 C 用户手动编译再执行，因为 C 的编译后的 .o 文件是针对特定的 CPU ，也许在下个 CPU 就需要重新编译了。参见：https://www.zhihu.com/question/21486706  \n  \n由于编译成 .class 这个行为是在程序执行的时候进行的，因为被称为“即时编译”（即JIT，just in time）。你也可以先 javac 编译后，再 java 命令 执行。\n\n## 1.热点编译\n\n官方的 java 实现是 Oracle 的 HotSpot JVM。HotSpot 的名字来与它看待代码编译的方式。对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行得越多就被认为是越热。  \n  \n因此 JVM 执行代码时，并不会立即编译代码。原因1：如果代码只执行一次，那编译完全就是浪费精力。对于只执行一次的代码，解释执行 Java 字节码比先编译然后执行的速度快。原因2：JVM 执行特定方法或者循环的次数越多，它就会越了解这段代码，使得 JVM 可以在编译代码时进行大量优化。  \n  \n例，`equals()` 方法，存在每个 Java 对象中，并且经常被子类重写。当解释器遇到 `b = obj1.equals(obj2)` 语句时，为了知道该执行哪个 `equals()` ，必须先查找 obj1 的类。这个动态查找的过程有点消耗时间。\n>寄存器和主内存：\n>```java\n>public class RegisterTest {\n>    private int sum;\n>    public void calculateSum(int n) {\n>        for(int i = 0; i < n; i++) {\n>            sum += i;\n>        }\n>    }\n>}\n>```\n>实例变量如果一直存在主内存中，但是从主内存获取数据是非常昂贵的操作，需要花费多个时钟周期才能完成，这样性能就会比较低，编译器就不会这么做，它会将 sum 的初始值装入寄存器，用寄存器中的值执行循环，然后（某个不确定时刻）将最终的结果从寄存器写回主内存。\n>使用寄存器是编译器普遍采用的优化方法，当开启逃逸分析（escape analysis）时，寄存器的使用更为频繁（详见本章尾）。\n\n比如，随着时间流逝， JVM 发现每次执行这条语句时，obj1 的类型都是 `java.lang.String`。于是 JVM 就可以生成直接调用 `String.equals()` 的编译代码。现在代码更快乐，不仅是因为被编译，也是因为跳过了查找该调用哪个方法的步骤。  \n不过没那么简单，下次执行代码时，obj1 完全有可能是别的类型而不是 `String` ，所以 JVM 必须生成编译代码处理这种可能，尽管如此，由于跳过了方法查找的步骤，这里的编译代码整体性能仍然要快（至少和 obj1 一直是 String时同样快）。这种优化只有在代码运行过一段时间观察它如何做之后才能使用：这是为何 JIT 编译器等待代码编译的第二个原因。\n\n# 2 调优入门：选择编译器类型（client/server或两者同用）\n\n有两种 JIT 编译器，client 和 server。两者编译器的最主要的差别在于编译代码的时机不同。  \nclient 编译器开启编译比 server 编译器要早。意味着在代码执行的开始阶段，client 编译器比 server 编译器要快，因为它编译代码相比 server 编译器而言要多。  \nserver 编译器等待编译的时候是否还能做更有价值的事：server 编译器在编译代码时可以更好地进行优化。最终，server 编译器生成的代码要比 client 编译器快。  \n此处的问题：为什么需要人来做这种选择？为什么 JVM 不能在启动用 client 编译器，然后随着代码变热使用 server 编译器？这种技术被称为**分层编译**。java7 的分层编译容易超出 JVM 代码缓存的大小，默认关闭。在 java8 分层编译默认为开启。  \n即时应用永远运行， server 编译器也不可能编译它的所有代码，但是任何程序都有一小部分代码很少执行，最好是编译这些代码——即便编译不是最好的方法——而不是以解释模式运行。\n>对于长时间运行的应用来说，应该一直使用 server 编译器，最好配合分层编译器。\n\n# 3 Java 和 JIT 编译器版本\n\nJIT 编译器有 3 种版本：  \n1. 32位 client 编译器（-client）\n2. 32位 server 编译器（-server）\n3. 64位 server 编译器（-d64）\n\n# 4 编译器中级调优\n\n## 1.调优代码缓存\n\nJVM 编译代码时，会在代码缓存中保存编译之后的汇编语言指令集。代码缓存一旦填满，JVM 就不能编译更多代码了（只能解释执行其余代码了）。  \n但是，如果设置过多，例如设置代码缓存为 1GB，JVM 就会保留 1GB 的本地内存空间。然后这部分内存在需要时才会分配，但它仍然是保留的，这意味着为了满足保留内存，你的机器必须有足够的虚拟内存。  \n此外，如果是 32位 JVM，则进程占用的总内存不能超过 4GB。这包括 Java堆、JVM 自身所有嗲吗占用的空间（包括它的本地库和线程栈）、分配给应用的本地内存（或者 NIO 库的直接内存），当然还有代码缓存。\n代码缓存： `-XX:ReservedCodeCacheSize=N` ，可以设置代码缓存的最大值。  \n![][1]\n\n## 2.编译阈值\n\n编译时基于两种 JVM 计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。  \nJVM 执行某个 Java 方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合就进入编译队列。被称为标准编译。  \n如果循环真的很长——或因包含所有程序逻辑而永远不退出，JVM 不等方法被调用就会编译循环。所以循环每完成一轮，回边计数器就会增加并被检测。如果循环的回边计数器超过阈值，那这个循环（不是整个方法）就可以被编译。被称为栈上替换（On-Stack Replacement，OSR）。  \n  \n标准编译由： `-XX:CompileThreshold=N` 标志触发。\n\n# 5 高级编译器调优\n\n前面说道，当方法（或循环）适合编译时，就会进入到编译队列。队列则由一个或多个后台线程处理。这是件好事，意味着编译过程是异步的，这使得即便是代码正在编译的时候，程序也能持续执行。如果是用标准编译所编译的方法，那下次调用该方法时就会执行编译后的方法；如果是用 OSR 编译的循环，那下次循环迭代时就会执行编译后的代码。  \n  \n编译队列并不严格遵守先进先出的原则：调用次数多的方法有更高的优先级（非公平更好使）。\n\n## 5.1 逃逸分析\n\n开启逃逸分析： `-XX:DoEscapeAnalysis`，默认为 true。server 编译器将会执行一些非常激进的优化措施，例如， for 循环中的新建变量，如果对象只在循环中引用，JVM 会毫不犹豫地对这个对象进行一系列优化。  \n包括，锁去除，值存储在寄存器而不是内存中，甚至不需要分配实际的对象，可以只追踪这个对象的个别字段。\n\n# 6 逆优化\n\n有两种逆优化的情形：代码状态分别为“made not entrant”（代码被丢弃）和“made zombie”（产生僵尸代码）时。  \n\n## 6.1 代码被丢弃\n\n当一个接口有多重实现，在使用switch 进行工厂模式的创建时，可能上次的编译器内联，在下次就必须使用解释执行了，因为对象变了，要开始新的编译，而上次的编译代码就属于丢弃代码。  \n另一种情况就是，分层编译。先使用 client 编译，再使用 server 编译，那么在第二次编译时，第一次编译的一些代码就要被丢弃，属于丢弃代码。\n\n## 6.2 逆优化僵尸代码\n\n1. 逆优化使得编译器可以回到之前版本的编译代码。  \n2. 先前的优化不再有效时（例，所设计的对象类型发生了更改），才会发生代码逆优化。\n3. 代码逆优化时，会对性能产生一些小而短暂的影响。\n\n# 7 小结\n\n1. 不用担心小方法，特别是 getter 和 setter ，因为它们很容易内联。编译器会修复这些问题。\n2. 需要编译的代码在编译队列中。队列中代码越多，程序达到最佳性能的时间越久。\n3. 虽然代码缓存的大小（也应该）调整，但它仍然是有限的资源。\n4. 代码越简单，优化越多。分析反馈和逃逸分析可以使代码更快，但复杂的循环结果和大方法限制了它的有效性。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/4_1.png\n","slug":"java_performance_the_definitive_guide/3_4.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauo0007axs6o43woe6u","content":"<h1 id=\"0-CPU-使用率\"><a href=\"#0-CPU-使用率\" class=\"headerlink\" title=\"0 CPU 使用率\"></a>0 CPU 使用率</h1><p>使用 vmstat 命令查看 CPU 使用率，即 us\\sy\\id 三个参数，用户、系统、空闲使用 CPU 的时间。  </p>\n<blockquote>\n<ol>\n<li>检查应用性能时，首先应该审查 CPU 时间（尤其是多线程，CPU 的上下文切换报告）</li>\n<li>优化代码的目的是提升而不是降低（更短时间段内的）CPU 使用率。</li>\n<li>在试图深入优化应用前，应该先弄清楚为何 CPU 使用率低。</li>\n</ol>\n</blockquote>\n<h1 id=\"1-JIT-编译器\"><a href=\"#1-JIT-编译器\" class=\"headerlink\" title=\"1 JIT 编译器\"></a>1 JIT 编译器</h1><p>java文件-&gt;编译-&gt;class字节码文件-&gt;JVM编译解释成平台相关的二进制文件。<br><strong>而 JIT 编译器属于最后的 JVM 编译过程，也可以称为后端编译器，这样便于理解</strong>。<br>Java 应用汇被编译——但不是编译成特定 CPU 所专用的二进制代码，而是被编译成一种理想化的汇编语言（即 .class 字节码文件），它专用于 JVM 所执行。这个编译时在程序执行时进行的，即编译同时执行，（C 这种编译语言会先编译成 .o 或者 .obj 再执行），而 Java 是直接执行编译代码（JVM 执行）。Java 是一种半编译半解释语言（先编译成 .class，再让 JVM 解释成特定 CPU 的指令），而 Java 的表面直接执行其实内部 JVM 帮我们做了编译解释，不像 C 用户手动编译再执行，因为 C 的编译后的 .o 文件是针对特定的 CPU ，也许在下个 CPU 就需要重新编译了。参见：<a href=\"https://www.zhihu.com/question/21486706\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/21486706</a>  </p>\n<p>由于编译成 .class 这个行为是在程序执行的时候进行的，因为被称为“即时编译”（即JIT，just in time）。你也可以先 javac 编译后，再 java 命令 执行。</p>\n<h2 id=\"1-热点编译\"><a href=\"#1-热点编译\" class=\"headerlink\" title=\"1.热点编译\"></a>1.热点编译</h2><p>官方的 java 实现是 Oracle 的 HotSpot JVM。HotSpot 的名字来与它看待代码编译的方式。对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行得越多就被认为是越热。  </p>\n<p>因此 JVM 执行代码时，并不会立即编译代码。原因1：如果代码只执行一次，那编译完全就是浪费精力。对于只执行一次的代码，解释执行 Java 字节码比先编译然后执行的速度快。原因2：JVM 执行特定方法或者循环的次数越多，它就会越了解这段代码，使得 JVM 可以在编译代码时进行大量优化。  </p>\n<p>例，<code>equals()</code> 方法，存在每个 Java 对象中，并且经常被子类重写。当解释器遇到 <code>b = obj1.equals(obj2)</code> 语句时，为了知道该执行哪个 <code>equals()</code> ，必须先查找 obj1 的类。这个动态查找的过程有点消耗时间。</p>\n<blockquote>\n<p>寄存器和主内存：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegisterTest</span> </span>&#123;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateSum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">&gt;            sum += i;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>实例变量如果一直存在主内存中，但是从主内存获取数据是非常昂贵的操作，需要花费多个时钟周期才能完成，这样性能就会比较低，编译器就不会这么做，它会将 sum 的初始值装入寄存器，用寄存器中的值执行循环，然后（某个不确定时刻）将最终的结果从寄存器写回主内存。<br>使用寄存器是编译器普遍采用的优化方法，当开启逃逸分析（escape analysis）时，寄存器的使用更为频繁（详见本章尾）。</p>\n</blockquote>\n<p>比如，随着时间流逝， JVM 发现每次执行这条语句时，obj1 的类型都是 <code>java.lang.String</code>。于是 JVM 就可以生成直接调用 <code>String.equals()</code> 的编译代码。现在代码更快乐，不仅是因为被编译，也是因为跳过了查找该调用哪个方法的步骤。<br>不过没那么简单，下次执行代码时，obj1 完全有可能是别的类型而不是 <code>String</code> ，所以 JVM 必须生成编译代码处理这种可能，尽管如此，由于跳过了方法查找的步骤，这里的编译代码整体性能仍然要快（至少和 obj1 一直是 String时同样快）。这种优化只有在代码运行过一段时间观察它如何做之后才能使用：这是为何 JIT 编译器等待代码编译的第二个原因。</p>\n<h1 id=\"2-调优入门：选择编译器类型（client-server或两者同用）\"><a href=\"#2-调优入门：选择编译器类型（client-server或两者同用）\" class=\"headerlink\" title=\"2 调优入门：选择编译器类型（client/server或两者同用）\"></a>2 调优入门：选择编译器类型（client/server或两者同用）</h1><p>有两种 JIT 编译器，client 和 server。两者编译器的最主要的差别在于编译代码的时机不同。<br>client 编译器开启编译比 server 编译器要早。意味着在代码执行的开始阶段，client 编译器比 server 编译器要快，因为它编译代码相比 server 编译器而言要多。<br>server 编译器等待编译的时候是否还能做更有价值的事：server 编译器在编译代码时可以更好地进行优化。最终，server 编译器生成的代码要比 client 编译器快。<br>此处的问题：为什么需要人来做这种选择？为什么 JVM 不能在启动用 client 编译器，然后随着代码变热使用 server 编译器？这种技术被称为<strong>分层编译</strong>。java7 的分层编译容易超出 JVM 代码缓存的大小，默认关闭。在 java8 分层编译默认为开启。<br>即时应用永远运行， server 编译器也不可能编译它的所有代码，但是任何程序都有一小部分代码很少执行，最好是编译这些代码——即便编译不是最好的方法——而不是以解释模式运行。</p>\n<blockquote>\n<p>对于长时间运行的应用来说，应该一直使用 server 编译器，最好配合分层编译器。</p>\n</blockquote>\n<h1 id=\"3-Java-和-JIT-编译器版本\"><a href=\"#3-Java-和-JIT-编译器版本\" class=\"headerlink\" title=\"3 Java 和 JIT 编译器版本\"></a>3 Java 和 JIT 编译器版本</h1><p>JIT 编译器有 3 种版本：  </p>\n<ol>\n<li>32位 client 编译器（-client）</li>\n<li>32位 server 编译器（-server）</li>\n<li>64位 server 编译器（-d64）</li>\n</ol>\n<h1 id=\"4-编译器中级调优\"><a href=\"#4-编译器中级调优\" class=\"headerlink\" title=\"4 编译器中级调优\"></a>4 编译器中级调优</h1><h2 id=\"1-调优代码缓存\"><a href=\"#1-调优代码缓存\" class=\"headerlink\" title=\"1.调优代码缓存\"></a>1.调优代码缓存</h2><p>JVM 编译代码时，会在代码缓存中保存编译之后的汇编语言指令集。代码缓存一旦填满，JVM 就不能编译更多代码了（只能解释执行其余代码了）。<br>但是，如果设置过多，例如设置代码缓存为 1GB，JVM 就会保留 1GB 的本地内存空间。然后这部分内存在需要时才会分配，但它仍然是保留的，这意味着为了满足保留内存，你的机器必须有足够的虚拟内存。<br>此外，如果是 32位 JVM，则进程占用的总内存不能超过 4GB。这包括 Java堆、JVM 自身所有嗲吗占用的空间（包括它的本地库和线程栈）、分配给应用的本地内存（或者 NIO 库的直接内存），当然还有代码缓存。<br>代码缓存： <code>-XX:ReservedCodeCacheSize=N</code> ，可以设置代码缓存的最大值。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/4_1.png\" alt=\"\"></p>\n<h2 id=\"2-编译阈值\"><a href=\"#2-编译阈值\" class=\"headerlink\" title=\"2.编译阈值\"></a>2.编译阈值</h2><p>编译时基于两种 JVM 计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。<br>JVM 执行某个 Java 方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合就进入编译队列。被称为标准编译。<br>如果循环真的很长——或因包含所有程序逻辑而永远不退出，JVM 不等方法被调用就会编译循环。所以循环每完成一轮，回边计数器就会增加并被检测。如果循环的回边计数器超过阈值，那这个循环（不是整个方法）就可以被编译。被称为栈上替换（On-Stack Replacement，OSR）。  </p>\n<p>标准编译由： <code>-XX:CompileThreshold=N</code> 标志触发。</p>\n<h1 id=\"5-高级编译器调优\"><a href=\"#5-高级编译器调优\" class=\"headerlink\" title=\"5 高级编译器调优\"></a>5 高级编译器调优</h1><p>前面说道，当方法（或循环）适合编译时，就会进入到编译队列。队列则由一个或多个后台线程处理。这是件好事，意味着编译过程是异步的，这使得即便是代码正在编译的时候，程序也能持续执行。如果是用标准编译所编译的方法，那下次调用该方法时就会执行编译后的方法；如果是用 OSR 编译的循环，那下次循环迭代时就会执行编译后的代码。  </p>\n<p>编译队列并不严格遵守先进先出的原则：调用次数多的方法有更高的优先级（非公平更好使）。</p>\n<h2 id=\"5-1-逃逸分析\"><a href=\"#5-1-逃逸分析\" class=\"headerlink\" title=\"5.1 逃逸分析\"></a>5.1 逃逸分析</h2><p>开启逃逸分析： <code>-XX:DoEscapeAnalysis</code>，默认为 true。server 编译器将会执行一些非常激进的优化措施，例如， for 循环中的新建变量，如果对象只在循环中引用，JVM 会毫不犹豫地对这个对象进行一系列优化。<br>包括，锁去除，值存储在寄存器而不是内存中，甚至不需要分配实际的对象，可以只追踪这个对象的个别字段。</p>\n<h1 id=\"6-逆优化\"><a href=\"#6-逆优化\" class=\"headerlink\" title=\"6 逆优化\"></a>6 逆优化</h1><p>有两种逆优化的情形：代码状态分别为“made not entrant”（代码被丢弃）和“made zombie”（产生僵尸代码）时。  </p>\n<h2 id=\"6-1-代码被丢弃\"><a href=\"#6-1-代码被丢弃\" class=\"headerlink\" title=\"6.1 代码被丢弃\"></a>6.1 代码被丢弃</h2><p>当一个接口有多重实现，在使用switch 进行工厂模式的创建时，可能上次的编译器内联，在下次就必须使用解释执行了，因为对象变了，要开始新的编译，而上次的编译代码就属于丢弃代码。<br>另一种情况就是，分层编译。先使用 client 编译，再使用 server 编译，那么在第二次编译时，第一次编译的一些代码就要被丢弃，属于丢弃代码。</p>\n<h2 id=\"6-2-逆优化僵尸代码\"><a href=\"#6-2-逆优化僵尸代码\" class=\"headerlink\" title=\"6.2 逆优化僵尸代码\"></a>6.2 逆优化僵尸代码</h2><ol>\n<li>逆优化使得编译器可以回到之前版本的编译代码。  </li>\n<li>先前的优化不再有效时（例，所设计的对象类型发生了更改），才会发生代码逆优化。</li>\n<li>代码逆优化时，会对性能产生一些小而短暂的影响。</li>\n</ol>\n<h1 id=\"7-小结\"><a href=\"#7-小结\" class=\"headerlink\" title=\"7 小结\"></a>7 小结</h1><ol>\n<li>不用担心小方法，特别是 getter 和 setter ，因为它们很容易内联。编译器会修复这些问题。</li>\n<li>需要编译的代码在编译队列中。队列中代码越多，程序达到最佳性能的时间越久。</li>\n<li>虽然代码缓存的大小（也应该）调整，但它仍然是有限的资源。</li>\n<li>代码越简单，优化越多。分析反馈和逃逸分析可以使代码更快，但复杂的循环结果和大方法限制了它的有效性。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0-CPU-使用率\"><a href=\"#0-CPU-使用率\" class=\"headerlink\" title=\"0 CPU 使用率\"></a>0 CPU 使用率</h1><p>使用 vmstat 命令查看 CPU 使用率，即 us\\sy\\id 三个参数，用户、系统、空闲使用 CPU 的时间。  </p>\n<blockquote>\n<ol>\n<li>检查应用性能时，首先应该审查 CPU 时间（尤其是多线程，CPU 的上下文切换报告）</li>\n<li>优化代码的目的是提升而不是降低（更短时间段内的）CPU 使用率。</li>\n<li>在试图深入优化应用前，应该先弄清楚为何 CPU 使用率低。</li>\n</ol>\n</blockquote>\n<h1 id=\"1-JIT-编译器\"><a href=\"#1-JIT-编译器\" class=\"headerlink\" title=\"1 JIT 编译器\"></a>1 JIT 编译器</h1><p>java文件-&gt;编译-&gt;class字节码文件-&gt;JVM编译解释成平台相关的二进制文件。<br><strong>而 JIT 编译器属于最后的 JVM 编译过程，也可以称为后端编译器，这样便于理解</strong>。<br>Java 应用汇被编译——但不是编译成特定 CPU 所专用的二进制代码，而是被编译成一种理想化的汇编语言（即 .class 字节码文件），它专用于 JVM 所执行。这个编译时在程序执行时进行的，即编译同时执行，（C 这种编译语言会先编译成 .o 或者 .obj 再执行），而 Java 是直接执行编译代码（JVM 执行）。Java 是一种半编译半解释语言（先编译成 .class，再让 JVM 解释成特定 CPU 的指令），而 Java 的表面直接执行其实内部 JVM 帮我们做了编译解释，不像 C 用户手动编译再执行，因为 C 的编译后的 .o 文件是针对特定的 CPU ，也许在下个 CPU 就需要重新编译了。参见：<a href=\"https://www.zhihu.com/question/21486706\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/21486706</a>  </p>\n<p>由于编译成 .class 这个行为是在程序执行的时候进行的，因为被称为“即时编译”（即JIT，just in time）。你也可以先 javac 编译后，再 java 命令 执行。</p>\n<h2 id=\"1-热点编译\"><a href=\"#1-热点编译\" class=\"headerlink\" title=\"1.热点编译\"></a>1.热点编译</h2><p>官方的 java 实现是 Oracle 的 HotSpot JVM。HotSpot 的名字来与它看待代码编译的方式。对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行得越多就被认为是越热。  </p>\n<p>因此 JVM 执行代码时，并不会立即编译代码。原因1：如果代码只执行一次，那编译完全就是浪费精力。对于只执行一次的代码，解释执行 Java 字节码比先编译然后执行的速度快。原因2：JVM 执行特定方法或者循环的次数越多，它就会越了解这段代码，使得 JVM 可以在编译代码时进行大量优化。  </p>\n<p>例，<code>equals()</code> 方法，存在每个 Java 对象中，并且经常被子类重写。当解释器遇到 <code>b = obj1.equals(obj2)</code> 语句时，为了知道该执行哪个 <code>equals()</code> ，必须先查找 obj1 的类。这个动态查找的过程有点消耗时间。</p>\n<blockquote>\n<p>寄存器和主内存：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegisterTest</span> </span>&#123;</span><br><span class=\"line\">&gt;    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">&gt;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateSum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">&gt;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">&gt;            sum += i;</span><br><span class=\"line\">&gt;        &#125;</span><br><span class=\"line\">&gt;    &#125;</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>实例变量如果一直存在主内存中，但是从主内存获取数据是非常昂贵的操作，需要花费多个时钟周期才能完成，这样性能就会比较低，编译器就不会这么做，它会将 sum 的初始值装入寄存器，用寄存器中的值执行循环，然后（某个不确定时刻）将最终的结果从寄存器写回主内存。<br>使用寄存器是编译器普遍采用的优化方法，当开启逃逸分析（escape analysis）时，寄存器的使用更为频繁（详见本章尾）。</p>\n</blockquote>\n<p>比如，随着时间流逝， JVM 发现每次执行这条语句时，obj1 的类型都是 <code>java.lang.String</code>。于是 JVM 就可以生成直接调用 <code>String.equals()</code> 的编译代码。现在代码更快乐，不仅是因为被编译，也是因为跳过了查找该调用哪个方法的步骤。<br>不过没那么简单，下次执行代码时，obj1 完全有可能是别的类型而不是 <code>String</code> ，所以 JVM 必须生成编译代码处理这种可能，尽管如此，由于跳过了方法查找的步骤，这里的编译代码整体性能仍然要快（至少和 obj1 一直是 String时同样快）。这种优化只有在代码运行过一段时间观察它如何做之后才能使用：这是为何 JIT 编译器等待代码编译的第二个原因。</p>\n<h1 id=\"2-调优入门：选择编译器类型（client-server或两者同用）\"><a href=\"#2-调优入门：选择编译器类型（client-server或两者同用）\" class=\"headerlink\" title=\"2 调优入门：选择编译器类型（client/server或两者同用）\"></a>2 调优入门：选择编译器类型（client/server或两者同用）</h1><p>有两种 JIT 编译器，client 和 server。两者编译器的最主要的差别在于编译代码的时机不同。<br>client 编译器开启编译比 server 编译器要早。意味着在代码执行的开始阶段，client 编译器比 server 编译器要快，因为它编译代码相比 server 编译器而言要多。<br>server 编译器等待编译的时候是否还能做更有价值的事：server 编译器在编译代码时可以更好地进行优化。最终，server 编译器生成的代码要比 client 编译器快。<br>此处的问题：为什么需要人来做这种选择？为什么 JVM 不能在启动用 client 编译器，然后随着代码变热使用 server 编译器？这种技术被称为<strong>分层编译</strong>。java7 的分层编译容易超出 JVM 代码缓存的大小，默认关闭。在 java8 分层编译默认为开启。<br>即时应用永远运行， server 编译器也不可能编译它的所有代码，但是任何程序都有一小部分代码很少执行，最好是编译这些代码——即便编译不是最好的方法——而不是以解释模式运行。</p>\n<blockquote>\n<p>对于长时间运行的应用来说，应该一直使用 server 编译器，最好配合分层编译器。</p>\n</blockquote>\n<h1 id=\"3-Java-和-JIT-编译器版本\"><a href=\"#3-Java-和-JIT-编译器版本\" class=\"headerlink\" title=\"3 Java 和 JIT 编译器版本\"></a>3 Java 和 JIT 编译器版本</h1><p>JIT 编译器有 3 种版本：  </p>\n<ol>\n<li>32位 client 编译器（-client）</li>\n<li>32位 server 编译器（-server）</li>\n<li>64位 server 编译器（-d64）</li>\n</ol>\n<h1 id=\"4-编译器中级调优\"><a href=\"#4-编译器中级调优\" class=\"headerlink\" title=\"4 编译器中级调优\"></a>4 编译器中级调优</h1><h2 id=\"1-调优代码缓存\"><a href=\"#1-调优代码缓存\" class=\"headerlink\" title=\"1.调优代码缓存\"></a>1.调优代码缓存</h2><p>JVM 编译代码时，会在代码缓存中保存编译之后的汇编语言指令集。代码缓存一旦填满，JVM 就不能编译更多代码了（只能解释执行其余代码了）。<br>但是，如果设置过多，例如设置代码缓存为 1GB，JVM 就会保留 1GB 的本地内存空间。然后这部分内存在需要时才会分配，但它仍然是保留的，这意味着为了满足保留内存，你的机器必须有足够的虚拟内存。<br>此外，如果是 32位 JVM，则进程占用的总内存不能超过 4GB。这包括 Java堆、JVM 自身所有嗲吗占用的空间（包括它的本地库和线程栈）、分配给应用的本地内存（或者 NIO 库的直接内存），当然还有代码缓存。<br>代码缓存： <code>-XX:ReservedCodeCacheSize=N</code> ，可以设置代码缓存的最大值。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/4_1.png\" alt=\"\"></p>\n<h2 id=\"2-编译阈值\"><a href=\"#2-编译阈值\" class=\"headerlink\" title=\"2.编译阈值\"></a>2.编译阈值</h2><p>编译时基于两种 JVM 计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。<br>JVM 执行某个 Java 方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合就进入编译队列。被称为标准编译。<br>如果循环真的很长——或因包含所有程序逻辑而永远不退出，JVM 不等方法被调用就会编译循环。所以循环每完成一轮，回边计数器就会增加并被检测。如果循环的回边计数器超过阈值，那这个循环（不是整个方法）就可以被编译。被称为栈上替换（On-Stack Replacement，OSR）。  </p>\n<p>标准编译由： <code>-XX:CompileThreshold=N</code> 标志触发。</p>\n<h1 id=\"5-高级编译器调优\"><a href=\"#5-高级编译器调优\" class=\"headerlink\" title=\"5 高级编译器调优\"></a>5 高级编译器调优</h1><p>前面说道，当方法（或循环）适合编译时，就会进入到编译队列。队列则由一个或多个后台线程处理。这是件好事，意味着编译过程是异步的，这使得即便是代码正在编译的时候，程序也能持续执行。如果是用标准编译所编译的方法，那下次调用该方法时就会执行编译后的方法；如果是用 OSR 编译的循环，那下次循环迭代时就会执行编译后的代码。  </p>\n<p>编译队列并不严格遵守先进先出的原则：调用次数多的方法有更高的优先级（非公平更好使）。</p>\n<h2 id=\"5-1-逃逸分析\"><a href=\"#5-1-逃逸分析\" class=\"headerlink\" title=\"5.1 逃逸分析\"></a>5.1 逃逸分析</h2><p>开启逃逸分析： <code>-XX:DoEscapeAnalysis</code>，默认为 true。server 编译器将会执行一些非常激进的优化措施，例如， for 循环中的新建变量，如果对象只在循环中引用，JVM 会毫不犹豫地对这个对象进行一系列优化。<br>包括，锁去除，值存储在寄存器而不是内存中，甚至不需要分配实际的对象，可以只追踪这个对象的个别字段。</p>\n<h1 id=\"6-逆优化\"><a href=\"#6-逆优化\" class=\"headerlink\" title=\"6 逆优化\"></a>6 逆优化</h1><p>有两种逆优化的情形：代码状态分别为“made not entrant”（代码被丢弃）和“made zombie”（产生僵尸代码）时。  </p>\n<h2 id=\"6-1-代码被丢弃\"><a href=\"#6-1-代码被丢弃\" class=\"headerlink\" title=\"6.1 代码被丢弃\"></a>6.1 代码被丢弃</h2><p>当一个接口有多重实现，在使用switch 进行工厂模式的创建时，可能上次的编译器内联，在下次就必须使用解释执行了，因为对象变了，要开始新的编译，而上次的编译代码就属于丢弃代码。<br>另一种情况就是，分层编译。先使用 client 编译，再使用 server 编译，那么在第二次编译时，第一次编译的一些代码就要被丢弃，属于丢弃代码。</p>\n<h2 id=\"6-2-逆优化僵尸代码\"><a href=\"#6-2-逆优化僵尸代码\" class=\"headerlink\" title=\"6.2 逆优化僵尸代码\"></a>6.2 逆优化僵尸代码</h2><ol>\n<li>逆优化使得编译器可以回到之前版本的编译代码。  </li>\n<li>先前的优化不再有效时（例，所设计的对象类型发生了更改），才会发生代码逆优化。</li>\n<li>代码逆优化时，会对性能产生一些小而短暂的影响。</li>\n</ol>\n<h1 id=\"7-小结\"><a href=\"#7-小结\" class=\"headerlink\" title=\"7 小结\"></a>7 小结</h1><ol>\n<li>不用担心小方法，特别是 getter 和 setter ，因为它们很容易内联。编译器会修复这些问题。</li>\n<li>需要编译的代码在编译队列中。队列中代码越多，程序达到最佳性能的时间越久。</li>\n<li>虽然代码缓存的大小（也应该）调整，但它仍然是有限的资源。</li>\n<li>代码越简单，优化越多。分析反馈和逃逸分析可以使代码更快，但复杂的循环结果和大方法限制了它的有效性。</li>\n</ol>\n"},{"title":"二、性能测试方法","date":"2016-12-31T16:47:00.000Z","updated":"2016-12-31T16:47:00.000Z","comments":1,"_content":"\n# 1 原则1：测试真实应用\n\n应该在产品实际使用的环境中进行性能测试。\n\n## 1.1 微基准测试\n\n### 1. 必须使用被测的结果\n\n例如下：\n```java\n@Test\npublic void doTest() {\n    int nLoops =  50;\n    double l;\n    long then = System.currentTimeMillis();\n    for (int i = 0; i < nLoops; i++) {\n        l = fibImpl1(50);\n    }\n    long now = System.currentTimeMillis();\n    System.out.println(\"Elapsed time:\" + (now - then));\n}\n\nprivate double fibImpl1(int n) {\n    if (n < 0) throw new IllegalArgumentException(\"Must be > 0\");\n    if (n == 0) return 0d;\n    if (n == 1) return 1d;\n    double d = fibImpl1(n - 2) + fibImpl1(n - 1);\n    if (Double.isInfinite(d)) throw new ArithmeticException(\"Overflow\");\n    return d;\n}\n```\n这段代码的问题在于，它实际永远都不会改变程序的任何状态。因为斐波那契的计算结果从来没有被使用，所以编译器可以很放心地去除计算结果。智能的编译器（包括当前的 Java7 和 Java8）最终执行的以下代码：\n```java\nlong then = System.currentTimeMillis();\nlong now = System.currentTimeMillis();\nSystem.out.println(\"Elapsed time:\" + (now - then));\n```\n解决在于，确保读取被测结果，而不只是简单地写。实际上，将局部变量 l 的定义改为实例变量（并用关键字 volatile 声明）就能测试这个方法的性能了。（必须声明 volatile 的原因参见第九章）。\n\n### 2. 不要包括无关的操作\n\n多余的循环迭代的多余的，如果编译器足够智能的话，就能发现这个问题，从而只执行一遍循环。  \n另外，fibImpl(1000) 的性能可能与 fibImpl(1) 相差很大。如果目的是为了比较不同实现的性能，测试的输入就应该考虑用一系列数据。如下：\n```java\nfor(int i = 0; i < nLoops; i++) {\n    l = fibImpl1(random.nextInteger());\n}\n```\n但是，微基准测试中的输入值必须事先计算好。\n\n### 3. 必须输入合理的参数\n\n此时还有第三个隐患：任意选择的随机输入值对于这段被测代码的用法来说并不具有代表性，实际用户可能只输入 100 以下的值。输入参数大于 1476 时，会抛出异常，因为此时计算出的是 double 类所能表示的最大斐波那契数。考虑如下实现：\n```java\npublic double fibImplSlow(int n) {\n    if (n < 0) throw new IllegalArgumentException(\"Must be > 0\");\n    if (n > 1476) throw new ArithmeticException(\"Must be < 1476\");\n    return verySlowImpl(n);\n}\n```\n虽然很难想象会有比原先用递归更慢的实现，但我们假定有这个实现。通过大量输入值比较这两种实现（fibImplSlow 和 verySlowImpl），发现前者比后者快得多——仅仅因为在方法开始时进行了范围检查。  \n如果在真实场景中，用户只会传入小于 100 的值，那这个比较就是不正确的。（仅仅在原先的实现上添加了边界测试就使得性能变好，通常这是不可能的）。\n>Java 的一个特点就是代码执行的越多性能越好，第四章详解。基于这点，微基准测试应该包括热身期，使得编译器能生成优化的代码。  \n>微基准测试需要热身期，否则测量的是编译而不是被测代码的性能了。\n\n综上，正确的微基准测试代码可能是这样：\n```java\nclass FibonacciTest {\n    private volatile double l;\n    private int nLoops;\n    private int[] input;\n\n    public static void main(String[] args) {\n        FibonacciTest ft = new FibonacciTest(Integer.parseInt(args[0]));\n        ft.doTest(true);\n        ft.doTest(false);\n    }\n\n    private FibonacciTest(int n) {\n        nLoops = n;\n        input = new int[nLoops];\n        Random r = new Random();\n        for (int i = 0; i < nLoops; i++) {\n            input[i] = r.nextInt(100);\n        }\n    }\n\n    private void doTest(boolean isWarmup) {\n        long then = System.currentTimeMillis();\n        for (int i = 0; i < nLoops; i++) {\n            l = fibImpl1(input[1]);\n        }\n        if (!isWarmup) {\n            long now = System.currentTimeMillis();\n            System.out.println(\"Elapsed time:\" + (now - then));\n        }\n    }\n\n    private double fibImpl1(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"Must be > 0\");\n        if (n == 0) return 0d;\n        if (n == 1) return 1d;\n        double d = fibImpl1(n - 2) + fibImpl1(n - 1);\n        if (Double.isInfinite(d)) throw new ArithmeticException(\"Overflow\");\n        return d;\n    }\n}\n```\n调用 fibImpl1() 的循环和方法开销，将每个结果都写入 volatile 变量中的额外开销导致测量结果有出入。  \n此外还要留意编译效应：频繁调用的方法、调用时的栈深度、方法参数的实际类型等，它还依赖代码实际运行的环境。  \n这里的基准测试，有大量的循环，整体时间以秒计，但每轮循环迭代通常是纳秒级。纳秒累计起来，“极少成都”就会成为频繁出现的性能问题。  \n特别是在做回归测试的时候，追踪级别设为纳秒很有意义。如果集合操作每次都节约几纳秒，日积月累下来意义就很重大了（第十二章详解），但是，对于那些不频繁的操作来说，例，同时只需要处理一个请求的 servlet ，修复微基准测所发现的纳秒级性能衰弱就是浪费时间（**后者才是过度优化！**）。\n\n# 2 原则2：理解批处理流逝时间，吞吐量和响应时间\n\n在客户端——服务器的吞吐量测试中，并不考虑客户端的思考时间。客户端向服务器发送请求，当它收到响应时，立刻发送新的请求。  \n指标常常被称为每秒事务数（TPS）、每秒请求数（RPS）、每秒操作数（OPS）。\n\n","source":"_posts/Java性能权威指南/第二章 性能测试方法.md","raw":"---\ntitle: 二、性能测试方法\ndate: 2017-01-01 00:47:00\nupdated: 2017-01-01 00:47:00\ncomments: true\ncategories: \n- 读书笔记\n- Java 性能权威指南\npermalink: java_performance_the_definitive_guide/2.html    \n---\n\n# 1 原则1：测试真实应用\n\n应该在产品实际使用的环境中进行性能测试。\n\n## 1.1 微基准测试\n\n### 1. 必须使用被测的结果\n\n例如下：\n```java\n@Test\npublic void doTest() {\n    int nLoops =  50;\n    double l;\n    long then = System.currentTimeMillis();\n    for (int i = 0; i < nLoops; i++) {\n        l = fibImpl1(50);\n    }\n    long now = System.currentTimeMillis();\n    System.out.println(\"Elapsed time:\" + (now - then));\n}\n\nprivate double fibImpl1(int n) {\n    if (n < 0) throw new IllegalArgumentException(\"Must be > 0\");\n    if (n == 0) return 0d;\n    if (n == 1) return 1d;\n    double d = fibImpl1(n - 2) + fibImpl1(n - 1);\n    if (Double.isInfinite(d)) throw new ArithmeticException(\"Overflow\");\n    return d;\n}\n```\n这段代码的问题在于，它实际永远都不会改变程序的任何状态。因为斐波那契的计算结果从来没有被使用，所以编译器可以很放心地去除计算结果。智能的编译器（包括当前的 Java7 和 Java8）最终执行的以下代码：\n```java\nlong then = System.currentTimeMillis();\nlong now = System.currentTimeMillis();\nSystem.out.println(\"Elapsed time:\" + (now - then));\n```\n解决在于，确保读取被测结果，而不只是简单地写。实际上，将局部变量 l 的定义改为实例变量（并用关键字 volatile 声明）就能测试这个方法的性能了。（必须声明 volatile 的原因参见第九章）。\n\n### 2. 不要包括无关的操作\n\n多余的循环迭代的多余的，如果编译器足够智能的话，就能发现这个问题，从而只执行一遍循环。  \n另外，fibImpl(1000) 的性能可能与 fibImpl(1) 相差很大。如果目的是为了比较不同实现的性能，测试的输入就应该考虑用一系列数据。如下：\n```java\nfor(int i = 0; i < nLoops; i++) {\n    l = fibImpl1(random.nextInteger());\n}\n```\n但是，微基准测试中的输入值必须事先计算好。\n\n### 3. 必须输入合理的参数\n\n此时还有第三个隐患：任意选择的随机输入值对于这段被测代码的用法来说并不具有代表性，实际用户可能只输入 100 以下的值。输入参数大于 1476 时，会抛出异常，因为此时计算出的是 double 类所能表示的最大斐波那契数。考虑如下实现：\n```java\npublic double fibImplSlow(int n) {\n    if (n < 0) throw new IllegalArgumentException(\"Must be > 0\");\n    if (n > 1476) throw new ArithmeticException(\"Must be < 1476\");\n    return verySlowImpl(n);\n}\n```\n虽然很难想象会有比原先用递归更慢的实现，但我们假定有这个实现。通过大量输入值比较这两种实现（fibImplSlow 和 verySlowImpl），发现前者比后者快得多——仅仅因为在方法开始时进行了范围检查。  \n如果在真实场景中，用户只会传入小于 100 的值，那这个比较就是不正确的。（仅仅在原先的实现上添加了边界测试就使得性能变好，通常这是不可能的）。\n>Java 的一个特点就是代码执行的越多性能越好，第四章详解。基于这点，微基准测试应该包括热身期，使得编译器能生成优化的代码。  \n>微基准测试需要热身期，否则测量的是编译而不是被测代码的性能了。\n\n综上，正确的微基准测试代码可能是这样：\n```java\nclass FibonacciTest {\n    private volatile double l;\n    private int nLoops;\n    private int[] input;\n\n    public static void main(String[] args) {\n        FibonacciTest ft = new FibonacciTest(Integer.parseInt(args[0]));\n        ft.doTest(true);\n        ft.doTest(false);\n    }\n\n    private FibonacciTest(int n) {\n        nLoops = n;\n        input = new int[nLoops];\n        Random r = new Random();\n        for (int i = 0; i < nLoops; i++) {\n            input[i] = r.nextInt(100);\n        }\n    }\n\n    private void doTest(boolean isWarmup) {\n        long then = System.currentTimeMillis();\n        for (int i = 0; i < nLoops; i++) {\n            l = fibImpl1(input[1]);\n        }\n        if (!isWarmup) {\n            long now = System.currentTimeMillis();\n            System.out.println(\"Elapsed time:\" + (now - then));\n        }\n    }\n\n    private double fibImpl1(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"Must be > 0\");\n        if (n == 0) return 0d;\n        if (n == 1) return 1d;\n        double d = fibImpl1(n - 2) + fibImpl1(n - 1);\n        if (Double.isInfinite(d)) throw new ArithmeticException(\"Overflow\");\n        return d;\n    }\n}\n```\n调用 fibImpl1() 的循环和方法开销，将每个结果都写入 volatile 变量中的额外开销导致测量结果有出入。  \n此外还要留意编译效应：频繁调用的方法、调用时的栈深度、方法参数的实际类型等，它还依赖代码实际运行的环境。  \n这里的基准测试，有大量的循环，整体时间以秒计，但每轮循环迭代通常是纳秒级。纳秒累计起来，“极少成都”就会成为频繁出现的性能问题。  \n特别是在做回归测试的时候，追踪级别设为纳秒很有意义。如果集合操作每次都节约几纳秒，日积月累下来意义就很重大了（第十二章详解），但是，对于那些不频繁的操作来说，例，同时只需要处理一个请求的 servlet ，修复微基准测所发现的纳秒级性能衰弱就是浪费时间（**后者才是过度优化！**）。\n\n# 2 原则2：理解批处理流逝时间，吞吐量和响应时间\n\n在客户端——服务器的吞吐量测试中，并不考虑客户端的思考时间。客户端向服务器发送请求，当它收到响应时，立刻发送新的请求。  \n指标常常被称为每秒事务数（TPS）、每秒请求数（RPS）、每秒操作数（OPS）。\n\n","slug":"java_performance_the_definitive_guide/2.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauq0009axs6dboejpsa","content":"<h1 id=\"1-原则1：测试真实应用\"><a href=\"#1-原则1：测试真实应用\" class=\"headerlink\" title=\"1 原则1：测试真实应用\"></a>1 原则1：测试真实应用</h1><p>应该在产品实际使用的环境中进行性能测试。</p>\n<h2 id=\"1-1-微基准测试\"><a href=\"#1-1-微基准测试\" class=\"headerlink\" title=\"1.1 微基准测试\"></a>1.1 微基准测试</h2><h3 id=\"1-必须使用被测的结果\"><a href=\"#1-必须使用被测的结果\" class=\"headerlink\" title=\"1. 必须使用被测的结果\"></a>1. 必须使用被测的结果</h3><p>例如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nLoops =  <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> then = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">        l = fibImpl1(<span class=\"number\">50</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Elapsed time:\"</span> + (now - then));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">double</span> <span class=\"title\">fibImpl1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Must be &gt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>d;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>d;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d = fibImpl1(n - <span class=\"number\">2</span>) + fibImpl1(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Double.isInfinite(d)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArithmeticException(<span class=\"string\">\"Overflow\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的问题在于，它实际永远都不会改变程序的任何状态。因为斐波那契的计算结果从来没有被使用，所以编译器可以很放心地去除计算结果。智能的编译器（包括当前的 Java7 和 Java8）最终执行的以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> then = System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Elapsed time:\"</span> + (now - then));</span><br></pre></td></tr></table></figure></p>\n<p>解决在于，确保读取被测结果，而不只是简单地写。实际上，将局部变量 l 的定义改为实例变量（并用关键字 volatile 声明）就能测试这个方法的性能了。（必须声明 volatile 的原因参见第九章）。</p>\n<h3 id=\"2-不要包括无关的操作\"><a href=\"#2-不要包括无关的操作\" class=\"headerlink\" title=\"2. 不要包括无关的操作\"></a>2. 不要包括无关的操作</h3><p>多余的循环迭代的多余的，如果编译器足够智能的话，就能发现这个问题，从而只执行一遍循环。<br>另外，fibImpl(1000) 的性能可能与 fibImpl(1) 相差很大。如果目的是为了比较不同实现的性能，测试的输入就应该考虑用一系列数据。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">    l = fibImpl1(random.nextInteger());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，微基准测试中的输入值必须事先计算好。</p>\n<h3 id=\"3-必须输入合理的参数\"><a href=\"#3-必须输入合理的参数\" class=\"headerlink\" title=\"3. 必须输入合理的参数\"></a>3. 必须输入合理的参数</h3><p>此时还有第三个隐患：任意选择的随机输入值对于这段被测代码的用法来说并不具有代表性，实际用户可能只输入 100 以下的值。输入参数大于 1476 时，会抛出异常，因为此时计算出的是 double 类所能表示的最大斐波那契数。考虑如下实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">fibImplSlow</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Must be &gt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1476</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArithmeticException(<span class=\"string\">\"Must be &lt; 1476\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> verySlowImpl(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然很难想象会有比原先用递归更慢的实现，但我们假定有这个实现。通过大量输入值比较这两种实现（fibImplSlow 和 verySlowImpl），发现前者比后者快得多——仅仅因为在方法开始时进行了范围检查。<br>如果在真实场景中，用户只会传入小于 100 的值，那这个比较就是不正确的。（仅仅在原先的实现上添加了边界测试就使得性能变好，通常这是不可能的）。</p>\n<blockquote>\n<p>Java 的一个特点就是代码执行的越多性能越好，第四章详解。基于这点，微基准测试应该包括热身期，使得编译器能生成优化的代码。<br>微基准测试需要热身期，否则测量的是编译而不是被测代码的性能了。</p>\n</blockquote>\n<p>综上，正确的微基准测试代码可能是这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FibonacciTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">double</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nLoops;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] input;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        FibonacciTest ft = <span class=\"keyword\">new</span> FibonacciTest(Integer.parseInt(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        ft.doTest(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        ft.doTest(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">FibonacciTest</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        nLoops = n;</span><br><span class=\"line\">        input = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nLoops];</span><br><span class=\"line\">        Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">            input[i] = r.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doTest</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isWarmup)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> then = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">            l = fibImpl1(input[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isWarmup) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Elapsed time:\"</span> + (now - then));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">double</span> <span class=\"title\">fibImpl1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Must be &gt; 0\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>d;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>d;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d = fibImpl1(n - <span class=\"number\">2</span>) + fibImpl1(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Double.isInfinite(d)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArithmeticException(<span class=\"string\">\"Overflow\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用 fibImpl1() 的循环和方法开销，将每个结果都写入 volatile 变量中的额外开销导致测量结果有出入。<br>此外还要留意编译效应：频繁调用的方法、调用时的栈深度、方法参数的实际类型等，它还依赖代码实际运行的环境。<br>这里的基准测试，有大量的循环，整体时间以秒计，但每轮循环迭代通常是纳秒级。纳秒累计起来，“极少成都”就会成为频繁出现的性能问题。<br>特别是在做回归测试的时候，追踪级别设为纳秒很有意义。如果集合操作每次都节约几纳秒，日积月累下来意义就很重大了（第十二章详解），但是，对于那些不频繁的操作来说，例，同时只需要处理一个请求的 servlet ，修复微基准测所发现的纳秒级性能衰弱就是浪费时间（<strong>后者才是过度优化！</strong>）。</p>\n<h1 id=\"2-原则2：理解批处理流逝时间，吞吐量和响应时间\"><a href=\"#2-原则2：理解批处理流逝时间，吞吐量和响应时间\" class=\"headerlink\" title=\"2 原则2：理解批处理流逝时间，吞吐量和响应时间\"></a>2 原则2：理解批处理流逝时间，吞吐量和响应时间</h1><p>在客户端——服务器的吞吐量测试中，并不考虑客户端的思考时间。客户端向服务器发送请求，当它收到响应时，立刻发送新的请求。<br>指标常常被称为每秒事务数（TPS）、每秒请求数（RPS）、每秒操作数（OPS）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-原则1：测试真实应用\"><a href=\"#1-原则1：测试真实应用\" class=\"headerlink\" title=\"1 原则1：测试真实应用\"></a>1 原则1：测试真实应用</h1><p>应该在产品实际使用的环境中进行性能测试。</p>\n<h2 id=\"1-1-微基准测试\"><a href=\"#1-1-微基准测试\" class=\"headerlink\" title=\"1.1 微基准测试\"></a>1.1 微基准测试</h2><h3 id=\"1-必须使用被测的结果\"><a href=\"#1-必须使用被测的结果\" class=\"headerlink\" title=\"1. 必须使用被测的结果\"></a>1. 必须使用被测的结果</h3><p>例如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nLoops =  <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> then = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">        l = fibImpl1(<span class=\"number\">50</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Elapsed time:\"</span> + (now - then));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">double</span> <span class=\"title\">fibImpl1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Must be &gt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>d;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>d;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> d = fibImpl1(n - <span class=\"number\">2</span>) + fibImpl1(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Double.isInfinite(d)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArithmeticException(<span class=\"string\">\"Overflow\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的问题在于，它实际永远都不会改变程序的任何状态。因为斐波那契的计算结果从来没有被使用，所以编译器可以很放心地去除计算结果。智能的编译器（包括当前的 Java7 和 Java8）最终执行的以下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> then = System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Elapsed time:\"</span> + (now - then));</span><br></pre></td></tr></table></figure></p>\n<p>解决在于，确保读取被测结果，而不只是简单地写。实际上，将局部变量 l 的定义改为实例变量（并用关键字 volatile 声明）就能测试这个方法的性能了。（必须声明 volatile 的原因参见第九章）。</p>\n<h3 id=\"2-不要包括无关的操作\"><a href=\"#2-不要包括无关的操作\" class=\"headerlink\" title=\"2. 不要包括无关的操作\"></a>2. 不要包括无关的操作</h3><p>多余的循环迭代的多余的，如果编译器足够智能的话，就能发现这个问题，从而只执行一遍循环。<br>另外，fibImpl(1000) 的性能可能与 fibImpl(1) 相差很大。如果目的是为了比较不同实现的性能，测试的输入就应该考虑用一系列数据。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">    l = fibImpl1(random.nextInteger());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，微基准测试中的输入值必须事先计算好。</p>\n<h3 id=\"3-必须输入合理的参数\"><a href=\"#3-必须输入合理的参数\" class=\"headerlink\" title=\"3. 必须输入合理的参数\"></a>3. 必须输入合理的参数</h3><p>此时还有第三个隐患：任意选择的随机输入值对于这段被测代码的用法来说并不具有代表性，实际用户可能只输入 100 以下的值。输入参数大于 1476 时，会抛出异常，因为此时计算出的是 double 类所能表示的最大斐波那契数。考虑如下实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">fibImplSlow</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Must be &gt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1476</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArithmeticException(<span class=\"string\">\"Must be &lt; 1476\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> verySlowImpl(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然很难想象会有比原先用递归更慢的实现，但我们假定有这个实现。通过大量输入值比较这两种实现（fibImplSlow 和 verySlowImpl），发现前者比后者快得多——仅仅因为在方法开始时进行了范围检查。<br>如果在真实场景中，用户只会传入小于 100 的值，那这个比较就是不正确的。（仅仅在原先的实现上添加了边界测试就使得性能变好，通常这是不可能的）。</p>\n<blockquote>\n<p>Java 的一个特点就是代码执行的越多性能越好，第四章详解。基于这点，微基准测试应该包括热身期，使得编译器能生成优化的代码。<br>微基准测试需要热身期，否则测量的是编译而不是被测代码的性能了。</p>\n</blockquote>\n<p>综上，正确的微基准测试代码可能是这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FibonacciTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">double</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nLoops;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] input;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        FibonacciTest ft = <span class=\"keyword\">new</span> FibonacciTest(Integer.parseInt(args[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        ft.doTest(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        ft.doTest(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">FibonacciTest</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        nLoops = n;</span><br><span class=\"line\">        input = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nLoops];</span><br><span class=\"line\">        Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">            input[i] = r.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doTest</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isWarmup)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> then = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class=\"line\">            l = fibImpl1(input[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isWarmup) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Elapsed time:\"</span> + (now - then));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">double</span> <span class=\"title\">fibImpl1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Must be &gt; 0\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>d;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>d;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d = fibImpl1(n - <span class=\"number\">2</span>) + fibImpl1(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Double.isInfinite(d)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArithmeticException(<span class=\"string\">\"Overflow\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用 fibImpl1() 的循环和方法开销，将每个结果都写入 volatile 变量中的额外开销导致测量结果有出入。<br>此外还要留意编译效应：频繁调用的方法、调用时的栈深度、方法参数的实际类型等，它还依赖代码实际运行的环境。<br>这里的基准测试，有大量的循环，整体时间以秒计，但每轮循环迭代通常是纳秒级。纳秒累计起来，“极少成都”就会成为频繁出现的性能问题。<br>特别是在做回归测试的时候，追踪级别设为纳秒很有意义。如果集合操作每次都节约几纳秒，日积月累下来意义就很重大了（第十二章详解），但是，对于那些不频繁的操作来说，例，同时只需要处理一个请求的 servlet ，修复微基准测所发现的纳秒级性能衰弱就是浪费时间（<strong>后者才是过度优化！</strong>）。</p>\n<h1 id=\"2-原则2：理解批处理流逝时间，吞吐量和响应时间\"><a href=\"#2-原则2：理解批处理流逝时间，吞吐量和响应时间\" class=\"headerlink\" title=\"2 原则2：理解批处理流逝时间，吞吐量和响应时间\"></a>2 原则2：理解批处理流逝时间，吞吐量和响应时间</h1><p>在客户端——服务器的吞吐量测试中，并不考虑客户端的思考时间。客户端向服务器发送请求，当它收到响应时，立刻发送新的请求。<br>指标常常被称为每秒事务数（TPS）、每秒请求数（RPS）、每秒操作数（OPS）。</p>\n"},{"title":"五、垃圾收集入门","date":"2017-01-10T04:00:00.000Z","updated":"2017-01-16T16:50:00.000Z","comments":1,"_content":"\n很多时候，我们没有机会重写代码，又要面临需要提高 Java 应用性能的压力，这种情况下对垃圾收集器的调优就变得至关重要。  \n>1. Serial 收集器（常用于单 CPU环境）。\n>2. Throughput（或者 Parallel）收集器。\n>3. Concurrent 收集器（CMS）。\n>4. G1 收集器。\n\n---\n\n# 1 垃圾收集概述\n\n简单来说，垃圾收集由两步构成：查找不再使用的对象，以及释放这些对象所管理的内存。 JVM 从查找不再使用的对象（垃圾对象）入手。有时，这也被称为查找不再有任何对象引用的对象（暗指采用“引用计数”的方式统计对象引用）。  \n  \n例，如下场景：一个程序要分配大小为 1000 字节的数组，紧接着又分配一个大小为 24 字节的数组，并在一个循环中持续进行这样的分配。最终程序会耗尽整个堆，结果如下图的**第一行**所示：堆空间被沾满，分配的数组间隔地分布于整个堆内：  \n![][1]  \n堆内存用尽会触发 JVM 回收不再使用的数组空间。假设所有大小为 24 字节的数组都不再被使用，而大小为 1000 字节的数组还继续使用，这样就形成了上图的**第二行**的场景。  \n虽然堆内部有足够的空闲空间，却找不到任何一个大于 24 字节的连续空间，除非 JVM 移动所有大小为 1000 字节的数组，让它们连续存储，把空闲的空间整合成一块更大的连续空间，供其他的内存分配使用（如上图的**第三行**）。  \n  \n而垃圾收集的性能就是由这些基本操作所决定的：找到不再使用的对象、回收它们使用的内存、对堆的内存布局进行压缩整理。完成这些操作时不同的收集器采用了不同的方法，这也是不同垃圾收起表现出不同性能特征的原因。  \n通常垃圾收集器自身往往也是多线程的。接下来的讨论中，我们从逻辑上将县城分成了两组，分别是应用程序线程和处理垃圾收集的线程。垃圾收集器回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。这一点在收集器移动对象时尤其重要：**在操作过程中，对象的内存地址会发生变化，因此这个过程中任何应用线程都不应再访问该对象。**  \n  \n所有应用线程都停止运行所产生的停顿被称为时空停顿（stop-the-world）。通常这些停顿对应用的性能影响对打，调优垃圾收集时，尽量减少这种停顿是最为关键的考量因素。\n\n## 1.1 分代垃圾收集器\n\n虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步划分为不同的区段，分别称为 Eden 空间和 survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。  \n  \n新生代被填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其它地方。这种操作被称为 Minor GC。  \n采用这种设计有两个性能上的优势：  \n1. 新生代仅是堆的一部分，这意味着应用线程停顿的时间更短。但是更加频繁。\n2. 对象分配与 Eden 空间，垃圾收集时，新生代空间被清空，Eden 空间的对象要么被移走，要么移动到另一个 Survivor 空间，要么被移动到老年代。这就相当于自动的进行了一次压缩整理。  \n  \n所有的垃圾收集算法在对新生代回收时都存在“时空停顿”现象。  \n  \nJVM 需要找出老年代中不再使用的对象，并对它们进行回收。而这便是垃圾收集算法差异最大的地方。简单的：停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对对空间进行整理。这个过程称为 Full GC。这通常会导致应用线程长时间的停顿。  \n  \n另，通过更复杂的计算，我们还有可能在应用线程运行的同时找出不再使用的对象；  \nCMS 和 G1 收集器就是通过这种方式进行垃圾收集的。由于它们不需要停止应用线程就能找出不再用的对象， CMS 和 G1 收集器被称为 Concurrent 垃圾收集器。同时，由于它们将停止应用程序的可能降到了最小，也被称为低停顿（Low-Pause）收集器。Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。  \n  \n使用 CMS 和 G1 收集器时，应用程序经历的停顿会更少（也更短），代价是会消耗更多的 CPU。\n>1. 所有的 GC 算法都将堆划分成了老年代和新生代。\n>2. 所有的 GC 算法在清理新生代对象时，都使用了“时空停顿”（stop-the-world）方式的垃圾收集方法。\n\n## 1.2 GC 算法\n\nJVM 提供了以下四种不同的垃圾收集算法。\n\n### 1.Serial 垃圾收集器\n\n它是单线程清理堆的内容。使用 Serial 垃圾收集器，无论是进行 Minor GC 还是 Full GC ，清理堆空间时，所有的应用线程都会被暂停。\n\n### 2.Throughput 垃圾收集器\n\nThroughput 收集器是 Server 级虚拟机（多 CPU）的默认收集器。  \n使用多线程回收新生代空间， Minoc GC 的速度比使用 Serial 收集器快得多。处理老年代在 JDK7 之后默认也是多线程。因为其使用多线程，也被称为 Parallel 收集器。  \n在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。\n\n### 3.CMS 收集器\n\nCMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。 CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。  \n它不使用 Throughput 的收集算法（-XX:+UseParallelGC），而是用新的算法（-XX:+UseParNewGC）来收集新生代对象。  \n它在 Full GC 不再暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。这种算法使 CMS 成为一个低延迟的收集器：应用线程只在 Minor GC 以后后台线程扫描老年代时发生极其短暂的停顿。  \n代价是额外的 CPU 使用率。而且后台线程不再进行任何压缩整理的工作，这意味着逐渐碎片化，碎片化一定程度， CMS 会降级为 Serial 收集器：暂停所有应用线程，使用单线程回收。之后再恢复到并发回收。（这种思想在写锁降级为读锁也有体现）。\n\n### 4.G1 收集器\n\nG1 垃圾收集器（垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4 GB）时产生的停顿。G1 收集算法将老年堆划分为若干个区域（Region），不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然采用暂停所有应用线程的方法，将存活对象移动到老年代或者 Survivor 空间，这也是多线程完成的。  \n  \nG1 收集器属于 Concurrent 收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。因此，使用G1 收集器的堆不大容易发生碎片化——虽然这种问题无法避免。  \n  \n>通常情况下垃圾收集是由 JVM 在需要的时候触发：新生代用尽时会触发 Minor GC，老年代用尽时会触发 Full GC，或者堆空间即将填满时会触发 Concurrent 垃圾收集。  \n>`System.gc()` 让应用程序强制进行 GC， Full GC。应用程序线程会因此而停顿相当长的一段时间。同时，调用这个方法也不会让应用程序更高效，它会让 GC 更早的开始，但那实际只是将性能的影响往后推迟而已。\n\n# 2 GC 调优基础\n\n## 2.1 调整堆的大小\n\n如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上。  \n如果分配的过于大也不行，GC 停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长，这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。还有一个风险是，操作系统使用虚拟内存机制管理机器的物理内存。一台机器可能有 8G 的物理内存，不过操作系统可能让你感觉有更多的可用内存。虚拟内存的数量取决于操作系统的设置，譬如操作系统可能让你感觉它的内存达到了 16G 。操作系统通过名为“交换”（swapping）（或者称之为分页，虽然两者技术存在差异）。你可以载入需要 16G 内存的应用程序，操作系统在需要时会将程序运行时不活跃的数据由内存复制到磁盘。再次需要这部分内存的内容时，操作系统再将它们由磁盘重新载入到内存（为了腾出空间，通常它会先将另一部分内存的内容复制到磁盘）。  \n  \n系统中运行着大量不同的应用程序时，这个流程工作的很顺畅，因为大多数的应用程序不会同时处于活跃状态。但是，对于 Java 应用，它工作得并不那么好。如果一个 Java 应用使用了这个系统上大约 12G 的堆，操作系统可能在 RAM 上分配了 8G 的堆空间，另外 4G 的空间存在于磁盘。这样操作系统需要将相当一部分的数据由磁盘交换到内存，而发生 Full GC 时，因为 JVM 必须访问整个堆的内容，如果系统发生内存交换，停顿时间会更长。  \n  \n堆的大小由 2 个参数值控制：初始值（-Xms）、最大值（-Xmx）。\n\n## 2.2 代空间的调整\n\n一旦堆的大小确定下来，JVM 就需要决定分配多少堆给新生代空间，多少给老年代空间。  \n必须清楚：如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少。但是老年代相对比较小，容易填满，会更频繁的触发 Full GC。  \n1. -XX:NewRatio=N：设置新生代与老年代的空间占用比率\n2. -XX:NewSize=N：设置新生代空间的初始大小\n3. -XX:MaxNewSize=N:设置新生代空间的最大大小\n4. -XmnN：将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。\n\n## 2.3 永久代和元空间的调整\n\nJVM 载入类的时候，它需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在 Java7 里，这部分空间被称为永久代（Permgen），在 Java8 中，它们被称为元空间（Metaspace）。  \n永久代和元空间并不完全一样。Java7 中永久代还保存了一些与类数据无关的杂项对象；这些对象在 Java8 中被挪到了普通的堆空间内。它们保存的信息只对编译器或者 JVM 的运行时有用。  \n通过 -XX:PermSize=N、-XX:MaxPerSize=N 来调整永久代大小。  \n通过 -XX:MetaspaceSize=N、-XX:MaxMetaspaceSize=N 来调整元空间的大小。  \n  \n调整这些区间会触发 Full GC ，所以是一种代价昂贵的操作。如果程序在启动时发生大量的 Full GC（因为需要载入数量巨大的类），通常都是由于永久代或者元空间发生了大小调整。\n\n# 3 垃圾回收工具\n\n开启 GC 的日志功能：使用 -verbose:gc 或 -XX:+PrintGC 的任意一个能创建基本的 GC 日志。使用 -XX:+PrintGCDetails 创建更详细的 GC 日志。\n\n# 4 小结\n\n多说无益，多尝试。\n\n![1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png","source":"_posts/Java性能权威指南/第五章 垃圾收集入门.md","raw":"---\ntitle: 五、垃圾收集入门\ndate: 2017-01-10 12:00:00\nupdated: 2017-01-17 00:50:00\ncomments: true\ncategories: \n- 读书笔记\n- Java 性能权威指南\npermalink: java_performance_the_definitive_guide/5.html    \n---\n\n很多时候，我们没有机会重写代码，又要面临需要提高 Java 应用性能的压力，这种情况下对垃圾收集器的调优就变得至关重要。  \n>1. Serial 收集器（常用于单 CPU环境）。\n>2. Throughput（或者 Parallel）收集器。\n>3. Concurrent 收集器（CMS）。\n>4. G1 收集器。\n\n---\n\n# 1 垃圾收集概述\n\n简单来说，垃圾收集由两步构成：查找不再使用的对象，以及释放这些对象所管理的内存。 JVM 从查找不再使用的对象（垃圾对象）入手。有时，这也被称为查找不再有任何对象引用的对象（暗指采用“引用计数”的方式统计对象引用）。  \n  \n例，如下场景：一个程序要分配大小为 1000 字节的数组，紧接着又分配一个大小为 24 字节的数组，并在一个循环中持续进行这样的分配。最终程序会耗尽整个堆，结果如下图的**第一行**所示：堆空间被沾满，分配的数组间隔地分布于整个堆内：  \n![][1]  \n堆内存用尽会触发 JVM 回收不再使用的数组空间。假设所有大小为 24 字节的数组都不再被使用，而大小为 1000 字节的数组还继续使用，这样就形成了上图的**第二行**的场景。  \n虽然堆内部有足够的空闲空间，却找不到任何一个大于 24 字节的连续空间，除非 JVM 移动所有大小为 1000 字节的数组，让它们连续存储，把空闲的空间整合成一块更大的连续空间，供其他的内存分配使用（如上图的**第三行**）。  \n  \n而垃圾收集的性能就是由这些基本操作所决定的：找到不再使用的对象、回收它们使用的内存、对堆的内存布局进行压缩整理。完成这些操作时不同的收集器采用了不同的方法，这也是不同垃圾收起表现出不同性能特征的原因。  \n通常垃圾收集器自身往往也是多线程的。接下来的讨论中，我们从逻辑上将县城分成了两组，分别是应用程序线程和处理垃圾收集的线程。垃圾收集器回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。这一点在收集器移动对象时尤其重要：**在操作过程中，对象的内存地址会发生变化，因此这个过程中任何应用线程都不应再访问该对象。**  \n  \n所有应用线程都停止运行所产生的停顿被称为时空停顿（stop-the-world）。通常这些停顿对应用的性能影响对打，调优垃圾收集时，尽量减少这种停顿是最为关键的考量因素。\n\n## 1.1 分代垃圾收集器\n\n虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步划分为不同的区段，分别称为 Eden 空间和 survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。  \n  \n新生代被填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其它地方。这种操作被称为 Minor GC。  \n采用这种设计有两个性能上的优势：  \n1. 新生代仅是堆的一部分，这意味着应用线程停顿的时间更短。但是更加频繁。\n2. 对象分配与 Eden 空间，垃圾收集时，新生代空间被清空，Eden 空间的对象要么被移走，要么移动到另一个 Survivor 空间，要么被移动到老年代。这就相当于自动的进行了一次压缩整理。  \n  \n所有的垃圾收集算法在对新生代回收时都存在“时空停顿”现象。  \n  \nJVM 需要找出老年代中不再使用的对象，并对它们进行回收。而这便是垃圾收集算法差异最大的地方。简单的：停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对对空间进行整理。这个过程称为 Full GC。这通常会导致应用线程长时间的停顿。  \n  \n另，通过更复杂的计算，我们还有可能在应用线程运行的同时找出不再使用的对象；  \nCMS 和 G1 收集器就是通过这种方式进行垃圾收集的。由于它们不需要停止应用线程就能找出不再用的对象， CMS 和 G1 收集器被称为 Concurrent 垃圾收集器。同时，由于它们将停止应用程序的可能降到了最小，也被称为低停顿（Low-Pause）收集器。Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。  \n  \n使用 CMS 和 G1 收集器时，应用程序经历的停顿会更少（也更短），代价是会消耗更多的 CPU。\n>1. 所有的 GC 算法都将堆划分成了老年代和新生代。\n>2. 所有的 GC 算法在清理新生代对象时，都使用了“时空停顿”（stop-the-world）方式的垃圾收集方法。\n\n## 1.2 GC 算法\n\nJVM 提供了以下四种不同的垃圾收集算法。\n\n### 1.Serial 垃圾收集器\n\n它是单线程清理堆的内容。使用 Serial 垃圾收集器，无论是进行 Minor GC 还是 Full GC ，清理堆空间时，所有的应用线程都会被暂停。\n\n### 2.Throughput 垃圾收集器\n\nThroughput 收集器是 Server 级虚拟机（多 CPU）的默认收集器。  \n使用多线程回收新生代空间， Minoc GC 的速度比使用 Serial 收集器快得多。处理老年代在 JDK7 之后默认也是多线程。因为其使用多线程，也被称为 Parallel 收集器。  \n在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。\n\n### 3.CMS 收集器\n\nCMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。 CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。  \n它不使用 Throughput 的收集算法（-XX:+UseParallelGC），而是用新的算法（-XX:+UseParNewGC）来收集新生代对象。  \n它在 Full GC 不再暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。这种算法使 CMS 成为一个低延迟的收集器：应用线程只在 Minor GC 以后后台线程扫描老年代时发生极其短暂的停顿。  \n代价是额外的 CPU 使用率。而且后台线程不再进行任何压缩整理的工作，这意味着逐渐碎片化，碎片化一定程度， CMS 会降级为 Serial 收集器：暂停所有应用线程，使用单线程回收。之后再恢复到并发回收。（这种思想在写锁降级为读锁也有体现）。\n\n### 4.G1 收集器\n\nG1 垃圾收集器（垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4 GB）时产生的停顿。G1 收集算法将老年堆划分为若干个区域（Region），不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然采用暂停所有应用线程的方法，将存活对象移动到老年代或者 Survivor 空间，这也是多线程完成的。  \n  \nG1 收集器属于 Concurrent 收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。因此，使用G1 收集器的堆不大容易发生碎片化——虽然这种问题无法避免。  \n  \n>通常情况下垃圾收集是由 JVM 在需要的时候触发：新生代用尽时会触发 Minor GC，老年代用尽时会触发 Full GC，或者堆空间即将填满时会触发 Concurrent 垃圾收集。  \n>`System.gc()` 让应用程序强制进行 GC， Full GC。应用程序线程会因此而停顿相当长的一段时间。同时，调用这个方法也不会让应用程序更高效，它会让 GC 更早的开始，但那实际只是将性能的影响往后推迟而已。\n\n# 2 GC 调优基础\n\n## 2.1 调整堆的大小\n\n如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上。  \n如果分配的过于大也不行，GC 停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长，这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。还有一个风险是，操作系统使用虚拟内存机制管理机器的物理内存。一台机器可能有 8G 的物理内存，不过操作系统可能让你感觉有更多的可用内存。虚拟内存的数量取决于操作系统的设置，譬如操作系统可能让你感觉它的内存达到了 16G 。操作系统通过名为“交换”（swapping）（或者称之为分页，虽然两者技术存在差异）。你可以载入需要 16G 内存的应用程序，操作系统在需要时会将程序运行时不活跃的数据由内存复制到磁盘。再次需要这部分内存的内容时，操作系统再将它们由磁盘重新载入到内存（为了腾出空间，通常它会先将另一部分内存的内容复制到磁盘）。  \n  \n系统中运行着大量不同的应用程序时，这个流程工作的很顺畅，因为大多数的应用程序不会同时处于活跃状态。但是，对于 Java 应用，它工作得并不那么好。如果一个 Java 应用使用了这个系统上大约 12G 的堆，操作系统可能在 RAM 上分配了 8G 的堆空间，另外 4G 的空间存在于磁盘。这样操作系统需要将相当一部分的数据由磁盘交换到内存，而发生 Full GC 时，因为 JVM 必须访问整个堆的内容，如果系统发生内存交换，停顿时间会更长。  \n  \n堆的大小由 2 个参数值控制：初始值（-Xms）、最大值（-Xmx）。\n\n## 2.2 代空间的调整\n\n一旦堆的大小确定下来，JVM 就需要决定分配多少堆给新生代空间，多少给老年代空间。  \n必须清楚：如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少。但是老年代相对比较小，容易填满，会更频繁的触发 Full GC。  \n1. -XX:NewRatio=N：设置新生代与老年代的空间占用比率\n2. -XX:NewSize=N：设置新生代空间的初始大小\n3. -XX:MaxNewSize=N:设置新生代空间的最大大小\n4. -XmnN：将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。\n\n## 2.3 永久代和元空间的调整\n\nJVM 载入类的时候，它需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在 Java7 里，这部分空间被称为永久代（Permgen），在 Java8 中，它们被称为元空间（Metaspace）。  \n永久代和元空间并不完全一样。Java7 中永久代还保存了一些与类数据无关的杂项对象；这些对象在 Java8 中被挪到了普通的堆空间内。它们保存的信息只对编译器或者 JVM 的运行时有用。  \n通过 -XX:PermSize=N、-XX:MaxPerSize=N 来调整永久代大小。  \n通过 -XX:MetaspaceSize=N、-XX:MaxMetaspaceSize=N 来调整元空间的大小。  \n  \n调整这些区间会触发 Full GC ，所以是一种代价昂贵的操作。如果程序在启动时发生大量的 Full GC（因为需要载入数量巨大的类），通常都是由于永久代或者元空间发生了大小调整。\n\n# 3 垃圾回收工具\n\n开启 GC 的日志功能：使用 -verbose:gc 或 -XX:+PrintGC 的任意一个能创建基本的 GC 日志。使用 -XX:+PrintGCDetails 创建更详细的 GC 日志。\n\n# 4 小结\n\n多说无益，多尝试。\n\n![1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png","slug":"java_performance_the_definitive_guide/5.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaur000aaxs61jpapgs6","content":"<p>很多时候，我们没有机会重写代码，又要面临需要提高 Java 应用性能的压力，这种情况下对垃圾收集器的调优就变得至关重要。  </p>\n<blockquote>\n<ol>\n<li>Serial 收集器（常用于单 CPU环境）。</li>\n<li>Throughput（或者 Parallel）收集器。</li>\n<li>Concurrent 收集器（CMS）。</li>\n<li>G1 收集器。</li>\n</ol>\n</blockquote>\n<hr>\n<h1 id=\"1-垃圾收集概述\"><a href=\"#1-垃圾收集概述\" class=\"headerlink\" title=\"1 垃圾收集概述\"></a>1 垃圾收集概述</h1><p>简单来说，垃圾收集由两步构成：查找不再使用的对象，以及释放这些对象所管理的内存。 JVM 从查找不再使用的对象（垃圾对象）入手。有时，这也被称为查找不再有任何对象引用的对象（暗指采用“引用计数”的方式统计对象引用）。  </p>\n<p>例，如下场景：一个程序要分配大小为 1000 字节的数组，紧接着又分配一个大小为 24 字节的数组，并在一个循环中持续进行这样的分配。最终程序会耗尽整个堆，结果如下图的<strong>第一行</strong>所示：堆空间被沾满，分配的数组间隔地分布于整个堆内：<br>![][1]<br>堆内存用尽会触发 JVM 回收不再使用的数组空间。假设所有大小为 24 字节的数组都不再被使用，而大小为 1000 字节的数组还继续使用，这样就形成了上图的<strong>第二行</strong>的场景。<br>虽然堆内部有足够的空闲空间，却找不到任何一个大于 24 字节的连续空间，除非 JVM 移动所有大小为 1000 字节的数组，让它们连续存储，把空闲的空间整合成一块更大的连续空间，供其他的内存分配使用（如上图的<strong>第三行</strong>）。  </p>\n<p>而垃圾收集的性能就是由这些基本操作所决定的：找到不再使用的对象、回收它们使用的内存、对堆的内存布局进行压缩整理。完成这些操作时不同的收集器采用了不同的方法，这也是不同垃圾收起表现出不同性能特征的原因。<br>通常垃圾收集器自身往往也是多线程的。接下来的讨论中，我们从逻辑上将县城分成了两组，分别是应用程序线程和处理垃圾收集的线程。垃圾收集器回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。这一点在收集器移动对象时尤其重要：<strong>在操作过程中，对象的内存地址会发生变化，因此这个过程中任何应用线程都不应再访问该对象。</strong>  </p>\n<p>所有应用线程都停止运行所产生的停顿被称为时空停顿（stop-the-world）。通常这些停顿对应用的性能影响对打，调优垃圾收集时，尽量减少这种停顿是最为关键的考量因素。</p>\n<h2 id=\"1-1-分代垃圾收集器\"><a href=\"#1-1-分代垃圾收集器\" class=\"headerlink\" title=\"1.1 分代垃圾收集器\"></a>1.1 分代垃圾收集器</h2><p>虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步划分为不同的区段，分别称为 Eden 空间和 survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。  </p>\n<p>新生代被填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其它地方。这种操作被称为 Minor GC。<br>采用这种设计有两个性能上的优势：  </p>\n<ol>\n<li>新生代仅是堆的一部分，这意味着应用线程停顿的时间更短。但是更加频繁。</li>\n<li>对象分配与 Eden 空间，垃圾收集时，新生代空间被清空，Eden 空间的对象要么被移走，要么移动到另一个 Survivor 空间，要么被移动到老年代。这就相当于自动的进行了一次压缩整理。  </li>\n</ol>\n<p>所有的垃圾收集算法在对新生代回收时都存在“时空停顿”现象。  </p>\n<p>JVM 需要找出老年代中不再使用的对象，并对它们进行回收。而这便是垃圾收集算法差异最大的地方。简单的：停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对对空间进行整理。这个过程称为 Full GC。这通常会导致应用线程长时间的停顿。  </p>\n<p>另，通过更复杂的计算，我们还有可能在应用线程运行的同时找出不再使用的对象；<br>CMS 和 G1 收集器就是通过这种方式进行垃圾收集的。由于它们不需要停止应用线程就能找出不再用的对象， CMS 和 G1 收集器被称为 Concurrent 垃圾收集器。同时，由于它们将停止应用程序的可能降到了最小，也被称为低停顿（Low-Pause）收集器。Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。  </p>\n<p>使用 CMS 和 G1 收集器时，应用程序经历的停顿会更少（也更短），代价是会消耗更多的 CPU。</p>\n<blockquote>\n<ol>\n<li>所有的 GC 算法都将堆划分成了老年代和新生代。</li>\n<li>所有的 GC 算法在清理新生代对象时，都使用了“时空停顿”（stop-the-world）方式的垃圾收集方法。</li>\n</ol>\n</blockquote>\n<h2 id=\"1-2-GC-算法\"><a href=\"#1-2-GC-算法\" class=\"headerlink\" title=\"1.2 GC 算法\"></a>1.2 GC 算法</h2><p>JVM 提供了以下四种不同的垃圾收集算法。</p>\n<h3 id=\"1-Serial-垃圾收集器\"><a href=\"#1-Serial-垃圾收集器\" class=\"headerlink\" title=\"1.Serial 垃圾收集器\"></a>1.Serial 垃圾收集器</h3><p>它是单线程清理堆的内容。使用 Serial 垃圾收集器，无论是进行 Minor GC 还是 Full GC ，清理堆空间时，所有的应用线程都会被暂停。</p>\n<h3 id=\"2-Throughput-垃圾收集器\"><a href=\"#2-Throughput-垃圾收集器\" class=\"headerlink\" title=\"2.Throughput 垃圾收集器\"></a>2.Throughput 垃圾收集器</h3><p>Throughput 收集器是 Server 级虚拟机（多 CPU）的默认收集器。<br>使用多线程回收新生代空间， Minoc GC 的速度比使用 Serial 收集器快得多。处理老年代在 JDK7 之后默认也是多线程。因为其使用多线程，也被称为 Parallel 收集器。<br>在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。</p>\n<h3 id=\"3-CMS-收集器\"><a href=\"#3-CMS-收集器\" class=\"headerlink\" title=\"3.CMS 收集器\"></a>3.CMS 收集器</h3><p>CMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。 CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。<br>它不使用 Throughput 的收集算法（-XX:+UseParallelGC），而是用新的算法（-XX:+UseParNewGC）来收集新生代对象。<br>它在 Full GC 不再暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。这种算法使 CMS 成为一个低延迟的收集器：应用线程只在 Minor GC 以后后台线程扫描老年代时发生极其短暂的停顿。<br>代价是额外的 CPU 使用率。而且后台线程不再进行任何压缩整理的工作，这意味着逐渐碎片化，碎片化一定程度， CMS 会降级为 Serial 收集器：暂停所有应用线程，使用单线程回收。之后再恢复到并发回收。（这种思想在写锁降级为读锁也有体现）。</p>\n<h3 id=\"4-G1-收集器\"><a href=\"#4-G1-收集器\" class=\"headerlink\" title=\"4.G1 收集器\"></a>4.G1 收集器</h3><p>G1 垃圾收集器（垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4 GB）时产生的停顿。G1 收集算法将老年堆划分为若干个区域（Region），不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然采用暂停所有应用线程的方法，将存活对象移动到老年代或者 Survivor 空间，这也是多线程完成的。  </p>\n<p>G1 收集器属于 Concurrent 收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。因此，使用G1 收集器的堆不大容易发生碎片化——虽然这种问题无法避免。  </p>\n<blockquote>\n<p>通常情况下垃圾收集是由 JVM 在需要的时候触发：新生代用尽时会触发 Minor GC，老年代用尽时会触发 Full GC，或者堆空间即将填满时会触发 Concurrent 垃圾收集。<br><code>System.gc()</code> 让应用程序强制进行 GC， Full GC。应用程序线程会因此而停顿相当长的一段时间。同时，调用这个方法也不会让应用程序更高效，它会让 GC 更早的开始，但那实际只是将性能的影响往后推迟而已。</p>\n</blockquote>\n<h1 id=\"2-GC-调优基础\"><a href=\"#2-GC-调优基础\" class=\"headerlink\" title=\"2 GC 调优基础\"></a>2 GC 调优基础</h1><h2 id=\"2-1-调整堆的大小\"><a href=\"#2-1-调整堆的大小\" class=\"headerlink\" title=\"2.1 调整堆的大小\"></a>2.1 调整堆的大小</h2><p>如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上。<br>如果分配的过于大也不行，GC 停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长，这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。还有一个风险是，操作系统使用虚拟内存机制管理机器的物理内存。一台机器可能有 8G 的物理内存，不过操作系统可能让你感觉有更多的可用内存。虚拟内存的数量取决于操作系统的设置，譬如操作系统可能让你感觉它的内存达到了 16G 。操作系统通过名为“交换”（swapping）（或者称之为分页，虽然两者技术存在差异）。你可以载入需要 16G 内存的应用程序，操作系统在需要时会将程序运行时不活跃的数据由内存复制到磁盘。再次需要这部分内存的内容时，操作系统再将它们由磁盘重新载入到内存（为了腾出空间，通常它会先将另一部分内存的内容复制到磁盘）。  </p>\n<p>系统中运行着大量不同的应用程序时，这个流程工作的很顺畅，因为大多数的应用程序不会同时处于活跃状态。但是，对于 Java 应用，它工作得并不那么好。如果一个 Java 应用使用了这个系统上大约 12G 的堆，操作系统可能在 RAM 上分配了 8G 的堆空间，另外 4G 的空间存在于磁盘。这样操作系统需要将相当一部分的数据由磁盘交换到内存，而发生 Full GC 时，因为 JVM 必须访问整个堆的内容，如果系统发生内存交换，停顿时间会更长。  </p>\n<p>堆的大小由 2 个参数值控制：初始值（-Xms）、最大值（-Xmx）。</p>\n<h2 id=\"2-2-代空间的调整\"><a href=\"#2-2-代空间的调整\" class=\"headerlink\" title=\"2.2 代空间的调整\"></a>2.2 代空间的调整</h2><p>一旦堆的大小确定下来，JVM 就需要决定分配多少堆给新生代空间，多少给老年代空间。<br>必须清楚：如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少。但是老年代相对比较小，容易填满，会更频繁的触发 Full GC。  </p>\n<ol>\n<li>-XX:NewRatio=N：设置新生代与老年代的空间占用比率</li>\n<li>-XX:NewSize=N：设置新生代空间的初始大小</li>\n<li>-XX:MaxNewSize=N:设置新生代空间的最大大小</li>\n<li>-XmnN：将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。</li>\n</ol>\n<h2 id=\"2-3-永久代和元空间的调整\"><a href=\"#2-3-永久代和元空间的调整\" class=\"headerlink\" title=\"2.3 永久代和元空间的调整\"></a>2.3 永久代和元空间的调整</h2><p>JVM 载入类的时候，它需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在 Java7 里，这部分空间被称为永久代（Permgen），在 Java8 中，它们被称为元空间（Metaspace）。<br>永久代和元空间并不完全一样。Java7 中永久代还保存了一些与类数据无关的杂项对象；这些对象在 Java8 中被挪到了普通的堆空间内。它们保存的信息只对编译器或者 JVM 的运行时有用。<br>通过 -XX:PermSize=N、-XX:MaxPerSize=N 来调整永久代大小。<br>通过 -XX:MetaspaceSize=N、-XX:MaxMetaspaceSize=N 来调整元空间的大小。  </p>\n<p>调整这些区间会触发 Full GC ，所以是一种代价昂贵的操作。如果程序在启动时发生大量的 Full GC（因为需要载入数量巨大的类），通常都是由于永久代或者元空间发生了大小调整。</p>\n<h1 id=\"3-垃圾回收工具\"><a href=\"#3-垃圾回收工具\" class=\"headerlink\" title=\"3 垃圾回收工具\"></a>3 垃圾回收工具</h1><p>开启 GC 的日志功能：使用 -verbose:gc 或 -XX:+PrintGC 的任意一个能创建基本的 GC 日志。使用 -XX:+PrintGCDetails 创建更详细的 GC 日志。</p>\n<h1 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4 小结\"></a>4 小结</h1><p>多说无益，多尝试。</p>\n<p>![1]: <a href=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png\" target=\"_blank\" rel=\"noopener\">http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>很多时候，我们没有机会重写代码，又要面临需要提高 Java 应用性能的压力，这种情况下对垃圾收集器的调优就变得至关重要。  </p>\n<blockquote>\n<ol>\n<li>Serial 收集器（常用于单 CPU环境）。</li>\n<li>Throughput（或者 Parallel）收集器。</li>\n<li>Concurrent 收集器（CMS）。</li>\n<li>G1 收集器。</li>\n</ol>\n</blockquote>\n<hr>\n<h1 id=\"1-垃圾收集概述\"><a href=\"#1-垃圾收集概述\" class=\"headerlink\" title=\"1 垃圾收集概述\"></a>1 垃圾收集概述</h1><p>简单来说，垃圾收集由两步构成：查找不再使用的对象，以及释放这些对象所管理的内存。 JVM 从查找不再使用的对象（垃圾对象）入手。有时，这也被称为查找不再有任何对象引用的对象（暗指采用“引用计数”的方式统计对象引用）。  </p>\n<p>例，如下场景：一个程序要分配大小为 1000 字节的数组，紧接着又分配一个大小为 24 字节的数组，并在一个循环中持续进行这样的分配。最终程序会耗尽整个堆，结果如下图的<strong>第一行</strong>所示：堆空间被沾满，分配的数组间隔地分布于整个堆内：<br>![][1]<br>堆内存用尽会触发 JVM 回收不再使用的数组空间。假设所有大小为 24 字节的数组都不再被使用，而大小为 1000 字节的数组还继续使用，这样就形成了上图的<strong>第二行</strong>的场景。<br>虽然堆内部有足够的空闲空间，却找不到任何一个大于 24 字节的连续空间，除非 JVM 移动所有大小为 1000 字节的数组，让它们连续存储，把空闲的空间整合成一块更大的连续空间，供其他的内存分配使用（如上图的<strong>第三行</strong>）。  </p>\n<p>而垃圾收集的性能就是由这些基本操作所决定的：找到不再使用的对象、回收它们使用的内存、对堆的内存布局进行压缩整理。完成这些操作时不同的收集器采用了不同的方法，这也是不同垃圾收起表现出不同性能特征的原因。<br>通常垃圾收集器自身往往也是多线程的。接下来的讨论中，我们从逻辑上将县城分成了两组，分别是应用程序线程和处理垃圾收集的线程。垃圾收集器回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。这一点在收集器移动对象时尤其重要：<strong>在操作过程中，对象的内存地址会发生变化，因此这个过程中任何应用线程都不应再访问该对象。</strong>  </p>\n<p>所有应用线程都停止运行所产生的停顿被称为时空停顿（stop-the-world）。通常这些停顿对应用的性能影响对打，调优垃圾收集时，尽量减少这种停顿是最为关键的考量因素。</p>\n<h2 id=\"1-1-分代垃圾收集器\"><a href=\"#1-1-分代垃圾收集器\" class=\"headerlink\" title=\"1.1 分代垃圾收集器\"></a>1.1 分代垃圾收集器</h2><p>虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步划分为不同的区段，分别称为 Eden 空间和 survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。  </p>\n<p>新生代被填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其它地方。这种操作被称为 Minor GC。<br>采用这种设计有两个性能上的优势：  </p>\n<ol>\n<li>新生代仅是堆的一部分，这意味着应用线程停顿的时间更短。但是更加频繁。</li>\n<li>对象分配与 Eden 空间，垃圾收集时，新生代空间被清空，Eden 空间的对象要么被移走，要么移动到另一个 Survivor 空间，要么被移动到老年代。这就相当于自动的进行了一次压缩整理。  </li>\n</ol>\n<p>所有的垃圾收集算法在对新生代回收时都存在“时空停顿”现象。  </p>\n<p>JVM 需要找出老年代中不再使用的对象，并对它们进行回收。而这便是垃圾收集算法差异最大的地方。简单的：停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对对空间进行整理。这个过程称为 Full GC。这通常会导致应用线程长时间的停顿。  </p>\n<p>另，通过更复杂的计算，我们还有可能在应用线程运行的同时找出不再使用的对象；<br>CMS 和 G1 收集器就是通过这种方式进行垃圾收集的。由于它们不需要停止应用线程就能找出不再用的对象， CMS 和 G1 收集器被称为 Concurrent 垃圾收集器。同时，由于它们将停止应用程序的可能降到了最小，也被称为低停顿（Low-Pause）收集器。Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。  </p>\n<p>使用 CMS 和 G1 收集器时，应用程序经历的停顿会更少（也更短），代价是会消耗更多的 CPU。</p>\n<blockquote>\n<ol>\n<li>所有的 GC 算法都将堆划分成了老年代和新生代。</li>\n<li>所有的 GC 算法在清理新生代对象时，都使用了“时空停顿”（stop-the-world）方式的垃圾收集方法。</li>\n</ol>\n</blockquote>\n<h2 id=\"1-2-GC-算法\"><a href=\"#1-2-GC-算法\" class=\"headerlink\" title=\"1.2 GC 算法\"></a>1.2 GC 算法</h2><p>JVM 提供了以下四种不同的垃圾收集算法。</p>\n<h3 id=\"1-Serial-垃圾收集器\"><a href=\"#1-Serial-垃圾收集器\" class=\"headerlink\" title=\"1.Serial 垃圾收集器\"></a>1.Serial 垃圾收集器</h3><p>它是单线程清理堆的内容。使用 Serial 垃圾收集器，无论是进行 Minor GC 还是 Full GC ，清理堆空间时，所有的应用线程都会被暂停。</p>\n<h3 id=\"2-Throughput-垃圾收集器\"><a href=\"#2-Throughput-垃圾收集器\" class=\"headerlink\" title=\"2.Throughput 垃圾收集器\"></a>2.Throughput 垃圾收集器</h3><p>Throughput 收集器是 Server 级虚拟机（多 CPU）的默认收集器。<br>使用多线程回收新生代空间， Minoc GC 的速度比使用 Serial 收集器快得多。处理老年代在 JDK7 之后默认也是多线程。因为其使用多线程，也被称为 Parallel 收集器。<br>在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。</p>\n<h3 id=\"3-CMS-收集器\"><a href=\"#3-CMS-收集器\" class=\"headerlink\" title=\"3.CMS 收集器\"></a>3.CMS 收集器</h3><p>CMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。 CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。<br>它不使用 Throughput 的收集算法（-XX:+UseParallelGC），而是用新的算法（-XX:+UseParNewGC）来收集新生代对象。<br>它在 Full GC 不再暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。这种算法使 CMS 成为一个低延迟的收集器：应用线程只在 Minor GC 以后后台线程扫描老年代时发生极其短暂的停顿。<br>代价是额外的 CPU 使用率。而且后台线程不再进行任何压缩整理的工作，这意味着逐渐碎片化，碎片化一定程度， CMS 会降级为 Serial 收集器：暂停所有应用线程，使用单线程回收。之后再恢复到并发回收。（这种思想在写锁降级为读锁也有体现）。</p>\n<h3 id=\"4-G1-收集器\"><a href=\"#4-G1-收集器\" class=\"headerlink\" title=\"4.G1 收集器\"></a>4.G1 收集器</h3><p>G1 垃圾收集器（垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4 GB）时产生的停顿。G1 收集算法将老年堆划分为若干个区域（Region），不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然采用暂停所有应用线程的方法，将存活对象移动到老年代或者 Survivor 空间，这也是多线程完成的。  </p>\n<p>G1 收集器属于 Concurrent 收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。因此，使用G1 收集器的堆不大容易发生碎片化——虽然这种问题无法避免。  </p>\n<blockquote>\n<p>通常情况下垃圾收集是由 JVM 在需要的时候触发：新生代用尽时会触发 Minor GC，老年代用尽时会触发 Full GC，或者堆空间即将填满时会触发 Concurrent 垃圾收集。<br><code>System.gc()</code> 让应用程序强制进行 GC， Full GC。应用程序线程会因此而停顿相当长的一段时间。同时，调用这个方法也不会让应用程序更高效，它会让 GC 更早的开始，但那实际只是将性能的影响往后推迟而已。</p>\n</blockquote>\n<h1 id=\"2-GC-调优基础\"><a href=\"#2-GC-调优基础\" class=\"headerlink\" title=\"2 GC 调优基础\"></a>2 GC 调优基础</h1><h2 id=\"2-1-调整堆的大小\"><a href=\"#2-1-调整堆的大小\" class=\"headerlink\" title=\"2.1 调整堆的大小\"></a>2.1 调整堆的大小</h2><p>如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上。<br>如果分配的过于大也不行，GC 停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长，这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。还有一个风险是，操作系统使用虚拟内存机制管理机器的物理内存。一台机器可能有 8G 的物理内存，不过操作系统可能让你感觉有更多的可用内存。虚拟内存的数量取决于操作系统的设置，譬如操作系统可能让你感觉它的内存达到了 16G 。操作系统通过名为“交换”（swapping）（或者称之为分页，虽然两者技术存在差异）。你可以载入需要 16G 内存的应用程序，操作系统在需要时会将程序运行时不活跃的数据由内存复制到磁盘。再次需要这部分内存的内容时，操作系统再将它们由磁盘重新载入到内存（为了腾出空间，通常它会先将另一部分内存的内容复制到磁盘）。  </p>\n<p>系统中运行着大量不同的应用程序时，这个流程工作的很顺畅，因为大多数的应用程序不会同时处于活跃状态。但是，对于 Java 应用，它工作得并不那么好。如果一个 Java 应用使用了这个系统上大约 12G 的堆，操作系统可能在 RAM 上分配了 8G 的堆空间，另外 4G 的空间存在于磁盘。这样操作系统需要将相当一部分的数据由磁盘交换到内存，而发生 Full GC 时，因为 JVM 必须访问整个堆的内容，如果系统发生内存交换，停顿时间会更长。  </p>\n<p>堆的大小由 2 个参数值控制：初始值（-Xms）、最大值（-Xmx）。</p>\n<h2 id=\"2-2-代空间的调整\"><a href=\"#2-2-代空间的调整\" class=\"headerlink\" title=\"2.2 代空间的调整\"></a>2.2 代空间的调整</h2><p>一旦堆的大小确定下来，JVM 就需要决定分配多少堆给新生代空间，多少给老年代空间。<br>必须清楚：如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少。但是老年代相对比较小，容易填满，会更频繁的触发 Full GC。  </p>\n<ol>\n<li>-XX:NewRatio=N：设置新生代与老年代的空间占用比率</li>\n<li>-XX:NewSize=N：设置新生代空间的初始大小</li>\n<li>-XX:MaxNewSize=N:设置新生代空间的最大大小</li>\n<li>-XmnN：将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。</li>\n</ol>\n<h2 id=\"2-3-永久代和元空间的调整\"><a href=\"#2-3-永久代和元空间的调整\" class=\"headerlink\" title=\"2.3 永久代和元空间的调整\"></a>2.3 永久代和元空间的调整</h2><p>JVM 载入类的时候，它需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在 Java7 里，这部分空间被称为永久代（Permgen），在 Java8 中，它们被称为元空间（Metaspace）。<br>永久代和元空间并不完全一样。Java7 中永久代还保存了一些与类数据无关的杂项对象；这些对象在 Java8 中被挪到了普通的堆空间内。它们保存的信息只对编译器或者 JVM 的运行时有用。<br>通过 -XX:PermSize=N、-XX:MaxPerSize=N 来调整永久代大小。<br>通过 -XX:MetaspaceSize=N、-XX:MaxMetaspaceSize=N 来调整元空间的大小。  </p>\n<p>调整这些区间会触发 Full GC ，所以是一种代价昂贵的操作。如果程序在启动时发生大量的 Full GC（因为需要载入数量巨大的类），通常都是由于永久代或者元空间发生了大小调整。</p>\n<h1 id=\"3-垃圾回收工具\"><a href=\"#3-垃圾回收工具\" class=\"headerlink\" title=\"3 垃圾回收工具\"></a>3 垃圾回收工具</h1><p>开启 GC 的日志功能：使用 -verbose:gc 或 -XX:+PrintGC 的任意一个能创建基本的 GC 日志。使用 -XX:+PrintGCDetails 创建更详细的 GC 日志。</p>\n<h1 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4 小结\"></a>4 小结</h1><p>多说无益，多尝试。</p>\n<p>![1]: <a href=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png\" target=\"_blank\" rel=\"noopener\">http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png</a></p>\n"},{"title":"四、Java并发编程基础","date":"2017-11-07T12:07:00.000Z","updated":"2017-11-07T12:07:00.000Z","comments":1,"_content":"\n# 1 线程简介\n\n## 1.1 什么是线程\n\n操作系统运行一个程序时，会为其创建一个进程。而操作系统调度的最小单元是线程，也叫轻量级进程（ Light Weight Process），\n在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。  \n处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。\n```java\npublic class MultiThread{\n    public static void main(String[] args) {\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n        for(ThreadInfo threadInfo : threadInfos) {\n            System.out.println(threadInfo.getThreadId() + \",\" + threadInfo.getThreadName());\n        }\n        /**\n         6,Monitor Ctrl-Break\n         5,Attach Listener\n         4,Signal Dispatcher\n         3,Finalizer\n         2,Reference Handler\n         1,main\n         */\n    } \n}\n```\n\n## 1.2 为什么要使用多线程\n\n### 1.2.1 更多的处理器核心\n\n程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器\n核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，\n就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。\n\n### 1.2.2 更快的响应时间\n\n编写一些较为复杂的代码，例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。这么多业务\n操作，如何能够让其更快地完成呢？\n\n### 1.2.3 更好的编程模型\n\nJava 为多线程编程提供了良好、考究并且一致的编程模型，使开发人员更加专注于问题的解决。\n\n## 1.3 线程优先级\n\n现代操作系统基于采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程\n调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器\n资源的线程属性。  \n  \n在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法\n来修改优先级，默认优先级是 5 ，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞的线程需要设置较高优先级，\n而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级。笔者在 JDK 1.8 的 WIN 10 环境：\n```java\npublic class Priority {\n\n    private static volatile boolean notStart = true;\n\n    private static volatile boolean notEnd = true;\n\n    public static void main(String[] args) throws InterruptedException {\n        List<Job> jobs = new ArrayList();\n        for (int i = 0; i < 10; i++) {\n            int priority = i < 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;\n            Job job = new Job(priority);\n            jobs.add(job);\n            Thread thread = new Thread(job, \"Thread:\" + i);\n            thread.setPriority(priority);\n            thread.start();\n        }\n        notStart = false;\n        TimeUnit.SECONDS.sleep(2);\n        notEnd = false;\n        for (Job job : jobs) {\n            System.out.println(\"Job Priority：\" + job.priority + \", Count：\" + job.jobCount);\n        }\n    }\n\n    static class Job implements Runnable {\n\n        private int priority;\n        private long jobCount;\n\n        public Job(int priority) {\n            this.priority = priority;\n        }\n\n        @Override\n        public void run() {\n            while (notStart) {\n                Thread.yield();\n            }\n            while (notEnd) {\n                Thread.yield();\n                jobCount++;\n            }\n        }\n    }\n}\n```\n输出：\n```java\nJob Priority：1, Count：16772\nJob Priority：1, Count：16761\nJob Priority：1, Count：16761\nJob Priority：1, Count：16758\nJob Priority：1, Count：16757\nJob Priority：10, Count：756747\nJob Priority：10, Count：757594\nJob Priority：10, Count：757263\nJob Priority：10, Count：759519\nJob Priority：10, Count：760287\n```\n\n## 1.4 线程的状态\n\n![][1]\n\n## 1.5 Daemon 线程\n\nDaemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候，\nJava 虚拟机将会退出。可以通过调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程。\n>Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置。\n\nDaemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行，如下：\n```java\npublic class Daemon {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new DaemonRunner(), \"DaemonRunner\");\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    static class DaemonRunner implements Runnable {\n\n        @Override\n        public void run() {\n            try {\n                SleepUtils.second(10);\n            } finally {\n                System.out.println(\"DaemonThread finally run.\");\n            }\n        }\n    }\n}\n```\n最终没有任何的输出，mian 线程在启动了线程 DaemonRunner 之后随着 main 方法执行完毕而终止，而此时 Java 虚拟机中已经灭有非 Daemon 线程，\n虚拟机需要退出。 Java 虚拟机中的所有 Daemon 线程都需要立即终止，因此 DaemonRunner 立即终止，但是 DaemonRunner 中的 finally 块并没有执行。\n\n# 2 启动和终止线程\n\n## 2.1 理解中断\n\n中断可以理解为线程的一个标识位属性，它标识一个运行中的线程是否被其它线程进行了中断操作。线程通过方法 `isInterrupted` 来进行判断是否被中断，\n也可以调用静态方法 `Thread.interrupted()` 对当前线程的中断标识位进行复位。下面的例子中，创建了两个线程， SleepThread 和 BusyThread ，\n前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。\n\n```java\npublic class Interrupted {\n    public static void main(String[] args) throws InterruptedException {\n        Thread sleepThread = new Thread(new SleepRunner(), \"SleepThread\");\n        sleepThread.setDaemon(true);\n\n        Thread busyThread = new Thread(new BusyRunner(), \"BusyThread\");\n        busyThread.setDaemon(true);\n\n        sleepThread.start();\n        busyThread.start();\n\n        Thread.sleep(5 * 1000);\n\n        sleepThread.interrupt();\n        busyThread.interrupt();\n\n        System.out.println(\"SleepThread interrupted is \" + sleepThread.isInterrupted());\n        System.out.println(\"BusyThread interrupted is \" + busyThread.isInterrupted());\n\n        Thread.sleep(2 * 1000);\n\n\n        System.out.println(\"SleepThread interrupted is \" + sleepThread.isInterrupted());\n        System.out.println(\"BusyThread interrupted is \" + busyThread.isInterrupted());\n        // SleepThread interrupted is false\n        // BusyThread interrupted is true\n        \n        Thread.sleep(2 * 1000);\n    }\n\n    static class SleepRunner implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    Thread.sleep(10 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class BusyRunner implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n            }\n        }\n    }\n}\n```\n线程 SleepThread 其中断标识位被清除了，而一直忙碌运作的线程 BusyThread ，其中断标识位没有被清除。\n\n## 2.2 安全地终止线程\n\n```java\npublic class Shutdown {\n    \n    public static void main(String[] args) throws InterruptedException {\n        Runner one = new Runner();\n        Thread countThread = new Thread(one, \"countThread\");\n        countThread.start();\n        \n        Thread.sleep(1 * 1000);\n        \n        countThread.interrupt();\n        \n        Runner two = new Runner();\n        countThread = new Thread(two, \"CountThread\");\n        countThread.start();\n        \n        Thread.sleep(1 * 1000);\n        \n        two.cancel();\n    }\n    \n    private static class Runner implements Runnable {\n        private long i ;\n        private volatile boolean on = true;\n        \n        @Override\n        public void run() {\n            while(on && !Thread.currentThread().isInterrupted()) {\n                i++;\n            }\n        }\n        \n        private void cancel() {\n            on = false;\n        }\n    }\n}\n```\n使用 `Thread.interrupted()` 或一个 boolean 来进行中断。\n\n# 3. 线程间通信\n\n## 3.1 volatile 和 synchronized 关键字\n\n每个执行的线程拥有一份拷贝，这样做的目的是加速程序的执行，所以程序在执行过程中，一个线程看到的变量并不一定是最新的。  \n  \n关键字 `volatile` 就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。  \n  \n举个例子：定义一个表示程序是否运行的成员变量 boolean on = true ，另一个线程可能执行了关闭动作 on = false ，这里涉及多个线程对变量的访问，\n因此需要定义称为 volatile boolean on = true ，这样其他线程对它改变时，所以线程都会感知，因为所有对 on　变量的访问和修改都需要以共享内存\n为准。  \n  \n关键字 synchronized 主要确保多个线程在同一时刻，只能由一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。  \n  \n使用 javap 工具分析 synchronized 关键字的实现细节，实例4-10：\n```java\npublic class Synchronized {\n    public static void main(String[] args) {\n        synchronized (Synchronized.class) {\n\n        }\n        m();\n    }\n\n    public static synchronized void m() {\n\n    }\n}\n```\n`javap -v Synchronized.class` :同步块的前面和后面分别有 monitorenter 和 monitorexit 指令，而同步方法依靠方法修饰符 ACC_SYNCHRONIZED 来完成。  \n其本质是对一个对象的监视器(monitor)进行获取，这个获取过程是排他的，即同一时刻只有一个线程获取到由 sychronized 所保护对象的监视器。  \n  \n任意一个对象都拥有自己的监视器，执行方法的线程必须先获取到该对象的监视器，没有获取到的线程将会阻塞在入口处，进入 BLOCKED 状态。  \n![][2]\n\n## 3.2 等待/通知机制\n\n一个线程修改了一个对象的值，另一个线程感知到了变化，进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程。前者是生产者，后者就是消费者。\n在功能上进行了解耦，“做什么”和“怎么做”。在 Java 实现类似的功能：  \n  \n简单的方法就是让消费者线程不断地循环检查变量是否符合预期，如下的消费者：\n```java\nwhile (value != desire) {\n    Thread.sleep(1000); // 防止过快的“无效”尝试\n}\ndoSomething();\n```\n存在的问题：\n1. 难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化。\n2. 难以降低开销。如果降低睡眠时间，比如休眠 1 毫秒，这样消费者能更加迅速地发生条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。\n\n可以通过等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在 Object ，方法和描述如下表所示：\n\n| 方法名称         | 描述                                                                                                        |\n| :---------------| :----------------------------------------------------------------------------------------------------------|\n| notyfy()        | 通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁                             |\n| notifyAll()     | 通知所有等待在该对象上的线程                                                                                   |\n| wait()          | 调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用 wait() 方法后，会释放对象的锁 |\n| wait(long)      | 超时等待一段时间，也就是等待长达 n 毫秒，如果没有通知就超时返回                                                    |\n| wait(long, int) | 对于超时时间更细粒度的控制，可以达到纳秒                                                                        |\n\n等待/通知机制，是指一个线程A 调用了对象O 的 wait() 方法进入等待状态，而另一个线程B 调用了对象O 的 notify() 或者 notifyAll() 方法，\n线程A 收到通知后从对象O 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的 wait() 和 notify()/notifyAll()\n的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。\n```java\npublic class WaitNotify {\n    static boolean flag = true;\n    static Object lock = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread waitThread = new Thread(new Wait(), \"WaitThread\");\n        waitThread.start();\n        Thread.sleep(1 * 1000);\n        Thread notifyThread = new Thread(new Notify(), \"NotifyThread\");\n        notifyThread.start();\n    }\n\n    static class Wait implements Runnable {\n\n        @Override\n        public void run() {\n            // 加锁，拥有 lock 的 Monitor\n            synchronized (lock) {\n                // 当条件不满足时，继续 wait ，同时释放了 lock 的锁\n                while (flag) {\n                    try {\n                        System.out.println(\"1\");\n                        System.out.println(Thread.currentThread() + \" flag is true. wait \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                        lock.wait();\n                        System.out.println(\"2\");\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                // 条件满足时，完成工作\n                System.out.println(Thread.currentThread() + \" flag is false. running \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n            }\n        }\n    }\n\n    static class Notify implements Runnable {\n\n        @Override\n        public void run() {\n            // 加锁，拥有 lock 的 Monitor\n            synchronized (lock) {\n                // 获取 lock 的锁，然后进行通知，通知时不会释放 lock 的锁\n                // 直到当前线程释放了 lock 后， WaitThread 才能从 wait 方法中返回\n                System.out.println(Thread.currentThread() + \" hold lock. notify \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                lock.notifyAll();\n                flag = false;\n                try {\n                    Thread.sleep(5 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            // 再次加锁\n            synchronized (lock) {\n                System.out.println(Thread.currentThread() + \" hold lock again. sleep \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                try {\n                    Thread.sleep(5 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## 3.3 Thread.join() 的使用\n\n如果一个线程A 执行了 thread.join() 语句，即：当前线程A 等待 thread 线程终止之后才从 thread.join() 返回。代码4-13如下：\n```java\npublic class Join {\n\n    public static void main(String[] args) {\n        Thread previous = Thread.currentThread();\n        for (int i = 0; i < 10; i++) {\n            // 每个线程拥有前一个线程的引用\n            Thread thread = new Thread(new Domino(previous), String.valueOf(i));\n            thread.start();\n            previous = thread;\n        }\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" terminate. \");\n    }\n\n    static class Domino implements Runnable {\n\n        private Thread thread;\n\n        public Domino(Thread thread) {\n            this.thread = thread;\n        }\n        @Override\n        public void run() {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \" terminate. \");\n        }\n    }\n}\n```\n\nThread.join() 源码大概是这样的结构：\n```java\n// 加锁当前线程对象\npublic final synchronized void join() throws InterruptedException {\n    // 条件不满足，继续等待\n    while(isAlive()) {\n        wait(0);\n    }\n    // 条件符合，方法返回\n}\n```\n逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑。\n\n## 3.4 ThreadLocal 的使用\n\n```java\npublic class Profiler {\n    // 第一次调用 get() 方法会进行初始化，每个线程只会执行一次\n    private static final ThreadLocal<Long> TIME_threadLocal = new ThreadLocal() {\n        @Override\n        protected Object initialValue() {\n            return System.currentTimeMillis();\n        }\n    };\n\n    public static final void begin() {\n        TIME_threadLocal.set(System.currentTimeMillis());\n    }\n    \n    public static final long end() {\n        return System.currentTimeMillis() - TIME_threadLocal.get();\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Profiler.begin();\n        Thread.sleep(1000);\n        System.out.println(\"Cost: \" + Profiler.end() + \" mills\");\n    }\n}\n```\n\n# 4 线程应用实例\n\n## 4.1 等待超时模式\n\n调用一个方法时等待一段时间，如果该方法能够在给定的时间段之内得到结果，那么将结果立即返回，反之，超时返回默认结果。  \n假设超时时间为 T ，那么在 now + T 之后就会超时。\n```java\npublic synchronized Object get(long t) {\n    long now = System.currentTimeMillis();\n    long future = now + t;\n    long remaining = t;\n    while (result == null && remaining > 0) {\n        wait(remaining);\n        remaining = future - System.currentTimeMillis();\n    }\n    return result;\n}\n```\n\n## 4.2 一个简单的数据库连接池示例\n\n主干代码：\n```java\npublic class ConnectionPool {\n    private LinkedList<Connection> pool = new LinkedList<>();\n\n    public ConnectionPool(int initialSize) {\n        if (initialSize > 0) {\n            for (int i = 0; i < initialSize; i++) {\n                pool.addLast(ConnectionDriver.createConnection());\n            }\n        }\n    }\n\n    public void releaseConnection(Connection connection) {\n        if (connection != null) {\n            synchronized (pool) {\n                pool.addLast(connection);\n                pool.notifyAll();\n            }\n        }\n    }\n\n    public Connection fetchConnection(long mills) throws InterruptedException {\n        synchronized (pool) {\n            if (mills <= 0) {\n                while (pool.isEmpty()) {\n                    pool.wait();\n                }\n                return pool.removeFirst();\n            } else {\n                long future = System.currentTimeMillis() + mills;\n                long remaining = mills;\n                while (pool.isEmpty() && remaining > 0) {\n                    pool.wait(remaining);\n                    remaining = future - System.currentTimeMillis();\n                }\n                Connection result = null;\n                if (!pool.isEmpty()) {\n                    result = pool.removeFirst();\n                }\n                return result;\n            }\n        }\n    }\n}\n```\n\n## 4.3 线程池技术\n\n主干代码：\n```java\npublic class DefaultThreadPool<Job extends Runnable> implements ThreadPool<Job> {\n\n    private static final int MAX_WORKER_NUMBERS = 10;\n    private static final int DEFAULT_WORKER_NUMBERS = 5;\n    private static final int MIN_WORK_NUMBERS = 1;\n\n    // 任务列表\n    private final LinkedList<Job> jobs = new LinkedList<>();\n\n    // 工作者列表，即保存着所有的消费者列表\n    private final List<Worker> workers = Collections.synchronizedList(new ArrayList<Worker>());\n\n    // 工作线程的数量\n    private int workerNum = DEFAULT_WORKER_NUMBERS;\n\n    // 线程编号\n    private int threadNum = 0;\n\n    @Override\n    public void execute(Job job) {\n        if (job != null) {\n            synchronized (jobs) {\n                jobs.addLast(job);\n                jobs.notify();\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        for (Worker worker : workers) {\n            worker.shutdown();\n        }\n    }\n\n    @Override\n    public void addWorkers(int num) {\n        synchronized (jobs) {\n            if (num + this.workerNum > MAX_WORKER_NUMBERS) {\n                num = MAX_WORKER_NUMBERS - this.workerNum;\n            }\n            initializeWorkers(num);\n            this.workerNum += num;\n        }\n    }\n\n    /**\n     *  移除工作线程，即移除消费者\n     */\n    @Override\n    public void removeWorker(int num) {\n        synchronized (jobs) {\n            if (num >= this.workerNum) {\n                throw new IllegalArgumentException(\"beyond workNum\");\n            }\n            int count = 0;\n            while (count < num) {\n                Worker worker = workers.get(count);\n                if (workers.remove(worker)) {\n                    worker.shutdown();\n                    count++;\n                }\n            }\n            this.workerNum -= count;\n        }\n    }\n\n    @Override\n    public int getJobSize() {\n        return jobs.size();\n    }\n\n    // 初始化工作者\n    private void initializeWorkers(int num) {\n        for (int i = 0; i < num; i++) {\n            Worker worker = new Worker();\n            workers.add(worker);\n            Thread thread = new Thread(worker, \"ThreadPool-Worker-\" + threadNum++);\n            thread.start();\n        }\n    }\n\n    // 工作者，即消费者，负责消费任务\n    class Worker implements Runnable {\n        // 允许外界控制是否停止\n        private volatile boolean running = true;\n\n        @Override\n        public void run() {\n            while (running) {\n                Job job = null;\n                synchronized (jobs) {\n                    while (jobs.isEmpty()) {\n                        try {\n                            jobs.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                    // 取出一个Job\n                    job = jobs.removeFirst();\n                }\n                if (job != null) {\n                    job.run();\n                }\n            }\n        }\n        public void shutdown() {\n            running = false;\n        }\n    }\n}\n```\n\n## 4.4 小结\n\n![][3]\n\n\n\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_3.png","source":"_posts/Java 并发编程的艺术/第四章 Java并发编程基础.md","raw":"---\ntitle: 四、Java并发编程基础\ndate: 2017-11-07 20:07:00\nupdated: 2017-11-07 20:07:00\ncomments: true\ncategories: \n- 读书笔记\n- Java并发编程的艺术\npermalink: concurrent-art/4.html    \n---\n\n# 1 线程简介\n\n## 1.1 什么是线程\n\n操作系统运行一个程序时，会为其创建一个进程。而操作系统调度的最小单元是线程，也叫轻量级进程（ Light Weight Process），\n在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。  \n处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。\n```java\npublic class MultiThread{\n    public static void main(String[] args) {\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n        for(ThreadInfo threadInfo : threadInfos) {\n            System.out.println(threadInfo.getThreadId() + \",\" + threadInfo.getThreadName());\n        }\n        /**\n         6,Monitor Ctrl-Break\n         5,Attach Listener\n         4,Signal Dispatcher\n         3,Finalizer\n         2,Reference Handler\n         1,main\n         */\n    } \n}\n```\n\n## 1.2 为什么要使用多线程\n\n### 1.2.1 更多的处理器核心\n\n程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器\n核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，\n就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。\n\n### 1.2.2 更快的响应时间\n\n编写一些较为复杂的代码，例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。这么多业务\n操作，如何能够让其更快地完成呢？\n\n### 1.2.3 更好的编程模型\n\nJava 为多线程编程提供了良好、考究并且一致的编程模型，使开发人员更加专注于问题的解决。\n\n## 1.3 线程优先级\n\n现代操作系统基于采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程\n调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器\n资源的线程属性。  \n  \n在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法\n来修改优先级，默认优先级是 5 ，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞的线程需要设置较高优先级，\n而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级。笔者在 JDK 1.8 的 WIN 10 环境：\n```java\npublic class Priority {\n\n    private static volatile boolean notStart = true;\n\n    private static volatile boolean notEnd = true;\n\n    public static void main(String[] args) throws InterruptedException {\n        List<Job> jobs = new ArrayList();\n        for (int i = 0; i < 10; i++) {\n            int priority = i < 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;\n            Job job = new Job(priority);\n            jobs.add(job);\n            Thread thread = new Thread(job, \"Thread:\" + i);\n            thread.setPriority(priority);\n            thread.start();\n        }\n        notStart = false;\n        TimeUnit.SECONDS.sleep(2);\n        notEnd = false;\n        for (Job job : jobs) {\n            System.out.println(\"Job Priority：\" + job.priority + \", Count：\" + job.jobCount);\n        }\n    }\n\n    static class Job implements Runnable {\n\n        private int priority;\n        private long jobCount;\n\n        public Job(int priority) {\n            this.priority = priority;\n        }\n\n        @Override\n        public void run() {\n            while (notStart) {\n                Thread.yield();\n            }\n            while (notEnd) {\n                Thread.yield();\n                jobCount++;\n            }\n        }\n    }\n}\n```\n输出：\n```java\nJob Priority：1, Count：16772\nJob Priority：1, Count：16761\nJob Priority：1, Count：16761\nJob Priority：1, Count：16758\nJob Priority：1, Count：16757\nJob Priority：10, Count：756747\nJob Priority：10, Count：757594\nJob Priority：10, Count：757263\nJob Priority：10, Count：759519\nJob Priority：10, Count：760287\n```\n\n## 1.4 线程的状态\n\n![][1]\n\n## 1.5 Daemon 线程\n\nDaemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候，\nJava 虚拟机将会退出。可以通过调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程。\n>Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置。\n\nDaemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行，如下：\n```java\npublic class Daemon {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new DaemonRunner(), \"DaemonRunner\");\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    static class DaemonRunner implements Runnable {\n\n        @Override\n        public void run() {\n            try {\n                SleepUtils.second(10);\n            } finally {\n                System.out.println(\"DaemonThread finally run.\");\n            }\n        }\n    }\n}\n```\n最终没有任何的输出，mian 线程在启动了线程 DaemonRunner 之后随着 main 方法执行完毕而终止，而此时 Java 虚拟机中已经灭有非 Daemon 线程，\n虚拟机需要退出。 Java 虚拟机中的所有 Daemon 线程都需要立即终止，因此 DaemonRunner 立即终止，但是 DaemonRunner 中的 finally 块并没有执行。\n\n# 2 启动和终止线程\n\n## 2.1 理解中断\n\n中断可以理解为线程的一个标识位属性，它标识一个运行中的线程是否被其它线程进行了中断操作。线程通过方法 `isInterrupted` 来进行判断是否被中断，\n也可以调用静态方法 `Thread.interrupted()` 对当前线程的中断标识位进行复位。下面的例子中，创建了两个线程， SleepThread 和 BusyThread ，\n前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。\n\n```java\npublic class Interrupted {\n    public static void main(String[] args) throws InterruptedException {\n        Thread sleepThread = new Thread(new SleepRunner(), \"SleepThread\");\n        sleepThread.setDaemon(true);\n\n        Thread busyThread = new Thread(new BusyRunner(), \"BusyThread\");\n        busyThread.setDaemon(true);\n\n        sleepThread.start();\n        busyThread.start();\n\n        Thread.sleep(5 * 1000);\n\n        sleepThread.interrupt();\n        busyThread.interrupt();\n\n        System.out.println(\"SleepThread interrupted is \" + sleepThread.isInterrupted());\n        System.out.println(\"BusyThread interrupted is \" + busyThread.isInterrupted());\n\n        Thread.sleep(2 * 1000);\n\n\n        System.out.println(\"SleepThread interrupted is \" + sleepThread.isInterrupted());\n        System.out.println(\"BusyThread interrupted is \" + busyThread.isInterrupted());\n        // SleepThread interrupted is false\n        // BusyThread interrupted is true\n        \n        Thread.sleep(2 * 1000);\n    }\n\n    static class SleepRunner implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    Thread.sleep(10 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class BusyRunner implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n            }\n        }\n    }\n}\n```\n线程 SleepThread 其中断标识位被清除了，而一直忙碌运作的线程 BusyThread ，其中断标识位没有被清除。\n\n## 2.2 安全地终止线程\n\n```java\npublic class Shutdown {\n    \n    public static void main(String[] args) throws InterruptedException {\n        Runner one = new Runner();\n        Thread countThread = new Thread(one, \"countThread\");\n        countThread.start();\n        \n        Thread.sleep(1 * 1000);\n        \n        countThread.interrupt();\n        \n        Runner two = new Runner();\n        countThread = new Thread(two, \"CountThread\");\n        countThread.start();\n        \n        Thread.sleep(1 * 1000);\n        \n        two.cancel();\n    }\n    \n    private static class Runner implements Runnable {\n        private long i ;\n        private volatile boolean on = true;\n        \n        @Override\n        public void run() {\n            while(on && !Thread.currentThread().isInterrupted()) {\n                i++;\n            }\n        }\n        \n        private void cancel() {\n            on = false;\n        }\n    }\n}\n```\n使用 `Thread.interrupted()` 或一个 boolean 来进行中断。\n\n# 3. 线程间通信\n\n## 3.1 volatile 和 synchronized 关键字\n\n每个执行的线程拥有一份拷贝，这样做的目的是加速程序的执行，所以程序在执行过程中，一个线程看到的变量并不一定是最新的。  \n  \n关键字 `volatile` 就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。  \n  \n举个例子：定义一个表示程序是否运行的成员变量 boolean on = true ，另一个线程可能执行了关闭动作 on = false ，这里涉及多个线程对变量的访问，\n因此需要定义称为 volatile boolean on = true ，这样其他线程对它改变时，所以线程都会感知，因为所有对 on　变量的访问和修改都需要以共享内存\n为准。  \n  \n关键字 synchronized 主要确保多个线程在同一时刻，只能由一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。  \n  \n使用 javap 工具分析 synchronized 关键字的实现细节，实例4-10：\n```java\npublic class Synchronized {\n    public static void main(String[] args) {\n        synchronized (Synchronized.class) {\n\n        }\n        m();\n    }\n\n    public static synchronized void m() {\n\n    }\n}\n```\n`javap -v Synchronized.class` :同步块的前面和后面分别有 monitorenter 和 monitorexit 指令，而同步方法依靠方法修饰符 ACC_SYNCHRONIZED 来完成。  \n其本质是对一个对象的监视器(monitor)进行获取，这个获取过程是排他的，即同一时刻只有一个线程获取到由 sychronized 所保护对象的监视器。  \n  \n任意一个对象都拥有自己的监视器，执行方法的线程必须先获取到该对象的监视器，没有获取到的线程将会阻塞在入口处，进入 BLOCKED 状态。  \n![][2]\n\n## 3.2 等待/通知机制\n\n一个线程修改了一个对象的值，另一个线程感知到了变化，进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程。前者是生产者，后者就是消费者。\n在功能上进行了解耦，“做什么”和“怎么做”。在 Java 实现类似的功能：  \n  \n简单的方法就是让消费者线程不断地循环检查变量是否符合预期，如下的消费者：\n```java\nwhile (value != desire) {\n    Thread.sleep(1000); // 防止过快的“无效”尝试\n}\ndoSomething();\n```\n存在的问题：\n1. 难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化。\n2. 难以降低开销。如果降低睡眠时间，比如休眠 1 毫秒，这样消费者能更加迅速地发生条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。\n\n可以通过等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在 Object ，方法和描述如下表所示：\n\n| 方法名称         | 描述                                                                                                        |\n| :---------------| :----------------------------------------------------------------------------------------------------------|\n| notyfy()        | 通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁                             |\n| notifyAll()     | 通知所有等待在该对象上的线程                                                                                   |\n| wait()          | 调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用 wait() 方法后，会释放对象的锁 |\n| wait(long)      | 超时等待一段时间，也就是等待长达 n 毫秒，如果没有通知就超时返回                                                    |\n| wait(long, int) | 对于超时时间更细粒度的控制，可以达到纳秒                                                                        |\n\n等待/通知机制，是指一个线程A 调用了对象O 的 wait() 方法进入等待状态，而另一个线程B 调用了对象O 的 notify() 或者 notifyAll() 方法，\n线程A 收到通知后从对象O 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的 wait() 和 notify()/notifyAll()\n的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。\n```java\npublic class WaitNotify {\n    static boolean flag = true;\n    static Object lock = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread waitThread = new Thread(new Wait(), \"WaitThread\");\n        waitThread.start();\n        Thread.sleep(1 * 1000);\n        Thread notifyThread = new Thread(new Notify(), \"NotifyThread\");\n        notifyThread.start();\n    }\n\n    static class Wait implements Runnable {\n\n        @Override\n        public void run() {\n            // 加锁，拥有 lock 的 Monitor\n            synchronized (lock) {\n                // 当条件不满足时，继续 wait ，同时释放了 lock 的锁\n                while (flag) {\n                    try {\n                        System.out.println(\"1\");\n                        System.out.println(Thread.currentThread() + \" flag is true. wait \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                        lock.wait();\n                        System.out.println(\"2\");\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                // 条件满足时，完成工作\n                System.out.println(Thread.currentThread() + \" flag is false. running \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n            }\n        }\n    }\n\n    static class Notify implements Runnable {\n\n        @Override\n        public void run() {\n            // 加锁，拥有 lock 的 Monitor\n            synchronized (lock) {\n                // 获取 lock 的锁，然后进行通知，通知时不会释放 lock 的锁\n                // 直到当前线程释放了 lock 后， WaitThread 才能从 wait 方法中返回\n                System.out.println(Thread.currentThread() + \" hold lock. notify \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                lock.notifyAll();\n                flag = false;\n                try {\n                    Thread.sleep(5 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            // 再次加锁\n            synchronized (lock) {\n                System.out.println(Thread.currentThread() + \" hold lock again. sleep \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                try {\n                    Thread.sleep(5 * 1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## 3.3 Thread.join() 的使用\n\n如果一个线程A 执行了 thread.join() 语句，即：当前线程A 等待 thread 线程终止之后才从 thread.join() 返回。代码4-13如下：\n```java\npublic class Join {\n\n    public static void main(String[] args) {\n        Thread previous = Thread.currentThread();\n        for (int i = 0; i < 10; i++) {\n            // 每个线程拥有前一个线程的引用\n            Thread thread = new Thread(new Domino(previous), String.valueOf(i));\n            thread.start();\n            previous = thread;\n        }\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" terminate. \");\n    }\n\n    static class Domino implements Runnable {\n\n        private Thread thread;\n\n        public Domino(Thread thread) {\n            this.thread = thread;\n        }\n        @Override\n        public void run() {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \" terminate. \");\n        }\n    }\n}\n```\n\nThread.join() 源码大概是这样的结构：\n```java\n// 加锁当前线程对象\npublic final synchronized void join() throws InterruptedException {\n    // 条件不满足，继续等待\n    while(isAlive()) {\n        wait(0);\n    }\n    // 条件符合，方法返回\n}\n```\n逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑。\n\n## 3.4 ThreadLocal 的使用\n\n```java\npublic class Profiler {\n    // 第一次调用 get() 方法会进行初始化，每个线程只会执行一次\n    private static final ThreadLocal<Long> TIME_threadLocal = new ThreadLocal() {\n        @Override\n        protected Object initialValue() {\n            return System.currentTimeMillis();\n        }\n    };\n\n    public static final void begin() {\n        TIME_threadLocal.set(System.currentTimeMillis());\n    }\n    \n    public static final long end() {\n        return System.currentTimeMillis() - TIME_threadLocal.get();\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Profiler.begin();\n        Thread.sleep(1000);\n        System.out.println(\"Cost: \" + Profiler.end() + \" mills\");\n    }\n}\n```\n\n# 4 线程应用实例\n\n## 4.1 等待超时模式\n\n调用一个方法时等待一段时间，如果该方法能够在给定的时间段之内得到结果，那么将结果立即返回，反之，超时返回默认结果。  \n假设超时时间为 T ，那么在 now + T 之后就会超时。\n```java\npublic synchronized Object get(long t) {\n    long now = System.currentTimeMillis();\n    long future = now + t;\n    long remaining = t;\n    while (result == null && remaining > 0) {\n        wait(remaining);\n        remaining = future - System.currentTimeMillis();\n    }\n    return result;\n}\n```\n\n## 4.2 一个简单的数据库连接池示例\n\n主干代码：\n```java\npublic class ConnectionPool {\n    private LinkedList<Connection> pool = new LinkedList<>();\n\n    public ConnectionPool(int initialSize) {\n        if (initialSize > 0) {\n            for (int i = 0; i < initialSize; i++) {\n                pool.addLast(ConnectionDriver.createConnection());\n            }\n        }\n    }\n\n    public void releaseConnection(Connection connection) {\n        if (connection != null) {\n            synchronized (pool) {\n                pool.addLast(connection);\n                pool.notifyAll();\n            }\n        }\n    }\n\n    public Connection fetchConnection(long mills) throws InterruptedException {\n        synchronized (pool) {\n            if (mills <= 0) {\n                while (pool.isEmpty()) {\n                    pool.wait();\n                }\n                return pool.removeFirst();\n            } else {\n                long future = System.currentTimeMillis() + mills;\n                long remaining = mills;\n                while (pool.isEmpty() && remaining > 0) {\n                    pool.wait(remaining);\n                    remaining = future - System.currentTimeMillis();\n                }\n                Connection result = null;\n                if (!pool.isEmpty()) {\n                    result = pool.removeFirst();\n                }\n                return result;\n            }\n        }\n    }\n}\n```\n\n## 4.3 线程池技术\n\n主干代码：\n```java\npublic class DefaultThreadPool<Job extends Runnable> implements ThreadPool<Job> {\n\n    private static final int MAX_WORKER_NUMBERS = 10;\n    private static final int DEFAULT_WORKER_NUMBERS = 5;\n    private static final int MIN_WORK_NUMBERS = 1;\n\n    // 任务列表\n    private final LinkedList<Job> jobs = new LinkedList<>();\n\n    // 工作者列表，即保存着所有的消费者列表\n    private final List<Worker> workers = Collections.synchronizedList(new ArrayList<Worker>());\n\n    // 工作线程的数量\n    private int workerNum = DEFAULT_WORKER_NUMBERS;\n\n    // 线程编号\n    private int threadNum = 0;\n\n    @Override\n    public void execute(Job job) {\n        if (job != null) {\n            synchronized (jobs) {\n                jobs.addLast(job);\n                jobs.notify();\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        for (Worker worker : workers) {\n            worker.shutdown();\n        }\n    }\n\n    @Override\n    public void addWorkers(int num) {\n        synchronized (jobs) {\n            if (num + this.workerNum > MAX_WORKER_NUMBERS) {\n                num = MAX_WORKER_NUMBERS - this.workerNum;\n            }\n            initializeWorkers(num);\n            this.workerNum += num;\n        }\n    }\n\n    /**\n     *  移除工作线程，即移除消费者\n     */\n    @Override\n    public void removeWorker(int num) {\n        synchronized (jobs) {\n            if (num >= this.workerNum) {\n                throw new IllegalArgumentException(\"beyond workNum\");\n            }\n            int count = 0;\n            while (count < num) {\n                Worker worker = workers.get(count);\n                if (workers.remove(worker)) {\n                    worker.shutdown();\n                    count++;\n                }\n            }\n            this.workerNum -= count;\n        }\n    }\n\n    @Override\n    public int getJobSize() {\n        return jobs.size();\n    }\n\n    // 初始化工作者\n    private void initializeWorkers(int num) {\n        for (int i = 0; i < num; i++) {\n            Worker worker = new Worker();\n            workers.add(worker);\n            Thread thread = new Thread(worker, \"ThreadPool-Worker-\" + threadNum++);\n            thread.start();\n        }\n    }\n\n    // 工作者，即消费者，负责消费任务\n    class Worker implements Runnable {\n        // 允许外界控制是否停止\n        private volatile boolean running = true;\n\n        @Override\n        public void run() {\n            while (running) {\n                Job job = null;\n                synchronized (jobs) {\n                    while (jobs.isEmpty()) {\n                        try {\n                            jobs.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                    }\n                    // 取出一个Job\n                    job = jobs.removeFirst();\n                }\n                if (job != null) {\n                    job.run();\n                }\n            }\n        }\n        public void shutdown() {\n            running = false;\n        }\n    }\n}\n```\n\n## 4.4 小结\n\n![][3]\n\n\n\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_3.png","slug":"concurrent-art/4.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaut000caxs6qhpfsyrr","content":"<h1 id=\"1-线程简介\"><a href=\"#1-线程简介\" class=\"headerlink\" title=\"1 线程简介\"></a>1 线程简介</h1><h2 id=\"1-1-什么是线程\"><a href=\"#1-1-什么是线程\" class=\"headerlink\" title=\"1.1 什么是线程\"></a>1.1 什么是线程</h2><p>操作系统运行一个程序时，会为其创建一个进程。而操作系统调度的最小单元是线程，也叫轻量级进程（ Light Weight Process），<br>在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。<br>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiThread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class=\"line\">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class=\"line\">            System.out.println(threadInfo.getThreadId() + <span class=\"string\">\",\"</span> + threadInfo.getThreadName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         6,Monitor Ctrl-Break</span></span><br><span class=\"line\"><span class=\"comment\">         5,Attach Listener</span></span><br><span class=\"line\"><span class=\"comment\">         4,Signal Dispatcher</span></span><br><span class=\"line\"><span class=\"comment\">         3,Finalizer</span></span><br><span class=\"line\"><span class=\"comment\">         2,Reference Handler</span></span><br><span class=\"line\"><span class=\"comment\">         1,main</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2-为什么要使用多线程\"><a href=\"#1-2-为什么要使用多线程\" class=\"headerlink\" title=\"1.2 为什么要使用多线程\"></a>1.2 为什么要使用多线程</h2><h3 id=\"1-2-1-更多的处理器核心\"><a href=\"#1-2-1-更多的处理器核心\" class=\"headerlink\" title=\"1.2.1 更多的处理器核心\"></a>1.2.1 更多的处理器核心</h3><p>程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器<br>核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，<br>就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>\n<h3 id=\"1-2-2-更快的响应时间\"><a href=\"#1-2-2-更快的响应时间\" class=\"headerlink\" title=\"1.2.2 更快的响应时间\"></a>1.2.2 更快的响应时间</h3><p>编写一些较为复杂的代码，例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。这么多业务<br>操作，如何能够让其更快地完成呢？</p>\n<h3 id=\"1-2-3-更好的编程模型\"><a href=\"#1-2-3-更好的编程模型\" class=\"headerlink\" title=\"1.2.3 更好的编程模型\"></a>1.2.3 更好的编程模型</h3><p>Java 为多线程编程提供了良好、考究并且一致的编程模型，使开发人员更加专注于问题的解决。</p>\n<h2 id=\"1-3-线程优先级\"><a href=\"#1-3-线程优先级\" class=\"headerlink\" title=\"1.3 线程优先级\"></a>1.3 线程优先级</h2><p>现代操作系统基于采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程<br>调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器<br>资源的线程属性。  </p>\n<p>在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法<br>来修改优先级，默认优先级是 5 ，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞的线程需要设置较高优先级，<br>而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级。笔者在 JDK 1.8 的 WIN 10 环境：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Priority</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> notStart = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> notEnd = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        List&lt;Job&gt; jobs = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> priority = i &lt; <span class=\"number\">5</span> ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</span><br><span class=\"line\">            Job job = <span class=\"keyword\">new</span> Job(priority);</span><br><span class=\"line\">            jobs.add(job);</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(job, <span class=\"string\">\"Thread:\"</span> + i);</span><br><span class=\"line\">            thread.setPriority(priority);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notStart = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        notEnd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Job job : jobs) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Job Priority：\"</span> + job.priority + <span class=\"string\">\", Count：\"</span> + job.jobCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Job</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> priority;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> jobCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Job</span><span class=\"params\">(<span class=\"keyword\">int</span> priority)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.priority = priority;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (notStart) &#123;</span><br><span class=\"line\">                Thread.yield();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (notEnd) &#123;</span><br><span class=\"line\">                Thread.yield();</span><br><span class=\"line\">                jobCount++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16772</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16761</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16761</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16758</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16757</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">756747</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">757594</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">757263</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">759519</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">760287</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-4-线程的状态\"><a href=\"#1-4-线程的状态\" class=\"headerlink\" title=\"1.4 线程的状态\"></a>1.4 线程的状态</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_1.png\" alt=\"\"></p>\n<h2 id=\"1-5-Daemon-线程\"><a href=\"#1-5-Daemon-线程\" class=\"headerlink\" title=\"1.5 Daemon 线程\"></a>1.5 Daemon 线程</h2><p>Daemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候，<br>Java 虚拟机将会退出。可以通过调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程。</p>\n<blockquote>\n<p>Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置。</p>\n</blockquote>\n<p>Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daemon</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> DaemonRunner(), <span class=\"string\">\"DaemonRunner\"</span>);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaemonRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                SleepUtils.second(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DaemonThread finally run.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终没有任何的输出，mian 线程在启动了线程 DaemonRunner 之后随着 main 方法执行完毕而终止，而此时 Java 虚拟机中已经灭有非 Daemon 线程，<br>虚拟机需要退出。 Java 虚拟机中的所有 Daemon 线程都需要立即终止，因此 DaemonRunner 立即终止，但是 DaemonRunner 中的 finally 块并没有执行。</p>\n<h1 id=\"2-启动和终止线程\"><a href=\"#2-启动和终止线程\" class=\"headerlink\" title=\"2 启动和终止线程\"></a>2 启动和终止线程</h1><h2 id=\"2-1-理解中断\"><a href=\"#2-1-理解中断\" class=\"headerlink\" title=\"2.1 理解中断\"></a>2.1 理解中断</h2><p>中断可以理解为线程的一个标识位属性，它标识一个运行中的线程是否被其它线程进行了中断操作。线程通过方法 <code>isInterrupted</code> 来进行判断是否被中断，<br>也可以调用静态方法 <code>Thread.interrupted()</code> 对当前线程的中断标识位进行复位。下面的例子中，创建了两个线程， SleepThread 和 BusyThread ，<br>前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interrupted</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread sleepThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> SleepRunner(), <span class=\"string\">\"SleepThread\"</span>);</span><br><span class=\"line\">        sleepThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread busyThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> BusyRunner(), <span class=\"string\">\"BusyThread\"</span>);</span><br><span class=\"line\">        busyThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        sleepThread.start();</span><br><span class=\"line\">        busyThread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        sleepThread.interrupt();</span><br><span class=\"line\">        busyThread.interrupt();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"SleepThread interrupted is \"</span> + sleepThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"BusyThread interrupted is \"</span> + busyThread.isInterrupted());</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"SleepThread interrupted is \"</span> + sleepThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"BusyThread interrupted is \"</span> + busyThread.isInterrupted());</span><br><span class=\"line\">        <span class=\"comment\">// SleepThread interrupted is false</span></span><br><span class=\"line\">        <span class=\"comment\">// BusyThread interrupted is true</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SleepRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BusyRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程 SleepThread 其中断标识位被清除了，而一直忙碌运作的线程 BusyThread ，其中断标识位没有被清除。</p>\n<h2 id=\"2-2-安全地终止线程\"><a href=\"#2-2-安全地终止线程\" class=\"headerlink\" title=\"2.2 安全地终止线程\"></a>2.2 安全地终止线程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shutdown</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Runner one = <span class=\"keyword\">new</span> Runner();</span><br><span class=\"line\">        Thread countThread = <span class=\"keyword\">new</span> Thread(one, <span class=\"string\">\"countThread\"</span>);</span><br><span class=\"line\">        countThread.start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        countThread.interrupt();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Runner two = <span class=\"keyword\">new</span> Runner();</span><br><span class=\"line\">        countThread = <span class=\"keyword\">new</span> Thread(two, <span class=\"string\">\"CountThread\"</span>);</span><br><span class=\"line\">        countThread.start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        two.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Runner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> i ;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> on = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            on = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>Thread.interrupted()</code> 或一个 boolean 来进行中断。</p>\n<h1 id=\"3-线程间通信\"><a href=\"#3-线程间通信\" class=\"headerlink\" title=\"3. 线程间通信\"></a>3. 线程间通信</h1><h2 id=\"3-1-volatile-和-synchronized-关键字\"><a href=\"#3-1-volatile-和-synchronized-关键字\" class=\"headerlink\" title=\"3.1 volatile 和 synchronized 关键字\"></a>3.1 volatile 和 synchronized 关键字</h2><p>每个执行的线程拥有一份拷贝，这样做的目的是加速程序的执行，所以程序在执行过程中，一个线程看到的变量并不一定是最新的。  </p>\n<p>关键字 <code>volatile</code> 就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。  </p>\n<p>举个例子：定义一个表示程序是否运行的成员变量 boolean on = true ，另一个线程可能执行了关闭动作 on = false ，这里涉及多个线程对变量的访问，<br>因此需要定义称为 volatile boolean on = true ，这样其他线程对它改变时，所以线程都会感知，因为所有对 on　变量的访问和修改都需要以共享内存<br>为准。  </p>\n<p>关键字 synchronized 主要确保多个线程在同一时刻，只能由一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。  </p>\n<p>使用 javap 工具分析 synchronized 关键字的实现细节，实例4-10：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Synchronized</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Synchronized.class) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">m</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>javap -v Synchronized.class</code> :同步块的前面和后面分别有 monitorenter 和 monitorexit 指令，而同步方法依靠方法修饰符 ACC_SYNCHRONIZED 来完成。<br>其本质是对一个对象的监视器(monitor)进行获取，这个获取过程是排他的，即同一时刻只有一个线程获取到由 sychronized 所保护对象的监视器。  </p>\n<p>任意一个对象都拥有自己的监视器，执行方法的线程必须先获取到该对象的监视器，没有获取到的线程将会阻塞在入口处，进入 BLOCKED 状态。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_2.png\" alt=\"\"></p>\n<h2 id=\"3-2-等待-通知机制\"><a href=\"#3-2-等待-通知机制\" class=\"headerlink\" title=\"3.2 等待/通知机制\"></a>3.2 等待/通知机制</h2><p>一个线程修改了一个对象的值，另一个线程感知到了变化，进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程。前者是生产者，后者就是消费者。<br>在功能上进行了解耦，“做什么”和“怎么做”。在 Java 实现类似的功能：  </p>\n<p>简单的方法就是让消费者线程不断地循环检查变量是否符合预期，如下的消费者：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (value != desire) &#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 防止过快的“无效”尝试</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething();</span><br></pre></td></tr></table></figure></p>\n<p>存在的问题：</p>\n<ol>\n<li>难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化。</li>\n<li>难以降低开销。如果降低睡眠时间，比如休眠 1 毫秒，这样消费者能更加迅速地发生条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</li>\n</ol>\n<p>可以通过等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在 Object ，方法和描述如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法名称</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">notyfy()</td>\n<td style=\"text-align:left\">通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">notifyAll()</td>\n<td style=\"text-align:left\">通知所有等待在该对象上的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wait()</td>\n<td style=\"text-align:left\">调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用 wait() 方法后，会释放对象的锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wait(long)</td>\n<td style=\"text-align:left\">超时等待一段时间，也就是等待长达 n 毫秒，如果没有通知就超时返回</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wait(long, int)</td>\n<td style=\"text-align:left\">对于超时时间更细粒度的控制，可以达到纳秒</td>\n</tr>\n</tbody>\n</table>\n<p>等待/通知机制，是指一个线程A 调用了对象O 的 wait() 方法进入等待状态，而另一个线程B 调用了对象O 的 notify() 或者 notifyAll() 方法，<br>线程A 收到通知后从对象O 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的 wait() 和 notify()/notifyAll()<br>的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitNotify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread waitThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Wait(), <span class=\"string\">\"WaitThread\"</span>);</span><br><span class=\"line\">        waitThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        Thread notifyThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Notify(), <span class=\"string\">\"NotifyThread\"</span>);</span><br><span class=\"line\">        notifyThread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wait</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 加锁，拥有 lock 的 Monitor</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当条件不满足时，继续 wait ，同时释放了 lock 的锁</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">                        System.out.println(Thread.currentThread() + <span class=\"string\">\" flag is true. wait \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                        lock.wait();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 条件满足时，完成工作</span></span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\" flag is false. running \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notify</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 加锁，拥有 lock 的 Monitor</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取 lock 的锁，然后进行通知，通知时不会释放 lock 的锁</span></span><br><span class=\"line\">                <span class=\"comment\">// 直到当前线程释放了 lock 后， WaitThread 才能从 wait 方法中返回</span></span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\" hold lock. notify \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                lock.notifyAll();</span><br><span class=\"line\">                flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 再次加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\" hold lock again. sleep \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-3-Thread-join-的使用\"><a href=\"#3-3-Thread-join-的使用\" class=\"headerlink\" title=\"3.3 Thread.join() 的使用\"></a>3.3 Thread.join() 的使用</h2><p>如果一个线程A 执行了 thread.join() 语句，即：当前线程A 等待 thread 线程终止之后才从 thread.join() 返回。代码4-13如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Join</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread previous = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每个线程拥有前一个线程的引用</span></span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Domino(previous), String.valueOf(i));</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            previous = thread;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" terminate. \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Domino</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Domino</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                thread.join();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" terminate. \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Thread.join() 源码大概是这样的结构：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加锁当前线程对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 条件不满足，继续等待</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(isAlive()) &#123;</span><br><span class=\"line\">        wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 条件符合，方法返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑。</p>\n<h2 id=\"3-4-ThreadLocal-的使用\"><a href=\"#3-4-ThreadLocal-的使用\" class=\"headerlink\" title=\"3.4 ThreadLocal 的使用\"></a>3.4 ThreadLocal 的使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Profiler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一次调用 get() 方法会进行初始化，每个线程只会执行一次</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Long&gt; TIME_threadLocal = <span class=\"keyword\">new</span> ThreadLocal() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> System.currentTimeMillis();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TIME_threadLocal.set(System.currentTimeMillis());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> System.currentTimeMillis() - TIME_threadLocal.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Profiler.begin();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Cost: \"</span> + Profiler.end() + <span class=\"string\">\" mills\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-线程应用实例\"><a href=\"#4-线程应用实例\" class=\"headerlink\" title=\"4 线程应用实例\"></a>4 线程应用实例</h1><h2 id=\"4-1-等待超时模式\"><a href=\"#4-1-等待超时模式\" class=\"headerlink\" title=\"4.1 等待超时模式\"></a>4.1 等待超时模式</h2><p>调用一个方法时等待一段时间，如果该方法能够在给定的时间段之内得到结果，那么将结果立即返回，反之，超时返回默认结果。<br>假设超时时间为 T ，那么在 now + T 之后就会超时。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Object <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> future = now + t;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> remaining = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (result == <span class=\"keyword\">null</span> &amp;&amp; remaining &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        wait(remaining);</span><br><span class=\"line\">        remaining = future - System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-2-一个简单的数据库连接池示例\"><a href=\"#4-2-一个简单的数据库连接池示例\" class=\"headerlink\" title=\"4.2 一个简单的数据库连接池示例\"></a>4.2 一个简单的数据库连接池示例</h2><p>主干代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnectionPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Connection&gt; pool = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnectionPool</span><span class=\"params\">(<span class=\"keyword\">int</span> initialSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class=\"line\">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">releaseConnection</span><span class=\"params\">(Connection connection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (pool) &#123;</span><br><span class=\"line\">                pool.addLast(connection);</span><br><span class=\"line\">                pool.notifyAll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">fetchConnection</span><span class=\"params\">(<span class=\"keyword\">long</span> mills)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (pool) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mills &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (pool.isEmpty()) &#123;</span><br><span class=\"line\">                    pool.wait();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> pool.removeFirst();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> future = System.currentTimeMillis() + mills;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> remaining = mills;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    pool.wait(remaining);</span><br><span class=\"line\">                    remaining = future - System.currentTimeMillis();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Connection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!pool.isEmpty()) &#123;</span><br><span class=\"line\">                    result = pool.removeFirst();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-线程池技术\"><a href=\"#4-3-线程池技术\" class=\"headerlink\" title=\"4.3 线程池技术\"></a>4.3 线程池技术</h2><p>主干代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultThreadPool</span>&lt;<span class=\"title\">Job</span> <span class=\"keyword\">extends</span> <span class=\"title\">Runnable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ThreadPool</span>&lt;<span class=\"title\">Job</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_WORKER_NUMBERS = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_WORKER_NUMBERS = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_WORK_NUMBERS = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 任务列表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedList&lt;Job&gt; jobs = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作者列表，即保存着所有的消费者列表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class=\"keyword\">new</span> ArrayList&lt;Worker&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作线程的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线程编号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Job job)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">                jobs.addLast(job);</span><br><span class=\"line\">                jobs.notify();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Worker worker : workers) &#123;</span><br><span class=\"line\">            worker.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorkers</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num + <span class=\"keyword\">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class=\"line\">                num = MAX_WORKER_NUMBERS - <span class=\"keyword\">this</span>.workerNum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            initializeWorkers(num);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.workerNum += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  移除工作线程，即移除消费者</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeWorker</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &gt;= <span class=\"keyword\">this</span>.workerNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"beyond workNum\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt; num) &#123;</span><br><span class=\"line\">                Worker worker = workers.get(count);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (workers.remove(worker)) &#123;</span><br><span class=\"line\">                    worker.shutdown();</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.workerNum -= count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getJobSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jobs.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化工作者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeWorkers</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">            Worker worker = <span class=\"keyword\">new</span> Worker();</span><br><span class=\"line\">            workers.add(worker);</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(worker, <span class=\"string\">\"ThreadPool-Worker-\"</span> + threadNum++);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作者，即消费者，负责消费任务</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 允许外界控制是否停止</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                Job job = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (jobs.isEmpty()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            jobs.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                            Thread.currentThread().interrupt();</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 取出一个Job</span></span><br><span class=\"line\">                    job = jobs.removeFirst();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    job.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            running = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-4-小结\"><a href=\"#4-4-小结\" class=\"headerlink\" title=\"4.4 小结\"></a>4.4 小结</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_3.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-线程简介\"><a href=\"#1-线程简介\" class=\"headerlink\" title=\"1 线程简介\"></a>1 线程简介</h1><h2 id=\"1-1-什么是线程\"><a href=\"#1-1-什么是线程\" class=\"headerlink\" title=\"1.1 什么是线程\"></a>1.1 什么是线程</h2><p>操作系统运行一个程序时，会为其创建一个进程。而操作系统调度的最小单元是线程，也叫轻量级进程（ Light Weight Process），<br>在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。<br>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiThread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class=\"line\">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class=\"line\">            System.out.println(threadInfo.getThreadId() + <span class=\"string\">\",\"</span> + threadInfo.getThreadName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         6,Monitor Ctrl-Break</span></span><br><span class=\"line\"><span class=\"comment\">         5,Attach Listener</span></span><br><span class=\"line\"><span class=\"comment\">         4,Signal Dispatcher</span></span><br><span class=\"line\"><span class=\"comment\">         3,Finalizer</span></span><br><span class=\"line\"><span class=\"comment\">         2,Reference Handler</span></span><br><span class=\"line\"><span class=\"comment\">         1,main</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2-为什么要使用多线程\"><a href=\"#1-2-为什么要使用多线程\" class=\"headerlink\" title=\"1.2 为什么要使用多线程\"></a>1.2 为什么要使用多线程</h2><h3 id=\"1-2-1-更多的处理器核心\"><a href=\"#1-2-1-更多的处理器核心\" class=\"headerlink\" title=\"1.2.1 更多的处理器核心\"></a>1.2.1 更多的处理器核心</h3><p>程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器<br>核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，<br>就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>\n<h3 id=\"1-2-2-更快的响应时间\"><a href=\"#1-2-2-更快的响应时间\" class=\"headerlink\" title=\"1.2.2 更快的响应时间\"></a>1.2.2 更快的响应时间</h3><p>编写一些较为复杂的代码，例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。这么多业务<br>操作，如何能够让其更快地完成呢？</p>\n<h3 id=\"1-2-3-更好的编程模型\"><a href=\"#1-2-3-更好的编程模型\" class=\"headerlink\" title=\"1.2.3 更好的编程模型\"></a>1.2.3 更好的编程模型</h3><p>Java 为多线程编程提供了良好、考究并且一致的编程模型，使开发人员更加专注于问题的解决。</p>\n<h2 id=\"1-3-线程优先级\"><a href=\"#1-3-线程优先级\" class=\"headerlink\" title=\"1.3 线程优先级\"></a>1.3 线程优先级</h2><p>现代操作系统基于采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程<br>调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器<br>资源的线程属性。  </p>\n<p>在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法<br>来修改优先级，默认优先级是 5 ，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞的线程需要设置较高优先级，<br>而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级。笔者在 JDK 1.8 的 WIN 10 环境：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Priority</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> notStart = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> notEnd = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        List&lt;Job&gt; jobs = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> priority = i &lt; <span class=\"number\">5</span> ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</span><br><span class=\"line\">            Job job = <span class=\"keyword\">new</span> Job(priority);</span><br><span class=\"line\">            jobs.add(job);</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(job, <span class=\"string\">\"Thread:\"</span> + i);</span><br><span class=\"line\">            thread.setPriority(priority);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        notStart = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        notEnd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Job job : jobs) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Job Priority：\"</span> + job.priority + <span class=\"string\">\", Count：\"</span> + job.jobCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Job</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> priority;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> jobCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Job</span><span class=\"params\">(<span class=\"keyword\">int</span> priority)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.priority = priority;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (notStart) &#123;</span><br><span class=\"line\">                Thread.yield();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (notEnd) &#123;</span><br><span class=\"line\">                Thread.yield();</span><br><span class=\"line\">                jobCount++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16772</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16761</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16761</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16758</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">1</span>, Count：<span class=\"number\">16757</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">756747</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">757594</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">757263</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">759519</span></span><br><span class=\"line\">Job Priority：<span class=\"number\">10</span>, Count：<span class=\"number\">760287</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-4-线程的状态\"><a href=\"#1-4-线程的状态\" class=\"headerlink\" title=\"1.4 线程的状态\"></a>1.4 线程的状态</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_1.png\" alt=\"\"></p>\n<h2 id=\"1-5-Daemon-线程\"><a href=\"#1-5-Daemon-线程\" class=\"headerlink\" title=\"1.5 Daemon 线程\"></a>1.5 Daemon 线程</h2><p>Daemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候，<br>Java 虚拟机将会退出。可以通过调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程。</p>\n<blockquote>\n<p>Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置。</p>\n</blockquote>\n<p>Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daemon</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> DaemonRunner(), <span class=\"string\">\"DaemonRunner\"</span>);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaemonRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                SleepUtils.second(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DaemonThread finally run.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终没有任何的输出，mian 线程在启动了线程 DaemonRunner 之后随着 main 方法执行完毕而终止，而此时 Java 虚拟机中已经灭有非 Daemon 线程，<br>虚拟机需要退出。 Java 虚拟机中的所有 Daemon 线程都需要立即终止，因此 DaemonRunner 立即终止，但是 DaemonRunner 中的 finally 块并没有执行。</p>\n<h1 id=\"2-启动和终止线程\"><a href=\"#2-启动和终止线程\" class=\"headerlink\" title=\"2 启动和终止线程\"></a>2 启动和终止线程</h1><h2 id=\"2-1-理解中断\"><a href=\"#2-1-理解中断\" class=\"headerlink\" title=\"2.1 理解中断\"></a>2.1 理解中断</h2><p>中断可以理解为线程的一个标识位属性，它标识一个运行中的线程是否被其它线程进行了中断操作。线程通过方法 <code>isInterrupted</code> 来进行判断是否被中断，<br>也可以调用静态方法 <code>Thread.interrupted()</code> 对当前线程的中断标识位进行复位。下面的例子中，创建了两个线程， SleepThread 和 BusyThread ，<br>前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interrupted</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread sleepThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> SleepRunner(), <span class=\"string\">\"SleepThread\"</span>);</span><br><span class=\"line\">        sleepThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread busyThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> BusyRunner(), <span class=\"string\">\"BusyThread\"</span>);</span><br><span class=\"line\">        busyThread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        sleepThread.start();</span><br><span class=\"line\">        busyThread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        sleepThread.interrupt();</span><br><span class=\"line\">        busyThread.interrupt();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"SleepThread interrupted is \"</span> + sleepThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"BusyThread interrupted is \"</span> + busyThread.isInterrupted());</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"SleepThread interrupted is \"</span> + sleepThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"BusyThread interrupted is \"</span> + busyThread.isInterrupted());</span><br><span class=\"line\">        <span class=\"comment\">// SleepThread interrupted is false</span></span><br><span class=\"line\">        <span class=\"comment\">// BusyThread interrupted is true</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SleepRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BusyRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程 SleepThread 其中断标识位被清除了，而一直忙碌运作的线程 BusyThread ，其中断标识位没有被清除。</p>\n<h2 id=\"2-2-安全地终止线程\"><a href=\"#2-2-安全地终止线程\" class=\"headerlink\" title=\"2.2 安全地终止线程\"></a>2.2 安全地终止线程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shutdown</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Runner one = <span class=\"keyword\">new</span> Runner();</span><br><span class=\"line\">        Thread countThread = <span class=\"keyword\">new</span> Thread(one, <span class=\"string\">\"countThread\"</span>);</span><br><span class=\"line\">        countThread.start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        countThread.interrupt();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Runner two = <span class=\"keyword\">new</span> Runner();</span><br><span class=\"line\">        countThread = <span class=\"keyword\">new</span> Thread(two, <span class=\"string\">\"CountThread\"</span>);</span><br><span class=\"line\">        countThread.start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        two.cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Runner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> i ;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> on = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            on = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>Thread.interrupted()</code> 或一个 boolean 来进行中断。</p>\n<h1 id=\"3-线程间通信\"><a href=\"#3-线程间通信\" class=\"headerlink\" title=\"3. 线程间通信\"></a>3. 线程间通信</h1><h2 id=\"3-1-volatile-和-synchronized-关键字\"><a href=\"#3-1-volatile-和-synchronized-关键字\" class=\"headerlink\" title=\"3.1 volatile 和 synchronized 关键字\"></a>3.1 volatile 和 synchronized 关键字</h2><p>每个执行的线程拥有一份拷贝，这样做的目的是加速程序的执行，所以程序在执行过程中，一个线程看到的变量并不一定是最新的。  </p>\n<p>关键字 <code>volatile</code> 就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。  </p>\n<p>举个例子：定义一个表示程序是否运行的成员变量 boolean on = true ，另一个线程可能执行了关闭动作 on = false ，这里涉及多个线程对变量的访问，<br>因此需要定义称为 volatile boolean on = true ，这样其他线程对它改变时，所以线程都会感知，因为所有对 on　变量的访问和修改都需要以共享内存<br>为准。  </p>\n<p>关键字 synchronized 主要确保多个线程在同一时刻，只能由一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。  </p>\n<p>使用 javap 工具分析 synchronized 关键字的实现细节，实例4-10：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Synchronized</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Synchronized.class) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">m</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>javap -v Synchronized.class</code> :同步块的前面和后面分别有 monitorenter 和 monitorexit 指令，而同步方法依靠方法修饰符 ACC_SYNCHRONIZED 来完成。<br>其本质是对一个对象的监视器(monitor)进行获取，这个获取过程是排他的，即同一时刻只有一个线程获取到由 sychronized 所保护对象的监视器。  </p>\n<p>任意一个对象都拥有自己的监视器，执行方法的线程必须先获取到该对象的监视器，没有获取到的线程将会阻塞在入口处，进入 BLOCKED 状态。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_2.png\" alt=\"\"></p>\n<h2 id=\"3-2-等待-通知机制\"><a href=\"#3-2-等待-通知机制\" class=\"headerlink\" title=\"3.2 等待/通知机制\"></a>3.2 等待/通知机制</h2><p>一个线程修改了一个对象的值，另一个线程感知到了变化，进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程。前者是生产者，后者就是消费者。<br>在功能上进行了解耦，“做什么”和“怎么做”。在 Java 实现类似的功能：  </p>\n<p>简单的方法就是让消费者线程不断地循环检查变量是否符合预期，如下的消费者：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (value != desire) &#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 防止过快的“无效”尝试</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething();</span><br></pre></td></tr></table></figure></p>\n<p>存在的问题：</p>\n<ol>\n<li>难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化。</li>\n<li>难以降低开销。如果降低睡眠时间，比如休眠 1 毫秒，这样消费者能更加迅速地发生条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</li>\n</ol>\n<p>可以通过等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在 Object ，方法和描述如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法名称</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">notyfy()</td>\n<td style=\"text-align:left\">通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">notifyAll()</td>\n<td style=\"text-align:left\">通知所有等待在该对象上的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wait()</td>\n<td style=\"text-align:left\">调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用 wait() 方法后，会释放对象的锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wait(long)</td>\n<td style=\"text-align:left\">超时等待一段时间，也就是等待长达 n 毫秒，如果没有通知就超时返回</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wait(long, int)</td>\n<td style=\"text-align:left\">对于超时时间更细粒度的控制，可以达到纳秒</td>\n</tr>\n</tbody>\n</table>\n<p>等待/通知机制，是指一个线程A 调用了对象O 的 wait() 方法进入等待状态，而另一个线程B 调用了对象O 的 notify() 或者 notifyAll() 方法，<br>线程A 收到通知后从对象O 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的 wait() 和 notify()/notifyAll()<br>的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitNotify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread waitThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Wait(), <span class=\"string\">\"WaitThread\"</span>);</span><br><span class=\"line\">        waitThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        Thread notifyThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Notify(), <span class=\"string\">\"NotifyThread\"</span>);</span><br><span class=\"line\">        notifyThread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wait</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 加锁，拥有 lock 的 Monitor</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当条件不满足时，继续 wait ，同时释放了 lock 的锁</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">                        System.out.println(Thread.currentThread() + <span class=\"string\">\" flag is true. wait \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                        lock.wait();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 条件满足时，完成工作</span></span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\" flag is false. running \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notify</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 加锁，拥有 lock 的 Monitor</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取 lock 的锁，然后进行通知，通知时不会释放 lock 的锁</span></span><br><span class=\"line\">                <span class=\"comment\">// 直到当前线程释放了 lock 后， WaitThread 才能从 wait 方法中返回</span></span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\" hold lock. notify \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                lock.notifyAll();</span><br><span class=\"line\">                flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 再次加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\" hold lock again. sleep \"</span> + <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"HH:mm:ss\"</span>).format(<span class=\"keyword\">new</span> Date()));</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-3-Thread-join-的使用\"><a href=\"#3-3-Thread-join-的使用\" class=\"headerlink\" title=\"3.3 Thread.join() 的使用\"></a>3.3 Thread.join() 的使用</h2><p>如果一个线程A 执行了 thread.join() 语句，即：当前线程A 等待 thread 线程终止之后才从 thread.join() 返回。代码4-13如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Join</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread previous = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每个线程拥有前一个线程的引用</span></span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Domino(previous), String.valueOf(i));</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            previous = thread;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" terminate. \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Domino</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Domino</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                thread.join();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" terminate. \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Thread.join() 源码大概是这样的结构：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加锁当前线程对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 条件不满足，继续等待</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(isAlive()) &#123;</span><br><span class=\"line\">        wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 条件符合，方法返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑。</p>\n<h2 id=\"3-4-ThreadLocal-的使用\"><a href=\"#3-4-ThreadLocal-的使用\" class=\"headerlink\" title=\"3.4 ThreadLocal 的使用\"></a>3.4 ThreadLocal 的使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Profiler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一次调用 get() 方法会进行初始化，每个线程只会执行一次</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Long&gt; TIME_threadLocal = <span class=\"keyword\">new</span> ThreadLocal() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> System.currentTimeMillis();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TIME_threadLocal.set(System.currentTimeMillis());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> System.currentTimeMillis() - TIME_threadLocal.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Profiler.begin();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Cost: \"</span> + Profiler.end() + <span class=\"string\">\" mills\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-线程应用实例\"><a href=\"#4-线程应用实例\" class=\"headerlink\" title=\"4 线程应用实例\"></a>4 线程应用实例</h1><h2 id=\"4-1-等待超时模式\"><a href=\"#4-1-等待超时模式\" class=\"headerlink\" title=\"4.1 等待超时模式\"></a>4.1 等待超时模式</h2><p>调用一个方法时等待一段时间，如果该方法能够在给定的时间段之内得到结果，那么将结果立即返回，反之，超时返回默认结果。<br>假设超时时间为 T ，那么在 now + T 之后就会超时。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Object <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> future = now + t;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> remaining = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (result == <span class=\"keyword\">null</span> &amp;&amp; remaining &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        wait(remaining);</span><br><span class=\"line\">        remaining = future - System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-2-一个简单的数据库连接池示例\"><a href=\"#4-2-一个简单的数据库连接池示例\" class=\"headerlink\" title=\"4.2 一个简单的数据库连接池示例\"></a>4.2 一个简单的数据库连接池示例</h2><p>主干代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConnectionPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Connection&gt; pool = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConnectionPool</span><span class=\"params\">(<span class=\"keyword\">int</span> initialSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class=\"line\">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">releaseConnection</span><span class=\"params\">(Connection connection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (pool) &#123;</span><br><span class=\"line\">                pool.addLast(connection);</span><br><span class=\"line\">                pool.notifyAll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">fetchConnection</span><span class=\"params\">(<span class=\"keyword\">long</span> mills)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (pool) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mills &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (pool.isEmpty()) &#123;</span><br><span class=\"line\">                    pool.wait();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> pool.removeFirst();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> future = System.currentTimeMillis() + mills;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> remaining = mills;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    pool.wait(remaining);</span><br><span class=\"line\">                    remaining = future - System.currentTimeMillis();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Connection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!pool.isEmpty()) &#123;</span><br><span class=\"line\">                    result = pool.removeFirst();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-线程池技术\"><a href=\"#4-3-线程池技术\" class=\"headerlink\" title=\"4.3 线程池技术\"></a>4.3 线程池技术</h2><p>主干代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultThreadPool</span>&lt;<span class=\"title\">Job</span> <span class=\"keyword\">extends</span> <span class=\"title\">Runnable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ThreadPool</span>&lt;<span class=\"title\">Job</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_WORKER_NUMBERS = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_WORKER_NUMBERS = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_WORK_NUMBERS = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 任务列表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedList&lt;Job&gt; jobs = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作者列表，即保存着所有的消费者列表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class=\"keyword\">new</span> ArrayList&lt;Worker&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作线程的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线程编号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Job job)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">                jobs.addLast(job);</span><br><span class=\"line\">                jobs.notify();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Worker worker : workers) &#123;</span><br><span class=\"line\">            worker.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorkers</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num + <span class=\"keyword\">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class=\"line\">                num = MAX_WORKER_NUMBERS - <span class=\"keyword\">this</span>.workerNum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            initializeWorkers(num);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.workerNum += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  移除工作线程，即移除消费者</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeWorker</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &gt;= <span class=\"keyword\">this</span>.workerNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"beyond workNum\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt; num) &#123;</span><br><span class=\"line\">                Worker worker = workers.get(count);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (workers.remove(worker)) &#123;</span><br><span class=\"line\">                    worker.shutdown();</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.workerNum -= count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getJobSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jobs.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化工作者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializeWorkers</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">            Worker worker = <span class=\"keyword\">new</span> Worker();</span><br><span class=\"line\">            workers.add(worker);</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(worker, <span class=\"string\">\"ThreadPool-Worker-\"</span> + threadNum++);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作者，即消费者，负责消费任务</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 允许外界控制是否停止</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                Job job = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (jobs) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (jobs.isEmpty()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            jobs.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                            Thread.currentThread().interrupt();</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 取出一个Job</span></span><br><span class=\"line\">                    job = jobs.removeFirst();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    job.run();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            running = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-4-小结\"><a href=\"#4-4-小结\" class=\"headerlink\" title=\"4.4 小结\"></a>4.4 小结</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_3.png\" alt=\"\"></p>\n"},{"title":"二、shell 脚本","date":"2018-05-16T15:51:00.000Z","updated":"2018-05-16T15:51:00.000Z","comments":1,"_content":"\n## 13 参考\n\n第十一章 构建基本脚本：http://www.suoniao.com/article/15930","source":"_posts/Linux命令行与shell脚本编程大全/第二部分 shell 脚本.md","raw":"---\ntitle: 二、shell 脚本\ndate: 2018-05-16 23:51:00\nupdated: 2018-05-16 23:51:00\ncomments: true\ncategories: \n- 读书笔记\n- Linux命令行与shell脚本编程大全\npermalink: linux_cli_shell/2.html    \n---\n\n## 13 参考\n\n第十一章 构建基本脚本：http://www.suoniao.com/article/15930","slug":"linux_cli_shell/2.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauu000daxs6rlep4kzu","content":"<h2 id=\"13-参考\"><a href=\"#13-参考\" class=\"headerlink\" title=\"13 参考\"></a>13 参考</h2><p>第十一章 构建基本脚本：<a href=\"http://www.suoniao.com/article/15930\" target=\"_blank\" rel=\"noopener\">http://www.suoniao.com/article/15930</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"13-参考\"><a href=\"#13-参考\" class=\"headerlink\" title=\"13 参考\"></a>13 参考</h2><p>第十一章 构建基本脚本：<a href=\"http://www.suoniao.com/article/15930\" target=\"_blank\" rel=\"noopener\">http://www.suoniao.com/article/15930</a></p>\n"},{"title":"ConcurrentHashMap","date":"2018-04-12T15:00:00.000Z","updated":"2018-04-12T17:00:00.000Z","comments":1,"_content":"\n# java7 的 ConcurrentHashMap\n\n在构造函数就初始化了 Segment  \n使用 Segment 可重入分段锁 + 链表结构的 HashEntry\n\n## Segment\n\n ```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable {\n\n        private static final long serialVersionUID = 2249069246763182397L;\n        // 如果是多处理器则是 64，否则是 1 次\n        static final int MAX_SCAN_RETRIES =\n            Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;\n\n        final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            // put 的时候，通过 scanAndLockForPut 自旋锁，for 循环 64/1 次尝试获取锁，如果一直没获取到，则 lock() 将自己挂起，然后等待 put 完之后的 unlock() 将自己唤醒\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n                unlock();\n            }\n            return oldValue;\n        }\n}\npublic int size() {\n        final Segment<K,V>[] segments = this.segments;\n        int size;\n        boolean overflow; \n        long sum;         \n        long last = 0L;   \n        int retries = -1;\n        try {\n            // 获取 size 时，先进行三次无锁 CAS 的合并计算，如果前后两次相同则返回结果，如果前后两次都不一样则再对每个 Segment 加锁后获取 size 进行合并\n            for (;;) {\n                if (retries++ == RETRIES_BEFORE_LOCK) {\n                    for (int j = 0; j < segments.length; ++j)\n                        ensureSegment(j).lock();\n                }\n                sum = 0L;\n                size = 0;\n                overflow = false;\n                for (int j = 0; j < segments.length; ++j) {\n                    Segment<K,V> seg = segmentAt(segments, j);\n                    if (seg != null) {\n                        sum += seg.modCount;\n                        int c = seg.count;\n                        if (c < 0 || (size += c) < 0)\n                            overflow = true;\n                    }\n                }\n                if (sum == last)\n                    break;\n                last = sum;\n            }\n        } finally {\n            if (retries > RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    segmentAt(segments, j).unlock();\n            }\n        }\n        return overflow ? Integer.MAX_VALUE : size;\n    }\n ```\n\n # java8 的 ConcurrentHashMap\n\n在 put 的时候构造 Node  \n使用 Node + CAS + Synchronized\n\n## Node\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node<K,V> next;\n    /**\n     * Virtualized support for map.get(); overridden in subclasses.\n     */\n    Node<K,V> find(int h, Object k) {\n        Node<K,V> e = this;\n        if (k != null) {\n            do {\n                K ek;\n                if (e.hash == h &&\n                    ((ek = e.key) == k || (ek != null && k.equals(ek))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n        return null;\n    }\n}\n\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\n/** Implementation for put and putIfAbsent */\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 初始化 Node\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果该 Node 节点未初始化则通过 CAS 插入数据\n            if (casTabAt(tab, i, null,\n                            new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            // 如果该 Node 下有数据，进行链表插入则使用 synchronized\n            V oldVal = null;\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                    (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                            value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 如果该节点是红黑树结构\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                        value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                // 判断该链表长度是否是 8 ，进行红黑树处理\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // 通过 binCount 判断是否是插入新数据还是更新数据，来更新数据 size baseCount\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n获取 size 通过 baseCount 和 CounterCell 数组。其中每次 put 都会进行更新 baseCount 和 CounterCell，但是对其中不懂。\n\n# 总\n\n分段锁虽然好，但是获取 size 复杂  \n在 jdk7 中：\n1. put 先采用 64 次自旋锁，获取不到再进行挂起自己等待 put 完唤醒  \n2. size() 则是采用三次尝试无锁操作，如果 size 不一致才对每个 Segment 加锁获取 size\n\n在 jdk8 中：\n1. put \b如果是新数据则使用 CAS \b插入，如果是链表已有数据则使用 synchronized，如果一个 Node 链表超过 8 个就会变成红黑树，避免了 HashDos 攻击，最后统计 size\n2. size() 直接获取 size\n\n参考：https://www.jianshu.com/p/e694f1e868ec\n","source":"_posts/Java 拾遗/1_ConcurrentHashMap.md","raw":"---\ntitle: ConcurrentHashMap\ndate: 2018-04-12 23:00:00\nupdated: 2018-04-13 01:00:00\ncomments: true\ncategories: \n- Java 拾遗\npermalink: A2B_Java/1_ConcurrentHashMap.html    \n---\n\n# java7 的 ConcurrentHashMap\n\n在构造函数就初始化了 Segment  \n使用 Segment 可重入分段锁 + 链表结构的 HashEntry\n\n## Segment\n\n ```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable {\n\n        private static final long serialVersionUID = 2249069246763182397L;\n        // 如果是多处理器则是 64，否则是 1 次\n        static final int MAX_SCAN_RETRIES =\n            Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;\n\n        final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            // put 的时候，通过 scanAndLockForPut 自旋锁，for 循环 64/1 次尝试获取锁，如果一直没获取到，则 lock() 将自己挂起，然后等待 put 完之后的 unlock() 将自己唤醒\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n                unlock();\n            }\n            return oldValue;\n        }\n}\npublic int size() {\n        final Segment<K,V>[] segments = this.segments;\n        int size;\n        boolean overflow; \n        long sum;         \n        long last = 0L;   \n        int retries = -1;\n        try {\n            // 获取 size 时，先进行三次无锁 CAS 的合并计算，如果前后两次相同则返回结果，如果前后两次都不一样则再对每个 Segment 加锁后获取 size 进行合并\n            for (;;) {\n                if (retries++ == RETRIES_BEFORE_LOCK) {\n                    for (int j = 0; j < segments.length; ++j)\n                        ensureSegment(j).lock();\n                }\n                sum = 0L;\n                size = 0;\n                overflow = false;\n                for (int j = 0; j < segments.length; ++j) {\n                    Segment<K,V> seg = segmentAt(segments, j);\n                    if (seg != null) {\n                        sum += seg.modCount;\n                        int c = seg.count;\n                        if (c < 0 || (size += c) < 0)\n                            overflow = true;\n                    }\n                }\n                if (sum == last)\n                    break;\n                last = sum;\n            }\n        } finally {\n            if (retries > RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    segmentAt(segments, j).unlock();\n            }\n        }\n        return overflow ? Integer.MAX_VALUE : size;\n    }\n ```\n\n # java8 的 ConcurrentHashMap\n\n在 put 的时候构造 Node  \n使用 Node + CAS + Synchronized\n\n## Node\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node<K,V> next;\n    /**\n     * Virtualized support for map.get(); overridden in subclasses.\n     */\n    Node<K,V> find(int h, Object k) {\n        Node<K,V> e = this;\n        if (k != null) {\n            do {\n                K ek;\n                if (e.hash == h &&\n                    ((ek = e.key) == k || (ek != null && k.equals(ek))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n        return null;\n    }\n}\n\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\n/** Implementation for put and putIfAbsent */\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 初始化 Node\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果该 Node 节点未初始化则通过 CAS 插入数据\n            if (casTabAt(tab, i, null,\n                            new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            // 如果该 Node 下有数据，进行链表插入则使用 synchronized\n            V oldVal = null;\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                    (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                            value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 如果该节点是红黑树结构\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                        value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                // 判断该链表长度是否是 8 ，进行红黑树处理\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // 通过 binCount 判断是否是插入新数据还是更新数据，来更新数据 size baseCount\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n获取 size 通过 baseCount 和 CounterCell 数组。其中每次 put 都会进行更新 baseCount 和 CounterCell，但是对其中不懂。\n\n# 总\n\n分段锁虽然好，但是获取 size 复杂  \n在 jdk7 中：\n1. put 先采用 64 次自旋锁，获取不到再进行挂起自己等待 put 完唤醒  \n2. size() 则是采用三次尝试无锁操作，如果 size 不一致才对每个 Segment 加锁获取 size\n\n在 jdk8 中：\n1. put \b如果是新数据则使用 CAS \b插入，如果是链表已有数据则使用 synchronized，如果一个 Node 链表超过 8 个就会变成红黑树，避免了 HashDos 攻击，最后统计 size\n2. size() 直接获取 size\n\n参考：https://www.jianshu.com/p/e694f1e868ec\n","slug":"A2B_Java/1_ConcurrentHashMap.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauw000faxs6tgg6oq3o","content":"<h1 id=\"java7-的-ConcurrentHashMap\"><a href=\"#java7-的-ConcurrentHashMap\" class=\"headerlink\" title=\"java7 的 ConcurrentHashMap\"></a>java7 的 ConcurrentHashMap</h1><p>在构造函数就初始化了 Segment<br>使用 Segment 可重入分段锁 + 链表结构的 HashEntry</p>\n<h2 id=\"Segment\"><a href=\"#Segment\" class=\"headerlink\" title=\"Segment\"></a>Segment</h2> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2249069246763182397L</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是多处理器则是 64，否则是 1 次</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_SCAN_RETRIES =</span><br><span class=\"line\">            Runtime.getRuntime().availableProcessors() &gt; <span class=\"number\">1</span> ? <span class=\"number\">64</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// put 的时候，通过 scanAndLockForPut 自旋锁，for 循环 64/1 次尝试获取锁，如果一直没获取到，则 lock() 将自己挂起，然后等待 put 完之后的 unlock() 将自己唤醒</span></span><br><span class=\"line\">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class=\"keyword\">null</span> :</span><br><span class=\"line\">                scanAndLockForPut(key, hash, value);</span><br><span class=\"line\">            V oldValue;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = (tab.length - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        K k;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((k = e.key) == key ||</span><br><span class=\"line\">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class=\"line\">                            oldValue = e.value;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent) &#123;</span><br><span class=\"line\">                                e.value = value;</span><br><span class=\"line\">                                ++modCount;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        e = e.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            node.setNext(first);</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            node = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> c = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">                            rehash(node);</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            setEntryAt(tab, index, node);</span><br><span class=\"line\">                        ++modCount;</span><br><span class=\"line\">                        count = c;</span><br><span class=\"line\">                        oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments = <span class=\"keyword\">this</span>.segments;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> overflow; </span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum;         </span><br><span class=\"line\">        <span class=\"keyword\">long</span> last = <span class=\"number\">0L</span>;   </span><br><span class=\"line\">        <span class=\"keyword\">int</span> retries = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取 size 时，先进行三次无锁 CAS 的合并计算，如果前后两次相同则返回结果，如果前后两次都不一样则再对每个 Segment 加锁后获取 size 进行合并</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                        ensureSegment(j).lock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sum = <span class=\"number\">0L</span>;</span><br><span class=\"line\">                size = <span class=\"number\">0</span>;</span><br><span class=\"line\">                overflow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class=\"line\">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (seg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        sum += seg.modCount;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> c = seg.count;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span> || (size += c) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                            overflow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum == last)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                last = sum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                    segmentAt(segments, j).unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"java8-的-ConcurrentHashMap\"><a href=\"#java8-的-ConcurrentHashMap\" class=\"headerlink\" title=\"java8 的 ConcurrentHashMap\"></a>java8 的 ConcurrentHashMap</h1><p>在 put 的时候构造 Node<br>使用 Node + CAS + Synchronized</p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> V val;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node&lt;K,V&gt; next;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                K ek;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                    ((ek = e.key) == k || (ek != <span class=\"keyword\">null</span> &amp;&amp; k.equals(ek))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Implementation for put and putIfAbsent */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化 Node</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果该 Node 节点未初始化则通过 CAS 插入数据</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果该 Node 下有数据，进行链表插入则使用 synchronized</span></span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                    (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                            value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果该节点是红黑树结构</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                        value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 判断该链表长度是否是 8 ，进行红黑树处理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 binCount 判断是否是插入新数据还是更新数据，来更新数据 size baseCount</span></span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取 size 通过 baseCount 和 CounterCell 数组。其中每次 put 都会进行更新 baseCount 和 CounterCell，但是对其中不懂。</p>\n<h1 id=\"总\"><a href=\"#总\" class=\"headerlink\" title=\"总\"></a>总</h1><p>分段锁虽然好，但是获取 size 复杂<br>在 jdk7 中：</p>\n<ol>\n<li>put 先采用 64 次自旋锁，获取不到再进行挂起自己等待 put 完唤醒  </li>\n<li>size() 则是采用三次尝试无锁操作，如果 size 不一致才对每个 Segment 加锁获取 size</li>\n</ol>\n<p>在 jdk8 中：</p>\n<ol>\n<li>put \b如果是新数据则使用 CAS \b插入，如果是链表已有数据则使用 synchronized，如果一个 Node 链表超过 8 个就会变成红黑树，避免了 HashDos 攻击，最后统计 size</li>\n<li>size() 直接获取 size</li>\n</ol>\n<p>参考：<a href=\"https://www.jianshu.com/p/e694f1e868ec\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e694f1e868ec</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"java7-的-ConcurrentHashMap\"><a href=\"#java7-的-ConcurrentHashMap\" class=\"headerlink\" title=\"java7 的 ConcurrentHashMap\"></a>java7 的 ConcurrentHashMap</h1><p>在构造函数就初始化了 Segment<br>使用 Segment 可重入分段锁 + 链表结构的 HashEntry</p>\n<h2 id=\"Segment\"><a href=\"#Segment\" class=\"headerlink\" title=\"Segment\"></a>Segment</h2> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Segment</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2249069246763182397L</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是多处理器则是 64，否则是 1 次</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_SCAN_RETRIES =</span><br><span class=\"line\">            Runtime.getRuntime().availableProcessors() &gt; <span class=\"number\">1</span> ? <span class=\"number\">64</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// put 的时候，通过 scanAndLockForPut 自旋锁，for 循环 64/1 次尝试获取锁，如果一直没获取到，则 lock() 将自己挂起，然后等待 put 完之后的 unlock() 将自己唤醒</span></span><br><span class=\"line\">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class=\"keyword\">null</span> :</span><br><span class=\"line\">                scanAndLockForPut(key, hash, value);</span><br><span class=\"line\">            V oldValue;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = (tab.length - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        K k;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((k = e.key) == key ||</span><br><span class=\"line\">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class=\"line\">                            oldValue = e.value;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent) &#123;</span><br><span class=\"line\">                                e.value = value;</span><br><span class=\"line\">                                ++modCount;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        e = e.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            node.setNext(first);</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            node = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> c = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">                            rehash(node);</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            setEntryAt(tab, index, node);</span><br><span class=\"line\">                        ++modCount;</span><br><span class=\"line\">                        count = c;</span><br><span class=\"line\">                        oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments = <span class=\"keyword\">this</span>.segments;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> overflow; </span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum;         </span><br><span class=\"line\">        <span class=\"keyword\">long</span> last = <span class=\"number\">0L</span>;   </span><br><span class=\"line\">        <span class=\"keyword\">int</span> retries = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取 size 时，先进行三次无锁 CAS 的合并计算，如果前后两次相同则返回结果，如果前后两次都不一样则再对每个 Segment 加锁后获取 size 进行合并</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                        ensureSegment(j).lock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sum = <span class=\"number\">0L</span>;</span><br><span class=\"line\">                size = <span class=\"number\">0</span>;</span><br><span class=\"line\">                overflow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class=\"line\">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (seg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        sum += seg.modCount;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> c = seg.count;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span> || (size += c) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                            overflow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum == last)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                last = sum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                    segmentAt(segments, j).unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"java8-的-ConcurrentHashMap\"><a href=\"#java8-的-ConcurrentHashMap\" class=\"headerlink\" title=\"java8 的 ConcurrentHashMap\"></a>java8 的 ConcurrentHashMap</h1><p>在 put 的时候构造 Node<br>使用 Node + CAS + Synchronized</p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> V val;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node&lt;K,V&gt; next;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                K ek;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                    ((ek = e.key) == k || (ek != <span class=\"keyword\">null</span> &amp;&amp; k.equals(ek))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Implementation for put and putIfAbsent */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化 Node</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果该 Node 节点未初始化则通过 CAS 插入数据</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果该 Node 下有数据，进行链表插入则使用 synchronized</span></span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                    (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                            value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果该节点是红黑树结构</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                        value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 判断该链表长度是否是 8 ，进行红黑树处理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 binCount 判断是否是插入新数据还是更新数据，来更新数据 size baseCount</span></span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取 size 通过 baseCount 和 CounterCell 数组。其中每次 put 都会进行更新 baseCount 和 CounterCell，但是对其中不懂。</p>\n<h1 id=\"总\"><a href=\"#总\" class=\"headerlink\" title=\"总\"></a>总</h1><p>分段锁虽然好，但是获取 size 复杂<br>在 jdk7 中：</p>\n<ol>\n<li>put 先采用 64 次自旋锁，获取不到再进行挂起自己等待 put 完唤醒  </li>\n<li>size() 则是采用三次尝试无锁操作，如果 size 不一致才对每个 Segment 加锁获取 size</li>\n</ol>\n<p>在 jdk8 中：</p>\n<ol>\n<li>put \b如果是新数据则使用 CAS \b插入，如果是链表已有数据则使用 synchronized，如果一个 Node 链表超过 8 个就会变成红黑树，避免了 HashDos 攻击，最后统计 size</li>\n<li>size() 直接获取 size</li>\n</ol>\n<p>参考：<a href=\"https://www.jianshu.com/p/e694f1e868ec\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e694f1e868ec</a></p>\n"},{"title":"一、bash shell 命令","date":"2018-05-16T15:51:00.000Z","updated":"2018-05-16T15:51:00.000Z","comments":1,"_content":"\n### 1. bash 手册\n\n用于查看命令的具体详情\n\nman xxx\n\n## 2. ls 文件和目录列表\n\n-a 显示隐藏文件  \n文件名支持 `*？` 符号过滤  \n\n### 3. 处理文件\n\n-i 询问参数  \ntouch  \ncp file1 file2：复制文件。参数 -R 用于递归复制文件  \nmv file1 file2：移动文件\nrm file1：删除文件，文件名支持`?*`\n\n### 4. 处理目录\n\nmkdir：创建目录。-p 创建多个目录和子目录  \nrmdir：删除空目录\nrm -rf：递归删除，-r 递归遍历，-f 删除不提示\n\n### 5. 查看文件内容\n\nfile file1：获取文件的类型  \ncat file1：显示文本所有内容，参数 -n 加上行数，参数 -b 只给有内容的行加行数  \nmore file1：  \nless file1：  \ntail file1：参数 -f，动态查看文件内容\n\n### 6. 检测程序\n\nps： -ef  \ntop：实时检测，q 退出  \nkill PID：-9 参数强制  \nkillall Name：关闭进程名，可以使用通配符\n\n### 7. 检测磁盘空间\n\nmount：挂载媒体的  \nunmount：移除可移动设备  \nsort file：文件排序  \ngrep pattern file：在 file 文件中查找 pattern 的行。-v 参数反向搜索  \ngzip/gunzip：压缩解压文件\ntar：-A 追加归档，-x 提取文件\n\n### 8. 理解 shell\n\n&：将任务置入后台模式  \nwhich 命令：查看命令的对应路径  \nhistory：最近的使用过的命令列表  \n\n### 9. 使用Linux环境变量\n\n查看环境全局变量：printenv/env  \n查看环境局部变量：set  \nexport：将一个局部变量的key导出到全局环境中  \n\n### 10. 管理文件系统\n\n1. ext 文件系统：单文件不能超过2GB。\n2. ext2 文件系统：保存更多信息。\n3. 日志文件系统：先将数据直接写入存储设备再更新索引节点表->文件的更改写入到临时文件中，数据成功写到存储设备和索引节点表后再删除对应的日志条目。\n4. ext3 文件系统：在 ext2 基础上，给每个存储设备增加了一个日志文件。\n5. ext4 文件系统。\n\n### 11. 安装软件程序\n\n1. Debian（Ubuntu）：dpkg 命令。\n2. Red Hat：rpm 命令。yum 命令。\n\n### 12. 使用编辑器\n\nvim  \nnano  \nemacs\n\n## 13. 参考\n\n1. 初识Linux shell：http://www.ituring.com.cn/book/tupubarticle/11430\n2. 走进shell：http://www.ituring.com.cn/book/tupubarticle/11431\n3. 基本的bash shell命令：http://www.ituring.com.cn/book/tupubarticle/11432\n4. 更多的bash shell命令： http://www.th7.cn/system/lin/201704/210752.shtml\n5. 理解shell：http://www.th7.cn/system/lin/201704/211006.shtml\n6. 使用Linux环境变量：http://www.voidcn.com/article/p-vizgjbtx-bmq.html\n7. 理解Linux文件权限：http://www.voidcn.com/article/p-whblgnni-bmq.html\n8. 管理文件系统：https://www.aliyun.com/jiaocheng/123749.html\n9. 安装软件程序：https://www.aliyun.com/jiaocheng/123748.html\n10. 使用编辑器：http://www.voidcn.com/article/p-fokuslvn-bnt.html\n","source":"_posts/Linux命令行与shell脚本编程大全/第一部分 bash shell 命令.md","raw":"---\ntitle: 一、bash shell 命令\ndate: 2018-05-16 23:51:00\nupdated: 2018-05-16 23:51:00\ncomments: true\ncategories: \n- 读书笔记\n- Linux命令行与shell脚本编程大全\npermalink: linux_cli_shell/1.html    \n---\n\n### 1. bash 手册\n\n用于查看命令的具体详情\n\nman xxx\n\n## 2. ls 文件和目录列表\n\n-a 显示隐藏文件  \n文件名支持 `*？` 符号过滤  \n\n### 3. 处理文件\n\n-i 询问参数  \ntouch  \ncp file1 file2：复制文件。参数 -R 用于递归复制文件  \nmv file1 file2：移动文件\nrm file1：删除文件，文件名支持`?*`\n\n### 4. 处理目录\n\nmkdir：创建目录。-p 创建多个目录和子目录  \nrmdir：删除空目录\nrm -rf：递归删除，-r 递归遍历，-f 删除不提示\n\n### 5. 查看文件内容\n\nfile file1：获取文件的类型  \ncat file1：显示文本所有内容，参数 -n 加上行数，参数 -b 只给有内容的行加行数  \nmore file1：  \nless file1：  \ntail file1：参数 -f，动态查看文件内容\n\n### 6. 检测程序\n\nps： -ef  \ntop：实时检测，q 退出  \nkill PID：-9 参数强制  \nkillall Name：关闭进程名，可以使用通配符\n\n### 7. 检测磁盘空间\n\nmount：挂载媒体的  \nunmount：移除可移动设备  \nsort file：文件排序  \ngrep pattern file：在 file 文件中查找 pattern 的行。-v 参数反向搜索  \ngzip/gunzip：压缩解压文件\ntar：-A 追加归档，-x 提取文件\n\n### 8. 理解 shell\n\n&：将任务置入后台模式  \nwhich 命令：查看命令的对应路径  \nhistory：最近的使用过的命令列表  \n\n### 9. 使用Linux环境变量\n\n查看环境全局变量：printenv/env  \n查看环境局部变量：set  \nexport：将一个局部变量的key导出到全局环境中  \n\n### 10. 管理文件系统\n\n1. ext 文件系统：单文件不能超过2GB。\n2. ext2 文件系统：保存更多信息。\n3. 日志文件系统：先将数据直接写入存储设备再更新索引节点表->文件的更改写入到临时文件中，数据成功写到存储设备和索引节点表后再删除对应的日志条目。\n4. ext3 文件系统：在 ext2 基础上，给每个存储设备增加了一个日志文件。\n5. ext4 文件系统。\n\n### 11. 安装软件程序\n\n1. Debian（Ubuntu）：dpkg 命令。\n2. Red Hat：rpm 命令。yum 命令。\n\n### 12. 使用编辑器\n\nvim  \nnano  \nemacs\n\n## 13. 参考\n\n1. 初识Linux shell：http://www.ituring.com.cn/book/tupubarticle/11430\n2. 走进shell：http://www.ituring.com.cn/book/tupubarticle/11431\n3. 基本的bash shell命令：http://www.ituring.com.cn/book/tupubarticle/11432\n4. 更多的bash shell命令： http://www.th7.cn/system/lin/201704/210752.shtml\n5. 理解shell：http://www.th7.cn/system/lin/201704/211006.shtml\n6. 使用Linux环境变量：http://www.voidcn.com/article/p-vizgjbtx-bmq.html\n7. 理解Linux文件权限：http://www.voidcn.com/article/p-whblgnni-bmq.html\n8. 管理文件系统：https://www.aliyun.com/jiaocheng/123749.html\n9. 安装软件程序：https://www.aliyun.com/jiaocheng/123748.html\n10. 使用编辑器：http://www.voidcn.com/article/p-fokuslvn-bnt.html\n","slug":"linux_cli_shell/1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaux000gaxs6948v6aq2","content":"<h3 id=\"1-bash-手册\"><a href=\"#1-bash-手册\" class=\"headerlink\" title=\"1. bash 手册\"></a>1. bash 手册</h3><p>用于查看命令的具体详情</p>\n<p>man xxx</p>\n<h2 id=\"2-ls-文件和目录列表\"><a href=\"#2-ls-文件和目录列表\" class=\"headerlink\" title=\"2. ls 文件和目录列表\"></a>2. ls 文件和目录列表</h2><p>-a 显示隐藏文件<br>文件名支持 <code>*？</code> 符号过滤  </p>\n<h3 id=\"3-处理文件\"><a href=\"#3-处理文件\" class=\"headerlink\" title=\"3. 处理文件\"></a>3. 处理文件</h3><p>-i 询问参数<br>touch<br>cp file1 file2：复制文件。参数 -R 用于递归复制文件<br>mv file1 file2：移动文件<br>rm file1：删除文件，文件名支持<code>?*</code></p>\n<h3 id=\"4-处理目录\"><a href=\"#4-处理目录\" class=\"headerlink\" title=\"4. 处理目录\"></a>4. 处理目录</h3><p>mkdir：创建目录。-p 创建多个目录和子目录<br>rmdir：删除空目录<br>rm -rf：递归删除，-r 递归遍历，-f 删除不提示</p>\n<h3 id=\"5-查看文件内容\"><a href=\"#5-查看文件内容\" class=\"headerlink\" title=\"5. 查看文件内容\"></a>5. 查看文件内容</h3><p>file file1：获取文件的类型<br>cat file1：显示文本所有内容，参数 -n 加上行数，参数 -b 只给有内容的行加行数<br>more file1：<br>less file1：<br>tail file1：参数 -f，动态查看文件内容</p>\n<h3 id=\"6-检测程序\"><a href=\"#6-检测程序\" class=\"headerlink\" title=\"6. 检测程序\"></a>6. 检测程序</h3><p>ps： -ef<br>top：实时检测，q 退出<br>kill PID：-9 参数强制<br>killall Name：关闭进程名，可以使用通配符</p>\n<h3 id=\"7-检测磁盘空间\"><a href=\"#7-检测磁盘空间\" class=\"headerlink\" title=\"7. 检测磁盘空间\"></a>7. 检测磁盘空间</h3><p>mount：挂载媒体的<br>unmount：移除可移动设备<br>sort file：文件排序<br>grep pattern file：在 file 文件中查找 pattern 的行。-v 参数反向搜索<br>gzip/gunzip：压缩解压文件<br>tar：-A 追加归档，-x 提取文件</p>\n<h3 id=\"8-理解-shell\"><a href=\"#8-理解-shell\" class=\"headerlink\" title=\"8. 理解 shell\"></a>8. 理解 shell</h3><p>&amp;：将任务置入后台模式<br>which 命令：查看命令的对应路径<br>history：最近的使用过的命令列表  </p>\n<h3 id=\"9-使用Linux环境变量\"><a href=\"#9-使用Linux环境变量\" class=\"headerlink\" title=\"9. 使用Linux环境变量\"></a>9. 使用Linux环境变量</h3><p>查看环境全局变量：printenv/env<br>查看环境局部变量：set<br>export：将一个局部变量的key导出到全局环境中  </p>\n<h3 id=\"10-管理文件系统\"><a href=\"#10-管理文件系统\" class=\"headerlink\" title=\"10. 管理文件系统\"></a>10. 管理文件系统</h3><ol>\n<li>ext 文件系统：单文件不能超过2GB。</li>\n<li>ext2 文件系统：保存更多信息。</li>\n<li>日志文件系统：先将数据直接写入存储设备再更新索引节点表-&gt;文件的更改写入到临时文件中，数据成功写到存储设备和索引节点表后再删除对应的日志条目。</li>\n<li>ext3 文件系统：在 ext2 基础上，给每个存储设备增加了一个日志文件。</li>\n<li>ext4 文件系统。</li>\n</ol>\n<h3 id=\"11-安装软件程序\"><a href=\"#11-安装软件程序\" class=\"headerlink\" title=\"11. 安装软件程序\"></a>11. 安装软件程序</h3><ol>\n<li>Debian（Ubuntu）：dpkg 命令。</li>\n<li>Red Hat：rpm 命令。yum 命令。</li>\n</ol>\n<h3 id=\"12-使用编辑器\"><a href=\"#12-使用编辑器\" class=\"headerlink\" title=\"12. 使用编辑器\"></a>12. 使用编辑器</h3><p>vim<br>nano<br>emacs</p>\n<h2 id=\"13-参考\"><a href=\"#13-参考\" class=\"headerlink\" title=\"13. 参考\"></a>13. 参考</h2><ol>\n<li>初识Linux shell：<a href=\"http://www.ituring.com.cn/book/tupubarticle/11430\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/tupubarticle/11430</a></li>\n<li>走进shell：<a href=\"http://www.ituring.com.cn/book/tupubarticle/11431\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/tupubarticle/11431</a></li>\n<li>基本的bash shell命令：<a href=\"http://www.ituring.com.cn/book/tupubarticle/11432\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/tupubarticle/11432</a></li>\n<li>更多的bash shell命令： <a href=\"http://www.th7.cn/system/lin/201704/210752.shtml\" target=\"_blank\" rel=\"noopener\">http://www.th7.cn/system/lin/201704/210752.shtml</a></li>\n<li>理解shell：<a href=\"http://www.th7.cn/system/lin/201704/211006.shtml\" target=\"_blank\" rel=\"noopener\">http://www.th7.cn/system/lin/201704/211006.shtml</a></li>\n<li>使用Linux环境变量：<a href=\"http://www.voidcn.com/article/p-vizgjbtx-bmq.html\" target=\"_blank\" rel=\"noopener\">http://www.voidcn.com/article/p-vizgjbtx-bmq.html</a></li>\n<li>理解Linux文件权限：<a href=\"http://www.voidcn.com/article/p-whblgnni-bmq.html\" target=\"_blank\" rel=\"noopener\">http://www.voidcn.com/article/p-whblgnni-bmq.html</a></li>\n<li>管理文件系统：<a href=\"https://www.aliyun.com/jiaocheng/123749.html\" target=\"_blank\" rel=\"noopener\">https://www.aliyun.com/jiaocheng/123749.html</a></li>\n<li>安装软件程序：<a href=\"https://www.aliyun.com/jiaocheng/123748.html\" target=\"_blank\" rel=\"noopener\">https://www.aliyun.com/jiaocheng/123748.html</a></li>\n<li>使用编辑器：<a href=\"http://www.voidcn.com/article/p-fokuslvn-bnt.html\" target=\"_blank\" rel=\"noopener\">http://www.voidcn.com/article/p-fokuslvn-bnt.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-bash-手册\"><a href=\"#1-bash-手册\" class=\"headerlink\" title=\"1. bash 手册\"></a>1. bash 手册</h3><p>用于查看命令的具体详情</p>\n<p>man xxx</p>\n<h2 id=\"2-ls-文件和目录列表\"><a href=\"#2-ls-文件和目录列表\" class=\"headerlink\" title=\"2. ls 文件和目录列表\"></a>2. ls 文件和目录列表</h2><p>-a 显示隐藏文件<br>文件名支持 <code>*？</code> 符号过滤  </p>\n<h3 id=\"3-处理文件\"><a href=\"#3-处理文件\" class=\"headerlink\" title=\"3. 处理文件\"></a>3. 处理文件</h3><p>-i 询问参数<br>touch<br>cp file1 file2：复制文件。参数 -R 用于递归复制文件<br>mv file1 file2：移动文件<br>rm file1：删除文件，文件名支持<code>?*</code></p>\n<h3 id=\"4-处理目录\"><a href=\"#4-处理目录\" class=\"headerlink\" title=\"4. 处理目录\"></a>4. 处理目录</h3><p>mkdir：创建目录。-p 创建多个目录和子目录<br>rmdir：删除空目录<br>rm -rf：递归删除，-r 递归遍历，-f 删除不提示</p>\n<h3 id=\"5-查看文件内容\"><a href=\"#5-查看文件内容\" class=\"headerlink\" title=\"5. 查看文件内容\"></a>5. 查看文件内容</h3><p>file file1：获取文件的类型<br>cat file1：显示文本所有内容，参数 -n 加上行数，参数 -b 只给有内容的行加行数<br>more file1：<br>less file1：<br>tail file1：参数 -f，动态查看文件内容</p>\n<h3 id=\"6-检测程序\"><a href=\"#6-检测程序\" class=\"headerlink\" title=\"6. 检测程序\"></a>6. 检测程序</h3><p>ps： -ef<br>top：实时检测，q 退出<br>kill PID：-9 参数强制<br>killall Name：关闭进程名，可以使用通配符</p>\n<h3 id=\"7-检测磁盘空间\"><a href=\"#7-检测磁盘空间\" class=\"headerlink\" title=\"7. 检测磁盘空间\"></a>7. 检测磁盘空间</h3><p>mount：挂载媒体的<br>unmount：移除可移动设备<br>sort file：文件排序<br>grep pattern file：在 file 文件中查找 pattern 的行。-v 参数反向搜索<br>gzip/gunzip：压缩解压文件<br>tar：-A 追加归档，-x 提取文件</p>\n<h3 id=\"8-理解-shell\"><a href=\"#8-理解-shell\" class=\"headerlink\" title=\"8. 理解 shell\"></a>8. 理解 shell</h3><p>&amp;：将任务置入后台模式<br>which 命令：查看命令的对应路径<br>history：最近的使用过的命令列表  </p>\n<h3 id=\"9-使用Linux环境变量\"><a href=\"#9-使用Linux环境变量\" class=\"headerlink\" title=\"9. 使用Linux环境变量\"></a>9. 使用Linux环境变量</h3><p>查看环境全局变量：printenv/env<br>查看环境局部变量：set<br>export：将一个局部变量的key导出到全局环境中  </p>\n<h3 id=\"10-管理文件系统\"><a href=\"#10-管理文件系统\" class=\"headerlink\" title=\"10. 管理文件系统\"></a>10. 管理文件系统</h3><ol>\n<li>ext 文件系统：单文件不能超过2GB。</li>\n<li>ext2 文件系统：保存更多信息。</li>\n<li>日志文件系统：先将数据直接写入存储设备再更新索引节点表-&gt;文件的更改写入到临时文件中，数据成功写到存储设备和索引节点表后再删除对应的日志条目。</li>\n<li>ext3 文件系统：在 ext2 基础上，给每个存储设备增加了一个日志文件。</li>\n<li>ext4 文件系统。</li>\n</ol>\n<h3 id=\"11-安装软件程序\"><a href=\"#11-安装软件程序\" class=\"headerlink\" title=\"11. 安装软件程序\"></a>11. 安装软件程序</h3><ol>\n<li>Debian（Ubuntu）：dpkg 命令。</li>\n<li>Red Hat：rpm 命令。yum 命令。</li>\n</ol>\n<h3 id=\"12-使用编辑器\"><a href=\"#12-使用编辑器\" class=\"headerlink\" title=\"12. 使用编辑器\"></a>12. 使用编辑器</h3><p>vim<br>nano<br>emacs</p>\n<h2 id=\"13-参考\"><a href=\"#13-参考\" class=\"headerlink\" title=\"13. 参考\"></a>13. 参考</h2><ol>\n<li>初识Linux shell：<a href=\"http://www.ituring.com.cn/book/tupubarticle/11430\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/tupubarticle/11430</a></li>\n<li>走进shell：<a href=\"http://www.ituring.com.cn/book/tupubarticle/11431\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/tupubarticle/11431</a></li>\n<li>基本的bash shell命令：<a href=\"http://www.ituring.com.cn/book/tupubarticle/11432\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/tupubarticle/11432</a></li>\n<li>更多的bash shell命令： <a href=\"http://www.th7.cn/system/lin/201704/210752.shtml\" target=\"_blank\" rel=\"noopener\">http://www.th7.cn/system/lin/201704/210752.shtml</a></li>\n<li>理解shell：<a href=\"http://www.th7.cn/system/lin/201704/211006.shtml\" target=\"_blank\" rel=\"noopener\">http://www.th7.cn/system/lin/201704/211006.shtml</a></li>\n<li>使用Linux环境变量：<a href=\"http://www.voidcn.com/article/p-vizgjbtx-bmq.html\" target=\"_blank\" rel=\"noopener\">http://www.voidcn.com/article/p-vizgjbtx-bmq.html</a></li>\n<li>理解Linux文件权限：<a href=\"http://www.voidcn.com/article/p-whblgnni-bmq.html\" target=\"_blank\" rel=\"noopener\">http://www.voidcn.com/article/p-whblgnni-bmq.html</a></li>\n<li>管理文件系统：<a href=\"https://www.aliyun.com/jiaocheng/123749.html\" target=\"_blank\" rel=\"noopener\">https://www.aliyun.com/jiaocheng/123749.html</a></li>\n<li>安装软件程序：<a href=\"https://www.aliyun.com/jiaocheng/123748.html\" target=\"_blank\" rel=\"noopener\">https://www.aliyun.com/jiaocheng/123748.html</a></li>\n<li>使用编辑器：<a href=\"http://www.voidcn.com/article/p-fokuslvn-bnt.html\" target=\"_blank\" rel=\"noopener\">http://www.voidcn.com/article/p-fokuslvn-bnt.html</a></li>\n</ol>\n"},{"title":"Servlet_Filter_Listener","date":"2018-04-12T15:00:00.000Z","updated":"2018-04-12T17:00:00.000Z","comments":1,"_content":"\n# 1. web.xml 的加载顺序\n\nServletContext -> context-param -> listener -> filter -> servlet。  \n前面的两个用于在 web.xml 设置变量，重要的是后面三个，即 Listener、Filter、Servlet，为 javaweb 的三大组件。\n\n# 2. Listener\n\n1. ServletContext 的监听器：ServletContextListener\n2. HttpSession 的监听器：HttpSessionListener\n3. ServletRequest 的监听器：ServletRequestListener\n\n>其中 Spring MVC 中 web.xml 常见配置的  \n>`org.springframework.web.context.request.RequestContextListener` 就是实现了 `ServletRequestListener` 用于监听每次请求。  \n>`org.springframework.web.context.ContextLoaderListener` 就是实现了 `ServletContextListener` 用于监听 ServletContext 的创建（即容器的启动），进而初始化 Spring 容器。\n\n# 3. Filter\n\n1. Filter 和 Servlet 类似也有三个生命周期方法，init、doFilter、destroy 三个。  \n2. Filter 是对多个请求进行拦截处理放行的，可以有多个 Filter。  \n3. 如果某个请求匹配到了多个过滤器，则根据 filter-mapping 的顺序进行过滤\n\n> 其中 Spring MVC 中 web.xml 常见配置的 `org.springframework.web.filter.CharacterEncodingFilter` 就是实现了 `Filter` 用于每次过滤的字符编码设置\n\n# 4. Servlet\n\n1. Servlet 用于处理客户端匹配的请求，获取请求，处理请求，返回响应。\n2. 三个生命周期方法，init、service、destroy。\n3. `<load-on-startup>` 如果是非负整数或零时，Servlet 容器先加载数值小的 servlet；如果是负数则 Servlet 容器将在首次访问时加载（懒汉模式）。\n4. Servlet 属于单例，多个请求可能会请求同一个 Servlet，即一个类只有一个对象，类由我们编写并写入 web.xml 配置中，但对象由容器创建，由容器调用相应的方法。\n\n> 其中 Spring MVC 中 web.xml 常见配置的 `org.springframework.web.servlet.DispatcherServlet` 就是继承了 `HttpServlet` 用于每次用户的请求。\n\n# 5. Spring 容器启动\n\n下面是 web.xml 的常见配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n         id=\"WebApp_ID\" version=\"2.5\">\n\n    <display-name>Archetype Created Web Application</display-name>\n\n    <filter>\n        <filter-name>characterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>characterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n\n    <listener>\n        <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>\n    </listener>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n            classpath:applicationContext.xml\n        </param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n```\n1. 创建 ServletContext 上下文并将 `context-param` 属性写入此上下文。\n2. 执行 `ContextLoaderListener` 将 Spring 的上下文 `WebApplicationContext` 写入 ServletContext 用于 Servlet 容器共享，接着读取 context-param 节点（已经被加载了）的 `contextConfigLocation` 解析 xml 并创建 Spring 容器和初始化。\n3. 执行 `CharacterEncodingFilter` 过滤器设置相应设置，用于以后的每次请求。\n4. 执行 `DispatcherServlet` \b用于 Servlet 的创建（根据 load-on-startup）。\n\n# 6. 参考\n\n三大组件参考：https://blog.csdn.net/xiaojie119120/article/details/73274759  \nSpring 容器启动参考：https://blog.csdn.net/u013510838/article/details/75066884\n\n","source":"_posts/Java 拾遗/2_Servlet_Filter_Listener.md","raw":"---\ntitle: Servlet_Filter_Listener\ndate: 2018-04-12 23:00:00\nupdated: 2018-04-13 01:00:00\ncomments: true\ncategories: \n- Java 拾遗\npermalink: A2B_Java/2_Servlet_Filter_Listener.html    \n---\n\n# 1. web.xml 的加载顺序\n\nServletContext -> context-param -> listener -> filter -> servlet。  \n前面的两个用于在 web.xml 设置变量，重要的是后面三个，即 Listener、Filter、Servlet，为 javaweb 的三大组件。\n\n# 2. Listener\n\n1. ServletContext 的监听器：ServletContextListener\n2. HttpSession 的监听器：HttpSessionListener\n3. ServletRequest 的监听器：ServletRequestListener\n\n>其中 Spring MVC 中 web.xml 常见配置的  \n>`org.springframework.web.context.request.RequestContextListener` 就是实现了 `ServletRequestListener` 用于监听每次请求。  \n>`org.springframework.web.context.ContextLoaderListener` 就是实现了 `ServletContextListener` 用于监听 ServletContext 的创建（即容器的启动），进而初始化 Spring 容器。\n\n# 3. Filter\n\n1. Filter 和 Servlet 类似也有三个生命周期方法，init、doFilter、destroy 三个。  \n2. Filter 是对多个请求进行拦截处理放行的，可以有多个 Filter。  \n3. 如果某个请求匹配到了多个过滤器，则根据 filter-mapping 的顺序进行过滤\n\n> 其中 Spring MVC 中 web.xml 常见配置的 `org.springframework.web.filter.CharacterEncodingFilter` 就是实现了 `Filter` 用于每次过滤的字符编码设置\n\n# 4. Servlet\n\n1. Servlet 用于处理客户端匹配的请求，获取请求，处理请求，返回响应。\n2. 三个生命周期方法，init、service、destroy。\n3. `<load-on-startup>` 如果是非负整数或零时，Servlet 容器先加载数值小的 servlet；如果是负数则 Servlet 容器将在首次访问时加载（懒汉模式）。\n4. Servlet 属于单例，多个请求可能会请求同一个 Servlet，即一个类只有一个对象，类由我们编写并写入 web.xml 配置中，但对象由容器创建，由容器调用相应的方法。\n\n> 其中 Spring MVC 中 web.xml 常见配置的 `org.springframework.web.servlet.DispatcherServlet` 就是继承了 `HttpServlet` 用于每次用户的请求。\n\n# 5. Spring 容器启动\n\n下面是 web.xml 的常见配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n         id=\"WebApp_ID\" version=\"2.5\">\n\n    <display-name>Archetype Created Web Application</display-name>\n\n    <filter>\n        <filter-name>characterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>characterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n\n    <listener>\n        <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>\n    </listener>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n            classpath:applicationContext.xml\n        </param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n```\n1. 创建 ServletContext 上下文并将 `context-param` 属性写入此上下文。\n2. 执行 `ContextLoaderListener` 将 Spring 的上下文 `WebApplicationContext` 写入 ServletContext 用于 Servlet 容器共享，接着读取 context-param 节点（已经被加载了）的 `contextConfigLocation` 解析 xml 并创建 Spring 容器和初始化。\n3. 执行 `CharacterEncodingFilter` 过滤器设置相应设置，用于以后的每次请求。\n4. 执行 `DispatcherServlet` \b用于 Servlet 的创建（根据 load-on-startup）。\n\n# 6. 参考\n\n三大组件参考：https://blog.csdn.net/xiaojie119120/article/details/73274759  \nSpring 容器启动参考：https://blog.csdn.net/u013510838/article/details/75066884\n\n","slug":"A2B_Java/2_Servlet_Filter_Listener.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauy000iaxs6yyhlj1qt","content":"<h1 id=\"1-web-xml-的加载顺序\"><a href=\"#1-web-xml-的加载顺序\" class=\"headerlink\" title=\"1. web.xml 的加载顺序\"></a>1. web.xml 的加载顺序</h1><p>ServletContext -&gt; context-param -&gt; listener -&gt; filter -&gt; servlet。<br>前面的两个用于在 web.xml 设置变量，重要的是后面三个，即 Listener、Filter、Servlet，为 javaweb 的三大组件。</p>\n<h1 id=\"2-Listener\"><a href=\"#2-Listener\" class=\"headerlink\" title=\"2. Listener\"></a>2. Listener</h1><ol>\n<li>ServletContext 的监听器：ServletContextListener</li>\n<li>HttpSession 的监听器：HttpSessionListener</li>\n<li>ServletRequest 的监听器：ServletRequestListener</li>\n</ol>\n<blockquote>\n<p>其中 Spring MVC 中 web.xml 常见配置的<br><code>org.springframework.web.context.request.RequestContextListener</code> 就是实现了 <code>ServletRequestListener</code> 用于监听每次请求。<br><code>org.springframework.web.context.ContextLoaderListener</code> 就是实现了 <code>ServletContextListener</code> 用于监听 ServletContext 的创建（即容器的启动），进而初始化 Spring 容器。</p>\n</blockquote>\n<h1 id=\"3-Filter\"><a href=\"#3-Filter\" class=\"headerlink\" title=\"3. Filter\"></a>3. Filter</h1><ol>\n<li>Filter 和 Servlet 类似也有三个生命周期方法，init、doFilter、destroy 三个。  </li>\n<li>Filter 是对多个请求进行拦截处理放行的，可以有多个 Filter。  </li>\n<li>如果某个请求匹配到了多个过滤器，则根据 filter-mapping 的顺序进行过滤</li>\n</ol>\n<blockquote>\n<p>其中 Spring MVC 中 web.xml 常见配置的 <code>org.springframework.web.filter.CharacterEncodingFilter</code> 就是实现了 <code>Filter</code> 用于每次过滤的字符编码设置</p>\n</blockquote>\n<h1 id=\"4-Servlet\"><a href=\"#4-Servlet\" class=\"headerlink\" title=\"4. Servlet\"></a>4. Servlet</h1><ol>\n<li>Servlet 用于处理客户端匹配的请求，获取请求，处理请求，返回响应。</li>\n<li>三个生命周期方法，init、service、destroy。</li>\n<li><code>&lt;load-on-startup&gt;</code> 如果是非负整数或零时，Servlet 容器先加载数值小的 servlet；如果是负数则 Servlet 容器将在首次访问时加载（懒汉模式）。</li>\n<li>Servlet 属于单例，多个请求可能会请求同一个 Servlet，即一个类只有一个对象，类由我们编写并写入 web.xml 配置中，但对象由容器创建，由容器调用相应的方法。</li>\n</ol>\n<blockquote>\n<p>其中 Spring MVC 中 web.xml 常见配置的 <code>org.springframework.web.servlet.DispatcherServlet</code> 就是继承了 <code>HttpServlet</code> 用于每次用户的请求。</p>\n</blockquote>\n<h1 id=\"5-Spring-容器启动\"><a href=\"#5-Spring-容器启动\" class=\"headerlink\" title=\"5. Spring 容器启动\"></a>5. Spring 容器启动</h1><p>下面是 web.xml 的常见配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">id</span>=<span class=\"string\">\"WebApp_ID\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>Archetype Created Web Application<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>characterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>characterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">            classpath:applicationContext.xml</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>创建 ServletContext 上下文并将 <code>context-param</code> 属性写入此上下文。</li>\n<li>执行 <code>ContextLoaderListener</code> 将 Spring 的上下文 <code>WebApplicationContext</code> 写入 ServletContext 用于 Servlet 容器共享，接着读取 context-param 节点（已经被加载了）的 <code>contextConfigLocation</code> 解析 xml 并创建 Spring 容器和初始化。</li>\n<li>执行 <code>CharacterEncodingFilter</code> 过滤器设置相应设置，用于以后的每次请求。</li>\n<li>执行 <code>DispatcherServlet</code> \b用于 Servlet 的创建（根据 load-on-startup）。</li>\n</ol>\n<h1 id=\"6-参考\"><a href=\"#6-参考\" class=\"headerlink\" title=\"6. 参考\"></a>6. 参考</h1><p>三大组件参考：<a href=\"https://blog.csdn.net/xiaojie119120/article/details/73274759\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiaojie119120/article/details/73274759</a><br>Spring 容器启动参考：<a href=\"https://blog.csdn.net/u013510838/article/details/75066884\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013510838/article/details/75066884</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-web-xml-的加载顺序\"><a href=\"#1-web-xml-的加载顺序\" class=\"headerlink\" title=\"1. web.xml 的加载顺序\"></a>1. web.xml 的加载顺序</h1><p>ServletContext -&gt; context-param -&gt; listener -&gt; filter -&gt; servlet。<br>前面的两个用于在 web.xml 设置变量，重要的是后面三个，即 Listener、Filter、Servlet，为 javaweb 的三大组件。</p>\n<h1 id=\"2-Listener\"><a href=\"#2-Listener\" class=\"headerlink\" title=\"2. Listener\"></a>2. Listener</h1><ol>\n<li>ServletContext 的监听器：ServletContextListener</li>\n<li>HttpSession 的监听器：HttpSessionListener</li>\n<li>ServletRequest 的监听器：ServletRequestListener</li>\n</ol>\n<blockquote>\n<p>其中 Spring MVC 中 web.xml 常见配置的<br><code>org.springframework.web.context.request.RequestContextListener</code> 就是实现了 <code>ServletRequestListener</code> 用于监听每次请求。<br><code>org.springframework.web.context.ContextLoaderListener</code> 就是实现了 <code>ServletContextListener</code> 用于监听 ServletContext 的创建（即容器的启动），进而初始化 Spring 容器。</p>\n</blockquote>\n<h1 id=\"3-Filter\"><a href=\"#3-Filter\" class=\"headerlink\" title=\"3. Filter\"></a>3. Filter</h1><ol>\n<li>Filter 和 Servlet 类似也有三个生命周期方法，init、doFilter、destroy 三个。  </li>\n<li>Filter 是对多个请求进行拦截处理放行的，可以有多个 Filter。  </li>\n<li>如果某个请求匹配到了多个过滤器，则根据 filter-mapping 的顺序进行过滤</li>\n</ol>\n<blockquote>\n<p>其中 Spring MVC 中 web.xml 常见配置的 <code>org.springframework.web.filter.CharacterEncodingFilter</code> 就是实现了 <code>Filter</code> 用于每次过滤的字符编码设置</p>\n</blockquote>\n<h1 id=\"4-Servlet\"><a href=\"#4-Servlet\" class=\"headerlink\" title=\"4. Servlet\"></a>4. Servlet</h1><ol>\n<li>Servlet 用于处理客户端匹配的请求，获取请求，处理请求，返回响应。</li>\n<li>三个生命周期方法，init、service、destroy。</li>\n<li><code>&lt;load-on-startup&gt;</code> 如果是非负整数或零时，Servlet 容器先加载数值小的 servlet；如果是负数则 Servlet 容器将在首次访问时加载（懒汉模式）。</li>\n<li>Servlet 属于单例，多个请求可能会请求同一个 Servlet，即一个类只有一个对象，类由我们编写并写入 web.xml 配置中，但对象由容器创建，由容器调用相应的方法。</li>\n</ol>\n<blockquote>\n<p>其中 Spring MVC 中 web.xml 常见配置的 <code>org.springframework.web.servlet.DispatcherServlet</code> 就是继承了 <code>HttpServlet</code> 用于每次用户的请求。</p>\n</blockquote>\n<h1 id=\"5-Spring-容器启动\"><a href=\"#5-Spring-容器启动\" class=\"headerlink\" title=\"5. Spring 容器启动\"></a>5. Spring 容器启动</h1><p>下面是 web.xml 的常见配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">id</span>=<span class=\"string\">\"WebApp_ID\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>Archetype Created Web Application<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>characterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>characterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">            classpath:applicationContext.xml</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>创建 ServletContext 上下文并将 <code>context-param</code> 属性写入此上下文。</li>\n<li>执行 <code>ContextLoaderListener</code> 将 Spring 的上下文 <code>WebApplicationContext</code> 写入 ServletContext 用于 Servlet 容器共享，接着读取 context-param 节点（已经被加载了）的 <code>contextConfigLocation</code> 解析 xml 并创建 Spring 容器和初始化。</li>\n<li>执行 <code>CharacterEncodingFilter</code> 过滤器设置相应设置，用于以后的每次请求。</li>\n<li>执行 <code>DispatcherServlet</code> \b用于 Servlet 的创建（根据 load-on-startup）。</li>\n</ol>\n<h1 id=\"6-参考\"><a href=\"#6-参考\" class=\"headerlink\" title=\"6. 参考\"></a>6. 参考</h1><p>三大组件参考：<a href=\"https://blog.csdn.net/xiaojie119120/article/details/73274759\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiaojie119120/article/details/73274759</a><br>Spring 容器启动参考：<a href=\"https://blog.csdn.net/u013510838/article/details/75066884\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013510838/article/details/75066884</a></p>\n"},{"title":"Spring_1","date":"2018-04-13T10:00:00.000Z","updated":"2018-04-13T11:00:00.000Z","comments":1,"_content":"\n# 1. Spring 的核心\n\n## 1. IOC/DI（控制反转/依赖注入）\n\n注入方式： set方法、构造器、工厂方法\n\n## 2. AOP（面向切面编程）\n\n使用的是动态代理，通过 JDK（接口实现） 或 CGLib 字节码工具包的继承来实现动态代理\n\n# 2. Bean 的生命周期\n\n## 1. 实例化 Bean\n\n对于 BeanFactory 容器，是懒实例；而 ApplicationiContext 容器则是容器启动时就会实例化所有的 Bean\n\n## 2. 设置对象属性（依赖注入）\n\nSpring 通过 BeanDefinition 中的信息进行依赖注入\n\n## 3. 注入 Aware 接口\n\nSpring 检查独享是否实现了 XXXAware 接口，并调用相应的方法\n\n## 4. BeanPostProcessor\n\n通过 BeanPostProcessor 接口的 postProcessBeforeInitialzation 方法，在 Bean 初始化前做调用，也称为前置处理（Aware 接口就是在这里完成注入的）  \npostProcessAfterInitialzation 方法在 Bean 初始化之后进行调用，也称为后置处理\n\n## 5. InitialzingBean 与 init-method\n\nInitializing 只有一个 afterPropertiesSet() 方法，在 Bean 初始化前做调用，和前置处理唯一区别是不会对 Bean 本身处理（Bean 不被参数传递）  \n同样功能在配置文件为 init-method\n\n## 6. DisposableBean 和 destroy-method\n\nBean 被清理之前调用 DisposableBean 接口的 destroy() 方法  \n同样功能在配置文件为 destroy-method\n\n","source":"_posts/Java 拾遗/5_Spring_1.md","raw":"---\ntitle: Spring_1\ndate: 2018-04-13 18:00:00\nupdated: 2018-04-13 19:00:00\ncomments: true\ncategories: \n- Java 拾遗\npermalink: A2B_Java/5_Spring_1.html    \n---\n\n# 1. Spring 的核心\n\n## 1. IOC/DI（控制反转/依赖注入）\n\n注入方式： set方法、构造器、工厂方法\n\n## 2. AOP（面向切面编程）\n\n使用的是动态代理，通过 JDK（接口实现） 或 CGLib 字节码工具包的继承来实现动态代理\n\n# 2. Bean 的生命周期\n\n## 1. 实例化 Bean\n\n对于 BeanFactory 容器，是懒实例；而 ApplicationiContext 容器则是容器启动时就会实例化所有的 Bean\n\n## 2. 设置对象属性（依赖注入）\n\nSpring 通过 BeanDefinition 中的信息进行依赖注入\n\n## 3. 注入 Aware 接口\n\nSpring 检查独享是否实现了 XXXAware 接口，并调用相应的方法\n\n## 4. BeanPostProcessor\n\n通过 BeanPostProcessor 接口的 postProcessBeforeInitialzation 方法，在 Bean 初始化前做调用，也称为前置处理（Aware 接口就是在这里完成注入的）  \npostProcessAfterInitialzation 方法在 Bean 初始化之后进行调用，也称为后置处理\n\n## 5. InitialzingBean 与 init-method\n\nInitializing 只有一个 afterPropertiesSet() 方法，在 Bean 初始化前做调用，和前置处理唯一区别是不会对 Bean 本身处理（Bean 不被参数传递）  \n同样功能在配置文件为 init-method\n\n## 6. DisposableBean 和 destroy-method\n\nBean 被清理之前调用 DisposableBean 接口的 destroy() 方法  \n同样功能在配置文件为 destroy-method\n\n","slug":"A2B_Java/5_Spring_1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkauz000jaxs6j787taln","content":"<h1 id=\"1-Spring-的核心\"><a href=\"#1-Spring-的核心\" class=\"headerlink\" title=\"1. Spring 的核心\"></a>1. Spring 的核心</h1><h2 id=\"1-IOC-DI（控制反转-依赖注入）\"><a href=\"#1-IOC-DI（控制反转-依赖注入）\" class=\"headerlink\" title=\"1. IOC/DI（控制反转/依赖注入）\"></a>1. IOC/DI（控制反转/依赖注入）</h2><p>注入方式： set方法、构造器、工厂方法</p>\n<h2 id=\"2-AOP（面向切面编程）\"><a href=\"#2-AOP（面向切面编程）\" class=\"headerlink\" title=\"2. AOP（面向切面编程）\"></a>2. AOP（面向切面编程）</h2><p>使用的是动态代理，通过 JDK（接口实现） 或 CGLib 字节码工具包的继承来实现动态代理</p>\n<h1 id=\"2-Bean-的生命周期\"><a href=\"#2-Bean-的生命周期\" class=\"headerlink\" title=\"2. Bean 的生命周期\"></a>2. Bean 的生命周期</h1><h2 id=\"1-实例化-Bean\"><a href=\"#1-实例化-Bean\" class=\"headerlink\" title=\"1. 实例化 Bean\"></a>1. 实例化 Bean</h2><p>对于 BeanFactory 容器，是懒实例；而 ApplicationiContext 容器则是容器启动时就会实例化所有的 Bean</p>\n<h2 id=\"2-设置对象属性（依赖注入）\"><a href=\"#2-设置对象属性（依赖注入）\" class=\"headerlink\" title=\"2. 设置对象属性（依赖注入）\"></a>2. 设置对象属性（依赖注入）</h2><p>Spring 通过 BeanDefinition 中的信息进行依赖注入</p>\n<h2 id=\"3-注入-Aware-接口\"><a href=\"#3-注入-Aware-接口\" class=\"headerlink\" title=\"3. 注入 Aware 接口\"></a>3. 注入 Aware 接口</h2><p>Spring 检查独享是否实现了 XXXAware 接口，并调用相应的方法</p>\n<h2 id=\"4-BeanPostProcessor\"><a href=\"#4-BeanPostProcessor\" class=\"headerlink\" title=\"4. BeanPostProcessor\"></a>4. BeanPostProcessor</h2><p>通过 BeanPostProcessor 接口的 postProcessBeforeInitialzation 方法，在 Bean 初始化前做调用，也称为前置处理（Aware 接口就是在这里完成注入的）<br>postProcessAfterInitialzation 方法在 Bean 初始化之后进行调用，也称为后置处理</p>\n<h2 id=\"5-InitialzingBean-与-init-method\"><a href=\"#5-InitialzingBean-与-init-method\" class=\"headerlink\" title=\"5. InitialzingBean 与 init-method\"></a>5. InitialzingBean 与 init-method</h2><p>Initializing 只有一个 afterPropertiesSet() 方法，在 Bean 初始化前做调用，和前置处理唯一区别是不会对 Bean 本身处理（Bean 不被参数传递）<br>同样功能在配置文件为 init-method</p>\n<h2 id=\"6-DisposableBean-和-destroy-method\"><a href=\"#6-DisposableBean-和-destroy-method\" class=\"headerlink\" title=\"6. DisposableBean 和 destroy-method\"></a>6. DisposableBean 和 destroy-method</h2><p>Bean 被清理之前调用 DisposableBean 接口的 destroy() 方法<br>同样功能在配置文件为 destroy-method</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-Spring-的核心\"><a href=\"#1-Spring-的核心\" class=\"headerlink\" title=\"1. Spring 的核心\"></a>1. Spring 的核心</h1><h2 id=\"1-IOC-DI（控制反转-依赖注入）\"><a href=\"#1-IOC-DI（控制反转-依赖注入）\" class=\"headerlink\" title=\"1. IOC/DI（控制反转/依赖注入）\"></a>1. IOC/DI（控制反转/依赖注入）</h2><p>注入方式： set方法、构造器、工厂方法</p>\n<h2 id=\"2-AOP（面向切面编程）\"><a href=\"#2-AOP（面向切面编程）\" class=\"headerlink\" title=\"2. AOP（面向切面编程）\"></a>2. AOP（面向切面编程）</h2><p>使用的是动态代理，通过 JDK（接口实现） 或 CGLib 字节码工具包的继承来实现动态代理</p>\n<h1 id=\"2-Bean-的生命周期\"><a href=\"#2-Bean-的生命周期\" class=\"headerlink\" title=\"2. Bean 的生命周期\"></a>2. Bean 的生命周期</h1><h2 id=\"1-实例化-Bean\"><a href=\"#1-实例化-Bean\" class=\"headerlink\" title=\"1. 实例化 Bean\"></a>1. 实例化 Bean</h2><p>对于 BeanFactory 容器，是懒实例；而 ApplicationiContext 容器则是容器启动时就会实例化所有的 Bean</p>\n<h2 id=\"2-设置对象属性（依赖注入）\"><a href=\"#2-设置对象属性（依赖注入）\" class=\"headerlink\" title=\"2. 设置对象属性（依赖注入）\"></a>2. 设置对象属性（依赖注入）</h2><p>Spring 通过 BeanDefinition 中的信息进行依赖注入</p>\n<h2 id=\"3-注入-Aware-接口\"><a href=\"#3-注入-Aware-接口\" class=\"headerlink\" title=\"3. 注入 Aware 接口\"></a>3. 注入 Aware 接口</h2><p>Spring 检查独享是否实现了 XXXAware 接口，并调用相应的方法</p>\n<h2 id=\"4-BeanPostProcessor\"><a href=\"#4-BeanPostProcessor\" class=\"headerlink\" title=\"4. BeanPostProcessor\"></a>4. BeanPostProcessor</h2><p>通过 BeanPostProcessor 接口的 postProcessBeforeInitialzation 方法，在 Bean 初始化前做调用，也称为前置处理（Aware 接口就是在这里完成注入的）<br>postProcessAfterInitialzation 方法在 Bean 初始化之后进行调用，也称为后置处理</p>\n<h2 id=\"5-InitialzingBean-与-init-method\"><a href=\"#5-InitialzingBean-与-init-method\" class=\"headerlink\" title=\"5. InitialzingBean 与 init-method\"></a>5. InitialzingBean 与 init-method</h2><p>Initializing 只有一个 afterPropertiesSet() 方法，在 Bean 初始化前做调用，和前置处理唯一区别是不会对 Bean 本身处理（Bean 不被参数传递）<br>同样功能在配置文件为 init-method</p>\n<h2 id=\"6-DisposableBean-和-destroy-method\"><a href=\"#6-DisposableBean-和-destroy-method\" class=\"headerlink\" title=\"6. DisposableBean 和 destroy-method\"></a>6. DisposableBean 和 destroy-method</h2><p>Bean 被清理之前调用 DisposableBean 接口的 destroy() 方法<br>同样功能在配置文件为 destroy-method</p>\n"},{"title":"Netty实战笔记","date":"2017-12-26T14:46:00.000Z","updated":"2017-12-26T14:46:00.000Z","comments":1,"_content":"","source":"_posts/Netty实战/Netty实战笔记.md","raw":"---\ntitle: Netty实战笔记\ndate: 2017-12-26 22:46:00\nupdated: 2017-12-26 22:46:00\ncomments: true\ncategories: \n- 读书笔记\n- Netty实战\npermalink: netty_in_action/1.html    \n---\n","slug":"netty_in_action/1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav0000maxs6sel9w4xl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JVM_Memory","date":"2018-04-13T10:00:00.000Z","updated":"2018-04-13T11:00:00.000Z","comments":1,"_content":"\n转自：https://www.cnblogs.com/dolphin0520/p/3613043.html\n\n# 1. 运行时数据区（Runtime Data Area）\n\n1. Java 栈（VM Stack）\n2. 本地方法栈（Native Method Stack）\n3. 程序计数器（Program Counter Register）\n4. 堆（Heap）\n5. \b方法区（Method Area）\n\n![1][]\n\n# 2. 各个区具体存储了什么数据\n\n## 2.1 程序计数器\n\n由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。  \n  \n在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。  \n  \n由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。\n\n## 2.2 Java 栈\n\nJava栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。  \n\n![2][]  \n\n局部变量表：对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。  \n  \n操作数栈：想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。  \n  \n指向运行时常量池的引用：因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。  \n  \n方法返回地址：当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。  \n  \n由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。\n\n## 2.3 本地方法栈\n\n本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。  \n在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。\n\n## 2.4 \b堆\n\nJava中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。  \nJava的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。\n\n## 2.5 方法区\n\n方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。  \n  \n在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。  \n  \n在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。  \n  \n在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。\n\n\b\n[1]: https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg\n[2]: https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg","source":"_posts/Java 拾遗/4_JVM_1.md","raw":"---\ntitle: JVM_Memory\ndate: 2018-04-13 18:00:00\nupdated: 2018-04-13 19:00:00\ncomments: true\ncategories: \n- Java 拾遗\npermalink: A2B_Java/4_JVM_Memory.html    \n---\n\n转自：https://www.cnblogs.com/dolphin0520/p/3613043.html\n\n# 1. 运行时数据区（Runtime Data Area）\n\n1. Java 栈（VM Stack）\n2. 本地方法栈（Native Method Stack）\n3. 程序计数器（Program Counter Register）\n4. 堆（Heap）\n5. \b方法区（Method Area）\n\n![1][]\n\n# 2. 各个区具体存储了什么数据\n\n## 2.1 程序计数器\n\n由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。  \n  \n在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。  \n  \n由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。\n\n## 2.2 Java 栈\n\nJava栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。  \n\n![2][]  \n\n局部变量表：对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。  \n  \n操作数栈：想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。  \n  \n指向运行时常量池的引用：因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。  \n  \n方法返回地址：当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。  \n  \n由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。\n\n## 2.3 本地方法栈\n\n本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。  \n在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。\n\n## 2.4 \b堆\n\nJava中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。  \nJava的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。\n\n## 2.5 方法区\n\n方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。  \n  \n在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。  \n  \n在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。  \n  \n在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。\n\n\b\n[1]: https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg\n[2]: https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg","slug":"A2B_Java/4_JVM_Memory.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav1000oaxs6a64uqa4l","content":"<p>转自：<a href=\"https://www.cnblogs.com/dolphin0520/p/3613043.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dolphin0520/p/3613043.html</a></p>\n<h1 id=\"1-运行时数据区（Runtime-Data-Area）\"><a href=\"#1-运行时数据区（Runtime-Data-Area）\" class=\"headerlink\" title=\"1. 运行时数据区（Runtime Data Area）\"></a>1. 运行时数据区（Runtime Data Area）</h1><ol>\n<li>Java 栈（VM Stack）</li>\n<li>本地方法栈（Native Method Stack）</li>\n<li>程序计数器（Program Counter Register）</li>\n<li>堆（Heap）</li>\n<li>\b方法区（Method Area）</li>\n</ol>\n<p>![1][]</p>\n<h1 id=\"2-各个区具体存储了什么数据\"><a href=\"#2-各个区具体存储了什么数据\" class=\"headerlink\" title=\"2. 各个区具体存储了什么数据\"></a>2. 各个区具体存储了什么数据</h1><h2 id=\"2-1-程序计数器\"><a href=\"#2-1-程序计数器\" class=\"headerlink\" title=\"2.1 程序计数器\"></a>2.1 程序计数器</h2><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。  </p>\n<p>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。  </p>\n<p>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>\n<h2 id=\"2-2-Java-栈\"><a href=\"#2-2-Java-栈\" class=\"headerlink\" title=\"2.2 Java 栈\"></a>2.2 Java 栈</h2><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。  </p>\n<p>![2][]  </p>\n<p>局部变量表：对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。  </p>\n<p>操作数栈：想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。  </p>\n<p>指向运行时常量池的引用：因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。  </p>\n<p>方法返回地址：当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。  </p>\n<p>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。</p>\n<h2 id=\"2-3-本地方法栈\"><a href=\"#2-3-本地方法栈\" class=\"headerlink\" title=\"2.3 本地方法栈\"></a>2.3 本地方法栈</h2><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。<br>在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</p>\n<h2 id=\"2-4-堆\"><a href=\"#2-4-堆\" class=\"headerlink\" title=\"2.4 \b堆\"></a>2.4 \b堆</h2><p>Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。<br>Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。</p>\n<h2 id=\"2-5-方法区\"><a href=\"#2-5-方法区\" class=\"headerlink\" title=\"2.5 方法区\"></a>2.5 方法区</h2><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。  </p>\n<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。  </p>\n<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。  </p>\n<p>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。</p>\n<p>\b<br>[1]: <a href=\"https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg\" target=\"_blank\" rel=\"noopener\">https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg</a><br>[2]: <a href=\"https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg\" target=\"_blank\" rel=\"noopener\">https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>转自：<a href=\"https://www.cnblogs.com/dolphin0520/p/3613043.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dolphin0520/p/3613043.html</a></p>\n<h1 id=\"1-运行时数据区（Runtime-Data-Area）\"><a href=\"#1-运行时数据区（Runtime-Data-Area）\" class=\"headerlink\" title=\"1. 运行时数据区（Runtime Data Area）\"></a>1. 运行时数据区（Runtime Data Area）</h1><ol>\n<li>Java 栈（VM Stack）</li>\n<li>本地方法栈（Native Method Stack）</li>\n<li>程序计数器（Program Counter Register）</li>\n<li>堆（Heap）</li>\n<li>\b方法区（Method Area）</li>\n</ol>\n<p>![1][]</p>\n<h1 id=\"2-各个区具体存储了什么数据\"><a href=\"#2-各个区具体存储了什么数据\" class=\"headerlink\" title=\"2. 各个区具体存储了什么数据\"></a>2. 各个区具体存储了什么数据</h1><h2 id=\"2-1-程序计数器\"><a href=\"#2-1-程序计数器\" class=\"headerlink\" title=\"2.1 程序计数器\"></a>2.1 程序计数器</h2><p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。  </p>\n<p>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。  </p>\n<p>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>\n<h2 id=\"2-2-Java-栈\"><a href=\"#2-2-Java-栈\" class=\"headerlink\" title=\"2.2 Java 栈\"></a>2.2 Java 栈</h2><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。  </p>\n<p>![2][]  </p>\n<p>局部变量表：对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。  </p>\n<p>操作数栈：想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。  </p>\n<p>指向运行时常量池的引用：因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。  </p>\n<p>方法返回地址：当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。  </p>\n<p>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。</p>\n<h2 id=\"2-3-本地方法栈\"><a href=\"#2-3-本地方法栈\" class=\"headerlink\" title=\"2.3 本地方法栈\"></a>2.3 本地方法栈</h2><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。<br>在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</p>\n<h2 id=\"2-4-堆\"><a href=\"#2-4-堆\" class=\"headerlink\" title=\"2.4 \b堆\"></a>2.4 \b堆</h2><p>Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。<br>Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。</p>\n<h2 id=\"2-5-方法区\"><a href=\"#2-5-方法区\" class=\"headerlink\" title=\"2.5 方法区\"></a>2.5 方法区</h2><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。  </p>\n<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。  </p>\n<p>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。  </p>\n<p>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。</p>\n<p>\b<br>[1]: <a href=\"https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg\" target=\"_blank\" rel=\"noopener\">https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg</a><br>[2]: <a href=\"https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg\" target=\"_blank\" rel=\"noopener\">https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg</a></p>\n"},{"title":"七、集群容错","date":"2018-05-30T15:14:06.000Z","updated":"2018-05-31T15:34:00.000Z","comments":1,"_content":"\n集群服务调用失败后，服务框架需要能够在底层自动容错。\n\n# 1 集群容错场景\n\n在分布式服务框架中，业务消费者不需要了解服务提供者的具体未知，它发起的服务调用请求也不包含服务提供者具体地址信息。因此，某个服务提供者是否可用对消费者而言无关紧要，最终的服务调用成功才是最重要的。  \n经过服务路由之后，选定某个服务提供者进行远程服务调用，但是服务调用可能会出错，下面进行故障场景进行分析。\n\n## 1.1 通信链路故障\n\n这里的链路指的是消费者和服务提供者之间的链路（通常为长连接），可能导致链路中断的原因有：  \n1. 通信过程中，对方突然宕机导致链路中断。\n2. 通信过程中，对方因为解码失败等原因 Rest 掉连接，导致链路中断。\n3. 通信过程中，消费者 write SocketChannel 发生 IOException 导致链路中断。\n4. 通信过程中，消费者 read SocketChannel 发生 IOException 导致链路中断。\n5. 通信双方因为心跳超时，主动 close SocketChannel 导致链路中断。\n6. 通信过程中，网络发生闪断故障。\n7. 通信过程中，交换机异常导致链路中断。\n8. 通信过程中，消费者或者服务提供者因为长时间 Full GC 导致链路中断。\n\n## 1.2 服务端超时\n\n1. 服务端的 I/O 线程没有及时从网络中读取客户端请求消息，导致该问题的原因通过是 I/O 线程被意外阻塞或者执行长周期操作。\n2. 服务端业务处理缓慢，或者被长时间阻塞，例如查询数据库，由于没有索引导致全表查询，耗时较长。\n3. 服务端发生长时间 Full GC，导致所有业务线程暂停运行，无法及时返回应答给客户端。\n\n## 1.3 服务端调用失败\n\n1. 服务端解码失败，返回消息解码失败异常。\n2. 服务端发生动态流控，返回流控异常。\n3. 服务端消息队列积压率超过最大阈值，返回系统阻塞异常。\n4. 访问权限校验失败，返回权限相关异常。\n5. 违反 SLA 策略，返回 SLA 控制相关异常。\n6. 其它系统异常。\n  \n服务调用异常不包括业务层面的处理异常，例如数据库操作异常、用户记录不存在等异常。\n\n# 2 容错策略\n\n服务不同，容错策略往往也不同，下面是集群容错和服务路由的关系：  \n![][1]  \n消费者根据配置的路由策略选择某个目标地址之后，发起远程服务调用，发起远程服务调用，在此期间如果发生了远程服务调用异常，则需要服务框架进行集群容错，重新进行选路和调用。集群容错是系统自动执行的，上层用户并不需要关心底层的服务调用过程。\n\n## 2.1 失败自动切换（FailOver）\n\n服务调用失败自动切换策略指的是当发生 RPC调用异常时，重新选路，查找下一个可用的服务提供者。  \n服务发布的时候，可以指定服务的集群容错策略。消费者可以覆盖服务提供者的通用配置，实现个性化的容错策略。  \n  \nFailOver 策略的设计思路如下：消费者路由操作完成之后，获得目标地址，调用通信框架的消息发送接口发送请求，监听服务端应答。如果返回的结果是 RPC调用异常（超时、流控、解码失败等系统异常），根据消费者集群容错的策略进行容错路由，如果是 FailOver，则重新返回到路由 Handler 的入口，从路由节点继续执行。选录完成之后，对目标地址进行对比，防止重新路由到故障服务节点，过滤掉上次的故障服务提供者之后，调用通信框架的消息发送接口发送请求消息。  \n* 读操作，因为通常它是幂等的。\n* 幂等性服务，保证调用1 次和 N 次效果相同。\n注意：失败重试会增加服务调用时延，因此框架必须对失败重试的最大次数做限制，通常默认为 3，防止无限制重试导致服务调用时延不可控。\n\n## 2.2 失败通知（Failback）\n\n适用于非幂等性的服务调用，通过对失败错误码等异常信息的判断，决定后续的执行策略。  \nFailback 的设计方案如下：服务框架获取到服务提供者返回的 RPC 异常响应之后，根据策略进行容错。将 RPC异常通知给消费者，由消费者捕获异常进行后续处理。\n\n## 2.3 失败缓存（Failcache）\n\nFailcache 策略是失败自动恢复的一种，应用场景如下：\n1. 服务有状态路由，必须定点发送到指定的服务提供者。当发生链路中断、流控等服务暂时不可用时，服务框架将消息临时缓存起来，等待周期T，重新发送，直到服务提供者能够正常处理该消息。\n2. 对时延要求不敏感的服务。系统服务调用失败，通常是链路暂时不可用、服务流控、GC 挂住服务提供者进程等，这种失败不是永久性的失败，它的恢复是可预期的。如果消费者对服务调用时延不敏感，可以考虑采用自动恢复模式，即先缓存，再等待，最后重试。\n3. 通知类服务。例如通知粉丝积分增长、记录接口日志等，对服务调用的实时性要求不高，可以容忍自动恢复带来的时延增加。  \n  \n为了保证可靠性，Failcache 策略在设计的时候需要考虑如下几个要素：\n1. 缓存时间、缓存对象上限数等需要做出限制，防止内存溢出。\n2. 缓存淘汰算法的选择，是否支持用户配置。\n3. 定时重试的周期T、重试的最大次数等需要做出限制并支持用户指定。\n重试达到最大上限仍失败，需要丢弃消息，记录异常日志。\n\n## 2.4 快速失败（Failfast）\n\n在业务高峰期，对于一些非核心的服务，希望只调用一次，失败也不再重试，为重要的核心服务解约宝贵的运行资源。此时，快速失败是不错的选择。\n原理在于，获取服务调用异常之后，直接忽略异常，记录异常日志。\n\n## 2.5 容错策略扩展\n\n无论默认支持多少种容错策略，在业务实际使用过程中都需要支持用户自定义扩展容错策略。\n\n# 3 个人总结\n\n集群容错虽然功能简单，设计也并不复杂（不复杂？？？），但是该特性却非常重要。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/7_1.png","source":"_posts/分布式服务框架原理与实践/第七章 集群容错.md","raw":"---\ntitle: 七、集群容错\ndate: 2018-05-30 23:14:06\nupdated: 2018-05-31 23:34:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/7.html    \n---\n\n集群服务调用失败后，服务框架需要能够在底层自动容错。\n\n# 1 集群容错场景\n\n在分布式服务框架中，业务消费者不需要了解服务提供者的具体未知，它发起的服务调用请求也不包含服务提供者具体地址信息。因此，某个服务提供者是否可用对消费者而言无关紧要，最终的服务调用成功才是最重要的。  \n经过服务路由之后，选定某个服务提供者进行远程服务调用，但是服务调用可能会出错，下面进行故障场景进行分析。\n\n## 1.1 通信链路故障\n\n这里的链路指的是消费者和服务提供者之间的链路（通常为长连接），可能导致链路中断的原因有：  \n1. 通信过程中，对方突然宕机导致链路中断。\n2. 通信过程中，对方因为解码失败等原因 Rest 掉连接，导致链路中断。\n3. 通信过程中，消费者 write SocketChannel 发生 IOException 导致链路中断。\n4. 通信过程中，消费者 read SocketChannel 发生 IOException 导致链路中断。\n5. 通信双方因为心跳超时，主动 close SocketChannel 导致链路中断。\n6. 通信过程中，网络发生闪断故障。\n7. 通信过程中，交换机异常导致链路中断。\n8. 通信过程中，消费者或者服务提供者因为长时间 Full GC 导致链路中断。\n\n## 1.2 服务端超时\n\n1. 服务端的 I/O 线程没有及时从网络中读取客户端请求消息，导致该问题的原因通过是 I/O 线程被意外阻塞或者执行长周期操作。\n2. 服务端业务处理缓慢，或者被长时间阻塞，例如查询数据库，由于没有索引导致全表查询，耗时较长。\n3. 服务端发生长时间 Full GC，导致所有业务线程暂停运行，无法及时返回应答给客户端。\n\n## 1.3 服务端调用失败\n\n1. 服务端解码失败，返回消息解码失败异常。\n2. 服务端发生动态流控，返回流控异常。\n3. 服务端消息队列积压率超过最大阈值，返回系统阻塞异常。\n4. 访问权限校验失败，返回权限相关异常。\n5. 违反 SLA 策略，返回 SLA 控制相关异常。\n6. 其它系统异常。\n  \n服务调用异常不包括业务层面的处理异常，例如数据库操作异常、用户记录不存在等异常。\n\n# 2 容错策略\n\n服务不同，容错策略往往也不同，下面是集群容错和服务路由的关系：  \n![][1]  \n消费者根据配置的路由策略选择某个目标地址之后，发起远程服务调用，发起远程服务调用，在此期间如果发生了远程服务调用异常，则需要服务框架进行集群容错，重新进行选路和调用。集群容错是系统自动执行的，上层用户并不需要关心底层的服务调用过程。\n\n## 2.1 失败自动切换（FailOver）\n\n服务调用失败自动切换策略指的是当发生 RPC调用异常时，重新选路，查找下一个可用的服务提供者。  \n服务发布的时候，可以指定服务的集群容错策略。消费者可以覆盖服务提供者的通用配置，实现个性化的容错策略。  \n  \nFailOver 策略的设计思路如下：消费者路由操作完成之后，获得目标地址，调用通信框架的消息发送接口发送请求，监听服务端应答。如果返回的结果是 RPC调用异常（超时、流控、解码失败等系统异常），根据消费者集群容错的策略进行容错路由，如果是 FailOver，则重新返回到路由 Handler 的入口，从路由节点继续执行。选录完成之后，对目标地址进行对比，防止重新路由到故障服务节点，过滤掉上次的故障服务提供者之后，调用通信框架的消息发送接口发送请求消息。  \n* 读操作，因为通常它是幂等的。\n* 幂等性服务，保证调用1 次和 N 次效果相同。\n注意：失败重试会增加服务调用时延，因此框架必须对失败重试的最大次数做限制，通常默认为 3，防止无限制重试导致服务调用时延不可控。\n\n## 2.2 失败通知（Failback）\n\n适用于非幂等性的服务调用，通过对失败错误码等异常信息的判断，决定后续的执行策略。  \nFailback 的设计方案如下：服务框架获取到服务提供者返回的 RPC 异常响应之后，根据策略进行容错。将 RPC异常通知给消费者，由消费者捕获异常进行后续处理。\n\n## 2.3 失败缓存（Failcache）\n\nFailcache 策略是失败自动恢复的一种，应用场景如下：\n1. 服务有状态路由，必须定点发送到指定的服务提供者。当发生链路中断、流控等服务暂时不可用时，服务框架将消息临时缓存起来，等待周期T，重新发送，直到服务提供者能够正常处理该消息。\n2. 对时延要求不敏感的服务。系统服务调用失败，通常是链路暂时不可用、服务流控、GC 挂住服务提供者进程等，这种失败不是永久性的失败，它的恢复是可预期的。如果消费者对服务调用时延不敏感，可以考虑采用自动恢复模式，即先缓存，再等待，最后重试。\n3. 通知类服务。例如通知粉丝积分增长、记录接口日志等，对服务调用的实时性要求不高，可以容忍自动恢复带来的时延增加。  \n  \n为了保证可靠性，Failcache 策略在设计的时候需要考虑如下几个要素：\n1. 缓存时间、缓存对象上限数等需要做出限制，防止内存溢出。\n2. 缓存淘汰算法的选择，是否支持用户配置。\n3. 定时重试的周期T、重试的最大次数等需要做出限制并支持用户指定。\n重试达到最大上限仍失败，需要丢弃消息，记录异常日志。\n\n## 2.4 快速失败（Failfast）\n\n在业务高峰期，对于一些非核心的服务，希望只调用一次，失败也不再重试，为重要的核心服务解约宝贵的运行资源。此时，快速失败是不错的选择。\n原理在于，获取服务调用异常之后，直接忽略异常，记录异常日志。\n\n## 2.5 容错策略扩展\n\n无论默认支持多少种容错策略，在业务实际使用过程中都需要支持用户自定义扩展容错策略。\n\n# 3 个人总结\n\n集群容错虽然功能简单，设计也并不复杂（不复杂？？？），但是该特性却非常重要。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/7_1.png","slug":"distributed_principle_prictice/7.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav2000raxs65mqjry7d","content":"<p>集群服务调用失败后，服务框架需要能够在底层自动容错。</p>\n<h1 id=\"1-集群容错场景\"><a href=\"#1-集群容错场景\" class=\"headerlink\" title=\"1 集群容错场景\"></a>1 集群容错场景</h1><p>在分布式服务框架中，业务消费者不需要了解服务提供者的具体未知，它发起的服务调用请求也不包含服务提供者具体地址信息。因此，某个服务提供者是否可用对消费者而言无关紧要，最终的服务调用成功才是最重要的。<br>经过服务路由之后，选定某个服务提供者进行远程服务调用，但是服务调用可能会出错，下面进行故障场景进行分析。</p>\n<h2 id=\"1-1-通信链路故障\"><a href=\"#1-1-通信链路故障\" class=\"headerlink\" title=\"1.1 通信链路故障\"></a>1.1 通信链路故障</h2><p>这里的链路指的是消费者和服务提供者之间的链路（通常为长连接），可能导致链路中断的原因有：  </p>\n<ol>\n<li>通信过程中，对方突然宕机导致链路中断。</li>\n<li>通信过程中，对方因为解码失败等原因 Rest 掉连接，导致链路中断。</li>\n<li>通信过程中，消费者 write SocketChannel 发生 IOException 导致链路中断。</li>\n<li>通信过程中，消费者 read SocketChannel 发生 IOException 导致链路中断。</li>\n<li>通信双方因为心跳超时，主动 close SocketChannel 导致链路中断。</li>\n<li>通信过程中，网络发生闪断故障。</li>\n<li>通信过程中，交换机异常导致链路中断。</li>\n<li>通信过程中，消费者或者服务提供者因为长时间 Full GC 导致链路中断。</li>\n</ol>\n<h2 id=\"1-2-服务端超时\"><a href=\"#1-2-服务端超时\" class=\"headerlink\" title=\"1.2 服务端超时\"></a>1.2 服务端超时</h2><ol>\n<li>服务端的 I/O 线程没有及时从网络中读取客户端请求消息，导致该问题的原因通过是 I/O 线程被意外阻塞或者执行长周期操作。</li>\n<li>服务端业务处理缓慢，或者被长时间阻塞，例如查询数据库，由于没有索引导致全表查询，耗时较长。</li>\n<li>服务端发生长时间 Full GC，导致所有业务线程暂停运行，无法及时返回应答给客户端。</li>\n</ol>\n<h2 id=\"1-3-服务端调用失败\"><a href=\"#1-3-服务端调用失败\" class=\"headerlink\" title=\"1.3 服务端调用失败\"></a>1.3 服务端调用失败</h2><ol>\n<li>服务端解码失败，返回消息解码失败异常。</li>\n<li>服务端发生动态流控，返回流控异常。</li>\n<li>服务端消息队列积压率超过最大阈值，返回系统阻塞异常。</li>\n<li>访问权限校验失败，返回权限相关异常。</li>\n<li>违反 SLA 策略，返回 SLA 控制相关异常。</li>\n<li>其它系统异常。</li>\n</ol>\n<p>服务调用异常不包括业务层面的处理异常，例如数据库操作异常、用户记录不存在等异常。</p>\n<h1 id=\"2-容错策略\"><a href=\"#2-容错策略\" class=\"headerlink\" title=\"2 容错策略\"></a>2 容错策略</h1><p>服务不同，容错策略往往也不同，下面是集群容错和服务路由的关系：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/7_1.png\" alt=\"\"><br>消费者根据配置的路由策略选择某个目标地址之后，发起远程服务调用，发起远程服务调用，在此期间如果发生了远程服务调用异常，则需要服务框架进行集群容错，重新进行选路和调用。集群容错是系统自动执行的，上层用户并不需要关心底层的服务调用过程。</p>\n<h2 id=\"2-1-失败自动切换（FailOver）\"><a href=\"#2-1-失败自动切换（FailOver）\" class=\"headerlink\" title=\"2.1 失败自动切换（FailOver）\"></a>2.1 失败自动切换（FailOver）</h2><p>服务调用失败自动切换策略指的是当发生 RPC调用异常时，重新选路，查找下一个可用的服务提供者。<br>服务发布的时候，可以指定服务的集群容错策略。消费者可以覆盖服务提供者的通用配置，实现个性化的容错策略。  </p>\n<p>FailOver 策略的设计思路如下：消费者路由操作完成之后，获得目标地址，调用通信框架的消息发送接口发送请求，监听服务端应答。如果返回的结果是 RPC调用异常（超时、流控、解码失败等系统异常），根据消费者集群容错的策略进行容错路由，如果是 FailOver，则重新返回到路由 Handler 的入口，从路由节点继续执行。选录完成之后，对目标地址进行对比，防止重新路由到故障服务节点，过滤掉上次的故障服务提供者之后，调用通信框架的消息发送接口发送请求消息。  </p>\n<ul>\n<li>读操作，因为通常它是幂等的。</li>\n<li>幂等性服务，保证调用1 次和 N 次效果相同。<br>注意：失败重试会增加服务调用时延，因此框架必须对失败重试的最大次数做限制，通常默认为 3，防止无限制重试导致服务调用时延不可控。</li>\n</ul>\n<h2 id=\"2-2-失败通知（Failback）\"><a href=\"#2-2-失败通知（Failback）\" class=\"headerlink\" title=\"2.2 失败通知（Failback）\"></a>2.2 失败通知（Failback）</h2><p>适用于非幂等性的服务调用，通过对失败错误码等异常信息的判断，决定后续的执行策略。<br>Failback 的设计方案如下：服务框架获取到服务提供者返回的 RPC 异常响应之后，根据策略进行容错。将 RPC异常通知给消费者，由消费者捕获异常进行后续处理。</p>\n<h2 id=\"2-3-失败缓存（Failcache）\"><a href=\"#2-3-失败缓存（Failcache）\" class=\"headerlink\" title=\"2.3 失败缓存（Failcache）\"></a>2.3 失败缓存（Failcache）</h2><p>Failcache 策略是失败自动恢复的一种，应用场景如下：</p>\n<ol>\n<li>服务有状态路由，必须定点发送到指定的服务提供者。当发生链路中断、流控等服务暂时不可用时，服务框架将消息临时缓存起来，等待周期T，重新发送，直到服务提供者能够正常处理该消息。</li>\n<li>对时延要求不敏感的服务。系统服务调用失败，通常是链路暂时不可用、服务流控、GC 挂住服务提供者进程等，这种失败不是永久性的失败，它的恢复是可预期的。如果消费者对服务调用时延不敏感，可以考虑采用自动恢复模式，即先缓存，再等待，最后重试。</li>\n<li>通知类服务。例如通知粉丝积分增长、记录接口日志等，对服务调用的实时性要求不高，可以容忍自动恢复带来的时延增加。  </li>\n</ol>\n<p>为了保证可靠性，Failcache 策略在设计的时候需要考虑如下几个要素：</p>\n<ol>\n<li>缓存时间、缓存对象上限数等需要做出限制，防止内存溢出。</li>\n<li>缓存淘汰算法的选择，是否支持用户配置。</li>\n<li>定时重试的周期T、重试的最大次数等需要做出限制并支持用户指定。<br>重试达到最大上限仍失败，需要丢弃消息，记录异常日志。</li>\n</ol>\n<h2 id=\"2-4-快速失败（Failfast）\"><a href=\"#2-4-快速失败（Failfast）\" class=\"headerlink\" title=\"2.4 快速失败（Failfast）\"></a>2.4 快速失败（Failfast）</h2><p>在业务高峰期，对于一些非核心的服务，希望只调用一次，失败也不再重试，为重要的核心服务解约宝贵的运行资源。此时，快速失败是不错的选择。<br>原理在于，获取服务调用异常之后，直接忽略异常，记录异常日志。</p>\n<h2 id=\"2-5-容错策略扩展\"><a href=\"#2-5-容错策略扩展\" class=\"headerlink\" title=\"2.5 容错策略扩展\"></a>2.5 容错策略扩展</h2><p>无论默认支持多少种容错策略，在业务实际使用过程中都需要支持用户自定义扩展容错策略。</p>\n<h1 id=\"3-个人总结\"><a href=\"#3-个人总结\" class=\"headerlink\" title=\"3 个人总结\"></a>3 个人总结</h1><p>集群容错虽然功能简单，设计也并不复杂（不复杂？？？），但是该特性却非常重要。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>集群服务调用失败后，服务框架需要能够在底层自动容错。</p>\n<h1 id=\"1-集群容错场景\"><a href=\"#1-集群容错场景\" class=\"headerlink\" title=\"1 集群容错场景\"></a>1 集群容错场景</h1><p>在分布式服务框架中，业务消费者不需要了解服务提供者的具体未知，它发起的服务调用请求也不包含服务提供者具体地址信息。因此，某个服务提供者是否可用对消费者而言无关紧要，最终的服务调用成功才是最重要的。<br>经过服务路由之后，选定某个服务提供者进行远程服务调用，但是服务调用可能会出错，下面进行故障场景进行分析。</p>\n<h2 id=\"1-1-通信链路故障\"><a href=\"#1-1-通信链路故障\" class=\"headerlink\" title=\"1.1 通信链路故障\"></a>1.1 通信链路故障</h2><p>这里的链路指的是消费者和服务提供者之间的链路（通常为长连接），可能导致链路中断的原因有：  </p>\n<ol>\n<li>通信过程中，对方突然宕机导致链路中断。</li>\n<li>通信过程中，对方因为解码失败等原因 Rest 掉连接，导致链路中断。</li>\n<li>通信过程中，消费者 write SocketChannel 发生 IOException 导致链路中断。</li>\n<li>通信过程中，消费者 read SocketChannel 发生 IOException 导致链路中断。</li>\n<li>通信双方因为心跳超时，主动 close SocketChannel 导致链路中断。</li>\n<li>通信过程中，网络发生闪断故障。</li>\n<li>通信过程中，交换机异常导致链路中断。</li>\n<li>通信过程中，消费者或者服务提供者因为长时间 Full GC 导致链路中断。</li>\n</ol>\n<h2 id=\"1-2-服务端超时\"><a href=\"#1-2-服务端超时\" class=\"headerlink\" title=\"1.2 服务端超时\"></a>1.2 服务端超时</h2><ol>\n<li>服务端的 I/O 线程没有及时从网络中读取客户端请求消息，导致该问题的原因通过是 I/O 线程被意外阻塞或者执行长周期操作。</li>\n<li>服务端业务处理缓慢，或者被长时间阻塞，例如查询数据库，由于没有索引导致全表查询，耗时较长。</li>\n<li>服务端发生长时间 Full GC，导致所有业务线程暂停运行，无法及时返回应答给客户端。</li>\n</ol>\n<h2 id=\"1-3-服务端调用失败\"><a href=\"#1-3-服务端调用失败\" class=\"headerlink\" title=\"1.3 服务端调用失败\"></a>1.3 服务端调用失败</h2><ol>\n<li>服务端解码失败，返回消息解码失败异常。</li>\n<li>服务端发生动态流控，返回流控异常。</li>\n<li>服务端消息队列积压率超过最大阈值，返回系统阻塞异常。</li>\n<li>访问权限校验失败，返回权限相关异常。</li>\n<li>违反 SLA 策略，返回 SLA 控制相关异常。</li>\n<li>其它系统异常。</li>\n</ol>\n<p>服务调用异常不包括业务层面的处理异常，例如数据库操作异常、用户记录不存在等异常。</p>\n<h1 id=\"2-容错策略\"><a href=\"#2-容错策略\" class=\"headerlink\" title=\"2 容错策略\"></a>2 容错策略</h1><p>服务不同，容错策略往往也不同，下面是集群容错和服务路由的关系：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/7_1.png\" alt=\"\"><br>消费者根据配置的路由策略选择某个目标地址之后，发起远程服务调用，发起远程服务调用，在此期间如果发生了远程服务调用异常，则需要服务框架进行集群容错，重新进行选路和调用。集群容错是系统自动执行的，上层用户并不需要关心底层的服务调用过程。</p>\n<h2 id=\"2-1-失败自动切换（FailOver）\"><a href=\"#2-1-失败自动切换（FailOver）\" class=\"headerlink\" title=\"2.1 失败自动切换（FailOver）\"></a>2.1 失败自动切换（FailOver）</h2><p>服务调用失败自动切换策略指的是当发生 RPC调用异常时，重新选路，查找下一个可用的服务提供者。<br>服务发布的时候，可以指定服务的集群容错策略。消费者可以覆盖服务提供者的通用配置，实现个性化的容错策略。  </p>\n<p>FailOver 策略的设计思路如下：消费者路由操作完成之后，获得目标地址，调用通信框架的消息发送接口发送请求，监听服务端应答。如果返回的结果是 RPC调用异常（超时、流控、解码失败等系统异常），根据消费者集群容错的策略进行容错路由，如果是 FailOver，则重新返回到路由 Handler 的入口，从路由节点继续执行。选录完成之后，对目标地址进行对比，防止重新路由到故障服务节点，过滤掉上次的故障服务提供者之后，调用通信框架的消息发送接口发送请求消息。  </p>\n<ul>\n<li>读操作，因为通常它是幂等的。</li>\n<li>幂等性服务，保证调用1 次和 N 次效果相同。<br>注意：失败重试会增加服务调用时延，因此框架必须对失败重试的最大次数做限制，通常默认为 3，防止无限制重试导致服务调用时延不可控。</li>\n</ul>\n<h2 id=\"2-2-失败通知（Failback）\"><a href=\"#2-2-失败通知（Failback）\" class=\"headerlink\" title=\"2.2 失败通知（Failback）\"></a>2.2 失败通知（Failback）</h2><p>适用于非幂等性的服务调用，通过对失败错误码等异常信息的判断，决定后续的执行策略。<br>Failback 的设计方案如下：服务框架获取到服务提供者返回的 RPC 异常响应之后，根据策略进行容错。将 RPC异常通知给消费者，由消费者捕获异常进行后续处理。</p>\n<h2 id=\"2-3-失败缓存（Failcache）\"><a href=\"#2-3-失败缓存（Failcache）\" class=\"headerlink\" title=\"2.3 失败缓存（Failcache）\"></a>2.3 失败缓存（Failcache）</h2><p>Failcache 策略是失败自动恢复的一种，应用场景如下：</p>\n<ol>\n<li>服务有状态路由，必须定点发送到指定的服务提供者。当发生链路中断、流控等服务暂时不可用时，服务框架将消息临时缓存起来，等待周期T，重新发送，直到服务提供者能够正常处理该消息。</li>\n<li>对时延要求不敏感的服务。系统服务调用失败，通常是链路暂时不可用、服务流控、GC 挂住服务提供者进程等，这种失败不是永久性的失败，它的恢复是可预期的。如果消费者对服务调用时延不敏感，可以考虑采用自动恢复模式，即先缓存，再等待，最后重试。</li>\n<li>通知类服务。例如通知粉丝积分增长、记录接口日志等，对服务调用的实时性要求不高，可以容忍自动恢复带来的时延增加。  </li>\n</ol>\n<p>为了保证可靠性，Failcache 策略在设计的时候需要考虑如下几个要素：</p>\n<ol>\n<li>缓存时间、缓存对象上限数等需要做出限制，防止内存溢出。</li>\n<li>缓存淘汰算法的选择，是否支持用户配置。</li>\n<li>定时重试的周期T、重试的最大次数等需要做出限制并支持用户指定。<br>重试达到最大上限仍失败，需要丢弃消息，记录异常日志。</li>\n</ol>\n<h2 id=\"2-4-快速失败（Failfast）\"><a href=\"#2-4-快速失败（Failfast）\" class=\"headerlink\" title=\"2.4 快速失败（Failfast）\"></a>2.4 快速失败（Failfast）</h2><p>在业务高峰期，对于一些非核心的服务，希望只调用一次，失败也不再重试，为重要的核心服务解约宝贵的运行资源。此时，快速失败是不错的选择。<br>原理在于，获取服务调用异常之后，直接忽略异常，记录异常日志。</p>\n<h2 id=\"2-5-容错策略扩展\"><a href=\"#2-5-容错策略扩展\" class=\"headerlink\" title=\"2.5 容错策略扩展\"></a>2.5 容错策略扩展</h2><p>无论默认支持多少种容错策略，在业务实际使用过程中都需要支持用户自定义扩展容错策略。</p>\n<h1 id=\"3-个人总结\"><a href=\"#3-个人总结\" class=\"headerlink\" title=\"3 个人总结\"></a>3 个人总结</h1><p>集群容错虽然功能简单，设计也并不复杂（不复杂？？？），但是该特性却非常重要。</p>\n"},{"title":"一、应用框架演进","date":"2018-05-18T15:41:00.000Z","updated":"2018-05-17T18:00:00.000Z","comments":1,"_content":"\n# 1 传统垂直应用架构\n\n以经典的 MVC 垂直架构为例，通常分三层：  \n1. View：视图展示层，使用 JSP/JS/HTML+CSS。\n2. Controller：调度控制层，请求的分发。\n3. Model：应用模型层，业务数据和业务执行逻辑，被多个视图重用。\n\n![][1]\n\n标准的 MVC 模式并不包含数据访问层，但实际开发中需要专门的数据库连接池和统一的数据库访问接口对接数据库，于是 ORM 框架逐渐流行起来。  \n\n通常基于 MVC 架构开发的应用代码会统一打成一个 war 包，不同的应用功能之间通过本地 API 进行调用，基本不存在跨进程的远程服务调用。  \n\n通常的基于热双机备份，判断应用进程宕机或僵死后，应用切换备机，然后尝试重新拉起主机。  \n而在高并发、大流量的应用场景中，需要做集群，通常前端通过 F5 等负载均衡器做七层负载均衡，后端做对等集群部署。  \n![][2]\n![][3]\n\n\n# 2 RPC 架构\n\nRPC 全称 Remote Procedure Call，它是一种进程间通信方式。允许像调用本地服务一样调用远程服务，具体实现可以不同。\n\n## 2.1 RPC 框架原理\n\nRPC 框架的目标就是让远程过程（服务）调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP/UDP）、序列化方式（XML/JSON/二进制）和通信细节。  \n调用原理图如下：  \n![][4]  \n\n1. 远程服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构，或者中间态的服务定义文件，例如 Thrift 的 IDL 文件；服务调用者需要通过一定的途径获取远程服务调用相关信息，例如服务端接口定义 Jar 包导入，获取服务端 IDL 文件等。\n2. 远程代理对象：服务调用者调用的服务实际是远程服务的本地代理，对于 Java 语言，它的实现就是 JDK 的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。\n3. 通信：RPC 框架与具体的协议无关。\n4. 序列化：远程通信，需要将对象转换成二进制码流进行网络传输，不同的序列化框架，支持的数据类型、数据包大小、异常类型及性能等都不同。有的甚至支持用户自定义序列化框架（Hadoop Avro）。\n\n## 2.2 实现一个简单的 RPC 框架\n\n1. 分四个聚合项目：Provider、Consumer、RpcFramework、ServiceApi。为了简单期间，RPC 核心和 ServiceApi 合并一个项目 C。\n2. Provider 依赖 C 项目，Consumer 依赖 C 项目。这样 Provider 和 Consumer 都有了同一个顶级接口以及同版本的 RPC 框架。\n3. RPC 框架提供 export() 用于 Provider 发布自己的实现类、refer() 用于 Consumer 调用对应的顶级接口。\n4. refer() 方法用于生成代理，此代理每次执行方法都会调用 invoke() 方法，而 invoke() 方法实际通过 socket 连接 Provider ，将调用的方法名、参数等传递给 Provider。\n5. export() 方法用于获取 Consumer 传递的方法名，参数等，以及自己暴露的接口实现类，来反射执行获取结果，并返回给 Consumer。\n6. 代理对象获取到了结果，返回给调用者。\n7. Provider 使用了反射，用于将调用者的方法名、参数、自己暴露的服务调用执行获取结果。Consumer 使用了代理，每次执行方法，都会调用 invoke() 即将调用的方法名、参数、调用的接口传递给 Provider。实现远程服务的本地代理。\n8. [\b参考的 GITHUB 地址](6)\n\n## 2.3 业界主流 RPC 框架\n\n1. Facebook 的 Apache Thrift。\n2. Hadoop 的 Avro-RPC。\n3. caucho 的 Hession。\n4. Google 的 gRPC。\n\n## 2.4 RPC 框架面临的挑战\n\n1. 提供服务的机器越来越多，服务 URL 配置管理变得非常困难（服务发布订阅中心）。\n2. 服务间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动（链路追踪）。\n3. 某个服务调用量特别大，需要加机器。为了解决容量规划问题，需要采集服务调用 KPI 数据，进行汇总和分析，计算出服务部署实例数和服务器的配置规格。\n4. 服务上线容易下线难，下线通知，需要统一的服务生命周期管理流程进行管控，如何保证敏感服务不被误调用，服务的访问安全策略又如何制定？\n5. 服务治理问题。\n\n# 3 SOA 服务化架构\n\nSOA 是一种粗粒度、松耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信。  \n\n## 3.1 面向服务设计的原则\n\n1. 服务可服用：不管是否存在即时复用的机会，服务均被设计为支持潜在的可复用。\n2. 服务共享一个标准契约：IDL 文件、Java 接口定义、甚至是一个接口说明文档。\n3. 服务是松耦合的：服务被设计为功能相对独立、尽量不依赖其它服务的独立功能提供者。\n4. 服务是底层逻辑的抽象：只有经服务契约所暴露的服务队外部世界可见，契约之外底层的实现逻辑是不可见的。\n5. 服务是可组合、可编排的：多个服务可能被编排组合成一个新的服务。\n6. 服务是可自治的：逻辑由服务所控制，并位于一个清晰的边界内，服务已经在边界内被控制，不依赖于其它服务。\n7. 服务是无状态的：这意味着要讲状态管理移至他处。\n8. 服务是可被自动发现的：服务发布上线后，允许被其它消费者自动发现。服务下线后，允许消费者接收服务下线通知。\n\n## 3.2 服务治理\n\nSOA 服务治理主要包括如下几个方面：\n1. 服务定义：SOA 治理最基础的方面就是监视服务的创建过程。\n2. 服务生命周期管理：服务需要进行规划、设计、实现、部署、维护、下线主要阶段。\n3. 服务版本治理：新版本的兼容性。\n4. 服务注册中心：服务提供者如何发布服务？服务消费者如何订阅服务？\n5. 服务监控：服务监控中心需要对服务的调用时延、成功率、吞吐率等数据进行实时采样和汇总。\n6. 运行期服务质量保障：包括服务限流、服务迁入迁出、服务升降级、服务权重调整和服务超时控制等，通过运行期的动态治理，可以在不重启服务的前提下达到快速提升服务运行质量的目标。\n7. 快速的故障定界定位手段：大规模分布式环境下海量业务/平台日志的采集、汇总和实时在线检索；分布式消息跟踪。\n8. 服务安全：是否允许任何人调用任何服务，数据敏感型服务是否允许所有用户访问所有数据，交互数据是否需要进行保护，服务的安全认证等。服务安全访问策略有多重，例如动态生成 Token 的方式做安全访问授权。\n\n# 4 微服务架构\n\n微服务架构（MSA）是一种服务化架构风格。  \nSOA 架构解决了应用服务化问题，但是随着服务规模越来越大、服务治理越来越多，微服务架构风格应运而生。微服务架构的主要特征如下：  \n1. 原子服务。\n2. 高密度部署：利用LXC（例如 Docker）实现容器级部署。\n3. 敏捷交付：服务由小研发团队负责设计、开发、测试、部署、线上治理、灰度发布和下线，运维整个生命周期支撑，实现真正的 DevOps。\n4. 微自治：服务足够小，功能单一，可以独立打包、部署、升级、回滚和弹性伸缩，不依赖其它服务，实现局部自治。\n\n相对于 SOA，主要差异如下：  \n1. 服务拆分粒度。\n2. 服务依赖：SOA 尽量重用，微服务功能单一独立。\n3. 服务规模：SOA 服务粒度大，多数会采用多个服务合并打 war 包，因此服务实例数比较有限。微服务强调尽可能拆分，同时很多服务会独立部署。\n4. 架构差异。\n5. 服务治理。\n6. 敏捷交付。\n\n# 5 个人理解总结 \n\n![][5]\n\n1. MVC架构：在于多个功能部署同一个进程，一个 war 包，通过 HTTP 请求来实现互相的调用。重点在于前后端分离。\n2. RPC架构：将核心和公共业务抽取出来，独立运行进程，使用 RPC 调用服务屏蔽底层通信逻辑。重点在于业务复用以及通用拆分。\n3. SOA架构：服务生命周期管控和SOA服务治理是关键。\n4. 微服务架构：敏捷开发、持续交付、DevOps理论，基于 Docker 等轻量级容器。重点在于独立打包、部署和升级，小团队敏捷交付，交付周期短。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_5.png\n\n[6]: https://github.com/LiWenGu/MySourceCode/tree/master/DubboDemo?1526581754181","source":"_posts/分布式服务框架原理与实践/第一章 应用框架演进.md","raw":"---\ntitle: 一、应用框架演进\ndate: 2018-05-18 23:41:00\nupdated: 2018-05-18 02:00:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/1.html    \n---\n\n# 1 传统垂直应用架构\n\n以经典的 MVC 垂直架构为例，通常分三层：  \n1. View：视图展示层，使用 JSP/JS/HTML+CSS。\n2. Controller：调度控制层，请求的分发。\n3. Model：应用模型层，业务数据和业务执行逻辑，被多个视图重用。\n\n![][1]\n\n标准的 MVC 模式并不包含数据访问层，但实际开发中需要专门的数据库连接池和统一的数据库访问接口对接数据库，于是 ORM 框架逐渐流行起来。  \n\n通常基于 MVC 架构开发的应用代码会统一打成一个 war 包，不同的应用功能之间通过本地 API 进行调用，基本不存在跨进程的远程服务调用。  \n\n通常的基于热双机备份，判断应用进程宕机或僵死后，应用切换备机，然后尝试重新拉起主机。  \n而在高并发、大流量的应用场景中，需要做集群，通常前端通过 F5 等负载均衡器做七层负载均衡，后端做对等集群部署。  \n![][2]\n![][3]\n\n\n# 2 RPC 架构\n\nRPC 全称 Remote Procedure Call，它是一种进程间通信方式。允许像调用本地服务一样调用远程服务，具体实现可以不同。\n\n## 2.1 RPC 框架原理\n\nRPC 框架的目标就是让远程过程（服务）调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP/UDP）、序列化方式（XML/JSON/二进制）和通信细节。  \n调用原理图如下：  \n![][4]  \n\n1. 远程服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构，或者中间态的服务定义文件，例如 Thrift 的 IDL 文件；服务调用者需要通过一定的途径获取远程服务调用相关信息，例如服务端接口定义 Jar 包导入，获取服务端 IDL 文件等。\n2. 远程代理对象：服务调用者调用的服务实际是远程服务的本地代理，对于 Java 语言，它的实现就是 JDK 的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。\n3. 通信：RPC 框架与具体的协议无关。\n4. 序列化：远程通信，需要将对象转换成二进制码流进行网络传输，不同的序列化框架，支持的数据类型、数据包大小、异常类型及性能等都不同。有的甚至支持用户自定义序列化框架（Hadoop Avro）。\n\n## 2.2 实现一个简单的 RPC 框架\n\n1. 分四个聚合项目：Provider、Consumer、RpcFramework、ServiceApi。为了简单期间，RPC 核心和 ServiceApi 合并一个项目 C。\n2. Provider 依赖 C 项目，Consumer 依赖 C 项目。这样 Provider 和 Consumer 都有了同一个顶级接口以及同版本的 RPC 框架。\n3. RPC 框架提供 export() 用于 Provider 发布自己的实现类、refer() 用于 Consumer 调用对应的顶级接口。\n4. refer() 方法用于生成代理，此代理每次执行方法都会调用 invoke() 方法，而 invoke() 方法实际通过 socket 连接 Provider ，将调用的方法名、参数等传递给 Provider。\n5. export() 方法用于获取 Consumer 传递的方法名，参数等，以及自己暴露的接口实现类，来反射执行获取结果，并返回给 Consumer。\n6. 代理对象获取到了结果，返回给调用者。\n7. Provider 使用了反射，用于将调用者的方法名、参数、自己暴露的服务调用执行获取结果。Consumer 使用了代理，每次执行方法，都会调用 invoke() 即将调用的方法名、参数、调用的接口传递给 Provider。实现远程服务的本地代理。\n8. [\b参考的 GITHUB 地址](6)\n\n## 2.3 业界主流 RPC 框架\n\n1. Facebook 的 Apache Thrift。\n2. Hadoop 的 Avro-RPC。\n3. caucho 的 Hession。\n4. Google 的 gRPC。\n\n## 2.4 RPC 框架面临的挑战\n\n1. 提供服务的机器越来越多，服务 URL 配置管理变得非常困难（服务发布订阅中心）。\n2. 服务间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动（链路追踪）。\n3. 某个服务调用量特别大，需要加机器。为了解决容量规划问题，需要采集服务调用 KPI 数据，进行汇总和分析，计算出服务部署实例数和服务器的配置规格。\n4. 服务上线容易下线难，下线通知，需要统一的服务生命周期管理流程进行管控，如何保证敏感服务不被误调用，服务的访问安全策略又如何制定？\n5. 服务治理问题。\n\n# 3 SOA 服务化架构\n\nSOA 是一种粗粒度、松耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信。  \n\n## 3.1 面向服务设计的原则\n\n1. 服务可服用：不管是否存在即时复用的机会，服务均被设计为支持潜在的可复用。\n2. 服务共享一个标准契约：IDL 文件、Java 接口定义、甚至是一个接口说明文档。\n3. 服务是松耦合的：服务被设计为功能相对独立、尽量不依赖其它服务的独立功能提供者。\n4. 服务是底层逻辑的抽象：只有经服务契约所暴露的服务队外部世界可见，契约之外底层的实现逻辑是不可见的。\n5. 服务是可组合、可编排的：多个服务可能被编排组合成一个新的服务。\n6. 服务是可自治的：逻辑由服务所控制，并位于一个清晰的边界内，服务已经在边界内被控制，不依赖于其它服务。\n7. 服务是无状态的：这意味着要讲状态管理移至他处。\n8. 服务是可被自动发现的：服务发布上线后，允许被其它消费者自动发现。服务下线后，允许消费者接收服务下线通知。\n\n## 3.2 服务治理\n\nSOA 服务治理主要包括如下几个方面：\n1. 服务定义：SOA 治理最基础的方面就是监视服务的创建过程。\n2. 服务生命周期管理：服务需要进行规划、设计、实现、部署、维护、下线主要阶段。\n3. 服务版本治理：新版本的兼容性。\n4. 服务注册中心：服务提供者如何发布服务？服务消费者如何订阅服务？\n5. 服务监控：服务监控中心需要对服务的调用时延、成功率、吞吐率等数据进行实时采样和汇总。\n6. 运行期服务质量保障：包括服务限流、服务迁入迁出、服务升降级、服务权重调整和服务超时控制等，通过运行期的动态治理，可以在不重启服务的前提下达到快速提升服务运行质量的目标。\n7. 快速的故障定界定位手段：大规模分布式环境下海量业务/平台日志的采集、汇总和实时在线检索；分布式消息跟踪。\n8. 服务安全：是否允许任何人调用任何服务，数据敏感型服务是否允许所有用户访问所有数据，交互数据是否需要进行保护，服务的安全认证等。服务安全访问策略有多重，例如动态生成 Token 的方式做安全访问授权。\n\n# 4 微服务架构\n\n微服务架构（MSA）是一种服务化架构风格。  \nSOA 架构解决了应用服务化问题，但是随着服务规模越来越大、服务治理越来越多，微服务架构风格应运而生。微服务架构的主要特征如下：  \n1. 原子服务。\n2. 高密度部署：利用LXC（例如 Docker）实现容器级部署。\n3. 敏捷交付：服务由小研发团队负责设计、开发、测试、部署、线上治理、灰度发布和下线，运维整个生命周期支撑，实现真正的 DevOps。\n4. 微自治：服务足够小，功能单一，可以独立打包、部署、升级、回滚和弹性伸缩，不依赖其它服务，实现局部自治。\n\n相对于 SOA，主要差异如下：  \n1. 服务拆分粒度。\n2. 服务依赖：SOA 尽量重用，微服务功能单一独立。\n3. 服务规模：SOA 服务粒度大，多数会采用多个服务合并打 war 包，因此服务实例数比较有限。微服务强调尽可能拆分，同时很多服务会独立部署。\n4. 架构差异。\n5. 服务治理。\n6. 敏捷交付。\n\n# 5 个人理解总结 \n\n![][5]\n\n1. MVC架构：在于多个功能部署同一个进程，一个 war 包，通过 HTTP 请求来实现互相的调用。重点在于前后端分离。\n2. RPC架构：将核心和公共业务抽取出来，独立运行进程，使用 RPC 调用服务屏蔽底层通信逻辑。重点在于业务复用以及通用拆分。\n3. SOA架构：服务生命周期管控和SOA服务治理是关键。\n4. 微服务架构：敏捷开发、持续交付、DevOps理论，基于 Docker 等轻量级容器。重点在于独立打包、部署和升级，小团队敏捷交付，交付周期短。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_5.png\n\n[6]: https://github.com/LiWenGu/MySourceCode/tree/master/DubboDemo?1526581754181","slug":"distributed_principle_prictice/1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav3000taxs6bactihvx","content":"<h1 id=\"1-传统垂直应用架构\"><a href=\"#1-传统垂直应用架构\" class=\"headerlink\" title=\"1 传统垂直应用架构\"></a>1 传统垂直应用架构</h1><p>以经典的 MVC 垂直架构为例，通常分三层：  </p>\n<ol>\n<li>View：视图展示层，使用 JSP/JS/HTML+CSS。</li>\n<li>Controller：调度控制层，请求的分发。</li>\n<li>Model：应用模型层，业务数据和业务执行逻辑，被多个视图重用。</li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_1.png\" alt=\"\"></p>\n<p>标准的 MVC 模式并不包含数据访问层，但实际开发中需要专门的数据库连接池和统一的数据库访问接口对接数据库，于是 ORM 框架逐渐流行起来。  </p>\n<p>通常基于 MVC 架构开发的应用代码会统一打成一个 war 包，不同的应用功能之间通过本地 API 进行调用，基本不存在跨进程的远程服务调用。  </p>\n<p>通常的基于热双机备份，判断应用进程宕机或僵死后，应用切换备机，然后尝试重新拉起主机。<br>而在高并发、大流量的应用场景中，需要做集群，通常前端通过 F5 等负载均衡器做七层负载均衡，后端做对等集群部署。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_2.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_3.png\" alt=\"\"></p>\n<h1 id=\"2-RPC-架构\"><a href=\"#2-RPC-架构\" class=\"headerlink\" title=\"2 RPC 架构\"></a>2 RPC 架构</h1><p>RPC 全称 Remote Procedure Call，它是一种进程间通信方式。允许像调用本地服务一样调用远程服务，具体实现可以不同。</p>\n<h2 id=\"2-1-RPC-框架原理\"><a href=\"#2-1-RPC-框架原理\" class=\"headerlink\" title=\"2.1 RPC 框架原理\"></a>2.1 RPC 框架原理</h2><p>RPC 框架的目标就是让远程过程（服务）调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP/UDP）、序列化方式（XML/JSON/二进制）和通信细节。<br>调用原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_4.png\" alt=\"\">  </p>\n<ol>\n<li>远程服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构，或者中间态的服务定义文件，例如 Thrift 的 IDL 文件；服务调用者需要通过一定的途径获取远程服务调用相关信息，例如服务端接口定义 Jar 包导入，获取服务端 IDL 文件等。</li>\n<li>远程代理对象：服务调用者调用的服务实际是远程服务的本地代理，对于 Java 语言，它的实现就是 JDK 的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。</li>\n<li>通信：RPC 框架与具体的协议无关。</li>\n<li>序列化：远程通信，需要将对象转换成二进制码流进行网络传输，不同的序列化框架，支持的数据类型、数据包大小、异常类型及性能等都不同。有的甚至支持用户自定义序列化框架（Hadoop Avro）。</li>\n</ol>\n<h2 id=\"2-2-实现一个简单的-RPC-框架\"><a href=\"#2-2-实现一个简单的-RPC-框架\" class=\"headerlink\" title=\"2.2 实现一个简单的 RPC 框架\"></a>2.2 实现一个简单的 RPC 框架</h2><ol>\n<li>分四个聚合项目：Provider、Consumer、RpcFramework、ServiceApi。为了简单期间，RPC 核心和 ServiceApi 合并一个项目 C。</li>\n<li>Provider 依赖 C 项目，Consumer 依赖 C 项目。这样 Provider 和 Consumer 都有了同一个顶级接口以及同版本的 RPC 框架。</li>\n<li>RPC 框架提供 export() 用于 Provider 发布自己的实现类、refer() 用于 Consumer 调用对应的顶级接口。</li>\n<li>refer() 方法用于生成代理，此代理每次执行方法都会调用 invoke() 方法，而 invoke() 方法实际通过 socket 连接 Provider ，将调用的方法名、参数等传递给 Provider。</li>\n<li>export() 方法用于获取 Consumer 传递的方法名，参数等，以及自己暴露的接口实现类，来反射执行获取结果，并返回给 Consumer。</li>\n<li>代理对象获取到了结果，返回给调用者。</li>\n<li>Provider 使用了反射，用于将调用者的方法名、参数、自己暴露的服务调用执行获取结果。Consumer 使用了代理，每次执行方法，都会调用 invoke() 即将调用的方法名、参数、调用的接口传递给 Provider。实现远程服务的本地代理。</li>\n<li><a href=\"6\">\b参考的 GITHUB 地址</a></li>\n</ol>\n<h2 id=\"2-3-业界主流-RPC-框架\"><a href=\"#2-3-业界主流-RPC-框架\" class=\"headerlink\" title=\"2.3 业界主流 RPC 框架\"></a>2.3 业界主流 RPC 框架</h2><ol>\n<li>Facebook 的 Apache Thrift。</li>\n<li>Hadoop 的 Avro-RPC。</li>\n<li>caucho 的 Hession。</li>\n<li>Google 的 gRPC。</li>\n</ol>\n<h2 id=\"2-4-RPC-框架面临的挑战\"><a href=\"#2-4-RPC-框架面临的挑战\" class=\"headerlink\" title=\"2.4 RPC 框架面临的挑战\"></a>2.4 RPC 框架面临的挑战</h2><ol>\n<li>提供服务的机器越来越多，服务 URL 配置管理变得非常困难（服务发布订阅中心）。</li>\n<li>服务间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动（链路追踪）。</li>\n<li>某个服务调用量特别大，需要加机器。为了解决容量规划问题，需要采集服务调用 KPI 数据，进行汇总和分析，计算出服务部署实例数和服务器的配置规格。</li>\n<li>服务上线容易下线难，下线通知，需要统一的服务生命周期管理流程进行管控，如何保证敏感服务不被误调用，服务的访问安全策略又如何制定？</li>\n<li>服务治理问题。</li>\n</ol>\n<h1 id=\"3-SOA-服务化架构\"><a href=\"#3-SOA-服务化架构\" class=\"headerlink\" title=\"3 SOA 服务化架构\"></a>3 SOA 服务化架构</h1><p>SOA 是一种粗粒度、松耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信。  </p>\n<h2 id=\"3-1-面向服务设计的原则\"><a href=\"#3-1-面向服务设计的原则\" class=\"headerlink\" title=\"3.1 面向服务设计的原则\"></a>3.1 面向服务设计的原则</h2><ol>\n<li>服务可服用：不管是否存在即时复用的机会，服务均被设计为支持潜在的可复用。</li>\n<li>服务共享一个标准契约：IDL 文件、Java 接口定义、甚至是一个接口说明文档。</li>\n<li>服务是松耦合的：服务被设计为功能相对独立、尽量不依赖其它服务的独立功能提供者。</li>\n<li>服务是底层逻辑的抽象：只有经服务契约所暴露的服务队外部世界可见，契约之外底层的实现逻辑是不可见的。</li>\n<li>服务是可组合、可编排的：多个服务可能被编排组合成一个新的服务。</li>\n<li>服务是可自治的：逻辑由服务所控制，并位于一个清晰的边界内，服务已经在边界内被控制，不依赖于其它服务。</li>\n<li>服务是无状态的：这意味着要讲状态管理移至他处。</li>\n<li>服务是可被自动发现的：服务发布上线后，允许被其它消费者自动发现。服务下线后，允许消费者接收服务下线通知。</li>\n</ol>\n<h2 id=\"3-2-服务治理\"><a href=\"#3-2-服务治理\" class=\"headerlink\" title=\"3.2 服务治理\"></a>3.2 服务治理</h2><p>SOA 服务治理主要包括如下几个方面：</p>\n<ol>\n<li>服务定义：SOA 治理最基础的方面就是监视服务的创建过程。</li>\n<li>服务生命周期管理：服务需要进行规划、设计、实现、部署、维护、下线主要阶段。</li>\n<li>服务版本治理：新版本的兼容性。</li>\n<li>服务注册中心：服务提供者如何发布服务？服务消费者如何订阅服务？</li>\n<li>服务监控：服务监控中心需要对服务的调用时延、成功率、吞吐率等数据进行实时采样和汇总。</li>\n<li>运行期服务质量保障：包括服务限流、服务迁入迁出、服务升降级、服务权重调整和服务超时控制等，通过运行期的动态治理，可以在不重启服务的前提下达到快速提升服务运行质量的目标。</li>\n<li>快速的故障定界定位手段：大规模分布式环境下海量业务/平台日志的采集、汇总和实时在线检索；分布式消息跟踪。</li>\n<li>服务安全：是否允许任何人调用任何服务，数据敏感型服务是否允许所有用户访问所有数据，交互数据是否需要进行保护，服务的安全认证等。服务安全访问策略有多重，例如动态生成 Token 的方式做安全访问授权。</li>\n</ol>\n<h1 id=\"4-微服务架构\"><a href=\"#4-微服务架构\" class=\"headerlink\" title=\"4 微服务架构\"></a>4 微服务架构</h1><p>微服务架构（MSA）是一种服务化架构风格。<br>SOA 架构解决了应用服务化问题，但是随着服务规模越来越大、服务治理越来越多，微服务架构风格应运而生。微服务架构的主要特征如下：  </p>\n<ol>\n<li>原子服务。</li>\n<li>高密度部署：利用LXC（例如 Docker）实现容器级部署。</li>\n<li>敏捷交付：服务由小研发团队负责设计、开发、测试、部署、线上治理、灰度发布和下线，运维整个生命周期支撑，实现真正的 DevOps。</li>\n<li>微自治：服务足够小，功能单一，可以独立打包、部署、升级、回滚和弹性伸缩，不依赖其它服务，实现局部自治。</li>\n</ol>\n<p>相对于 SOA，主要差异如下：  </p>\n<ol>\n<li>服务拆分粒度。</li>\n<li>服务依赖：SOA 尽量重用，微服务功能单一独立。</li>\n<li>服务规模：SOA 服务粒度大，多数会采用多个服务合并打 war 包，因此服务实例数比较有限。微服务强调尽可能拆分，同时很多服务会独立部署。</li>\n<li>架构差异。</li>\n<li>服务治理。</li>\n<li>敏捷交付。</li>\n</ol>\n<h1 id=\"5-个人理解总结\"><a href=\"#5-个人理解总结\" class=\"headerlink\" title=\"5 个人理解总结\"></a>5 个人理解总结</h1><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_5.png\" alt=\"\"></p>\n<ol>\n<li>MVC架构：在于多个功能部署同一个进程，一个 war 包，通过 HTTP 请求来实现互相的调用。重点在于前后端分离。</li>\n<li>RPC架构：将核心和公共业务抽取出来，独立运行进程，使用 RPC 调用服务屏蔽底层通信逻辑。重点在于业务复用以及通用拆分。</li>\n<li>SOA架构：服务生命周期管控和SOA服务治理是关键。</li>\n<li>微服务架构：敏捷开发、持续交付、DevOps理论，基于 Docker 等轻量级容器。重点在于独立打包、部署和升级，小团队敏捷交付，交付周期短。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-传统垂直应用架构\"><a href=\"#1-传统垂直应用架构\" class=\"headerlink\" title=\"1 传统垂直应用架构\"></a>1 传统垂直应用架构</h1><p>以经典的 MVC 垂直架构为例，通常分三层：  </p>\n<ol>\n<li>View：视图展示层，使用 JSP/JS/HTML+CSS。</li>\n<li>Controller：调度控制层，请求的分发。</li>\n<li>Model：应用模型层，业务数据和业务执行逻辑，被多个视图重用。</li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_1.png\" alt=\"\"></p>\n<p>标准的 MVC 模式并不包含数据访问层，但实际开发中需要专门的数据库连接池和统一的数据库访问接口对接数据库，于是 ORM 框架逐渐流行起来。  </p>\n<p>通常基于 MVC 架构开发的应用代码会统一打成一个 war 包，不同的应用功能之间通过本地 API 进行调用，基本不存在跨进程的远程服务调用。  </p>\n<p>通常的基于热双机备份，判断应用进程宕机或僵死后，应用切换备机，然后尝试重新拉起主机。<br>而在高并发、大流量的应用场景中，需要做集群，通常前端通过 F5 等负载均衡器做七层负载均衡，后端做对等集群部署。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_2.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_3.png\" alt=\"\"></p>\n<h1 id=\"2-RPC-架构\"><a href=\"#2-RPC-架构\" class=\"headerlink\" title=\"2 RPC 架构\"></a>2 RPC 架构</h1><p>RPC 全称 Remote Procedure Call，它是一种进程间通信方式。允许像调用本地服务一样调用远程服务，具体实现可以不同。</p>\n<h2 id=\"2-1-RPC-框架原理\"><a href=\"#2-1-RPC-框架原理\" class=\"headerlink\" title=\"2.1 RPC 框架原理\"></a>2.1 RPC 框架原理</h2><p>RPC 框架的目标就是让远程过程（服务）调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP/UDP）、序列化方式（XML/JSON/二进制）和通信细节。<br>调用原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_4.png\" alt=\"\">  </p>\n<ol>\n<li>远程服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构，或者中间态的服务定义文件，例如 Thrift 的 IDL 文件；服务调用者需要通过一定的途径获取远程服务调用相关信息，例如服务端接口定义 Jar 包导入，获取服务端 IDL 文件等。</li>\n<li>远程代理对象：服务调用者调用的服务实际是远程服务的本地代理，对于 Java 语言，它的实现就是 JDK 的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。</li>\n<li>通信：RPC 框架与具体的协议无关。</li>\n<li>序列化：远程通信，需要将对象转换成二进制码流进行网络传输，不同的序列化框架，支持的数据类型、数据包大小、异常类型及性能等都不同。有的甚至支持用户自定义序列化框架（Hadoop Avro）。</li>\n</ol>\n<h2 id=\"2-2-实现一个简单的-RPC-框架\"><a href=\"#2-2-实现一个简单的-RPC-框架\" class=\"headerlink\" title=\"2.2 实现一个简单的 RPC 框架\"></a>2.2 实现一个简单的 RPC 框架</h2><ol>\n<li>分四个聚合项目：Provider、Consumer、RpcFramework、ServiceApi。为了简单期间，RPC 核心和 ServiceApi 合并一个项目 C。</li>\n<li>Provider 依赖 C 项目，Consumer 依赖 C 项目。这样 Provider 和 Consumer 都有了同一个顶级接口以及同版本的 RPC 框架。</li>\n<li>RPC 框架提供 export() 用于 Provider 发布自己的实现类、refer() 用于 Consumer 调用对应的顶级接口。</li>\n<li>refer() 方法用于生成代理，此代理每次执行方法都会调用 invoke() 方法，而 invoke() 方法实际通过 socket 连接 Provider ，将调用的方法名、参数等传递给 Provider。</li>\n<li>export() 方法用于获取 Consumer 传递的方法名，参数等，以及自己暴露的接口实现类，来反射执行获取结果，并返回给 Consumer。</li>\n<li>代理对象获取到了结果，返回给调用者。</li>\n<li>Provider 使用了反射，用于将调用者的方法名、参数、自己暴露的服务调用执行获取结果。Consumer 使用了代理，每次执行方法，都会调用 invoke() 即将调用的方法名、参数、调用的接口传递给 Provider。实现远程服务的本地代理。</li>\n<li><a href=\"6\">\b参考的 GITHUB 地址</a></li>\n</ol>\n<h2 id=\"2-3-业界主流-RPC-框架\"><a href=\"#2-3-业界主流-RPC-框架\" class=\"headerlink\" title=\"2.3 业界主流 RPC 框架\"></a>2.3 业界主流 RPC 框架</h2><ol>\n<li>Facebook 的 Apache Thrift。</li>\n<li>Hadoop 的 Avro-RPC。</li>\n<li>caucho 的 Hession。</li>\n<li>Google 的 gRPC。</li>\n</ol>\n<h2 id=\"2-4-RPC-框架面临的挑战\"><a href=\"#2-4-RPC-框架面临的挑战\" class=\"headerlink\" title=\"2.4 RPC 框架面临的挑战\"></a>2.4 RPC 框架面临的挑战</h2><ol>\n<li>提供服务的机器越来越多，服务 URL 配置管理变得非常困难（服务发布订阅中心）。</li>\n<li>服务间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动（链路追踪）。</li>\n<li>某个服务调用量特别大，需要加机器。为了解决容量规划问题，需要采集服务调用 KPI 数据，进行汇总和分析，计算出服务部署实例数和服务器的配置规格。</li>\n<li>服务上线容易下线难，下线通知，需要统一的服务生命周期管理流程进行管控，如何保证敏感服务不被误调用，服务的访问安全策略又如何制定？</li>\n<li>服务治理问题。</li>\n</ol>\n<h1 id=\"3-SOA-服务化架构\"><a href=\"#3-SOA-服务化架构\" class=\"headerlink\" title=\"3 SOA 服务化架构\"></a>3 SOA 服务化架构</h1><p>SOA 是一种粗粒度、松耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信。  </p>\n<h2 id=\"3-1-面向服务设计的原则\"><a href=\"#3-1-面向服务设计的原则\" class=\"headerlink\" title=\"3.1 面向服务设计的原则\"></a>3.1 面向服务设计的原则</h2><ol>\n<li>服务可服用：不管是否存在即时复用的机会，服务均被设计为支持潜在的可复用。</li>\n<li>服务共享一个标准契约：IDL 文件、Java 接口定义、甚至是一个接口说明文档。</li>\n<li>服务是松耦合的：服务被设计为功能相对独立、尽量不依赖其它服务的独立功能提供者。</li>\n<li>服务是底层逻辑的抽象：只有经服务契约所暴露的服务队外部世界可见，契约之外底层的实现逻辑是不可见的。</li>\n<li>服务是可组合、可编排的：多个服务可能被编排组合成一个新的服务。</li>\n<li>服务是可自治的：逻辑由服务所控制，并位于一个清晰的边界内，服务已经在边界内被控制，不依赖于其它服务。</li>\n<li>服务是无状态的：这意味着要讲状态管理移至他处。</li>\n<li>服务是可被自动发现的：服务发布上线后，允许被其它消费者自动发现。服务下线后，允许消费者接收服务下线通知。</li>\n</ol>\n<h2 id=\"3-2-服务治理\"><a href=\"#3-2-服务治理\" class=\"headerlink\" title=\"3.2 服务治理\"></a>3.2 服务治理</h2><p>SOA 服务治理主要包括如下几个方面：</p>\n<ol>\n<li>服务定义：SOA 治理最基础的方面就是监视服务的创建过程。</li>\n<li>服务生命周期管理：服务需要进行规划、设计、实现、部署、维护、下线主要阶段。</li>\n<li>服务版本治理：新版本的兼容性。</li>\n<li>服务注册中心：服务提供者如何发布服务？服务消费者如何订阅服务？</li>\n<li>服务监控：服务监控中心需要对服务的调用时延、成功率、吞吐率等数据进行实时采样和汇总。</li>\n<li>运行期服务质量保障：包括服务限流、服务迁入迁出、服务升降级、服务权重调整和服务超时控制等，通过运行期的动态治理，可以在不重启服务的前提下达到快速提升服务运行质量的目标。</li>\n<li>快速的故障定界定位手段：大规模分布式环境下海量业务/平台日志的采集、汇总和实时在线检索；分布式消息跟踪。</li>\n<li>服务安全：是否允许任何人调用任何服务，数据敏感型服务是否允许所有用户访问所有数据，交互数据是否需要进行保护，服务的安全认证等。服务安全访问策略有多重，例如动态生成 Token 的方式做安全访问授权。</li>\n</ol>\n<h1 id=\"4-微服务架构\"><a href=\"#4-微服务架构\" class=\"headerlink\" title=\"4 微服务架构\"></a>4 微服务架构</h1><p>微服务架构（MSA）是一种服务化架构风格。<br>SOA 架构解决了应用服务化问题，但是随着服务规模越来越大、服务治理越来越多，微服务架构风格应运而生。微服务架构的主要特征如下：  </p>\n<ol>\n<li>原子服务。</li>\n<li>高密度部署：利用LXC（例如 Docker）实现容器级部署。</li>\n<li>敏捷交付：服务由小研发团队负责设计、开发、测试、部署、线上治理、灰度发布和下线，运维整个生命周期支撑，实现真正的 DevOps。</li>\n<li>微自治：服务足够小，功能单一，可以独立打包、部署、升级、回滚和弹性伸缩，不依赖其它服务，实现局部自治。</li>\n</ol>\n<p>相对于 SOA，主要差异如下：  </p>\n<ol>\n<li>服务拆分粒度。</li>\n<li>服务依赖：SOA 尽量重用，微服务功能单一独立。</li>\n<li>服务规模：SOA 服务粒度大，多数会采用多个服务合并打 war 包，因此服务实例数比较有限。微服务强调尽可能拆分，同时很多服务会独立部署。</li>\n<li>架构差异。</li>\n<li>服务治理。</li>\n<li>敏捷交付。</li>\n</ol>\n<h1 id=\"5-个人理解总结\"><a href=\"#5-个人理解总结\" class=\"headerlink\" title=\"5 个人理解总结\"></a>5 个人理解总结</h1><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_5.png\" alt=\"\"></p>\n<ol>\n<li>MVC架构：在于多个功能部署同一个进程，一个 war 包，通过 HTTP 请求来实现互相的调用。重点在于前后端分离。</li>\n<li>RPC架构：将核心和公共业务抽取出来，独立运行进程，使用 RPC 调用服务屏蔽底层通信逻辑。重点在于业务复用以及通用拆分。</li>\n<li>SOA架构：服务生命周期管控和SOA服务治理是关键。</li>\n<li>微服务架构：敏捷开发、持续交付、DevOps理论，基于 Docker 等轻量级容器。重点在于独立打包、部署和升级，小团队敏捷交付，交付周期短。</li>\n</ol>\n"},{"title":"九、服务注册中心","date":"2018-06-02T04:10:00.000Z","updated":"2018-06-02T04:10:00.000Z","comments":1,"_content":"\n# 1 几个概念\n\n## 1.1 服务提供者\n\n## 1.2 服务消费者\n\n## 1.3 服务注册中心\n\n服务注册中心是分布式服务框架的目录服务器，相比于传统的目录服务器，它有如下几个特点：  \n1. 高 HA：支持数据持久化、支持集群。\n2. 数据一致性问题：集群中所有的客户端应该看到同一份数据，不能出现读或者写数据不一致。\n3. 数据变更主动推送：当注册中心的数据发生变更时（增加、删除、修改）需要能够及时将变化的数据通知给客户端。\n\n# 2 关键功能特性设计\n\n服务注册中心的工作原理如下：  \n![][1]  \n1. 服务提供者在启动时，根据服务发布文件中配置的服务发布信息向注册中心注册自己提供的服务。\n2. 服务消费者在启动时，根据消费者配置文件中配置的服务消费信息向注册中心订阅自己所需的服务，消费者刷新本地缓存的路由表。\n3. 注册中心返回服务提供者地址列表，如果有变更，注册中心主动推送变更数据给消费者，消费者刷新本地缓存的路由表。\n4. 服务消费者从本地缓存的服务提供者地址列表中，基于负载均衡算法选择一台服务提供者进行调用。\n\n## 2.1 支持对等集群\n\n服务注册中心需要支持对等集群，如下图，其中某一个或者多个服务注册中心进程宕机，不会导致服务注册中心集群功能不可用。  \n![][2]  \n对于客户端，无论服务注册中心集群配置多少个进程，客户端只需要连接其中某一个即可（服务端之间自己进行数据同步），如下图：  \n![][3]\n\n## 2.2 提供 CRUD 接口\n\n客户端连接服务注册中心之后，需要能够对服务注册中心的数据进行操作：\n1. 查询接口：查询系统当前发布的服务信息和订阅的消费者信息。\n2. 修改接口：修改已经发布的服务属性或者消费者属性信息，通常用于运行态的服务治理。\n3. 新增接口：发布或者订阅新的服务。\n4. 删除接口：去注册已经发布的服务，或者消费者取消订阅关系。\n\n## 2.3 安全加固\n\n服务注册中心需要进行安全加固，安全加固主要涉及两部分：  \n1. 链路的安全性。\n2. 数据的安全性。\n  \n链路的安全性指的是服务注册中心对客户端连接进行安全认证，认证策略非常多，最简单的就是基于 IP地址的黑名单校验，更加复杂的有基于用户名+密码的认证，或者基于秘钥+数字证书的认证。  \n认证失败，则关闭链路，拒绝客户端连接。  \n  \n数据的安全性主要针对服务注册中心的数据进行权限控制：  \n1. 非授权客户端既不能读取也不能写入数据。\n2. 普通运维人员只能读取数据，不能修改数据。\n3. 管理员既可以读取也可以修改数据。\n4. 不同的服务目录可以设置不同的访问权限，例如消费者只能查看它所在机房的服务。\n数据安全性工作原理如下：  \n![][4]\n\n## 2.4 订阅发布机制\n\n对于服务提供者，可以根据服务名等信息动态发布服务；对于消费者，可以根据订阅关系主动获得服务发布者的地址信息等。订阅发布机制还有一个比较重要的机制就是对变化的监听和主动推送能力：\n1. 消费者可以监听一个或者多个服务目录，当目录名称、内容发生变更时，消费者可以实时地获得变更的数据或者变更后的结果信息。\n2. 服务提供者可以发布一个或者多个服务，动态修改服务名称、服务内容等，可以主动将修改后的数据或者修改后的结果推送给所有监听此服务目录的消费者。  \n订阅发布机制有如下优点：  \n1. 透明化路由：服务提供者和消费者互相解耦，服务提供者未知透明，消费者不需要再硬编码服务提供者地址。\n2. 服务健康状态监测：服务注册中心可以实时监测发布服务的质量，如果服务提供者宕机，由服务注册中心实时通知消费者。\n3. 弹性伸缩能力（动态发现）：应用在云端部署之后，由于 VM资源占用率过高，动态伸展出一个新的服务提供者，服务注册中心会将新增的服务提供者地址信息推送给消费者，消费者刷新本地路由表之后可以访问新的服务提供者，实现服务的弹性伸缩。\n\n## 2.3 可靠性\n\n服务注册中心需要支持对等集群，任意一台宕机后，服务都能自动切换到其它正常的服务注册中心。  \n如果服务注册中心全部宕机，只影响新的服务注册、已发布服务的下线。（想想为什么）  \n服务提供者的健康状态监测也由服务注册中心负责监测，通过长连接心跳检测服务提供者的存在，宕机则实时推送消息，实现实时故障隔离。\n\n# 3 基于 ZooKeeper 的服务注册中心设计\n\n## 3.1 服务订阅发布流程设计\n\n流程设计如下图：  \n![][5]\n\n## 3.2 服务健康状态监测\n\n基于 ZK 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态监测。\n\n## 3.3 对等集群防止单点故障\n\nZK 使用了原子广播（恢复服务和广播服务）实现故障转移以及同步。\n\n# 4 个人总结\n\n服务注册中心要保证可靠性、安全性、可扩展性。ZK 是常用的技术。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_5.png","source":"_posts/分布式服务框架原理与实践/第九章 服务注册中心.md","raw":"---\ntitle: 九、服务注册中心\ndate: 2018-06-02 12:10:00\nupdated: 2018-06-02 12:10:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/9.html    \n---\n\n# 1 几个概念\n\n## 1.1 服务提供者\n\n## 1.2 服务消费者\n\n## 1.3 服务注册中心\n\n服务注册中心是分布式服务框架的目录服务器，相比于传统的目录服务器，它有如下几个特点：  \n1. 高 HA：支持数据持久化、支持集群。\n2. 数据一致性问题：集群中所有的客户端应该看到同一份数据，不能出现读或者写数据不一致。\n3. 数据变更主动推送：当注册中心的数据发生变更时（增加、删除、修改）需要能够及时将变化的数据通知给客户端。\n\n# 2 关键功能特性设计\n\n服务注册中心的工作原理如下：  \n![][1]  \n1. 服务提供者在启动时，根据服务发布文件中配置的服务发布信息向注册中心注册自己提供的服务。\n2. 服务消费者在启动时，根据消费者配置文件中配置的服务消费信息向注册中心订阅自己所需的服务，消费者刷新本地缓存的路由表。\n3. 注册中心返回服务提供者地址列表，如果有变更，注册中心主动推送变更数据给消费者，消费者刷新本地缓存的路由表。\n4. 服务消费者从本地缓存的服务提供者地址列表中，基于负载均衡算法选择一台服务提供者进行调用。\n\n## 2.1 支持对等集群\n\n服务注册中心需要支持对等集群，如下图，其中某一个或者多个服务注册中心进程宕机，不会导致服务注册中心集群功能不可用。  \n![][2]  \n对于客户端，无论服务注册中心集群配置多少个进程，客户端只需要连接其中某一个即可（服务端之间自己进行数据同步），如下图：  \n![][3]\n\n## 2.2 提供 CRUD 接口\n\n客户端连接服务注册中心之后，需要能够对服务注册中心的数据进行操作：\n1. 查询接口：查询系统当前发布的服务信息和订阅的消费者信息。\n2. 修改接口：修改已经发布的服务属性或者消费者属性信息，通常用于运行态的服务治理。\n3. 新增接口：发布或者订阅新的服务。\n4. 删除接口：去注册已经发布的服务，或者消费者取消订阅关系。\n\n## 2.3 安全加固\n\n服务注册中心需要进行安全加固，安全加固主要涉及两部分：  \n1. 链路的安全性。\n2. 数据的安全性。\n  \n链路的安全性指的是服务注册中心对客户端连接进行安全认证，认证策略非常多，最简单的就是基于 IP地址的黑名单校验，更加复杂的有基于用户名+密码的认证，或者基于秘钥+数字证书的认证。  \n认证失败，则关闭链路，拒绝客户端连接。  \n  \n数据的安全性主要针对服务注册中心的数据进行权限控制：  \n1. 非授权客户端既不能读取也不能写入数据。\n2. 普通运维人员只能读取数据，不能修改数据。\n3. 管理员既可以读取也可以修改数据。\n4. 不同的服务目录可以设置不同的访问权限，例如消费者只能查看它所在机房的服务。\n数据安全性工作原理如下：  \n![][4]\n\n## 2.4 订阅发布机制\n\n对于服务提供者，可以根据服务名等信息动态发布服务；对于消费者，可以根据订阅关系主动获得服务发布者的地址信息等。订阅发布机制还有一个比较重要的机制就是对变化的监听和主动推送能力：\n1. 消费者可以监听一个或者多个服务目录，当目录名称、内容发生变更时，消费者可以实时地获得变更的数据或者变更后的结果信息。\n2. 服务提供者可以发布一个或者多个服务，动态修改服务名称、服务内容等，可以主动将修改后的数据或者修改后的结果推送给所有监听此服务目录的消费者。  \n订阅发布机制有如下优点：  \n1. 透明化路由：服务提供者和消费者互相解耦，服务提供者未知透明，消费者不需要再硬编码服务提供者地址。\n2. 服务健康状态监测：服务注册中心可以实时监测发布服务的质量，如果服务提供者宕机，由服务注册中心实时通知消费者。\n3. 弹性伸缩能力（动态发现）：应用在云端部署之后，由于 VM资源占用率过高，动态伸展出一个新的服务提供者，服务注册中心会将新增的服务提供者地址信息推送给消费者，消费者刷新本地路由表之后可以访问新的服务提供者，实现服务的弹性伸缩。\n\n## 2.3 可靠性\n\n服务注册中心需要支持对等集群，任意一台宕机后，服务都能自动切换到其它正常的服务注册中心。  \n如果服务注册中心全部宕机，只影响新的服务注册、已发布服务的下线。（想想为什么）  \n服务提供者的健康状态监测也由服务注册中心负责监测，通过长连接心跳检测服务提供者的存在，宕机则实时推送消息，实现实时故障隔离。\n\n# 3 基于 ZooKeeper 的服务注册中心设计\n\n## 3.1 服务订阅发布流程设计\n\n流程设计如下图：  \n![][5]\n\n## 3.2 服务健康状态监测\n\n基于 ZK 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态监测。\n\n## 3.3 对等集群防止单点故障\n\nZK 使用了原子广播（恢复服务和广播服务）实现故障转移以及同步。\n\n# 4 个人总结\n\n服务注册中心要保证可靠性、安全性、可扩展性。ZK 是常用的技术。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_5.png","slug":"distributed_principle_prictice/9.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav4000waxs6ilp7hzwu","content":"<h1 id=\"1-几个概念\"><a href=\"#1-几个概念\" class=\"headerlink\" title=\"1 几个概念\"></a>1 几个概念</h1><h2 id=\"1-1-服务提供者\"><a href=\"#1-1-服务提供者\" class=\"headerlink\" title=\"1.1 服务提供者\"></a>1.1 服务提供者</h2><h2 id=\"1-2-服务消费者\"><a href=\"#1-2-服务消费者\" class=\"headerlink\" title=\"1.2 服务消费者\"></a>1.2 服务消费者</h2><h2 id=\"1-3-服务注册中心\"><a href=\"#1-3-服务注册中心\" class=\"headerlink\" title=\"1.3 服务注册中心\"></a>1.3 服务注册中心</h2><p>服务注册中心是分布式服务框架的目录服务器，相比于传统的目录服务器，它有如下几个特点：  </p>\n<ol>\n<li>高 HA：支持数据持久化、支持集群。</li>\n<li>数据一致性问题：集群中所有的客户端应该看到同一份数据，不能出现读或者写数据不一致。</li>\n<li>数据变更主动推送：当注册中心的数据发生变更时（增加、删除、修改）需要能够及时将变化的数据通知给客户端。</li>\n</ol>\n<h1 id=\"2-关键功能特性设计\"><a href=\"#2-关键功能特性设计\" class=\"headerlink\" title=\"2 关键功能特性设计\"></a>2 关键功能特性设计</h1><p>服务注册中心的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_1.png\" alt=\"\">  </p>\n<ol>\n<li>服务提供者在启动时，根据服务发布文件中配置的服务发布信息向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，根据消费者配置文件中配置的服务消费信息向注册中心订阅自己所需的服务，消费者刷新本地缓存的路由表。</li>\n<li>注册中心返回服务提供者地址列表，如果有变更，注册中心主动推送变更数据给消费者，消费者刷新本地缓存的路由表。</li>\n<li>服务消费者从本地缓存的服务提供者地址列表中，基于负载均衡算法选择一台服务提供者进行调用。</li>\n</ol>\n<h2 id=\"2-1-支持对等集群\"><a href=\"#2-1-支持对等集群\" class=\"headerlink\" title=\"2.1 支持对等集群\"></a>2.1 支持对等集群</h2><p>服务注册中心需要支持对等集群，如下图，其中某一个或者多个服务注册中心进程宕机，不会导致服务注册中心集群功能不可用。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_2.png\" alt=\"\"><br>对于客户端，无论服务注册中心集群配置多少个进程，客户端只需要连接其中某一个即可（服务端之间自己进行数据同步），如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_3.png\" alt=\"\"></p>\n<h2 id=\"2-2-提供-CRUD-接口\"><a href=\"#2-2-提供-CRUD-接口\" class=\"headerlink\" title=\"2.2 提供 CRUD 接口\"></a>2.2 提供 CRUD 接口</h2><p>客户端连接服务注册中心之后，需要能够对服务注册中心的数据进行操作：</p>\n<ol>\n<li>查询接口：查询系统当前发布的服务信息和订阅的消费者信息。</li>\n<li>修改接口：修改已经发布的服务属性或者消费者属性信息，通常用于运行态的服务治理。</li>\n<li>新增接口：发布或者订阅新的服务。</li>\n<li>删除接口：去注册已经发布的服务，或者消费者取消订阅关系。</li>\n</ol>\n<h2 id=\"2-3-安全加固\"><a href=\"#2-3-安全加固\" class=\"headerlink\" title=\"2.3 安全加固\"></a>2.3 安全加固</h2><p>服务注册中心需要进行安全加固，安全加固主要涉及两部分：  </p>\n<ol>\n<li>链路的安全性。</li>\n<li>数据的安全性。</li>\n</ol>\n<p>链路的安全性指的是服务注册中心对客户端连接进行安全认证，认证策略非常多，最简单的就是基于 IP地址的黑名单校验，更加复杂的有基于用户名+密码的认证，或者基于秘钥+数字证书的认证。<br>认证失败，则关闭链路，拒绝客户端连接。  </p>\n<p>数据的安全性主要针对服务注册中心的数据进行权限控制：  </p>\n<ol>\n<li>非授权客户端既不能读取也不能写入数据。</li>\n<li>普通运维人员只能读取数据，不能修改数据。</li>\n<li>管理员既可以读取也可以修改数据。</li>\n<li>不同的服务目录可以设置不同的访问权限，例如消费者只能查看它所在机房的服务。<br>数据安全性工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_4.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"2-4-订阅发布机制\"><a href=\"#2-4-订阅发布机制\" class=\"headerlink\" title=\"2.4 订阅发布机制\"></a>2.4 订阅发布机制</h2><p>对于服务提供者，可以根据服务名等信息动态发布服务；对于消费者，可以根据订阅关系主动获得服务发布者的地址信息等。订阅发布机制还有一个比较重要的机制就是对变化的监听和主动推送能力：</p>\n<ol>\n<li>消费者可以监听一个或者多个服务目录，当目录名称、内容发生变更时，消费者可以实时地获得变更的数据或者变更后的结果信息。</li>\n<li>服务提供者可以发布一个或者多个服务，动态修改服务名称、服务内容等，可以主动将修改后的数据或者修改后的结果推送给所有监听此服务目录的消费者。<br>订阅发布机制有如下优点：  </li>\n<li>透明化路由：服务提供者和消费者互相解耦，服务提供者未知透明，消费者不需要再硬编码服务提供者地址。</li>\n<li>服务健康状态监测：服务注册中心可以实时监测发布服务的质量，如果服务提供者宕机，由服务注册中心实时通知消费者。</li>\n<li>弹性伸缩能力（动态发现）：应用在云端部署之后，由于 VM资源占用率过高，动态伸展出一个新的服务提供者，服务注册中心会将新增的服务提供者地址信息推送给消费者，消费者刷新本地路由表之后可以访问新的服务提供者，实现服务的弹性伸缩。</li>\n</ol>\n<h2 id=\"2-3-可靠性\"><a href=\"#2-3-可靠性\" class=\"headerlink\" title=\"2.3 可靠性\"></a>2.3 可靠性</h2><p>服务注册中心需要支持对等集群，任意一台宕机后，服务都能自动切换到其它正常的服务注册中心。<br>如果服务注册中心全部宕机，只影响新的服务注册、已发布服务的下线。（想想为什么）<br>服务提供者的健康状态监测也由服务注册中心负责监测，通过长连接心跳检测服务提供者的存在，宕机则实时推送消息，实现实时故障隔离。</p>\n<h1 id=\"3-基于-ZooKeeper-的服务注册中心设计\"><a href=\"#3-基于-ZooKeeper-的服务注册中心设计\" class=\"headerlink\" title=\"3 基于 ZooKeeper 的服务注册中心设计\"></a>3 基于 ZooKeeper 的服务注册中心设计</h1><h2 id=\"3-1-服务订阅发布流程设计\"><a href=\"#3-1-服务订阅发布流程设计\" class=\"headerlink\" title=\"3.1 服务订阅发布流程设计\"></a>3.1 服务订阅发布流程设计</h2><p>流程设计如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_5.png\" alt=\"\"></p>\n<h2 id=\"3-2-服务健康状态监测\"><a href=\"#3-2-服务健康状态监测\" class=\"headerlink\" title=\"3.2 服务健康状态监测\"></a>3.2 服务健康状态监测</h2><p>基于 ZK 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态监测。</p>\n<h2 id=\"3-3-对等集群防止单点故障\"><a href=\"#3-3-对等集群防止单点故障\" class=\"headerlink\" title=\"3.3 对等集群防止单点故障\"></a>3.3 对等集群防止单点故障</h2><p>ZK 使用了原子广播（恢复服务和广播服务）实现故障转移以及同步。</p>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>服务注册中心要保证可靠性、安全性、可扩展性。ZK 是常用的技术。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-几个概念\"><a href=\"#1-几个概念\" class=\"headerlink\" title=\"1 几个概念\"></a>1 几个概念</h1><h2 id=\"1-1-服务提供者\"><a href=\"#1-1-服务提供者\" class=\"headerlink\" title=\"1.1 服务提供者\"></a>1.1 服务提供者</h2><h2 id=\"1-2-服务消费者\"><a href=\"#1-2-服务消费者\" class=\"headerlink\" title=\"1.2 服务消费者\"></a>1.2 服务消费者</h2><h2 id=\"1-3-服务注册中心\"><a href=\"#1-3-服务注册中心\" class=\"headerlink\" title=\"1.3 服务注册中心\"></a>1.3 服务注册中心</h2><p>服务注册中心是分布式服务框架的目录服务器，相比于传统的目录服务器，它有如下几个特点：  </p>\n<ol>\n<li>高 HA：支持数据持久化、支持集群。</li>\n<li>数据一致性问题：集群中所有的客户端应该看到同一份数据，不能出现读或者写数据不一致。</li>\n<li>数据变更主动推送：当注册中心的数据发生变更时（增加、删除、修改）需要能够及时将变化的数据通知给客户端。</li>\n</ol>\n<h1 id=\"2-关键功能特性设计\"><a href=\"#2-关键功能特性设计\" class=\"headerlink\" title=\"2 关键功能特性设计\"></a>2 关键功能特性设计</h1><p>服务注册中心的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_1.png\" alt=\"\">  </p>\n<ol>\n<li>服务提供者在启动时，根据服务发布文件中配置的服务发布信息向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，根据消费者配置文件中配置的服务消费信息向注册中心订阅自己所需的服务，消费者刷新本地缓存的路由表。</li>\n<li>注册中心返回服务提供者地址列表，如果有变更，注册中心主动推送变更数据给消费者，消费者刷新本地缓存的路由表。</li>\n<li>服务消费者从本地缓存的服务提供者地址列表中，基于负载均衡算法选择一台服务提供者进行调用。</li>\n</ol>\n<h2 id=\"2-1-支持对等集群\"><a href=\"#2-1-支持对等集群\" class=\"headerlink\" title=\"2.1 支持对等集群\"></a>2.1 支持对等集群</h2><p>服务注册中心需要支持对等集群，如下图，其中某一个或者多个服务注册中心进程宕机，不会导致服务注册中心集群功能不可用。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_2.png\" alt=\"\"><br>对于客户端，无论服务注册中心集群配置多少个进程，客户端只需要连接其中某一个即可（服务端之间自己进行数据同步），如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_3.png\" alt=\"\"></p>\n<h2 id=\"2-2-提供-CRUD-接口\"><a href=\"#2-2-提供-CRUD-接口\" class=\"headerlink\" title=\"2.2 提供 CRUD 接口\"></a>2.2 提供 CRUD 接口</h2><p>客户端连接服务注册中心之后，需要能够对服务注册中心的数据进行操作：</p>\n<ol>\n<li>查询接口：查询系统当前发布的服务信息和订阅的消费者信息。</li>\n<li>修改接口：修改已经发布的服务属性或者消费者属性信息，通常用于运行态的服务治理。</li>\n<li>新增接口：发布或者订阅新的服务。</li>\n<li>删除接口：去注册已经发布的服务，或者消费者取消订阅关系。</li>\n</ol>\n<h2 id=\"2-3-安全加固\"><a href=\"#2-3-安全加固\" class=\"headerlink\" title=\"2.3 安全加固\"></a>2.3 安全加固</h2><p>服务注册中心需要进行安全加固，安全加固主要涉及两部分：  </p>\n<ol>\n<li>链路的安全性。</li>\n<li>数据的安全性。</li>\n</ol>\n<p>链路的安全性指的是服务注册中心对客户端连接进行安全认证，认证策略非常多，最简单的就是基于 IP地址的黑名单校验，更加复杂的有基于用户名+密码的认证，或者基于秘钥+数字证书的认证。<br>认证失败，则关闭链路，拒绝客户端连接。  </p>\n<p>数据的安全性主要针对服务注册中心的数据进行权限控制：  </p>\n<ol>\n<li>非授权客户端既不能读取也不能写入数据。</li>\n<li>普通运维人员只能读取数据，不能修改数据。</li>\n<li>管理员既可以读取也可以修改数据。</li>\n<li>不同的服务目录可以设置不同的访问权限，例如消费者只能查看它所在机房的服务。<br>数据安全性工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_4.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"2-4-订阅发布机制\"><a href=\"#2-4-订阅发布机制\" class=\"headerlink\" title=\"2.4 订阅发布机制\"></a>2.4 订阅发布机制</h2><p>对于服务提供者，可以根据服务名等信息动态发布服务；对于消费者，可以根据订阅关系主动获得服务发布者的地址信息等。订阅发布机制还有一个比较重要的机制就是对变化的监听和主动推送能力：</p>\n<ol>\n<li>消费者可以监听一个或者多个服务目录，当目录名称、内容发生变更时，消费者可以实时地获得变更的数据或者变更后的结果信息。</li>\n<li>服务提供者可以发布一个或者多个服务，动态修改服务名称、服务内容等，可以主动将修改后的数据或者修改后的结果推送给所有监听此服务目录的消费者。<br>订阅发布机制有如下优点：  </li>\n<li>透明化路由：服务提供者和消费者互相解耦，服务提供者未知透明，消费者不需要再硬编码服务提供者地址。</li>\n<li>服务健康状态监测：服务注册中心可以实时监测发布服务的质量，如果服务提供者宕机，由服务注册中心实时通知消费者。</li>\n<li>弹性伸缩能力（动态发现）：应用在云端部署之后，由于 VM资源占用率过高，动态伸展出一个新的服务提供者，服务注册中心会将新增的服务提供者地址信息推送给消费者，消费者刷新本地路由表之后可以访问新的服务提供者，实现服务的弹性伸缩。</li>\n</ol>\n<h2 id=\"2-3-可靠性\"><a href=\"#2-3-可靠性\" class=\"headerlink\" title=\"2.3 可靠性\"></a>2.3 可靠性</h2><p>服务注册中心需要支持对等集群，任意一台宕机后，服务都能自动切换到其它正常的服务注册中心。<br>如果服务注册中心全部宕机，只影响新的服务注册、已发布服务的下线。（想想为什么）<br>服务提供者的健康状态监测也由服务注册中心负责监测，通过长连接心跳检测服务提供者的存在，宕机则实时推送消息，实现实时故障隔离。</p>\n<h1 id=\"3-基于-ZooKeeper-的服务注册中心设计\"><a href=\"#3-基于-ZooKeeper-的服务注册中心设计\" class=\"headerlink\" title=\"3 基于 ZooKeeper 的服务注册中心设计\"></a>3 基于 ZooKeeper 的服务注册中心设计</h1><h2 id=\"3-1-服务订阅发布流程设计\"><a href=\"#3-1-服务订阅发布流程设计\" class=\"headerlink\" title=\"3.1 服务订阅发布流程设计\"></a>3.1 服务订阅发布流程设计</h2><p>流程设计如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_5.png\" alt=\"\"></p>\n<h2 id=\"3-2-服务健康状态监测\"><a href=\"#3-2-服务健康状态监测\" class=\"headerlink\" title=\"3.2 服务健康状态监测\"></a>3.2 服务健康状态监测</h2><p>基于 ZK 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态监测。</p>\n<h2 id=\"3-3-对等集群防止单点故障\"><a href=\"#3-3-对等集群防止单点故障\" class=\"headerlink\" title=\"3.3 对等集群防止单点故障\"></a>3.3 对等集群防止单点故障</h2><p>ZK 使用了原子广播（恢复服务和广播服务）实现故障转移以及同步。</p>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>服务注册中心要保证可靠性、安全性、可扩展性。ZK 是常用的技术。</p>\n"},{"title":"ThreadLocal","date":"2018-04-13T10:00:00.000Z","updated":"2018-04-13T11:00:00.000Z","comments":1,"_content":"\n# 1. Thread：ThreadLocalMap = 1:1\n\n每个 Thread 内部维护了一个 ThreadLocal.ThreadLocalMap 对象\n\n# 2. ThreadLocalMap：[ThreadLocal, Entry] = 1:16\n\n每个 ThreadLocalMap 内部维护的键值对是 [ThreadLocal, Entry]。  \n而在底层，查找的时候是通过 `ThreadLocal.threadLocalHashCode & (table.length - 1)` 获取值，得到 0~15 之间的值，并获取到 Entry[i]，进而获取 Entry.value。  \n>因此一个线程的 ThreadLocal 最好不要超过 16 个\n\n如下底层源码：  \n```java\nstatic class ThreadLocalMap {\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n\n    private static final int INITIAL_CAPACITY = 16;\n\n    private Entry[] table;\n}\n```\n由于底层通过数组维护，如果在 set 时碰到了 hash 碰撞则进行 replace：  \n```java\nfor (Entry e = tab[i];\n        e != null;\n        e = tab[i = nextIndex(i, len)]) {\n    ThreadLocal<?> k = e.get();\n\n    if (k == key) {\n        e.value = value;\n        return;\n    }\n\n    if (k == null) {\n        replaceStaleEntry(key, value, i);\n        return;\n    }\n}\n```\n\n# 3. 图解\n\n![1][]\n\n# 4. 注意\n\n1. ThreadLocal 并未解决多线程访问共享对象的问题，而是每个线程一个\b独占的变量\n2. ThreadLocal并不是每个线程拷贝一个对象，而是直接new（新建）一个\n3. 如果ThreadLocal.set()的对象是多线程共享的，那么还是涉及并发问题。\n\n# 5. Spring 中的 ThreadLocal 使用\n\nSpring使用ThreadLocal解决线程安全问题。一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。  \n一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。\n\n参考：https://blog.csdn.net/u010887744/article/details/54730556  \n参考：http://neoremind.com/2010/11/threadlocal_learn/\n\n[1]: https://img-blog.csdn.net/20170125180420388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg4Nzc0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center","source":"_posts/Java 拾遗/3_ThreadLocal.md","raw":"---\ntitle: ThreadLocal\ndate: 2018-04-13 18:00:00\nupdated: 2018-04-13 19:00:00\ncomments: true\ncategories: \n- Java 拾遗\npermalink: A2B_Java/3_ThreadLocal.html    \n---\n\n# 1. Thread：ThreadLocalMap = 1:1\n\n每个 Thread 内部维护了一个 ThreadLocal.ThreadLocalMap 对象\n\n# 2. ThreadLocalMap：[ThreadLocal, Entry] = 1:16\n\n每个 ThreadLocalMap 内部维护的键值对是 [ThreadLocal, Entry]。  \n而在底层，查找的时候是通过 `ThreadLocal.threadLocalHashCode & (table.length - 1)` 获取值，得到 0~15 之间的值，并获取到 Entry[i]，进而获取 Entry.value。  \n>因此一个线程的 ThreadLocal 最好不要超过 16 个\n\n如下底层源码：  \n```java\nstatic class ThreadLocalMap {\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n\n    private static final int INITIAL_CAPACITY = 16;\n\n    private Entry[] table;\n}\n```\n由于底层通过数组维护，如果在 set 时碰到了 hash 碰撞则进行 replace：  \n```java\nfor (Entry e = tab[i];\n        e != null;\n        e = tab[i = nextIndex(i, len)]) {\n    ThreadLocal<?> k = e.get();\n\n    if (k == key) {\n        e.value = value;\n        return;\n    }\n\n    if (k == null) {\n        replaceStaleEntry(key, value, i);\n        return;\n    }\n}\n```\n\n# 3. 图解\n\n![1][]\n\n# 4. 注意\n\n1. ThreadLocal 并未解决多线程访问共享对象的问题，而是每个线程一个\b独占的变量\n2. ThreadLocal并不是每个线程拷贝一个对象，而是直接new（新建）一个\n3. 如果ThreadLocal.set()的对象是多线程共享的，那么还是涉及并发问题。\n\n# 5. Spring 中的 ThreadLocal 使用\n\nSpring使用ThreadLocal解决线程安全问题。一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。  \n一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。\n\n参考：https://blog.csdn.net/u010887744/article/details/54730556  \n参考：http://neoremind.com/2010/11/threadlocal_learn/\n\n[1]: https://img-blog.csdn.net/20170125180420388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg4Nzc0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center","slug":"A2B_Java/3_ThreadLocal.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav4000yaxs6b2fmenma","content":"<h1 id=\"1-Thread：ThreadLocalMap-1-1\"><a href=\"#1-Thread：ThreadLocalMap-1-1\" class=\"headerlink\" title=\"1. Thread：ThreadLocalMap = 1:1\"></a>1. Thread：ThreadLocalMap = 1:1</h1><p>每个 Thread 内部维护了一个 ThreadLocal.ThreadLocalMap 对象</p>\n<h1 id=\"2-ThreadLocalMap：-ThreadLocal-Entry-1-16\"><a href=\"#2-ThreadLocalMap：-ThreadLocal-Entry-1-16\" class=\"headerlink\" title=\"2. ThreadLocalMap：[ThreadLocal, Entry] = 1:16\"></a>2. ThreadLocalMap：[ThreadLocal, Entry] = 1:16</h1><p>每个 ThreadLocalMap 内部维护的键值对是 [ThreadLocal, Entry]。<br>而在底层，查找的时候是通过 <code>ThreadLocal.threadLocalHashCode &amp; (table.length - 1)</code> 获取值，得到 0~15 之间的值，并获取到 Entry[i]，进而获取 Entry.value。  </p>\n<blockquote>\n<p>因此一个线程的 ThreadLocal 最好不要超过 16 个</p>\n</blockquote>\n<p>如下底层源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于底层通过数组维护，如果在 set 时碰到了 hash 碰撞则进行 replace：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">        e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        replaceStaleEntry(key, value, i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-图解\"><a href=\"#3-图解\" class=\"headerlink\" title=\"3. 图解\"></a>3. 图解</h1><p><img src=\"https://img-blog.csdn.net/20170125180420388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg4Nzc0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"1\"></p>\n<h1 id=\"4-注意\"><a href=\"#4-注意\" class=\"headerlink\" title=\"4. 注意\"></a>4. 注意</h1><ol>\n<li>ThreadLocal 并未解决多线程访问共享对象的问题，而是每个线程一个\b独占的变量</li>\n<li>ThreadLocal并不是每个线程拷贝一个对象，而是直接new（新建）一个</li>\n<li>如果ThreadLocal.set()的对象是多线程共享的，那么还是涉及并发问题。</li>\n</ol>\n<h1 id=\"5-Spring-中的-ThreadLocal-使用\"><a href=\"#5-Spring-中的-ThreadLocal-使用\" class=\"headerlink\" title=\"5. Spring 中的 ThreadLocal 使用\"></a>5. Spring 中的 ThreadLocal 使用</h1><p>Spring使用ThreadLocal解决线程安全问题。一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。<br>一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。</p>\n<p>参考：<a href=\"https://blog.csdn.net/u010887744/article/details/54730556\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010887744/article/details/54730556</a><br>参考：<a href=\"http://neoremind.com/2010/11/threadlocal_learn/\" target=\"_blank\" rel=\"noopener\">http://neoremind.com/2010/11/threadlocal_learn/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-Thread：ThreadLocalMap-1-1\"><a href=\"#1-Thread：ThreadLocalMap-1-1\" class=\"headerlink\" title=\"1. Thread：ThreadLocalMap = 1:1\"></a>1. Thread：ThreadLocalMap = 1:1</h1><p>每个 Thread 内部维护了一个 ThreadLocal.ThreadLocalMap 对象</p>\n<h1 id=\"2-ThreadLocalMap：-ThreadLocal-Entry-1-16\"><a href=\"#2-ThreadLocalMap：-ThreadLocal-Entry-1-16\" class=\"headerlink\" title=\"2. ThreadLocalMap：[ThreadLocal, Entry] = 1:16\"></a>2. ThreadLocalMap：[ThreadLocal, Entry] = 1:16</h1><p>每个 ThreadLocalMap 内部维护的键值对是 [ThreadLocal, Entry]。<br>而在底层，查找的时候是通过 <code>ThreadLocal.threadLocalHashCode &amp; (table.length - 1)</code> 获取值，得到 0~15 之间的值，并获取到 Entry[i]，进而获取 Entry.value。  </p>\n<blockquote>\n<p>因此一个线程的 ThreadLocal 最好不要超过 16 个</p>\n</blockquote>\n<p>如下底层源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于底层通过数组维护，如果在 set 时碰到了 hash 碰撞则进行 replace：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">        e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        replaceStaleEntry(key, value, i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-图解\"><a href=\"#3-图解\" class=\"headerlink\" title=\"3. 图解\"></a>3. 图解</h1><p><img src=\"https://img-blog.csdn.net/20170125180420388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg4Nzc0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"1\"></p>\n<h1 id=\"4-注意\"><a href=\"#4-注意\" class=\"headerlink\" title=\"4. 注意\"></a>4. 注意</h1><ol>\n<li>ThreadLocal 并未解决多线程访问共享对象的问题，而是每个线程一个\b独占的变量</li>\n<li>ThreadLocal并不是每个线程拷贝一个对象，而是直接new（新建）一个</li>\n<li>如果ThreadLocal.set()的对象是多线程共享的，那么还是涉及并发问题。</li>\n</ol>\n<h1 id=\"5-Spring-中的-ThreadLocal-使用\"><a href=\"#5-Spring-中的-ThreadLocal-使用\" class=\"headerlink\" title=\"5. Spring 中的 ThreadLocal 使用\"></a>5. Spring 中的 ThreadLocal 使用</h1><p>Spring使用ThreadLocal解决线程安全问题。一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。<br>一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。</p>\n<p>参考：<a href=\"https://blog.csdn.net/u010887744/article/details/54730556\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010887744/article/details/54730556</a><br>参考：<a href=\"http://neoremind.com/2010/11/threadlocal_learn/\" target=\"_blank\" rel=\"noopener\">http://neoremind.com/2010/11/threadlocal_learn/</a></p>\n"},{"title":"三、通信框架","date":"2018-05-20T14:55:00.000Z","updated":"2018-05-22T14:41:00.000Z","comments":1,"_content":"\n# 恭喜 RNG，恭喜 UZI\n六年\b  \n恋恋不忘  \n必有回响\n![][0]\n\n---\n\n# 1 关键技术点分析\n\n## 1.1 长连接还是短连接\n\n绝大多数的分布式服务框架（RPC框架）都推荐使用长连接进行内部通信，为什么选择长连接而不是短连接呢？具体原因如下：  \n1. 相对比短连接，长连接更节省资源。长连接只会在首次创建时或者链路断连重连才创建链路，链路创建成功之后服务提供者和消费者会通过业务消息和心跳维系链路，实现多消息复用同一个链路节省资源。\n2. 远程通信是常态，调用时延是关键指标：服务化之后，本地 API 调用变成了远程服务调用，大量本地方法演进成了跨进程通信，网络时延称为关键指标之一。相比于一次简单的服务调用，链路的重建通常耗时更多，这就会导致链路层的时延消耗远远大于服务调用本身的损耗，这对于大型的业务系统而言是无法接受的。\n\n## 1.2 BIO 还是 NIO\n\n经典的 BIO 通信模型如下：  \n![][1]  \n采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回给客户端，线程销毁，这就是典型的一请求一应答通信模型。  \n该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈 1:1 的正比关系。由于线程是 Java 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。  \n  \n在 I/O 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或 I/O 多路复用技术进行处理。 I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外线程/进程，也不需要维护这些线程/进程的运行，节省系统资源。  \n  \nJDK1.4 提供了对非阻塞I/O（NIO）的支持，JDK1.5 使用 epoll 替代了传统的 select/poll，极大提升了 NIO 通信的性能。  \nNIO 采用多路复用技术，一个多路复用器 Selector 可以同时轮询多个 Channel ，由于 JDK 使用了 epoll() 代替了传统的 select 实现，所以它并没有最大连接句柄 1024/2048 的限制。这就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。  \n采用多路复用器 Selector 实现的 Reactor 通信模型如下：  \n![][2]\n  \n## 1.3 自研还是选择开源 NIO 框架\n\n选择 Netty！\n\n# 2 功能设计\n\n分布式服务框架的底层通信框架首先是一个通用的通信框架，它不应该与具体的协议绑定。基于通信框架智商，可以构建私有协议栈和公有协议栈。  \n架构原理如下图：  \n![][3]\n\n## 2.1 服务端设计\n\n通信框架服务端的职责如下：  \n1. 提供上层 API，用于初始化服务端实例，设置服务端通信相关参数，包括服务端的 I/O 线程池、监听地址、TCP 相关参数、接收和发送缓冲区大小等。\n2. 提供可扩展的编解码插件，用户可以通过扩展的方式实现自定义协议的编码和解码。\n3. 提供拦截面，用于私有协议栈开发。例如通过新增鉴权插件实现服务端对客户端的安全认证。\n\n## 2.2 客户端设计\n\n客户端需要考虑网络连接超时、连接失败等异常场景。\n\n# 3 可靠性设计\n\n## 3.1 链路有效性检测\n\n当网络发生单通、连接被防火墙 Hang 住，长时间 GC 或者通信线程发生非预期异常时，会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间，当早晨业务高峰期到来时，由于链路不可用会导致瞬间的大批量业务失败或者超时。  \n  \n从技术层面看，要解决链路的可靠性问题，必须周期性地对链路进行有效性检测。目前最流行和最通用的做法就是心跳检测。  \n1. TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。\n2. 协议层的心跳检测，主要存在于长连接协议中，例如 SMPP 协议。\n3. 应用层的心跳检测，主要由各业务产品通过约定方式定时给对方发送心跳消息实现。\n  \n心跳的检测原理如下：  \n![][8]\n  \n不同的协议，心跳检测机制也存在差异，归类两类：  \n1. Ping-Pong 型心跳：由通信一方定时发送 Ping 消息，对方接收到 Ping 消息之后，立即返回 Pong 应答消息给对方，属于请求-响应型心跳。\n2. Ping-Ping 型心跳：不区分心跳请求和应答，由通信双方按照约定定时向对方发送心跳 Ping 消息，属于双向心跳。\n  \n心跳检测策略如下：  \n1. 连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称为心跳超时。\n2. 读取和发送心跳消息的时候如果直接发生了 I/O 异常，说明链路已经失效，这被称为心跳失败。\n  \n无论发生心跳超时还是心跳失败，都需要关闭链路，由客户端发起重连操作，保证链路能够恢复正常。  \nNetty 的心跳检测实际上是利用了链路空闲检测机制实现的，它的空闲检测机制分为三种：  \n* 读空闲，链路持续时间 t 没有读取到任何消息。\n* 写空闲，链路持续时间 t 没有发送任何消息。\n* 读写空闲，链路持续时间 t 没有接受或者发送任何消息。\n\n## 3.2 断连重连机制\n\n为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。  \n为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于 SocketChannel、Socket等。\n\n## 3.3 消息缓存重发\n\n当我们调用消息发送接口的时候，消息并没有真正被写入到 Socket 中，而是先放入 NIO 通信框架的消息发送队列中，由 Reactor 线程扫描待发送的消息队列，异步地发送给通信对端。假如很不辛，消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端，如下图：  \n![][9]  \n  \n发生此故障时，我们希望 NIO 框架能够自动实现消息缓存和重新发送，遗憾的是作为基础的 NIO 通信框架，无论是 Mina 还是 Netty，都没有提供该功能，需要通信框架自己封装实现。  \n  \n并非所有场景都需要通信框架做重发，例如服务框架的客户端，如果某个服务提供者不可用，会自动切换到下一个可用的服务提供者之上。假定是链路中断导致的服务提供者不可用，即便链路重新恢复，也没有必要将之前积压的消息重新发送，因为消息已经通过 FailOver 机制切换到另一个服务提供者处理。所以，消息缓存重发只是一种策略，通信框架应该支持链路级重发策略。\n\n## 3.4 资源优雅释放\n\nJava 的优雅停机通常通过注册 JDK 的 ShutdownHook 来实现，当系统接收到退出指令后，首先标记系统处于退出状态，不再接收新的消息，然后将积压的消息处理完，最后调用资源回收接口将资源销毁，最后各线程退出执行。  \n  \n通常优雅退出有个时间限制，例如 30s，如果到达执行时间仍然没有完成推出前的操作，则由监控监本直接 kill -9 pid，强制退出。\n\n# 4 性能设计\n\n分布式服务框架被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。对通信框架有很高的性能要求。\n\n## 4.1 性能差的三宗罪\n\n1. 网络传输方式：同步阻塞 I/O，采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后，为其创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，导致并发量的增加，发生句柄溢出。\n2. 序列化性能差：Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言；相对其它开源的序列化框架，Java 序列化后的码流太大，导致额外的资源占用；序列化性能差，资源占用率高（主要是 CPU 资源占用高）。\n3. 线程模型问题：由于采用同步阻塞 I/O，导致每个 TCP 连接都占用了一个线程。\n\n## 4.2 通信性能三原则\n\n1. 传输：用什么样的通道将数据发送给对方：BIO/NIO/AIO。I/O 模型在很大程度上决定了通信的性能。\n2. 协议：采用什么样的通信协议， HTTP 等公有协议或者内部私有协议。通常内部私有协议可以被设计得更优。\n3. 线程：数据报如何读取？读取之后的编解码在哪个线程进行？编解码后的消息如何派发？Reactor 线程模型的不同，对性能的影响也非常大。\n\n## 4.3 高性能之道\n\nNetty 支持高性能通信的架构特性进行总结：  \n1. 异步非阻塞通信：Netty 的 I/O 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 SocketChannel。由于读写都是非阻塞的，这就可以充分提升 I/O 的运行效率，避免由频繁的 I/O 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。\n2. 高效的 I/O 线程模型：Netty 支持 Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型，可以满足不同的容量和性能需求。\n3. 高性能的序列化框架：默认提供了 Protobuf 二进制序列化框架，其它二进制序列化框架可以进行编解码框架扩展实现。  \n  \n还支持零拷贝、内存池等其它性能相关的特性。\n\n# 5 最佳实践\n\n1. 服务端只负责客户端的接入，不处理 I/O 读写操作，因此服务端的 boosGroup 设置线程数为1：`EventLoopGroup bossGroup = new NioEventLoopGroup(1);`。\n2. 客户端的 NioEventLoopGroup 由于服务提供者可能有 1000个或更多，导致创建了 1000个对象，可以使用大的线程池，或者创建一个包含 NioEventLoopGroup 的数组，将客户端连接按照 Hash 算法分组，将所有连接均匀的打散在 NioEventLoopGroup 中。\n\n# 6 个人总结\n\n通信框架的重点在于 BIO、NIO、AIO，以及序列化。    \n这就是为什么别人面试会问 BIO/NIO/AIO/序列化。\n\n\n[0]: http://photocdn.sohu.com/20180521/Img538252610.jpg\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_3.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_8.png\n[9]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_9.png","source":"_posts/分布式服务框架原理与实践/第三章 通信框架.1.md","raw":"---\ntitle: 三、通信框架\ndate: 2018-05-20 22:55:00\nupdated: 2018-05-22 22:41:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/3.html    \n---\n\n# 恭喜 RNG，恭喜 UZI\n六年\b  \n恋恋不忘  \n必有回响\n![][0]\n\n---\n\n# 1 关键技术点分析\n\n## 1.1 长连接还是短连接\n\n绝大多数的分布式服务框架（RPC框架）都推荐使用长连接进行内部通信，为什么选择长连接而不是短连接呢？具体原因如下：  \n1. 相对比短连接，长连接更节省资源。长连接只会在首次创建时或者链路断连重连才创建链路，链路创建成功之后服务提供者和消费者会通过业务消息和心跳维系链路，实现多消息复用同一个链路节省资源。\n2. 远程通信是常态，调用时延是关键指标：服务化之后，本地 API 调用变成了远程服务调用，大量本地方法演进成了跨进程通信，网络时延称为关键指标之一。相比于一次简单的服务调用，链路的重建通常耗时更多，这就会导致链路层的时延消耗远远大于服务调用本身的损耗，这对于大型的业务系统而言是无法接受的。\n\n## 1.2 BIO 还是 NIO\n\n经典的 BIO 通信模型如下：  \n![][1]  \n采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回给客户端，线程销毁，这就是典型的一请求一应答通信模型。  \n该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈 1:1 的正比关系。由于线程是 Java 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。  \n  \n在 I/O 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或 I/O 多路复用技术进行处理。 I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外线程/进程，也不需要维护这些线程/进程的运行，节省系统资源。  \n  \nJDK1.4 提供了对非阻塞I/O（NIO）的支持，JDK1.5 使用 epoll 替代了传统的 select/poll，极大提升了 NIO 通信的性能。  \nNIO 采用多路复用技术，一个多路复用器 Selector 可以同时轮询多个 Channel ，由于 JDK 使用了 epoll() 代替了传统的 select 实现，所以它并没有最大连接句柄 1024/2048 的限制。这就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。  \n采用多路复用器 Selector 实现的 Reactor 通信模型如下：  \n![][2]\n  \n## 1.3 自研还是选择开源 NIO 框架\n\n选择 Netty！\n\n# 2 功能设计\n\n分布式服务框架的底层通信框架首先是一个通用的通信框架，它不应该与具体的协议绑定。基于通信框架智商，可以构建私有协议栈和公有协议栈。  \n架构原理如下图：  \n![][3]\n\n## 2.1 服务端设计\n\n通信框架服务端的职责如下：  \n1. 提供上层 API，用于初始化服务端实例，设置服务端通信相关参数，包括服务端的 I/O 线程池、监听地址、TCP 相关参数、接收和发送缓冲区大小等。\n2. 提供可扩展的编解码插件，用户可以通过扩展的方式实现自定义协议的编码和解码。\n3. 提供拦截面，用于私有协议栈开发。例如通过新增鉴权插件实现服务端对客户端的安全认证。\n\n## 2.2 客户端设计\n\n客户端需要考虑网络连接超时、连接失败等异常场景。\n\n# 3 可靠性设计\n\n## 3.1 链路有效性检测\n\n当网络发生单通、连接被防火墙 Hang 住，长时间 GC 或者通信线程发生非预期异常时，会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间，当早晨业务高峰期到来时，由于链路不可用会导致瞬间的大批量业务失败或者超时。  \n  \n从技术层面看，要解决链路的可靠性问题，必须周期性地对链路进行有效性检测。目前最流行和最通用的做法就是心跳检测。  \n1. TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。\n2. 协议层的心跳检测，主要存在于长连接协议中，例如 SMPP 协议。\n3. 应用层的心跳检测，主要由各业务产品通过约定方式定时给对方发送心跳消息实现。\n  \n心跳的检测原理如下：  \n![][8]\n  \n不同的协议，心跳检测机制也存在差异，归类两类：  \n1. Ping-Pong 型心跳：由通信一方定时发送 Ping 消息，对方接收到 Ping 消息之后，立即返回 Pong 应答消息给对方，属于请求-响应型心跳。\n2. Ping-Ping 型心跳：不区分心跳请求和应答，由通信双方按照约定定时向对方发送心跳 Ping 消息，属于双向心跳。\n  \n心跳检测策略如下：  \n1. 连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称为心跳超时。\n2. 读取和发送心跳消息的时候如果直接发生了 I/O 异常，说明链路已经失效，这被称为心跳失败。\n  \n无论发生心跳超时还是心跳失败，都需要关闭链路，由客户端发起重连操作，保证链路能够恢复正常。  \nNetty 的心跳检测实际上是利用了链路空闲检测机制实现的，它的空闲检测机制分为三种：  \n* 读空闲，链路持续时间 t 没有读取到任何消息。\n* 写空闲，链路持续时间 t 没有发送任何消息。\n* 读写空闲，链路持续时间 t 没有接受或者发送任何消息。\n\n## 3.2 断连重连机制\n\n为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。  \n为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于 SocketChannel、Socket等。\n\n## 3.3 消息缓存重发\n\n当我们调用消息发送接口的时候，消息并没有真正被写入到 Socket 中，而是先放入 NIO 通信框架的消息发送队列中，由 Reactor 线程扫描待发送的消息队列，异步地发送给通信对端。假如很不辛，消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端，如下图：  \n![][9]  \n  \n发生此故障时，我们希望 NIO 框架能够自动实现消息缓存和重新发送，遗憾的是作为基础的 NIO 通信框架，无论是 Mina 还是 Netty，都没有提供该功能，需要通信框架自己封装实现。  \n  \n并非所有场景都需要通信框架做重发，例如服务框架的客户端，如果某个服务提供者不可用，会自动切换到下一个可用的服务提供者之上。假定是链路中断导致的服务提供者不可用，即便链路重新恢复，也没有必要将之前积压的消息重新发送，因为消息已经通过 FailOver 机制切换到另一个服务提供者处理。所以，消息缓存重发只是一种策略，通信框架应该支持链路级重发策略。\n\n## 3.4 资源优雅释放\n\nJava 的优雅停机通常通过注册 JDK 的 ShutdownHook 来实现，当系统接收到退出指令后，首先标记系统处于退出状态，不再接收新的消息，然后将积压的消息处理完，最后调用资源回收接口将资源销毁，最后各线程退出执行。  \n  \n通常优雅退出有个时间限制，例如 30s，如果到达执行时间仍然没有完成推出前的操作，则由监控监本直接 kill -9 pid，强制退出。\n\n# 4 性能设计\n\n分布式服务框架被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。对通信框架有很高的性能要求。\n\n## 4.1 性能差的三宗罪\n\n1. 网络传输方式：同步阻塞 I/O，采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后，为其创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，导致并发量的增加，发生句柄溢出。\n2. 序列化性能差：Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言；相对其它开源的序列化框架，Java 序列化后的码流太大，导致额外的资源占用；序列化性能差，资源占用率高（主要是 CPU 资源占用高）。\n3. 线程模型问题：由于采用同步阻塞 I/O，导致每个 TCP 连接都占用了一个线程。\n\n## 4.2 通信性能三原则\n\n1. 传输：用什么样的通道将数据发送给对方：BIO/NIO/AIO。I/O 模型在很大程度上决定了通信的性能。\n2. 协议：采用什么样的通信协议， HTTP 等公有协议或者内部私有协议。通常内部私有协议可以被设计得更优。\n3. 线程：数据报如何读取？读取之后的编解码在哪个线程进行？编解码后的消息如何派发？Reactor 线程模型的不同，对性能的影响也非常大。\n\n## 4.3 高性能之道\n\nNetty 支持高性能通信的架构特性进行总结：  \n1. 异步非阻塞通信：Netty 的 I/O 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 SocketChannel。由于读写都是非阻塞的，这就可以充分提升 I/O 的运行效率，避免由频繁的 I/O 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。\n2. 高效的 I/O 线程模型：Netty 支持 Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型，可以满足不同的容量和性能需求。\n3. 高性能的序列化框架：默认提供了 Protobuf 二进制序列化框架，其它二进制序列化框架可以进行编解码框架扩展实现。  \n  \n还支持零拷贝、内存池等其它性能相关的特性。\n\n# 5 最佳实践\n\n1. 服务端只负责客户端的接入，不处理 I/O 读写操作，因此服务端的 boosGroup 设置线程数为1：`EventLoopGroup bossGroup = new NioEventLoopGroup(1);`。\n2. 客户端的 NioEventLoopGroup 由于服务提供者可能有 1000个或更多，导致创建了 1000个对象，可以使用大的线程池，或者创建一个包含 NioEventLoopGroup 的数组，将客户端连接按照 Hash 算法分组，将所有连接均匀的打散在 NioEventLoopGroup 中。\n\n# 6 个人总结\n\n通信框架的重点在于 BIO、NIO、AIO，以及序列化。    \n这就是为什么别人面试会问 BIO/NIO/AIO/序列化。\n\n\n[0]: http://photocdn.sohu.com/20180521/Img538252610.jpg\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_3.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_8.png\n[9]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_9.png","slug":"distributed_principle_prictice/3.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav50011axs6jovhaz9u","content":"<h1 id=\"恭喜-RNG，恭喜-UZI\"><a href=\"#恭喜-RNG，恭喜-UZI\" class=\"headerlink\" title=\"恭喜 RNG，恭喜 UZI\"></a>恭喜 RNG，恭喜 UZI</h1><p>六年\b<br>恋恋不忘<br>必有回响<br><img src=\"http://photocdn.sohu.com/20180521/Img538252610.jpg\" alt=\"\"></p>\n<hr>\n<h1 id=\"1-关键技术点分析\"><a href=\"#1-关键技术点分析\" class=\"headerlink\" title=\"1 关键技术点分析\"></a>1 关键技术点分析</h1><h2 id=\"1-1-长连接还是短连接\"><a href=\"#1-1-长连接还是短连接\" class=\"headerlink\" title=\"1.1 长连接还是短连接\"></a>1.1 长连接还是短连接</h2><p>绝大多数的分布式服务框架（RPC框架）都推荐使用长连接进行内部通信，为什么选择长连接而不是短连接呢？具体原因如下：  </p>\n<ol>\n<li>相对比短连接，长连接更节省资源。长连接只会在首次创建时或者链路断连重连才创建链路，链路创建成功之后服务提供者和消费者会通过业务消息和心跳维系链路，实现多消息复用同一个链路节省资源。</li>\n<li>远程通信是常态，调用时延是关键指标：服务化之后，本地 API 调用变成了远程服务调用，大量本地方法演进成了跨进程通信，网络时延称为关键指标之一。相比于一次简单的服务调用，链路的重建通常耗时更多，这就会导致链路层的时延消耗远远大于服务调用本身的损耗，这对于大型的业务系统而言是无法接受的。</li>\n</ol>\n<h2 id=\"1-2-BIO-还是-NIO\"><a href=\"#1-2-BIO-还是-NIO\" class=\"headerlink\" title=\"1.2 BIO 还是 NIO\"></a>1.2 BIO 还是 NIO</h2><p>经典的 BIO 通信模型如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_1.png\" alt=\"\"><br>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回给客户端，线程销毁，这就是典型的一请求一应答通信模型。<br>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈 1:1 的正比关系。由于线程是 Java 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。  </p>\n<p>在 I/O 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或 I/O 多路复用技术进行处理。 I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外线程/进程，也不需要维护这些线程/进程的运行，节省系统资源。  </p>\n<p>JDK1.4 提供了对非阻塞I/O（NIO）的支持，JDK1.5 使用 epoll 替代了传统的 select/poll，极大提升了 NIO 通信的性能。<br>NIO 采用多路复用技术，一个多路复用器 Selector 可以同时轮询多个 Channel ，由于 JDK 使用了 epoll() 代替了传统的 select 实现，所以它并没有最大连接句柄 1024/2048 的限制。这就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。<br>采用多路复用器 Selector 实现的 Reactor 通信模型如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-自研还是选择开源-NIO-框架\"><a href=\"#1-3-自研还是选择开源-NIO-框架\" class=\"headerlink\" title=\"1.3 自研还是选择开源 NIO 框架\"></a>1.3 自研还是选择开源 NIO 框架</h2><p>选择 Netty！</p>\n<h1 id=\"2-功能设计\"><a href=\"#2-功能设计\" class=\"headerlink\" title=\"2 功能设计\"></a>2 功能设计</h1><p>分布式服务框架的底层通信框架首先是一个通用的通信框架，它不应该与具体的协议绑定。基于通信框架智商，可以构建私有协议栈和公有协议栈。<br>架构原理如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_3.png\" alt=\"\"></p>\n<h2 id=\"2-1-服务端设计\"><a href=\"#2-1-服务端设计\" class=\"headerlink\" title=\"2.1 服务端设计\"></a>2.1 服务端设计</h2><p>通信框架服务端的职责如下：  </p>\n<ol>\n<li>提供上层 API，用于初始化服务端实例，设置服务端通信相关参数，包括服务端的 I/O 线程池、监听地址、TCP 相关参数、接收和发送缓冲区大小等。</li>\n<li>提供可扩展的编解码插件，用户可以通过扩展的方式实现自定义协议的编码和解码。</li>\n<li>提供拦截面，用于私有协议栈开发。例如通过新增鉴权插件实现服务端对客户端的安全认证。</li>\n</ol>\n<h2 id=\"2-2-客户端设计\"><a href=\"#2-2-客户端设计\" class=\"headerlink\" title=\"2.2 客户端设计\"></a>2.2 客户端设计</h2><p>客户端需要考虑网络连接超时、连接失败等异常场景。</p>\n<h1 id=\"3-可靠性设计\"><a href=\"#3-可靠性设计\" class=\"headerlink\" title=\"3 可靠性设计\"></a>3 可靠性设计</h1><h2 id=\"3-1-链路有效性检测\"><a href=\"#3-1-链路有效性检测\" class=\"headerlink\" title=\"3.1 链路有效性检测\"></a>3.1 链路有效性检测</h2><p>当网络发生单通、连接被防火墙 Hang 住，长时间 GC 或者通信线程发生非预期异常时，会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间，当早晨业务高峰期到来时，由于链路不可用会导致瞬间的大批量业务失败或者超时。  </p>\n<p>从技术层面看，要解决链路的可靠性问题，必须周期性地对链路进行有效性检测。目前最流行和最通用的做法就是心跳检测。  </p>\n<ol>\n<li>TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。</li>\n<li>协议层的心跳检测，主要存在于长连接协议中，例如 SMPP 协议。</li>\n<li>应用层的心跳检测，主要由各业务产品通过约定方式定时给对方发送心跳消息实现。</li>\n</ol>\n<p>心跳的检测原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_8.png\" alt=\"\"></p>\n<p>不同的协议，心跳检测机制也存在差异，归类两类：  </p>\n<ol>\n<li>Ping-Pong 型心跳：由通信一方定时发送 Ping 消息，对方接收到 Ping 消息之后，立即返回 Pong 应答消息给对方，属于请求-响应型心跳。</li>\n<li>Ping-Ping 型心跳：不区分心跳请求和应答，由通信双方按照约定定时向对方发送心跳 Ping 消息，属于双向心跳。</li>\n</ol>\n<p>心跳检测策略如下：  </p>\n<ol>\n<li>连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称为心跳超时。</li>\n<li>读取和发送心跳消息的时候如果直接发生了 I/O 异常，说明链路已经失效，这被称为心跳失败。</li>\n</ol>\n<p>无论发生心跳超时还是心跳失败，都需要关闭链路，由客户端发起重连操作，保证链路能够恢复正常。<br>Netty 的心跳检测实际上是利用了链路空闲检测机制实现的，它的空闲检测机制分为三种：  </p>\n<ul>\n<li>读空闲，链路持续时间 t 没有读取到任何消息。</li>\n<li>写空闲，链路持续时间 t 没有发送任何消息。</li>\n<li>读写空闲，链路持续时间 t 没有接受或者发送任何消息。</li>\n</ul>\n<h2 id=\"3-2-断连重连机制\"><a href=\"#3-2-断连重连机制\" class=\"headerlink\" title=\"3.2 断连重连机制\"></a>3.2 断连重连机制</h2><p>为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。<br>为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于 SocketChannel、Socket等。</p>\n<h2 id=\"3-3-消息缓存重发\"><a href=\"#3-3-消息缓存重发\" class=\"headerlink\" title=\"3.3 消息缓存重发\"></a>3.3 消息缓存重发</h2><p>当我们调用消息发送接口的时候，消息并没有真正被写入到 Socket 中，而是先放入 NIO 通信框架的消息发送队列中，由 Reactor 线程扫描待发送的消息队列，异步地发送给通信对端。假如很不辛，消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_9.png\" alt=\"\">  </p>\n<p>发生此故障时，我们希望 NIO 框架能够自动实现消息缓存和重新发送，遗憾的是作为基础的 NIO 通信框架，无论是 Mina 还是 Netty，都没有提供该功能，需要通信框架自己封装实现。  </p>\n<p>并非所有场景都需要通信框架做重发，例如服务框架的客户端，如果某个服务提供者不可用，会自动切换到下一个可用的服务提供者之上。假定是链路中断导致的服务提供者不可用，即便链路重新恢复，也没有必要将之前积压的消息重新发送，因为消息已经通过 FailOver 机制切换到另一个服务提供者处理。所以，消息缓存重发只是一种策略，通信框架应该支持链路级重发策略。</p>\n<h2 id=\"3-4-资源优雅释放\"><a href=\"#3-4-资源优雅释放\" class=\"headerlink\" title=\"3.4 资源优雅释放\"></a>3.4 资源优雅释放</h2><p>Java 的优雅停机通常通过注册 JDK 的 ShutdownHook 来实现，当系统接收到退出指令后，首先标记系统处于退出状态，不再接收新的消息，然后将积压的消息处理完，最后调用资源回收接口将资源销毁，最后各线程退出执行。  </p>\n<p>通常优雅退出有个时间限制，例如 30s，如果到达执行时间仍然没有完成推出前的操作，则由监控监本直接 kill -9 pid，强制退出。</p>\n<h1 id=\"4-性能设计\"><a href=\"#4-性能设计\" class=\"headerlink\" title=\"4 性能设计\"></a>4 性能设计</h1><p>分布式服务框架被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。对通信框架有很高的性能要求。</p>\n<h2 id=\"4-1-性能差的三宗罪\"><a href=\"#4-1-性能差的三宗罪\" class=\"headerlink\" title=\"4.1 性能差的三宗罪\"></a>4.1 性能差的三宗罪</h2><ol>\n<li>网络传输方式：同步阻塞 I/O，采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后，为其创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，导致并发量的增加，发生句柄溢出。</li>\n<li>序列化性能差：Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言；相对其它开源的序列化框架，Java 序列化后的码流太大，导致额外的资源占用；序列化性能差，资源占用率高（主要是 CPU 资源占用高）。</li>\n<li>线程模型问题：由于采用同步阻塞 I/O，导致每个 TCP 连接都占用了一个线程。</li>\n</ol>\n<h2 id=\"4-2-通信性能三原则\"><a href=\"#4-2-通信性能三原则\" class=\"headerlink\" title=\"4.2 通信性能三原则\"></a>4.2 通信性能三原则</h2><ol>\n<li>传输：用什么样的通道将数据发送给对方：BIO/NIO/AIO。I/O 模型在很大程度上决定了通信的性能。</li>\n<li>协议：采用什么样的通信协议， HTTP 等公有协议或者内部私有协议。通常内部私有协议可以被设计得更优。</li>\n<li>线程：数据报如何读取？读取之后的编解码在哪个线程进行？编解码后的消息如何派发？Reactor 线程模型的不同，对性能的影响也非常大。</li>\n</ol>\n<h2 id=\"4-3-高性能之道\"><a href=\"#4-3-高性能之道\" class=\"headerlink\" title=\"4.3 高性能之道\"></a>4.3 高性能之道</h2><p>Netty 支持高性能通信的架构特性进行总结：  </p>\n<ol>\n<li>异步非阻塞通信：Netty 的 I/O 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 SocketChannel。由于读写都是非阻塞的，这就可以充分提升 I/O 的运行效率，避免由频繁的 I/O 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>\n<li>高效的 I/O 线程模型：Netty 支持 Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型，可以满足不同的容量和性能需求。</li>\n<li>高性能的序列化框架：默认提供了 Protobuf 二进制序列化框架，其它二进制序列化框架可以进行编解码框架扩展实现。  </li>\n</ol>\n<p>还支持零拷贝、内存池等其它性能相关的特性。</p>\n<h1 id=\"5-最佳实践\"><a href=\"#5-最佳实践\" class=\"headerlink\" title=\"5 最佳实践\"></a>5 最佳实践</h1><ol>\n<li>服务端只负责客户端的接入，不处理 I/O 读写操作，因此服务端的 boosGroup 设置线程数为1：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);</code>。</li>\n<li>客户端的 NioEventLoopGroup 由于服务提供者可能有 1000个或更多，导致创建了 1000个对象，可以使用大的线程池，或者创建一个包含 NioEventLoopGroup 的数组，将客户端连接按照 Hash 算法分组，将所有连接均匀的打散在 NioEventLoopGroup 中。</li>\n</ol>\n<h1 id=\"6-个人总结\"><a href=\"#6-个人总结\" class=\"headerlink\" title=\"6 个人总结\"></a>6 个人总结</h1><p>通信框架的重点在于 BIO、NIO、AIO，以及序列化。<br>这就是为什么别人面试会问 BIO/NIO/AIO/序列化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"恭喜-RNG，恭喜-UZI\"><a href=\"#恭喜-RNG，恭喜-UZI\" class=\"headerlink\" title=\"恭喜 RNG，恭喜 UZI\"></a>恭喜 RNG，恭喜 UZI</h1><p>六年\b<br>恋恋不忘<br>必有回响<br><img src=\"http://photocdn.sohu.com/20180521/Img538252610.jpg\" alt=\"\"></p>\n<hr>\n<h1 id=\"1-关键技术点分析\"><a href=\"#1-关键技术点分析\" class=\"headerlink\" title=\"1 关键技术点分析\"></a>1 关键技术点分析</h1><h2 id=\"1-1-长连接还是短连接\"><a href=\"#1-1-长连接还是短连接\" class=\"headerlink\" title=\"1.1 长连接还是短连接\"></a>1.1 长连接还是短连接</h2><p>绝大多数的分布式服务框架（RPC框架）都推荐使用长连接进行内部通信，为什么选择长连接而不是短连接呢？具体原因如下：  </p>\n<ol>\n<li>相对比短连接，长连接更节省资源。长连接只会在首次创建时或者链路断连重连才创建链路，链路创建成功之后服务提供者和消费者会通过业务消息和心跳维系链路，实现多消息复用同一个链路节省资源。</li>\n<li>远程通信是常态，调用时延是关键指标：服务化之后，本地 API 调用变成了远程服务调用，大量本地方法演进成了跨进程通信，网络时延称为关键指标之一。相比于一次简单的服务调用，链路的重建通常耗时更多，这就会导致链路层的时延消耗远远大于服务调用本身的损耗，这对于大型的业务系统而言是无法接受的。</li>\n</ol>\n<h2 id=\"1-2-BIO-还是-NIO\"><a href=\"#1-2-BIO-还是-NIO\" class=\"headerlink\" title=\"1.2 BIO 还是 NIO\"></a>1.2 BIO 还是 NIO</h2><p>经典的 BIO 通信模型如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_1.png\" alt=\"\"><br>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回给客户端，线程销毁，这就是典型的一请求一应答通信模型。<br>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈 1:1 的正比关系。由于线程是 Java 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。  </p>\n<p>在 I/O 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或 I/O 多路复用技术进行处理。 I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外线程/进程，也不需要维护这些线程/进程的运行，节省系统资源。  </p>\n<p>JDK1.4 提供了对非阻塞I/O（NIO）的支持，JDK1.5 使用 epoll 替代了传统的 select/poll，极大提升了 NIO 通信的性能。<br>NIO 采用多路复用技术，一个多路复用器 Selector 可以同时轮询多个 Channel ，由于 JDK 使用了 epoll() 代替了传统的 select 实现，所以它并没有最大连接句柄 1024/2048 的限制。这就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。<br>采用多路复用器 Selector 实现的 Reactor 通信模型如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-自研还是选择开源-NIO-框架\"><a href=\"#1-3-自研还是选择开源-NIO-框架\" class=\"headerlink\" title=\"1.3 自研还是选择开源 NIO 框架\"></a>1.3 自研还是选择开源 NIO 框架</h2><p>选择 Netty！</p>\n<h1 id=\"2-功能设计\"><a href=\"#2-功能设计\" class=\"headerlink\" title=\"2 功能设计\"></a>2 功能设计</h1><p>分布式服务框架的底层通信框架首先是一个通用的通信框架，它不应该与具体的协议绑定。基于通信框架智商，可以构建私有协议栈和公有协议栈。<br>架构原理如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_3.png\" alt=\"\"></p>\n<h2 id=\"2-1-服务端设计\"><a href=\"#2-1-服务端设计\" class=\"headerlink\" title=\"2.1 服务端设计\"></a>2.1 服务端设计</h2><p>通信框架服务端的职责如下：  </p>\n<ol>\n<li>提供上层 API，用于初始化服务端实例，设置服务端通信相关参数，包括服务端的 I/O 线程池、监听地址、TCP 相关参数、接收和发送缓冲区大小等。</li>\n<li>提供可扩展的编解码插件，用户可以通过扩展的方式实现自定义协议的编码和解码。</li>\n<li>提供拦截面，用于私有协议栈开发。例如通过新增鉴权插件实现服务端对客户端的安全认证。</li>\n</ol>\n<h2 id=\"2-2-客户端设计\"><a href=\"#2-2-客户端设计\" class=\"headerlink\" title=\"2.2 客户端设计\"></a>2.2 客户端设计</h2><p>客户端需要考虑网络连接超时、连接失败等异常场景。</p>\n<h1 id=\"3-可靠性设计\"><a href=\"#3-可靠性设计\" class=\"headerlink\" title=\"3 可靠性设计\"></a>3 可靠性设计</h1><h2 id=\"3-1-链路有效性检测\"><a href=\"#3-1-链路有效性检测\" class=\"headerlink\" title=\"3.1 链路有效性检测\"></a>3.1 链路有效性检测</h2><p>当网络发生单通、连接被防火墙 Hang 住，长时间 GC 或者通信线程发生非预期异常时，会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间，当早晨业务高峰期到来时，由于链路不可用会导致瞬间的大批量业务失败或者超时。  </p>\n<p>从技术层面看，要解决链路的可靠性问题，必须周期性地对链路进行有效性检测。目前最流行和最通用的做法就是心跳检测。  </p>\n<ol>\n<li>TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。</li>\n<li>协议层的心跳检测，主要存在于长连接协议中，例如 SMPP 协议。</li>\n<li>应用层的心跳检测，主要由各业务产品通过约定方式定时给对方发送心跳消息实现。</li>\n</ol>\n<p>心跳的检测原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_8.png\" alt=\"\"></p>\n<p>不同的协议，心跳检测机制也存在差异，归类两类：  </p>\n<ol>\n<li>Ping-Pong 型心跳：由通信一方定时发送 Ping 消息，对方接收到 Ping 消息之后，立即返回 Pong 应答消息给对方，属于请求-响应型心跳。</li>\n<li>Ping-Ping 型心跳：不区分心跳请求和应答，由通信双方按照约定定时向对方发送心跳 Ping 消息，属于双向心跳。</li>\n</ol>\n<p>心跳检测策略如下：  </p>\n<ol>\n<li>连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称为心跳超时。</li>\n<li>读取和发送心跳消息的时候如果直接发生了 I/O 异常，说明链路已经失效，这被称为心跳失败。</li>\n</ol>\n<p>无论发生心跳超时还是心跳失败，都需要关闭链路，由客户端发起重连操作，保证链路能够恢复正常。<br>Netty 的心跳检测实际上是利用了链路空闲检测机制实现的，它的空闲检测机制分为三种：  </p>\n<ul>\n<li>读空闲，链路持续时间 t 没有读取到任何消息。</li>\n<li>写空闲，链路持续时间 t 没有发送任何消息。</li>\n<li>读写空闲，链路持续时间 t 没有接受或者发送任何消息。</li>\n</ul>\n<h2 id=\"3-2-断连重连机制\"><a href=\"#3-2-断连重连机制\" class=\"headerlink\" title=\"3.2 断连重连机制\"></a>3.2 断连重连机制</h2><p>为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。<br>为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于 SocketChannel、Socket等。</p>\n<h2 id=\"3-3-消息缓存重发\"><a href=\"#3-3-消息缓存重发\" class=\"headerlink\" title=\"3.3 消息缓存重发\"></a>3.3 消息缓存重发</h2><p>当我们调用消息发送接口的时候，消息并没有真正被写入到 Socket 中，而是先放入 NIO 通信框架的消息发送队列中，由 Reactor 线程扫描待发送的消息队列，异步地发送给通信对端。假如很不辛，消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_9.png\" alt=\"\">  </p>\n<p>发生此故障时，我们希望 NIO 框架能够自动实现消息缓存和重新发送，遗憾的是作为基础的 NIO 通信框架，无论是 Mina 还是 Netty，都没有提供该功能，需要通信框架自己封装实现。  </p>\n<p>并非所有场景都需要通信框架做重发，例如服务框架的客户端，如果某个服务提供者不可用，会自动切换到下一个可用的服务提供者之上。假定是链路中断导致的服务提供者不可用，即便链路重新恢复，也没有必要将之前积压的消息重新发送，因为消息已经通过 FailOver 机制切换到另一个服务提供者处理。所以，消息缓存重发只是一种策略，通信框架应该支持链路级重发策略。</p>\n<h2 id=\"3-4-资源优雅释放\"><a href=\"#3-4-资源优雅释放\" class=\"headerlink\" title=\"3.4 资源优雅释放\"></a>3.4 资源优雅释放</h2><p>Java 的优雅停机通常通过注册 JDK 的 ShutdownHook 来实现，当系统接收到退出指令后，首先标记系统处于退出状态，不再接收新的消息，然后将积压的消息处理完，最后调用资源回收接口将资源销毁，最后各线程退出执行。  </p>\n<p>通常优雅退出有个时间限制，例如 30s，如果到达执行时间仍然没有完成推出前的操作，则由监控监本直接 kill -9 pid，强制退出。</p>\n<h1 id=\"4-性能设计\"><a href=\"#4-性能设计\" class=\"headerlink\" title=\"4 性能设计\"></a>4 性能设计</h1><p>分布式服务框架被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。对通信框架有很高的性能要求。</p>\n<h2 id=\"4-1-性能差的三宗罪\"><a href=\"#4-1-性能差的三宗罪\" class=\"headerlink\" title=\"4.1 性能差的三宗罪\"></a>4.1 性能差的三宗罪</h2><ol>\n<li>网络传输方式：同步阻塞 I/O，采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后，为其创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，导致并发量的增加，发生句柄溢出。</li>\n<li>序列化性能差：Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言；相对其它开源的序列化框架，Java 序列化后的码流太大，导致额外的资源占用；序列化性能差，资源占用率高（主要是 CPU 资源占用高）。</li>\n<li>线程模型问题：由于采用同步阻塞 I/O，导致每个 TCP 连接都占用了一个线程。</li>\n</ol>\n<h2 id=\"4-2-通信性能三原则\"><a href=\"#4-2-通信性能三原则\" class=\"headerlink\" title=\"4.2 通信性能三原则\"></a>4.2 通信性能三原则</h2><ol>\n<li>传输：用什么样的通道将数据发送给对方：BIO/NIO/AIO。I/O 模型在很大程度上决定了通信的性能。</li>\n<li>协议：采用什么样的通信协议， HTTP 等公有协议或者内部私有协议。通常内部私有协议可以被设计得更优。</li>\n<li>线程：数据报如何读取？读取之后的编解码在哪个线程进行？编解码后的消息如何派发？Reactor 线程模型的不同，对性能的影响也非常大。</li>\n</ol>\n<h2 id=\"4-3-高性能之道\"><a href=\"#4-3-高性能之道\" class=\"headerlink\" title=\"4.3 高性能之道\"></a>4.3 高性能之道</h2><p>Netty 支持高性能通信的架构特性进行总结：  </p>\n<ol>\n<li>异步非阻塞通信：Netty 的 I/O 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 SocketChannel。由于读写都是非阻塞的，这就可以充分提升 I/O 的运行效率，避免由频繁的 I/O 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>\n<li>高效的 I/O 线程模型：Netty 支持 Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型，可以满足不同的容量和性能需求。</li>\n<li>高性能的序列化框架：默认提供了 Protobuf 二进制序列化框架，其它二进制序列化框架可以进行编解码框架扩展实现。  </li>\n</ol>\n<p>还支持零拷贝、内存池等其它性能相关的特性。</p>\n<h1 id=\"5-最佳实践\"><a href=\"#5-最佳实践\" class=\"headerlink\" title=\"5 最佳实践\"></a>5 最佳实践</h1><ol>\n<li>服务端只负责客户端的接入，不处理 I/O 读写操作，因此服务端的 boosGroup 设置线程数为1：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);</code>。</li>\n<li>客户端的 NioEventLoopGroup 由于服务提供者可能有 1000个或更多，导致创建了 1000个对象，可以使用大的线程池，或者创建一个包含 NioEventLoopGroup 的数组，将客户端连接按照 Hash 算法分组，将所有连接均匀的打散在 NioEventLoopGroup 中。</li>\n</ol>\n<h1 id=\"6-个人总结\"><a href=\"#6-个人总结\" class=\"headerlink\" title=\"6 个人总结\"></a>6 个人总结</h1><p>通信框架的重点在于 BIO、NIO、AIO，以及序列化。<br>这就是为什么别人面试会问 BIO/NIO/AIO/序列化。</p>\n"},{"title":"二十一、服务化最佳实践","date":"2018-06-21T16:00:00.000Z","updated":"2018-06-21T17:18:00.000Z","comments":1,"_content":"\n# 1 性能和时延问题\n\n由本地 API 调用变为远程网络通信，增加了额外的性能损耗。\n\n## 1.1 RPC 框架高性能设计\n\n1. I/O 调度模型\n2. 序列化框架\n3. 线程调度模型：并行/无锁化算法\n\n### 1.1.1 I/O 调度模型\n\n使用 Netty，它在各种 NIO 框架中性能排名第一：\n1. 零拷贝：使用堆外内存。\n2. 内存池：使用堆外内存池。\n3. 无锁化的串行设计：尽量局部无锁化的串行线程。\n4. 高效并发编程：Volatile、CAS。\n\n### 1.1.2 序列化框架\n\n二进制序列化框架\n\n### 1.1.3 高性能的 Reactor 线程模型\n\n1. 专门的 NIO 线程：Acceptor 线程用于监听服务端，接受客户端的 TCP 连接请求。\n2. 网络 I/O 操作：读、写等由一个 NIO 线程池负责。\n3. 1 个 NIO 线程可以同时处理 N 条链路（epoll）。\n\n## 1.2 业务最佳实践\n\n1. 能异步的尽可能使用异步或并行服务调用。\n2. 线程池的参数配置必须合理（上下文切换损耗）。\n3. 尽量减少要传输的码流大小。\n4. 超时时间合理设置。\n5. 核心服务独立线程池。\n6. 利用 Docker 做物理资源层隔离。\n\n# 2 事务一致性问题\n\n## 2.1 分布式事务设计方案\n\n使用两阶段提交（具体参考 Paxos协议）。  \n![][1]  \n阶段一：全局事务管理器向所有事务参与者发送准备请求：事务参与者向全局事务管理器恢复自己是否准备就绪。  \n阶段二：全局事务管理器接收到所有事务参与者的回复之后做判断，如果所有事务参与者都可以提交，则向所有事务提交者发送提交申请，否则进行回滚。事务参与者根据全局事务管理器的指令进行提交或者回滚操作。\n\n## 2.2 分布式事务优化\n\n在大多数的业务场景中，我们可以使用最终一致性替代传统的强一致性，尽量避免使用分布式事务。  \n在实践中常用的最终一致性方案就是使用带有事务功能的 MQ 做中间人角色，它的工作原理如下：在做本地事务之前，先向 MQ 发送一个 prepare 消息，然后执行本地事务，本地事务提交成功的话，向 MQ 发送一个 commit 消息，否则发送一个 rollback 消息，取消之前的消息。MQ 只会收到 commit 确认才会将消息投递出去，所以这样的形式可以保证在一切正常的情况下，本地事务和 MQ 可以达到一致性。但是分布式调用存在很多异常场景，例如网络超时、VM宕机等，假如系统执行了 local_tx() 成功之后，还没来及将 commit 消息发送给 MQ ，或者说发送出去由于网络超时等原因， MQ 没有收到 commit ，发生了 commit 消息丢失，那么 MQ 就不会把 prepare 消息投递出去。 MQ 会根据策略去尝试询问（回调）发消息的系统（checkCommit）进行检查该消息是否应该投递出去或者丢弃，得到系统的确认之后， MQ 会做投递还是丢弃，这样就完全保证了 MQ 和发消息的系统的一致性，从而保证了接收消息系统的一致性。\n\n# 3 研发团队协作问题\n\n## 3.1 共用服务注册中心\n\n为了方便开发测试，经常会在线下共用一个所有服务贡献过得服务注册中心，这时，一个正在开发中的服务发布到服务注册中心，可能会导致一些消费者不可用。  \n解决方案：可以让服务提供者开发方，只订阅服务（开发的服务可能依赖其它服务），而不注册正在开发的服务，通过直连测试正在开发的服务。工作原理图如下：  \n![][2]\n\n## 3.2 直连提供者\n\n如果服务提供者多实例部署，但是服务提供者存在 BUG，就需要做远程端点调试，这会带来两个问题：  \n1. 调试过程中可能被其它消费者消费。\n2. 服务提供者多实例部署，远程调试地址无法确定，调试效率低。\n  \n解决策略：直连指定服务提供者。\n\n## 3.3 多团队进度协同\n\n假如前端 Web 门户依赖后台 A/B/C/D 4 个服务，分别由 4 个不同的研发团队负责，门户要求新特性 2 周内上线。 A/B 可以按期，但是 C/D 由于有其它更高优先级的任务，只能延期。导致依赖的服务越多，交付效率越低。  \n解决策略：调用链将应用、服务、中间件之间的依赖关系串接并展示出来，基于调用链首入口的交付时间做输入，利用依赖管理工具，自动计算出调用链上各个服务的最迟交付时间点，避免人为需求排序失误导致的需求延期。\n\n## 3.4 服务降级和 Mock 测试\n\n## 3.5 协同调试问题\n\n当依赖的服务尚未开发完成，将路由切换到模拟测试模式，自动调用 Mock 桩。上线时自动切换到真实的服务提供者。\n\n## 3.6 接口前后兼容性\n\n1. 严格遵守兼容性代码规范，文档实时同步更新通知。\n\n# 4 个人总结\n\n事务一致性问题、测试效率问题、依赖开发等，这只列举了部分问题，还有更多的问题需要在实践中探索，找出适合自己产品的服务化最佳实践。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_2.png","source":"_posts/分布式服务框架原理与实践/第二十一章 服务化最佳实践.md","raw":"---\ntitle: 二十一、服务化最佳实践\ndate: 2018-06-22 00:00:00\nupdated: 2018-06-22 01:18:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/21.html    \n---\n\n# 1 性能和时延问题\n\n由本地 API 调用变为远程网络通信，增加了额外的性能损耗。\n\n## 1.1 RPC 框架高性能设计\n\n1. I/O 调度模型\n2. 序列化框架\n3. 线程调度模型：并行/无锁化算法\n\n### 1.1.1 I/O 调度模型\n\n使用 Netty，它在各种 NIO 框架中性能排名第一：\n1. 零拷贝：使用堆外内存。\n2. 内存池：使用堆外内存池。\n3. 无锁化的串行设计：尽量局部无锁化的串行线程。\n4. 高效并发编程：Volatile、CAS。\n\n### 1.1.2 序列化框架\n\n二进制序列化框架\n\n### 1.1.3 高性能的 Reactor 线程模型\n\n1. 专门的 NIO 线程：Acceptor 线程用于监听服务端，接受客户端的 TCP 连接请求。\n2. 网络 I/O 操作：读、写等由一个 NIO 线程池负责。\n3. 1 个 NIO 线程可以同时处理 N 条链路（epoll）。\n\n## 1.2 业务最佳实践\n\n1. 能异步的尽可能使用异步或并行服务调用。\n2. 线程池的参数配置必须合理（上下文切换损耗）。\n3. 尽量减少要传输的码流大小。\n4. 超时时间合理设置。\n5. 核心服务独立线程池。\n6. 利用 Docker 做物理资源层隔离。\n\n# 2 事务一致性问题\n\n## 2.1 分布式事务设计方案\n\n使用两阶段提交（具体参考 Paxos协议）。  \n![][1]  \n阶段一：全局事务管理器向所有事务参与者发送准备请求：事务参与者向全局事务管理器恢复自己是否准备就绪。  \n阶段二：全局事务管理器接收到所有事务参与者的回复之后做判断，如果所有事务参与者都可以提交，则向所有事务提交者发送提交申请，否则进行回滚。事务参与者根据全局事务管理器的指令进行提交或者回滚操作。\n\n## 2.2 分布式事务优化\n\n在大多数的业务场景中，我们可以使用最终一致性替代传统的强一致性，尽量避免使用分布式事务。  \n在实践中常用的最终一致性方案就是使用带有事务功能的 MQ 做中间人角色，它的工作原理如下：在做本地事务之前，先向 MQ 发送一个 prepare 消息，然后执行本地事务，本地事务提交成功的话，向 MQ 发送一个 commit 消息，否则发送一个 rollback 消息，取消之前的消息。MQ 只会收到 commit 确认才会将消息投递出去，所以这样的形式可以保证在一切正常的情况下，本地事务和 MQ 可以达到一致性。但是分布式调用存在很多异常场景，例如网络超时、VM宕机等，假如系统执行了 local_tx() 成功之后，还没来及将 commit 消息发送给 MQ ，或者说发送出去由于网络超时等原因， MQ 没有收到 commit ，发生了 commit 消息丢失，那么 MQ 就不会把 prepare 消息投递出去。 MQ 会根据策略去尝试询问（回调）发消息的系统（checkCommit）进行检查该消息是否应该投递出去或者丢弃，得到系统的确认之后， MQ 会做投递还是丢弃，这样就完全保证了 MQ 和发消息的系统的一致性，从而保证了接收消息系统的一致性。\n\n# 3 研发团队协作问题\n\n## 3.1 共用服务注册中心\n\n为了方便开发测试，经常会在线下共用一个所有服务贡献过得服务注册中心，这时，一个正在开发中的服务发布到服务注册中心，可能会导致一些消费者不可用。  \n解决方案：可以让服务提供者开发方，只订阅服务（开发的服务可能依赖其它服务），而不注册正在开发的服务，通过直连测试正在开发的服务。工作原理图如下：  \n![][2]\n\n## 3.2 直连提供者\n\n如果服务提供者多实例部署，但是服务提供者存在 BUG，就需要做远程端点调试，这会带来两个问题：  \n1. 调试过程中可能被其它消费者消费。\n2. 服务提供者多实例部署，远程调试地址无法确定，调试效率低。\n  \n解决策略：直连指定服务提供者。\n\n## 3.3 多团队进度协同\n\n假如前端 Web 门户依赖后台 A/B/C/D 4 个服务，分别由 4 个不同的研发团队负责，门户要求新特性 2 周内上线。 A/B 可以按期，但是 C/D 由于有其它更高优先级的任务，只能延期。导致依赖的服务越多，交付效率越低。  \n解决策略：调用链将应用、服务、中间件之间的依赖关系串接并展示出来，基于调用链首入口的交付时间做输入，利用依赖管理工具，自动计算出调用链上各个服务的最迟交付时间点，避免人为需求排序失误导致的需求延期。\n\n## 3.4 服务降级和 Mock 测试\n\n## 3.5 协同调试问题\n\n当依赖的服务尚未开发完成，将路由切换到模拟测试模式，自动调用 Mock 桩。上线时自动切换到真实的服务提供者。\n\n## 3.6 接口前后兼容性\n\n1. 严格遵守兼容性代码规范，文档实时同步更新通知。\n\n# 4 个人总结\n\n事务一致性问题、测试效率问题、依赖开发等，这只列举了部分问题，还有更多的问题需要在实践中探索，找出适合自己产品的服务化最佳实践。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_2.png","slug":"distributed_principle_prictice/21.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav60013axs67imx1ltz","content":"<h1 id=\"1-性能和时延问题\"><a href=\"#1-性能和时延问题\" class=\"headerlink\" title=\"1 性能和时延问题\"></a>1 性能和时延问题</h1><p>由本地 API 调用变为远程网络通信，增加了额外的性能损耗。</p>\n<h2 id=\"1-1-RPC-框架高性能设计\"><a href=\"#1-1-RPC-框架高性能设计\" class=\"headerlink\" title=\"1.1 RPC 框架高性能设计\"></a>1.1 RPC 框架高性能设计</h2><ol>\n<li>I/O 调度模型</li>\n<li>序列化框架</li>\n<li>线程调度模型：并行/无锁化算法</li>\n</ol>\n<h3 id=\"1-1-1-I-O-调度模型\"><a href=\"#1-1-1-I-O-调度模型\" class=\"headerlink\" title=\"1.1.1 I/O 调度模型\"></a>1.1.1 I/O 调度模型</h3><p>使用 Netty，它在各种 NIO 框架中性能排名第一：</p>\n<ol>\n<li>零拷贝：使用堆外内存。</li>\n<li>内存池：使用堆外内存池。</li>\n<li>无锁化的串行设计：尽量局部无锁化的串行线程。</li>\n<li>高效并发编程：Volatile、CAS。</li>\n</ol>\n<h3 id=\"1-1-2-序列化框架\"><a href=\"#1-1-2-序列化框架\" class=\"headerlink\" title=\"1.1.2 序列化框架\"></a>1.1.2 序列化框架</h3><p>二进制序列化框架</p>\n<h3 id=\"1-1-3-高性能的-Reactor-线程模型\"><a href=\"#1-1-3-高性能的-Reactor-线程模型\" class=\"headerlink\" title=\"1.1.3 高性能的 Reactor 线程模型\"></a>1.1.3 高性能的 Reactor 线程模型</h3><ol>\n<li>专门的 NIO 线程：Acceptor 线程用于监听服务端，接受客户端的 TCP 连接请求。</li>\n<li>网络 I/O 操作：读、写等由一个 NIO 线程池负责。</li>\n<li>1 个 NIO 线程可以同时处理 N 条链路（epoll）。</li>\n</ol>\n<h2 id=\"1-2-业务最佳实践\"><a href=\"#1-2-业务最佳实践\" class=\"headerlink\" title=\"1.2 业务最佳实践\"></a>1.2 业务最佳实践</h2><ol>\n<li>能异步的尽可能使用异步或并行服务调用。</li>\n<li>线程池的参数配置必须合理（上下文切换损耗）。</li>\n<li>尽量减少要传输的码流大小。</li>\n<li>超时时间合理设置。</li>\n<li>核心服务独立线程池。</li>\n<li>利用 Docker 做物理资源层隔离。</li>\n</ol>\n<h1 id=\"2-事务一致性问题\"><a href=\"#2-事务一致性问题\" class=\"headerlink\" title=\"2 事务一致性问题\"></a>2 事务一致性问题</h1><h2 id=\"2-1-分布式事务设计方案\"><a href=\"#2-1-分布式事务设计方案\" class=\"headerlink\" title=\"2.1 分布式事务设计方案\"></a>2.1 分布式事务设计方案</h2><p>使用两阶段提交（具体参考 Paxos协议）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_1.png\" alt=\"\"><br>阶段一：全局事务管理器向所有事务参与者发送准备请求：事务参与者向全局事务管理器恢复自己是否准备就绪。<br>阶段二：全局事务管理器接收到所有事务参与者的回复之后做判断，如果所有事务参与者都可以提交，则向所有事务提交者发送提交申请，否则进行回滚。事务参与者根据全局事务管理器的指令进行提交或者回滚操作。</p>\n<h2 id=\"2-2-分布式事务优化\"><a href=\"#2-2-分布式事务优化\" class=\"headerlink\" title=\"2.2 分布式事务优化\"></a>2.2 分布式事务优化</h2><p>在大多数的业务场景中，我们可以使用最终一致性替代传统的强一致性，尽量避免使用分布式事务。<br>在实践中常用的最终一致性方案就是使用带有事务功能的 MQ 做中间人角色，它的工作原理如下：在做本地事务之前，先向 MQ 发送一个 prepare 消息，然后执行本地事务，本地事务提交成功的话，向 MQ 发送一个 commit 消息，否则发送一个 rollback 消息，取消之前的消息。MQ 只会收到 commit 确认才会将消息投递出去，所以这样的形式可以保证在一切正常的情况下，本地事务和 MQ 可以达到一致性。但是分布式调用存在很多异常场景，例如网络超时、VM宕机等，假如系统执行了 local_tx() 成功之后，还没来及将 commit 消息发送给 MQ ，或者说发送出去由于网络超时等原因， MQ 没有收到 commit ，发生了 commit 消息丢失，那么 MQ 就不会把 prepare 消息投递出去。 MQ 会根据策略去尝试询问（回调）发消息的系统（checkCommit）进行检查该消息是否应该投递出去或者丢弃，得到系统的确认之后， MQ 会做投递还是丢弃，这样就完全保证了 MQ 和发消息的系统的一致性，从而保证了接收消息系统的一致性。</p>\n<h1 id=\"3-研发团队协作问题\"><a href=\"#3-研发团队协作问题\" class=\"headerlink\" title=\"3 研发团队协作问题\"></a>3 研发团队协作问题</h1><h2 id=\"3-1-共用服务注册中心\"><a href=\"#3-1-共用服务注册中心\" class=\"headerlink\" title=\"3.1 共用服务注册中心\"></a>3.1 共用服务注册中心</h2><p>为了方便开发测试，经常会在线下共用一个所有服务贡献过得服务注册中心，这时，一个正在开发中的服务发布到服务注册中心，可能会导致一些消费者不可用。<br>解决方案：可以让服务提供者开发方，只订阅服务（开发的服务可能依赖其它服务），而不注册正在开发的服务，通过直连测试正在开发的服务。工作原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_2.png\" alt=\"\"></p>\n<h2 id=\"3-2-直连提供者\"><a href=\"#3-2-直连提供者\" class=\"headerlink\" title=\"3.2 直连提供者\"></a>3.2 直连提供者</h2><p>如果服务提供者多实例部署，但是服务提供者存在 BUG，就需要做远程端点调试，这会带来两个问题：  </p>\n<ol>\n<li>调试过程中可能被其它消费者消费。</li>\n<li>服务提供者多实例部署，远程调试地址无法确定，调试效率低。</li>\n</ol>\n<p>解决策略：直连指定服务提供者。</p>\n<h2 id=\"3-3-多团队进度协同\"><a href=\"#3-3-多团队进度协同\" class=\"headerlink\" title=\"3.3 多团队进度协同\"></a>3.3 多团队进度协同</h2><p>假如前端 Web 门户依赖后台 A/B/C/D 4 个服务，分别由 4 个不同的研发团队负责，门户要求新特性 2 周内上线。 A/B 可以按期，但是 C/D 由于有其它更高优先级的任务，只能延期。导致依赖的服务越多，交付效率越低。<br>解决策略：调用链将应用、服务、中间件之间的依赖关系串接并展示出来，基于调用链首入口的交付时间做输入，利用依赖管理工具，自动计算出调用链上各个服务的最迟交付时间点，避免人为需求排序失误导致的需求延期。</p>\n<h2 id=\"3-4-服务降级和-Mock-测试\"><a href=\"#3-4-服务降级和-Mock-测试\" class=\"headerlink\" title=\"3.4 服务降级和 Mock 测试\"></a>3.4 服务降级和 Mock 测试</h2><h2 id=\"3-5-协同调试问题\"><a href=\"#3-5-协同调试问题\" class=\"headerlink\" title=\"3.5 协同调试问题\"></a>3.5 协同调试问题</h2><p>当依赖的服务尚未开发完成，将路由切换到模拟测试模式，自动调用 Mock 桩。上线时自动切换到真实的服务提供者。</p>\n<h2 id=\"3-6-接口前后兼容性\"><a href=\"#3-6-接口前后兼容性\" class=\"headerlink\" title=\"3.6 接口前后兼容性\"></a>3.6 接口前后兼容性</h2><ol>\n<li>严格遵守兼容性代码规范，文档实时同步更新通知。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>事务一致性问题、测试效率问题、依赖开发等，这只列举了部分问题，还有更多的问题需要在实践中探索，找出适合自己产品的服务化最佳实践。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-性能和时延问题\"><a href=\"#1-性能和时延问题\" class=\"headerlink\" title=\"1 性能和时延问题\"></a>1 性能和时延问题</h1><p>由本地 API 调用变为远程网络通信，增加了额外的性能损耗。</p>\n<h2 id=\"1-1-RPC-框架高性能设计\"><a href=\"#1-1-RPC-框架高性能设计\" class=\"headerlink\" title=\"1.1 RPC 框架高性能设计\"></a>1.1 RPC 框架高性能设计</h2><ol>\n<li>I/O 调度模型</li>\n<li>序列化框架</li>\n<li>线程调度模型：并行/无锁化算法</li>\n</ol>\n<h3 id=\"1-1-1-I-O-调度模型\"><a href=\"#1-1-1-I-O-调度模型\" class=\"headerlink\" title=\"1.1.1 I/O 调度模型\"></a>1.1.1 I/O 调度模型</h3><p>使用 Netty，它在各种 NIO 框架中性能排名第一：</p>\n<ol>\n<li>零拷贝：使用堆外内存。</li>\n<li>内存池：使用堆外内存池。</li>\n<li>无锁化的串行设计：尽量局部无锁化的串行线程。</li>\n<li>高效并发编程：Volatile、CAS。</li>\n</ol>\n<h3 id=\"1-1-2-序列化框架\"><a href=\"#1-1-2-序列化框架\" class=\"headerlink\" title=\"1.1.2 序列化框架\"></a>1.1.2 序列化框架</h3><p>二进制序列化框架</p>\n<h3 id=\"1-1-3-高性能的-Reactor-线程模型\"><a href=\"#1-1-3-高性能的-Reactor-线程模型\" class=\"headerlink\" title=\"1.1.3 高性能的 Reactor 线程模型\"></a>1.1.3 高性能的 Reactor 线程模型</h3><ol>\n<li>专门的 NIO 线程：Acceptor 线程用于监听服务端，接受客户端的 TCP 连接请求。</li>\n<li>网络 I/O 操作：读、写等由一个 NIO 线程池负责。</li>\n<li>1 个 NIO 线程可以同时处理 N 条链路（epoll）。</li>\n</ol>\n<h2 id=\"1-2-业务最佳实践\"><a href=\"#1-2-业务最佳实践\" class=\"headerlink\" title=\"1.2 业务最佳实践\"></a>1.2 业务最佳实践</h2><ol>\n<li>能异步的尽可能使用异步或并行服务调用。</li>\n<li>线程池的参数配置必须合理（上下文切换损耗）。</li>\n<li>尽量减少要传输的码流大小。</li>\n<li>超时时间合理设置。</li>\n<li>核心服务独立线程池。</li>\n<li>利用 Docker 做物理资源层隔离。</li>\n</ol>\n<h1 id=\"2-事务一致性问题\"><a href=\"#2-事务一致性问题\" class=\"headerlink\" title=\"2 事务一致性问题\"></a>2 事务一致性问题</h1><h2 id=\"2-1-分布式事务设计方案\"><a href=\"#2-1-分布式事务设计方案\" class=\"headerlink\" title=\"2.1 分布式事务设计方案\"></a>2.1 分布式事务设计方案</h2><p>使用两阶段提交（具体参考 Paxos协议）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_1.png\" alt=\"\"><br>阶段一：全局事务管理器向所有事务参与者发送准备请求：事务参与者向全局事务管理器恢复自己是否准备就绪。<br>阶段二：全局事务管理器接收到所有事务参与者的回复之后做判断，如果所有事务参与者都可以提交，则向所有事务提交者发送提交申请，否则进行回滚。事务参与者根据全局事务管理器的指令进行提交或者回滚操作。</p>\n<h2 id=\"2-2-分布式事务优化\"><a href=\"#2-2-分布式事务优化\" class=\"headerlink\" title=\"2.2 分布式事务优化\"></a>2.2 分布式事务优化</h2><p>在大多数的业务场景中，我们可以使用最终一致性替代传统的强一致性，尽量避免使用分布式事务。<br>在实践中常用的最终一致性方案就是使用带有事务功能的 MQ 做中间人角色，它的工作原理如下：在做本地事务之前，先向 MQ 发送一个 prepare 消息，然后执行本地事务，本地事务提交成功的话，向 MQ 发送一个 commit 消息，否则发送一个 rollback 消息，取消之前的消息。MQ 只会收到 commit 确认才会将消息投递出去，所以这样的形式可以保证在一切正常的情况下，本地事务和 MQ 可以达到一致性。但是分布式调用存在很多异常场景，例如网络超时、VM宕机等，假如系统执行了 local_tx() 成功之后，还没来及将 commit 消息发送给 MQ ，或者说发送出去由于网络超时等原因， MQ 没有收到 commit ，发生了 commit 消息丢失，那么 MQ 就不会把 prepare 消息投递出去。 MQ 会根据策略去尝试询问（回调）发消息的系统（checkCommit）进行检查该消息是否应该投递出去或者丢弃，得到系统的确认之后， MQ 会做投递还是丢弃，这样就完全保证了 MQ 和发消息的系统的一致性，从而保证了接收消息系统的一致性。</p>\n<h1 id=\"3-研发团队协作问题\"><a href=\"#3-研发团队协作问题\" class=\"headerlink\" title=\"3 研发团队协作问题\"></a>3 研发团队协作问题</h1><h2 id=\"3-1-共用服务注册中心\"><a href=\"#3-1-共用服务注册中心\" class=\"headerlink\" title=\"3.1 共用服务注册中心\"></a>3.1 共用服务注册中心</h2><p>为了方便开发测试，经常会在线下共用一个所有服务贡献过得服务注册中心，这时，一个正在开发中的服务发布到服务注册中心，可能会导致一些消费者不可用。<br>解决方案：可以让服务提供者开发方，只订阅服务（开发的服务可能依赖其它服务），而不注册正在开发的服务，通过直连测试正在开发的服务。工作原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_2.png\" alt=\"\"></p>\n<h2 id=\"3-2-直连提供者\"><a href=\"#3-2-直连提供者\" class=\"headerlink\" title=\"3.2 直连提供者\"></a>3.2 直连提供者</h2><p>如果服务提供者多实例部署，但是服务提供者存在 BUG，就需要做远程端点调试，这会带来两个问题：  </p>\n<ol>\n<li>调试过程中可能被其它消费者消费。</li>\n<li>服务提供者多实例部署，远程调试地址无法确定，调试效率低。</li>\n</ol>\n<p>解决策略：直连指定服务提供者。</p>\n<h2 id=\"3-3-多团队进度协同\"><a href=\"#3-3-多团队进度协同\" class=\"headerlink\" title=\"3.3 多团队进度协同\"></a>3.3 多团队进度协同</h2><p>假如前端 Web 门户依赖后台 A/B/C/D 4 个服务，分别由 4 个不同的研发团队负责，门户要求新特性 2 周内上线。 A/B 可以按期，但是 C/D 由于有其它更高优先级的任务，只能延期。导致依赖的服务越多，交付效率越低。<br>解决策略：调用链将应用、服务、中间件之间的依赖关系串接并展示出来，基于调用链首入口的交付时间做输入，利用依赖管理工具，自动计算出调用链上各个服务的最迟交付时间点，避免人为需求排序失误导致的需求延期。</p>\n<h2 id=\"3-4-服务降级和-Mock-测试\"><a href=\"#3-4-服务降级和-Mock-测试\" class=\"headerlink\" title=\"3.4 服务降级和 Mock 测试\"></a>3.4 服务降级和 Mock 测试</h2><h2 id=\"3-5-协同调试问题\"><a href=\"#3-5-协同调试问题\" class=\"headerlink\" title=\"3.5 协同调试问题\"></a>3.5 协同调试问题</h2><p>当依赖的服务尚未开发完成，将路由切换到模拟测试模式，自动调用 Mock 桩。上线时自动切换到真实的服务提供者。</p>\n<h2 id=\"3-6-接口前后兼容性\"><a href=\"#3-6-接口前后兼容性\" class=\"headerlink\" title=\"3.6 接口前后兼容性\"></a>3.6 接口前后兼容性</h2><ol>\n<li>严格遵守兼容性代码规范，文档实时同步更新通知。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>事务一致性问题、测试效率问题、依赖开发等，这只列举了部分问题，还有更多的问题需要在实践中探索，找出适合自己产品的服务化最佳实践。</p>\n"},{"title":"八、服务调用","date":"2018-05-31T15:34:00.000Z","updated":"2018-06-02T04:10:00.000Z","comments":1,"_content":"\n由于惯性思维，很多人会将传统 MVC架构/RPC架构的做法带入到分布式服务框架的架构设计中，其中有些思想存在误区，或者已经过时，它们会破坏分布式服务框架的架构品质。\n\n# 1 几个误区\n\n## 1.1 NIO 就是异步服务\n\nNIO 只解决了通信层面的异步问题，跟服务调用的异步没有必然关系，也就是说，即便采用传统的 BIO 通信，依然可以实现异步服务调用，只不过通信效率和可靠性比较差。  \n下面对异步服务调用和通信框架的关系进行说明：  \n![][1]  \n用户发起远程服务调用之后，经历层层业务逻辑处理、消息编码，最终序列化后的消息会被放入到通信框架的消息队列中。业务线程可以选择同步等待、也可以选择直接返回，通过消息队列的方式实现业务层和通信层的分离是比较成熟、典型的做法。  \n采用 NIO还是 BIO对上层的业务是不可见的，双方的汇聚点就是消息队列。业务线程将消息放入到发送队列中，可以选择主动等待或者立即返回，跟通信框架是否是 NIO 没有任何关系。\n\n## 1.2 服务调用天生就是同步的\n\n服务调用主要有两种模式：\n1. OneWay 模式：只有请求，没有应答，例如通知消息。\n2. 请求-应答模式：一请求，一应答的模式，这种模式最常用。\n  \nOneWay 模式的服务调用由于不需要返回应答，因此很容易被设计成异步的：消费者发起远程服务调用之后，立即返回，不需要同步阻塞等待应答。  \n对于请求-应答模式，可以利用 Future-Listener 机制来实现异步服务调用。从业务角度看，它的效果与同步等待等价，但是从技术角度来看，可以保证业务线程在不同步阻塞的情况下实现同步等待的效果，执行效率更高。\n\n## 1.3 异步服务调用性能更高\n\n复杂的场景，异步服务调用会更高，越复杂的场景，异步服务调用优势越大。\n\n# 2 服务调用方式\n\n## 2.1 同步服务调用\n\n没什么可说的，只是需要注意设置用户线程等待超时时间。\n\n## 2.2 异步服务调用\n\n基于 JDK的 Future机制，异步服务调用的工作原理如下：  \n![][2]  \n1. 消费者调用服务端发布的接口，接口调用由分布式服务框架包装成动态代理，发起远程服务调用。\n2. 通信框架异步发送请求消息，如果没有发生 I/O异常，返回。\n3. 请求消息发送成功后，I/O 线程构造 Future 对象，设置到 RPC上下文中。\n4. 用户线程通过 RPC上下文获取 Future对象。\n5. 构造 Listener 对象，将其添加到 Future中，用于服务端应答异步回调通知。\n6. 用户线程返回，不阻塞等待应答，\n7. 服务端返回应答消息，通信框架负责反序列化等。\n8. I/O 线程将应答设置到 Future 对象的操作结果中。\n9. Future 对象扫描注册的监听器列表，循环调用监听器的 operationComplete方法，将结果通知给监听器，监听器获取到结果，执行后续业务，异步调用结束。\n  \n还有一种异步调用形式，就是不添加 Listener，用户连续发起 N次服务调用，然后依次从 RPC上下文中获取 Futrue对象，最终再主动 get结果，业务线程阻塞，相对比老的同步服务调用，它的阻塞时间更短，工作原理如下：  \n![][3]  \n  \n其串行到并行的优化原理如下图：  \n![][4]  \n![][5]  \n  \n异步服务调用的代码示例如下：  \n```java\nXxxService1.xxxMethod(Req); // 立即返回 null\nFuture f1 = RpcContext.getContext().getFuture();\nXxxService2.xxxMethod(Req);\nFuture f2 = RpcContext.getContext().getFuture();\nObject xResult1 = f1.get(3000);\nObject xResult2 = f2.get(3000);\n```\n第二种基于 Future-Listener 的纯异步服务调用示例如下：  \n```java\nXxxService1.xxxMethod(Req);\nFuture f1 = RpcContext.getContext().getFuture();\nListener l = new Listener();\nf1.addListener(l);\n```\n\n## 2.3 并行服务调用\n\nA服务->B服务->C服务->...  \n串行服务调用比较简单，但在一些业务场景中，需要采用并行服务调用来降低 E2E 的时延。\n1. 多个服务之间逻辑不存在互相依赖关系，执行先后顺序没有严格的要求，逻辑上可以被并行执行。\n2. 长流程业务，调用多个服务，对时延比较敏感，其中有部分服务逻辑上无上下文关联。\n目标主要有两个：\n1. 降低业务 E2E 时延。\n2. 提升整个系统的吞吐量。\n\n## 2.4 泛化调用\n\n主要用于客户端没有API 接口及数据模型的场景，使用 Map表示。\n\n# 3 最佳实践\n\n服务框架支持多种服务调用方式，在实现项目中中如何选择，建议从以下几个角度考虑：  \n1. 降低业务 E2E时延：业务调用链是否太长、某些服务是否不太可靠，需要对服务调用流程进行梳理，看是否可以通过并行服务调用来提升调用效率，降低服务调用时延。\n2. 可靠性角度：某些业务调用链上的关键服务不太可靠，一旦出故障会导致大量线程资源被挂住，可以考虑使用异步服务调用防止故障扩展。\n3. 业务场景：对于测试，不想为每个测试用例都开发一个服务接口，能否做一个通用的测试框架，通过 Map等泛容器实现通用服务调用。\n4. 传统的 RPC调用：服务调用比较简单，对时延要求不高的场景，可以考虑同步服务调用。\n\n# 4 个人总结\n\n服务调用有多种形式，需要从业务和技术做出取舍。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_5.png","source":"_posts/分布式服务框架原理与实践/第八章 服务调用.md","raw":"---\ntitle: 八、服务调用\ndate: 2018-05-31 23:34:00\nupdated: 2018-06-02 12:10:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/8.html    \n---\n\n由于惯性思维，很多人会将传统 MVC架构/RPC架构的做法带入到分布式服务框架的架构设计中，其中有些思想存在误区，或者已经过时，它们会破坏分布式服务框架的架构品质。\n\n# 1 几个误区\n\n## 1.1 NIO 就是异步服务\n\nNIO 只解决了通信层面的异步问题，跟服务调用的异步没有必然关系，也就是说，即便采用传统的 BIO 通信，依然可以实现异步服务调用，只不过通信效率和可靠性比较差。  \n下面对异步服务调用和通信框架的关系进行说明：  \n![][1]  \n用户发起远程服务调用之后，经历层层业务逻辑处理、消息编码，最终序列化后的消息会被放入到通信框架的消息队列中。业务线程可以选择同步等待、也可以选择直接返回，通过消息队列的方式实现业务层和通信层的分离是比较成熟、典型的做法。  \n采用 NIO还是 BIO对上层的业务是不可见的，双方的汇聚点就是消息队列。业务线程将消息放入到发送队列中，可以选择主动等待或者立即返回，跟通信框架是否是 NIO 没有任何关系。\n\n## 1.2 服务调用天生就是同步的\n\n服务调用主要有两种模式：\n1. OneWay 模式：只有请求，没有应答，例如通知消息。\n2. 请求-应答模式：一请求，一应答的模式，这种模式最常用。\n  \nOneWay 模式的服务调用由于不需要返回应答，因此很容易被设计成异步的：消费者发起远程服务调用之后，立即返回，不需要同步阻塞等待应答。  \n对于请求-应答模式，可以利用 Future-Listener 机制来实现异步服务调用。从业务角度看，它的效果与同步等待等价，但是从技术角度来看，可以保证业务线程在不同步阻塞的情况下实现同步等待的效果，执行效率更高。\n\n## 1.3 异步服务调用性能更高\n\n复杂的场景，异步服务调用会更高，越复杂的场景，异步服务调用优势越大。\n\n# 2 服务调用方式\n\n## 2.1 同步服务调用\n\n没什么可说的，只是需要注意设置用户线程等待超时时间。\n\n## 2.2 异步服务调用\n\n基于 JDK的 Future机制，异步服务调用的工作原理如下：  \n![][2]  \n1. 消费者调用服务端发布的接口，接口调用由分布式服务框架包装成动态代理，发起远程服务调用。\n2. 通信框架异步发送请求消息，如果没有发生 I/O异常，返回。\n3. 请求消息发送成功后，I/O 线程构造 Future 对象，设置到 RPC上下文中。\n4. 用户线程通过 RPC上下文获取 Future对象。\n5. 构造 Listener 对象，将其添加到 Future中，用于服务端应答异步回调通知。\n6. 用户线程返回，不阻塞等待应答，\n7. 服务端返回应答消息，通信框架负责反序列化等。\n8. I/O 线程将应答设置到 Future 对象的操作结果中。\n9. Future 对象扫描注册的监听器列表，循环调用监听器的 operationComplete方法，将结果通知给监听器，监听器获取到结果，执行后续业务，异步调用结束。\n  \n还有一种异步调用形式，就是不添加 Listener，用户连续发起 N次服务调用，然后依次从 RPC上下文中获取 Futrue对象，最终再主动 get结果，业务线程阻塞，相对比老的同步服务调用，它的阻塞时间更短，工作原理如下：  \n![][3]  \n  \n其串行到并行的优化原理如下图：  \n![][4]  \n![][5]  \n  \n异步服务调用的代码示例如下：  \n```java\nXxxService1.xxxMethod(Req); // 立即返回 null\nFuture f1 = RpcContext.getContext().getFuture();\nXxxService2.xxxMethod(Req);\nFuture f2 = RpcContext.getContext().getFuture();\nObject xResult1 = f1.get(3000);\nObject xResult2 = f2.get(3000);\n```\n第二种基于 Future-Listener 的纯异步服务调用示例如下：  \n```java\nXxxService1.xxxMethod(Req);\nFuture f1 = RpcContext.getContext().getFuture();\nListener l = new Listener();\nf1.addListener(l);\n```\n\n## 2.3 并行服务调用\n\nA服务->B服务->C服务->...  \n串行服务调用比较简单，但在一些业务场景中，需要采用并行服务调用来降低 E2E 的时延。\n1. 多个服务之间逻辑不存在互相依赖关系，执行先后顺序没有严格的要求，逻辑上可以被并行执行。\n2. 长流程业务，调用多个服务，对时延比较敏感，其中有部分服务逻辑上无上下文关联。\n目标主要有两个：\n1. 降低业务 E2E 时延。\n2. 提升整个系统的吞吐量。\n\n## 2.4 泛化调用\n\n主要用于客户端没有API 接口及数据模型的场景，使用 Map表示。\n\n# 3 最佳实践\n\n服务框架支持多种服务调用方式，在实现项目中中如何选择，建议从以下几个角度考虑：  \n1. 降低业务 E2E时延：业务调用链是否太长、某些服务是否不太可靠，需要对服务调用流程进行梳理，看是否可以通过并行服务调用来提升调用效率，降低服务调用时延。\n2. 可靠性角度：某些业务调用链上的关键服务不太可靠，一旦出故障会导致大量线程资源被挂住，可以考虑使用异步服务调用防止故障扩展。\n3. 业务场景：对于测试，不想为每个测试用例都开发一个服务接口，能否做一个通用的测试框架，通过 Map等泛容器实现通用服务调用。\n4. 传统的 RPC调用：服务调用比较简单，对时延要求不高的场景，可以考虑同步服务调用。\n\n# 4 个人总结\n\n服务调用有多种形式，需要从业务和技术做出取舍。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_5.png","slug":"distributed_principle_prictice/8.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav70016axs6ygtcmp4t","content":"<p>由于惯性思维，很多人会将传统 MVC架构/RPC架构的做法带入到分布式服务框架的架构设计中，其中有些思想存在误区，或者已经过时，它们会破坏分布式服务框架的架构品质。</p>\n<h1 id=\"1-几个误区\"><a href=\"#1-几个误区\" class=\"headerlink\" title=\"1 几个误区\"></a>1 几个误区</h1><h2 id=\"1-1-NIO-就是异步服务\"><a href=\"#1-1-NIO-就是异步服务\" class=\"headerlink\" title=\"1.1 NIO 就是异步服务\"></a>1.1 NIO 就是异步服务</h2><p>NIO 只解决了通信层面的异步问题，跟服务调用的异步没有必然关系，也就是说，即便采用传统的 BIO 通信，依然可以实现异步服务调用，只不过通信效率和可靠性比较差。<br>下面对异步服务调用和通信框架的关系进行说明：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_1.png\" alt=\"\"><br>用户发起远程服务调用之后，经历层层业务逻辑处理、消息编码，最终序列化后的消息会被放入到通信框架的消息队列中。业务线程可以选择同步等待、也可以选择直接返回，通过消息队列的方式实现业务层和通信层的分离是比较成熟、典型的做法。<br>采用 NIO还是 BIO对上层的业务是不可见的，双方的汇聚点就是消息队列。业务线程将消息放入到发送队列中，可以选择主动等待或者立即返回，跟通信框架是否是 NIO 没有任何关系。</p>\n<h2 id=\"1-2-服务调用天生就是同步的\"><a href=\"#1-2-服务调用天生就是同步的\" class=\"headerlink\" title=\"1.2 服务调用天生就是同步的\"></a>1.2 服务调用天生就是同步的</h2><p>服务调用主要有两种模式：</p>\n<ol>\n<li>OneWay 模式：只有请求，没有应答，例如通知消息。</li>\n<li>请求-应答模式：一请求，一应答的模式，这种模式最常用。</li>\n</ol>\n<p>OneWay 模式的服务调用由于不需要返回应答，因此很容易被设计成异步的：消费者发起远程服务调用之后，立即返回，不需要同步阻塞等待应答。<br>对于请求-应答模式，可以利用 Future-Listener 机制来实现异步服务调用。从业务角度看，它的效果与同步等待等价，但是从技术角度来看，可以保证业务线程在不同步阻塞的情况下实现同步等待的效果，执行效率更高。</p>\n<h2 id=\"1-3-异步服务调用性能更高\"><a href=\"#1-3-异步服务调用性能更高\" class=\"headerlink\" title=\"1.3 异步服务调用性能更高\"></a>1.3 异步服务调用性能更高</h2><p>复杂的场景，异步服务调用会更高，越复杂的场景，异步服务调用优势越大。</p>\n<h1 id=\"2-服务调用方式\"><a href=\"#2-服务调用方式\" class=\"headerlink\" title=\"2 服务调用方式\"></a>2 服务调用方式</h1><h2 id=\"2-1-同步服务调用\"><a href=\"#2-1-同步服务调用\" class=\"headerlink\" title=\"2.1 同步服务调用\"></a>2.1 同步服务调用</h2><p>没什么可说的，只是需要注意设置用户线程等待超时时间。</p>\n<h2 id=\"2-2-异步服务调用\"><a href=\"#2-2-异步服务调用\" class=\"headerlink\" title=\"2.2 异步服务调用\"></a>2.2 异步服务调用</h2><p>基于 JDK的 Future机制，异步服务调用的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_2.png\" alt=\"\">  </p>\n<ol>\n<li>消费者调用服务端发布的接口，接口调用由分布式服务框架包装成动态代理，发起远程服务调用。</li>\n<li>通信框架异步发送请求消息，如果没有发生 I/O异常，返回。</li>\n<li>请求消息发送成功后，I/O 线程构造 Future 对象，设置到 RPC上下文中。</li>\n<li>用户线程通过 RPC上下文获取 Future对象。</li>\n<li>构造 Listener 对象，将其添加到 Future中，用于服务端应答异步回调通知。</li>\n<li>用户线程返回，不阻塞等待应答，</li>\n<li>服务端返回应答消息，通信框架负责反序列化等。</li>\n<li>I/O 线程将应答设置到 Future 对象的操作结果中。</li>\n<li>Future 对象扫描注册的监听器列表，循环调用监听器的 operationComplete方法，将结果通知给监听器，监听器获取到结果，执行后续业务，异步调用结束。</li>\n</ol>\n<p>还有一种异步调用形式，就是不添加 Listener，用户连续发起 N次服务调用，然后依次从 RPC上下文中获取 Futrue对象，最终再主动 get结果，业务线程阻塞，相对比老的同步服务调用，它的阻塞时间更短，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_3.png\" alt=\"\">  </p>\n<p>其串行到并行的优化原理如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_4.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_5.png\" alt=\"\">  </p>\n<p>异步服务调用的代码示例如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XxxService1.xxxMethod(Req); <span class=\"comment\">// 立即返回 null</span></span><br><span class=\"line\">Future f1 = RpcContext.getContext().getFuture();</span><br><span class=\"line\">XxxService2.xxxMethod(Req);</span><br><span class=\"line\">Future f2 = RpcContext.getContext().getFuture();</span><br><span class=\"line\">Object xResult1 = f1.get(<span class=\"number\">3000</span>);</span><br><span class=\"line\">Object xResult2 = f2.get(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第二种基于 Future-Listener 的纯异步服务调用示例如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XxxService1.xxxMethod(Req);</span><br><span class=\"line\">Future f1 = RpcContext.getContext().getFuture();</span><br><span class=\"line\">Listener l = <span class=\"keyword\">new</span> Listener();</span><br><span class=\"line\">f1.addListener(l);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-并行服务调用\"><a href=\"#2-3-并行服务调用\" class=\"headerlink\" title=\"2.3 并行服务调用\"></a>2.3 并行服务调用</h2><p>A服务-&gt;B服务-&gt;C服务-&gt;…<br>串行服务调用比较简单，但在一些业务场景中，需要采用并行服务调用来降低 E2E 的时延。</p>\n<ol>\n<li>多个服务之间逻辑不存在互相依赖关系，执行先后顺序没有严格的要求，逻辑上可以被并行执行。</li>\n<li>长流程业务，调用多个服务，对时延比较敏感，其中有部分服务逻辑上无上下文关联。<br>目标主要有两个：</li>\n<li>降低业务 E2E 时延。</li>\n<li>提升整个系统的吞吐量。</li>\n</ol>\n<h2 id=\"2-4-泛化调用\"><a href=\"#2-4-泛化调用\" class=\"headerlink\" title=\"2.4 泛化调用\"></a>2.4 泛化调用</h2><p>主要用于客户端没有API 接口及数据模型的场景，使用 Map表示。</p>\n<h1 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3 最佳实践\"></a>3 最佳实践</h1><p>服务框架支持多种服务调用方式，在实现项目中中如何选择，建议从以下几个角度考虑：  </p>\n<ol>\n<li>降低业务 E2E时延：业务调用链是否太长、某些服务是否不太可靠，需要对服务调用流程进行梳理，看是否可以通过并行服务调用来提升调用效率，降低服务调用时延。</li>\n<li>可靠性角度：某些业务调用链上的关键服务不太可靠，一旦出故障会导致大量线程资源被挂住，可以考虑使用异步服务调用防止故障扩展。</li>\n<li>业务场景：对于测试，不想为每个测试用例都开发一个服务接口，能否做一个通用的测试框架，通过 Map等泛容器实现通用服务调用。</li>\n<li>传统的 RPC调用：服务调用比较简单，对时延要求不高的场景，可以考虑同步服务调用。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>服务调用有多种形式，需要从业务和技术做出取舍。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于惯性思维，很多人会将传统 MVC架构/RPC架构的做法带入到分布式服务框架的架构设计中，其中有些思想存在误区，或者已经过时，它们会破坏分布式服务框架的架构品质。</p>\n<h1 id=\"1-几个误区\"><a href=\"#1-几个误区\" class=\"headerlink\" title=\"1 几个误区\"></a>1 几个误区</h1><h2 id=\"1-1-NIO-就是异步服务\"><a href=\"#1-1-NIO-就是异步服务\" class=\"headerlink\" title=\"1.1 NIO 就是异步服务\"></a>1.1 NIO 就是异步服务</h2><p>NIO 只解决了通信层面的异步问题，跟服务调用的异步没有必然关系，也就是说，即便采用传统的 BIO 通信，依然可以实现异步服务调用，只不过通信效率和可靠性比较差。<br>下面对异步服务调用和通信框架的关系进行说明：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_1.png\" alt=\"\"><br>用户发起远程服务调用之后，经历层层业务逻辑处理、消息编码，最终序列化后的消息会被放入到通信框架的消息队列中。业务线程可以选择同步等待、也可以选择直接返回，通过消息队列的方式实现业务层和通信层的分离是比较成熟、典型的做法。<br>采用 NIO还是 BIO对上层的业务是不可见的，双方的汇聚点就是消息队列。业务线程将消息放入到发送队列中，可以选择主动等待或者立即返回，跟通信框架是否是 NIO 没有任何关系。</p>\n<h2 id=\"1-2-服务调用天生就是同步的\"><a href=\"#1-2-服务调用天生就是同步的\" class=\"headerlink\" title=\"1.2 服务调用天生就是同步的\"></a>1.2 服务调用天生就是同步的</h2><p>服务调用主要有两种模式：</p>\n<ol>\n<li>OneWay 模式：只有请求，没有应答，例如通知消息。</li>\n<li>请求-应答模式：一请求，一应答的模式，这种模式最常用。</li>\n</ol>\n<p>OneWay 模式的服务调用由于不需要返回应答，因此很容易被设计成异步的：消费者发起远程服务调用之后，立即返回，不需要同步阻塞等待应答。<br>对于请求-应答模式，可以利用 Future-Listener 机制来实现异步服务调用。从业务角度看，它的效果与同步等待等价，但是从技术角度来看，可以保证业务线程在不同步阻塞的情况下实现同步等待的效果，执行效率更高。</p>\n<h2 id=\"1-3-异步服务调用性能更高\"><a href=\"#1-3-异步服务调用性能更高\" class=\"headerlink\" title=\"1.3 异步服务调用性能更高\"></a>1.3 异步服务调用性能更高</h2><p>复杂的场景，异步服务调用会更高，越复杂的场景，异步服务调用优势越大。</p>\n<h1 id=\"2-服务调用方式\"><a href=\"#2-服务调用方式\" class=\"headerlink\" title=\"2 服务调用方式\"></a>2 服务调用方式</h1><h2 id=\"2-1-同步服务调用\"><a href=\"#2-1-同步服务调用\" class=\"headerlink\" title=\"2.1 同步服务调用\"></a>2.1 同步服务调用</h2><p>没什么可说的，只是需要注意设置用户线程等待超时时间。</p>\n<h2 id=\"2-2-异步服务调用\"><a href=\"#2-2-异步服务调用\" class=\"headerlink\" title=\"2.2 异步服务调用\"></a>2.2 异步服务调用</h2><p>基于 JDK的 Future机制，异步服务调用的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_2.png\" alt=\"\">  </p>\n<ol>\n<li>消费者调用服务端发布的接口，接口调用由分布式服务框架包装成动态代理，发起远程服务调用。</li>\n<li>通信框架异步发送请求消息，如果没有发生 I/O异常，返回。</li>\n<li>请求消息发送成功后，I/O 线程构造 Future 对象，设置到 RPC上下文中。</li>\n<li>用户线程通过 RPC上下文获取 Future对象。</li>\n<li>构造 Listener 对象，将其添加到 Future中，用于服务端应答异步回调通知。</li>\n<li>用户线程返回，不阻塞等待应答，</li>\n<li>服务端返回应答消息，通信框架负责反序列化等。</li>\n<li>I/O 线程将应答设置到 Future 对象的操作结果中。</li>\n<li>Future 对象扫描注册的监听器列表，循环调用监听器的 operationComplete方法，将结果通知给监听器，监听器获取到结果，执行后续业务，异步调用结束。</li>\n</ol>\n<p>还有一种异步调用形式，就是不添加 Listener，用户连续发起 N次服务调用，然后依次从 RPC上下文中获取 Futrue对象，最终再主动 get结果，业务线程阻塞，相对比老的同步服务调用，它的阻塞时间更短，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_3.png\" alt=\"\">  </p>\n<p>其串行到并行的优化原理如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_4.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_5.png\" alt=\"\">  </p>\n<p>异步服务调用的代码示例如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XxxService1.xxxMethod(Req); <span class=\"comment\">// 立即返回 null</span></span><br><span class=\"line\">Future f1 = RpcContext.getContext().getFuture();</span><br><span class=\"line\">XxxService2.xxxMethod(Req);</span><br><span class=\"line\">Future f2 = RpcContext.getContext().getFuture();</span><br><span class=\"line\">Object xResult1 = f1.get(<span class=\"number\">3000</span>);</span><br><span class=\"line\">Object xResult2 = f2.get(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第二种基于 Future-Listener 的纯异步服务调用示例如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XxxService1.xxxMethod(Req);</span><br><span class=\"line\">Future f1 = RpcContext.getContext().getFuture();</span><br><span class=\"line\">Listener l = <span class=\"keyword\">new</span> Listener();</span><br><span class=\"line\">f1.addListener(l);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-并行服务调用\"><a href=\"#2-3-并行服务调用\" class=\"headerlink\" title=\"2.3 并行服务调用\"></a>2.3 并行服务调用</h2><p>A服务-&gt;B服务-&gt;C服务-&gt;…<br>串行服务调用比较简单，但在一些业务场景中，需要采用并行服务调用来降低 E2E 的时延。</p>\n<ol>\n<li>多个服务之间逻辑不存在互相依赖关系，执行先后顺序没有严格的要求，逻辑上可以被并行执行。</li>\n<li>长流程业务，调用多个服务，对时延比较敏感，其中有部分服务逻辑上无上下文关联。<br>目标主要有两个：</li>\n<li>降低业务 E2E 时延。</li>\n<li>提升整个系统的吞吐量。</li>\n</ol>\n<h2 id=\"2-4-泛化调用\"><a href=\"#2-4-泛化调用\" class=\"headerlink\" title=\"2.4 泛化调用\"></a>2.4 泛化调用</h2><p>主要用于客户端没有API 接口及数据模型的场景，使用 Map表示。</p>\n<h1 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3 最佳实践\"></a>3 最佳实践</h1><p>服务框架支持多种服务调用方式，在实现项目中中如何选择，建议从以下几个角度考虑：  </p>\n<ol>\n<li>降低业务 E2E时延：业务调用链是否太长、某些服务是否不太可靠，需要对服务调用流程进行梳理，看是否可以通过并行服务调用来提升调用效率，降低服务调用时延。</li>\n<li>可靠性角度：某些业务调用链上的关键服务不太可靠，一旦出故障会导致大量线程资源被挂住，可以考虑使用异步服务调用防止故障扩展。</li>\n<li>业务场景：对于测试，不想为每个测试用例都开发一个服务接口，能否做一个通用的测试框架，通过 Map等泛容器实现通用服务调用。</li>\n<li>传统的 RPC调用：服务调用比较简单，对时延要求不高的场景，可以考虑同步服务调用。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>服务调用有多种形式，需要从业务和技术做出取舍。</p>\n"},{"title":"二十、微服务架构","date":"2018-06-20T16:44:00.000Z","updated":"2018-06-21T16:00:00.000Z","comments":1,"_content":"\n# 1 微服务架构产生的历史背景\n\n## 1.1 研发成本挑战\n\n### 1.1.1 代码重复率\n\n1. 从技术架构角度看，传统垂直架构的特点是本地 API 接口调用，不存在业务的拆分和互相调用，使用到什么功能就本地开发，非常方便，不需要过度依赖于其它功能模块。\n2. 跨地域、跨开发小组协调很困难。\n\n### 1.1.2 需求变更困难\n\n代码重复率变高之后，已有功能变更或者新需求加入都会非常困难，以充值缴费功能为例，不同的充值渠道开发了相同的限额保护功能，当限额保护功能发生变更之后，所有重复开发的限额保护功能都需要重新修改和测试，很容易出现修改不一致或者被遗漏，导致部分渠道充值功能正常：  \n![][1]  \n![][2]\n\n## 1.2 运维成本高\n\n### 1.2.1 代码维护困难\n\n传统的业务流程是由一长串本地接口或者方法调用串联起来的，而且往往由一个负责开发和维护。随着业务的发展和需求变化，本地diamante在不断地迭代和变更，最后形成了一个个垂直的功能孤岛，只有原来的开发者才理解接口调用关系和功能需求，一旦原来的开发者离职或调到其它项目组，这些功能模块的运维就会变得非常困难：  \n![][3]\n\n### 1.2.2 部署效率低\n\n1. 业务没有拆分，很多功能模块都打到同一个 war 包中，一旦有一个功能发生变更，就需要重新打包和部署。\n2. 测试工作量较大，因此存在大量重复的功能类库，需要针对所有调用方进行测试，测试工作量大。\n\n## 1.3 新需求上线周期长\n\n1. 新功能通常无法独立编译、打包、部署和上线，它可能混杂在老的系统中开发，很难剥离出来，这就无法通过服务灰度发布的形式快速上线。\n2. 由于业务没有进行水平和垂直拆分，导致代码重复率高，新需求的开发、测试、打包和部署成本都比较高。\n\n# 2 微服务架构带来的改变\n\n## 2.1 应用解耦\n\n微服务化之前，一个大型的应用系统通常会包含多个子应用，不同应用之间存在很多重复的公共代码，所有应用共用一套数据库，架构图如下：  \n![][4]  \n将功能A 和功能B 服务化之后，应用作为消费者直接调用服务A 和服务B ，这样就实现了对原有重复代码的收编，同时系统之间的调用关系也更加清晰，如下图：  \n![][5]  \n基于服务注册中心的定于发布机制，实现服务消费者和提供者之间的解耦。\n\n## 2.2 分而治之\n\n将核心业务抽取出来，作为独立的服务，逐渐形成稳定的底层微服务。  \n应用的拆分分为水平拆分和垂直拆分两种，水平拆分以业务领域为维度，抽象出几个不同的业务域，每个业务域作为一个独立的服务中心对外提供服务。领域服务可以独立地伸缩和升级，快速地响应需求变化，同时与其它业务领域解耦。原理图如下：  \n![][6]  \n应用的垂直拆分主要包括前后台逻辑拆分、业务逻辑和数据访问层拆分，拆分之后的效果图如下：  \n![][7]\n\n## 2.3 敏捷交付\n\n敏捷性的产生，是将运行中的系统解耦为一系列功能单一服务的结果。微服务架构能够对系统中其它部分的依赖加以限制，这种特性能够让基于微服务架构的应用在应对 BUG 或是对新特性需求时，能够快速地进行变更。而传统的垂直架构：“要对应用程序中某个小部分进行变更，就必须对整体架构进行重新编译和构建，并且重新进行全量部署。”\n\n# 3 微服务架构解析\n\n微服务架构（MSA）是一种架构风格，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。对比图如下：  \n![][8]\n\n## 3.1 微服务划分原则\n\n通用的划分原则是：微服务通常是简单、原子的微型服务，它的功能单一，只负责处理一件事，与代码行数并没有直接关系，与需要处理的业务复杂度有关。有些复杂的功能，尽管功能单一，但是代码量可能成百上千行，因此不能以代码量作为划分微服务的维度。  \n  \n“微”所表达的是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。\n\n## 3.2 开发微服务\n\n对于不同的微服务，虽然实现逻辑不同，但是开发方式、持续集成环境、测试策略和部署机制以及后续的上线运维都是类似的，为了满足 DRY 原则并消除浪费，需要搭建统一的开发打包和持续集成环境。  \n![][9]\n\n## 3.3 基于 Docker 容器部署微服务\n\nDocker 是一套开源工具，它能够以某种方式对现有的基于容器的虚拟化技术进行封装，使得它能够在更广阔的工程社区中得到应用，主要在于快速和可移植性。\n\n### 3.3.1 快速\n\n普通的虚拟机在每次开机时都需要启动一个完整的新操作系统实例，而 Docker 容器能够通过内核共享的方式，共享一套托管操作系统。这意味着，Docker 容器的启动和停止只需要几百毫秒。这样就有更高的敏捷性。  \n![][10]  \n物理机 VS Docker VS 虚拟机 \n\n### 3.3.2 可移植性\n\n1. 线上线下环境等同性：本地模拟线上环境，定位 BUG 更快。\n2. 与特定的云提供商解耦：参考 JVM。\n3. 提升运维效率：Docker 对可移植的容器部署进行标准化，节省时间与精力。如果你在构建某个应用程序，你的选择包括物理机、虚拟化的本地基础设施、公有云和私有云，以及各种可用的 PaaS 选项。而通过 Docker 标准化的容器格式，任何一种提供商都可以实现一种统一的部署体验。\n4. 敏捷性：快速启动，更敏捷。\n\n## 3.4 治理和运维微服务\n\n微服务架构对运维和部署流水线要求非常高，服务拆分的粒度越细，运维和治理成本就越高，挑战总结如下：  \n1. 监控度量问题：海量微服务的各种维度性能 KPI 采集、汇总和分析，实时和历史数据同比和环比，对采集模块的实时性、汇总模块的计算能力、前端运维 Portal 多维度展示能力要求非常高。\n2. 分布式运维：服务拆分得越细，一个完整业务流程的调用链就越长，需要采集、汇总和计算的数据量就越大，分布式消息跟踪系统需要能够支撑大规模微服务化后带来的性能挑战。\n3. 海量微服务对服务注册中心的处理能力、通知的实时性也带来了巨大挑战。\n4. 微服务治理：微服务化之后，微服务相比于传统的 SOA 服务有了指数级增长，服务治理的展示界面、检索速度等需要能够支撑这种变化。\n5. 量变引起质变：当需要运维的服务规模达到一定上限后，就由量变引起质变，传统的运维框架架构可能无法支撑，需要重构。\n  \n解决微服务运维的主要措施就是：分布式和自动化。利用分布式系统的性能线性增长和弹性扩容能力，支撑大规模微服务对运维系统带来的性能冲击，包括：  \n1. 分布式性能数据采集、日志采集 Agent。\n2. 分布式汇总和计算框架。\n3. 分布式文件存储服务。\n4. 分布式日志检索服务。\n5. 分布式报表展示框架。\n\n## 3.5 特点总结\n\n1. 单一职责原则：每个服务应该负责单独的功能。\n2. 独立部署、升级、扩展和替换。\n3. 支持异构/多语言。\n4. 轻量级。\n\n因此优点如下：  \n1. 开发、测试和运维更加简单。\n2. 局部修改很容易部署，有利于持续集成和持续交付。\n3. 技术选择更灵活，不与特定语言和工具绑定。\n4. 有利于小团队作战，敏捷交付。\n\n# 4 个人总结\n\n微服务涉及到了组织架构、涉及、交付、运维等方面的变革，核心目标是为了解决系统的交付周期，降低维护成本和研发成本。  \n但是带来了运维成本、服务管理成本等。  \n不可脱离业务实际而强制使用微服务。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_5.png\n[6]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_6.png\n[7]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_7.png\n[8]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_8.png\n[9]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_9.png\n[10]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_10.png","source":"_posts/分布式服务框架原理与实践/第二十章 微服务架构.md","raw":"---\ntitle: 二十、微服务架构\ndate: 2018-06-21 00:44:00\nupdated: 2018-06-22 00:00:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/20.html    \n---\n\n# 1 微服务架构产生的历史背景\n\n## 1.1 研发成本挑战\n\n### 1.1.1 代码重复率\n\n1. 从技术架构角度看，传统垂直架构的特点是本地 API 接口调用，不存在业务的拆分和互相调用，使用到什么功能就本地开发，非常方便，不需要过度依赖于其它功能模块。\n2. 跨地域、跨开发小组协调很困难。\n\n### 1.1.2 需求变更困难\n\n代码重复率变高之后，已有功能变更或者新需求加入都会非常困难，以充值缴费功能为例，不同的充值渠道开发了相同的限额保护功能，当限额保护功能发生变更之后，所有重复开发的限额保护功能都需要重新修改和测试，很容易出现修改不一致或者被遗漏，导致部分渠道充值功能正常：  \n![][1]  \n![][2]\n\n## 1.2 运维成本高\n\n### 1.2.1 代码维护困难\n\n传统的业务流程是由一长串本地接口或者方法调用串联起来的，而且往往由一个负责开发和维护。随着业务的发展和需求变化，本地diamante在不断地迭代和变更，最后形成了一个个垂直的功能孤岛，只有原来的开发者才理解接口调用关系和功能需求，一旦原来的开发者离职或调到其它项目组，这些功能模块的运维就会变得非常困难：  \n![][3]\n\n### 1.2.2 部署效率低\n\n1. 业务没有拆分，很多功能模块都打到同一个 war 包中，一旦有一个功能发生变更，就需要重新打包和部署。\n2. 测试工作量较大，因此存在大量重复的功能类库，需要针对所有调用方进行测试，测试工作量大。\n\n## 1.3 新需求上线周期长\n\n1. 新功能通常无法独立编译、打包、部署和上线，它可能混杂在老的系统中开发，很难剥离出来，这就无法通过服务灰度发布的形式快速上线。\n2. 由于业务没有进行水平和垂直拆分，导致代码重复率高，新需求的开发、测试、打包和部署成本都比较高。\n\n# 2 微服务架构带来的改变\n\n## 2.1 应用解耦\n\n微服务化之前，一个大型的应用系统通常会包含多个子应用，不同应用之间存在很多重复的公共代码，所有应用共用一套数据库，架构图如下：  \n![][4]  \n将功能A 和功能B 服务化之后，应用作为消费者直接调用服务A 和服务B ，这样就实现了对原有重复代码的收编，同时系统之间的调用关系也更加清晰，如下图：  \n![][5]  \n基于服务注册中心的定于发布机制，实现服务消费者和提供者之间的解耦。\n\n## 2.2 分而治之\n\n将核心业务抽取出来，作为独立的服务，逐渐形成稳定的底层微服务。  \n应用的拆分分为水平拆分和垂直拆分两种，水平拆分以业务领域为维度，抽象出几个不同的业务域，每个业务域作为一个独立的服务中心对外提供服务。领域服务可以独立地伸缩和升级，快速地响应需求变化，同时与其它业务领域解耦。原理图如下：  \n![][6]  \n应用的垂直拆分主要包括前后台逻辑拆分、业务逻辑和数据访问层拆分，拆分之后的效果图如下：  \n![][7]\n\n## 2.3 敏捷交付\n\n敏捷性的产生，是将运行中的系统解耦为一系列功能单一服务的结果。微服务架构能够对系统中其它部分的依赖加以限制，这种特性能够让基于微服务架构的应用在应对 BUG 或是对新特性需求时，能够快速地进行变更。而传统的垂直架构：“要对应用程序中某个小部分进行变更，就必须对整体架构进行重新编译和构建，并且重新进行全量部署。”\n\n# 3 微服务架构解析\n\n微服务架构（MSA）是一种架构风格，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。对比图如下：  \n![][8]\n\n## 3.1 微服务划分原则\n\n通用的划分原则是：微服务通常是简单、原子的微型服务，它的功能单一，只负责处理一件事，与代码行数并没有直接关系，与需要处理的业务复杂度有关。有些复杂的功能，尽管功能单一，但是代码量可能成百上千行，因此不能以代码量作为划分微服务的维度。  \n  \n“微”所表达的是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。\n\n## 3.2 开发微服务\n\n对于不同的微服务，虽然实现逻辑不同，但是开发方式、持续集成环境、测试策略和部署机制以及后续的上线运维都是类似的，为了满足 DRY 原则并消除浪费，需要搭建统一的开发打包和持续集成环境。  \n![][9]\n\n## 3.3 基于 Docker 容器部署微服务\n\nDocker 是一套开源工具，它能够以某种方式对现有的基于容器的虚拟化技术进行封装，使得它能够在更广阔的工程社区中得到应用，主要在于快速和可移植性。\n\n### 3.3.1 快速\n\n普通的虚拟机在每次开机时都需要启动一个完整的新操作系统实例，而 Docker 容器能够通过内核共享的方式，共享一套托管操作系统。这意味着，Docker 容器的启动和停止只需要几百毫秒。这样就有更高的敏捷性。  \n![][10]  \n物理机 VS Docker VS 虚拟机 \n\n### 3.3.2 可移植性\n\n1. 线上线下环境等同性：本地模拟线上环境，定位 BUG 更快。\n2. 与特定的云提供商解耦：参考 JVM。\n3. 提升运维效率：Docker 对可移植的容器部署进行标准化，节省时间与精力。如果你在构建某个应用程序，你的选择包括物理机、虚拟化的本地基础设施、公有云和私有云，以及各种可用的 PaaS 选项。而通过 Docker 标准化的容器格式，任何一种提供商都可以实现一种统一的部署体验。\n4. 敏捷性：快速启动，更敏捷。\n\n## 3.4 治理和运维微服务\n\n微服务架构对运维和部署流水线要求非常高，服务拆分的粒度越细，运维和治理成本就越高，挑战总结如下：  \n1. 监控度量问题：海量微服务的各种维度性能 KPI 采集、汇总和分析，实时和历史数据同比和环比，对采集模块的实时性、汇总模块的计算能力、前端运维 Portal 多维度展示能力要求非常高。\n2. 分布式运维：服务拆分得越细，一个完整业务流程的调用链就越长，需要采集、汇总和计算的数据量就越大，分布式消息跟踪系统需要能够支撑大规模微服务化后带来的性能挑战。\n3. 海量微服务对服务注册中心的处理能力、通知的实时性也带来了巨大挑战。\n4. 微服务治理：微服务化之后，微服务相比于传统的 SOA 服务有了指数级增长，服务治理的展示界面、检索速度等需要能够支撑这种变化。\n5. 量变引起质变：当需要运维的服务规模达到一定上限后，就由量变引起质变，传统的运维框架架构可能无法支撑，需要重构。\n  \n解决微服务运维的主要措施就是：分布式和自动化。利用分布式系统的性能线性增长和弹性扩容能力，支撑大规模微服务对运维系统带来的性能冲击，包括：  \n1. 分布式性能数据采集、日志采集 Agent。\n2. 分布式汇总和计算框架。\n3. 分布式文件存储服务。\n4. 分布式日志检索服务。\n5. 分布式报表展示框架。\n\n## 3.5 特点总结\n\n1. 单一职责原则：每个服务应该负责单独的功能。\n2. 独立部署、升级、扩展和替换。\n3. 支持异构/多语言。\n4. 轻量级。\n\n因此优点如下：  \n1. 开发、测试和运维更加简单。\n2. 局部修改很容易部署，有利于持续集成和持续交付。\n3. 技术选择更灵活，不与特定语言和工具绑定。\n4. 有利于小团队作战，敏捷交付。\n\n# 4 个人总结\n\n微服务涉及到了组织架构、涉及、交付、运维等方面的变革，核心目标是为了解决系统的交付周期，降低维护成本和研发成本。  \n但是带来了运维成本、服务管理成本等。  \n不可脱离业务实际而强制使用微服务。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_5.png\n[6]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_6.png\n[7]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_7.png\n[8]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_8.png\n[9]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_9.png\n[10]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_10.png","slug":"distributed_principle_prictice/20.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkav80018axs6eui1tbfq","content":"<h1 id=\"1-微服务架构产生的历史背景\"><a href=\"#1-微服务架构产生的历史背景\" class=\"headerlink\" title=\"1 微服务架构产生的历史背景\"></a>1 微服务架构产生的历史背景</h1><h2 id=\"1-1-研发成本挑战\"><a href=\"#1-1-研发成本挑战\" class=\"headerlink\" title=\"1.1 研发成本挑战\"></a>1.1 研发成本挑战</h2><h3 id=\"1-1-1-代码重复率\"><a href=\"#1-1-1-代码重复率\" class=\"headerlink\" title=\"1.1.1 代码重复率\"></a>1.1.1 代码重复率</h3><ol>\n<li>从技术架构角度看，传统垂直架构的特点是本地 API 接口调用，不存在业务的拆分和互相调用，使用到什么功能就本地开发，非常方便，不需要过度依赖于其它功能模块。</li>\n<li>跨地域、跨开发小组协调很困难。</li>\n</ol>\n<h3 id=\"1-1-2-需求变更困难\"><a href=\"#1-1-2-需求变更困难\" class=\"headerlink\" title=\"1.1.2 需求变更困难\"></a>1.1.2 需求变更困难</h3><p>代码重复率变高之后，已有功能变更或者新需求加入都会非常困难，以充值缴费功能为例，不同的充值渠道开发了相同的限额保护功能，当限额保护功能发生变更之后，所有重复开发的限额保护功能都需要重新修改和测试，很容易出现修改不一致或者被遗漏，导致部分渠道充值功能正常：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_1.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_2.png\" alt=\"\"></p>\n<h2 id=\"1-2-运维成本高\"><a href=\"#1-2-运维成本高\" class=\"headerlink\" title=\"1.2 运维成本高\"></a>1.2 运维成本高</h2><h3 id=\"1-2-1-代码维护困难\"><a href=\"#1-2-1-代码维护困难\" class=\"headerlink\" title=\"1.2.1 代码维护困难\"></a>1.2.1 代码维护困难</h3><p>传统的业务流程是由一长串本地接口或者方法调用串联起来的，而且往往由一个负责开发和维护。随着业务的发展和需求变化，本地diamante在不断地迭代和变更，最后形成了一个个垂直的功能孤岛，只有原来的开发者才理解接口调用关系和功能需求，一旦原来的开发者离职或调到其它项目组，这些功能模块的运维就会变得非常困难：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_3.png\" alt=\"\"></p>\n<h3 id=\"1-2-2-部署效率低\"><a href=\"#1-2-2-部署效率低\" class=\"headerlink\" title=\"1.2.2 部署效率低\"></a>1.2.2 部署效率低</h3><ol>\n<li>业务没有拆分，很多功能模块都打到同一个 war 包中，一旦有一个功能发生变更，就需要重新打包和部署。</li>\n<li>测试工作量较大，因此存在大量重复的功能类库，需要针对所有调用方进行测试，测试工作量大。</li>\n</ol>\n<h2 id=\"1-3-新需求上线周期长\"><a href=\"#1-3-新需求上线周期长\" class=\"headerlink\" title=\"1.3 新需求上线周期长\"></a>1.3 新需求上线周期长</h2><ol>\n<li>新功能通常无法独立编译、打包、部署和上线，它可能混杂在老的系统中开发，很难剥离出来，这就无法通过服务灰度发布的形式快速上线。</li>\n<li>由于业务没有进行水平和垂直拆分，导致代码重复率高，新需求的开发、测试、打包和部署成本都比较高。</li>\n</ol>\n<h1 id=\"2-微服务架构带来的改变\"><a href=\"#2-微服务架构带来的改变\" class=\"headerlink\" title=\"2 微服务架构带来的改变\"></a>2 微服务架构带来的改变</h1><h2 id=\"2-1-应用解耦\"><a href=\"#2-1-应用解耦\" class=\"headerlink\" title=\"2.1 应用解耦\"></a>2.1 应用解耦</h2><p>微服务化之前，一个大型的应用系统通常会包含多个子应用，不同应用之间存在很多重复的公共代码，所有应用共用一套数据库，架构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_4.png\" alt=\"\"><br>将功能A 和功能B 服务化之后，应用作为消费者直接调用服务A 和服务B ，这样就实现了对原有重复代码的收编，同时系统之间的调用关系也更加清晰，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_5.png\" alt=\"\"><br>基于服务注册中心的定于发布机制，实现服务消费者和提供者之间的解耦。</p>\n<h2 id=\"2-2-分而治之\"><a href=\"#2-2-分而治之\" class=\"headerlink\" title=\"2.2 分而治之\"></a>2.2 分而治之</h2><p>将核心业务抽取出来，作为独立的服务，逐渐形成稳定的底层微服务。<br>应用的拆分分为水平拆分和垂直拆分两种，水平拆分以业务领域为维度，抽象出几个不同的业务域，每个业务域作为一个独立的服务中心对外提供服务。领域服务可以独立地伸缩和升级，快速地响应需求变化，同时与其它业务领域解耦。原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_6.png\" alt=\"\"><br>应用的垂直拆分主要包括前后台逻辑拆分、业务逻辑和数据访问层拆分，拆分之后的效果图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_7.png\" alt=\"\"></p>\n<h2 id=\"2-3-敏捷交付\"><a href=\"#2-3-敏捷交付\" class=\"headerlink\" title=\"2.3 敏捷交付\"></a>2.3 敏捷交付</h2><p>敏捷性的产生，是将运行中的系统解耦为一系列功能单一服务的结果。微服务架构能够对系统中其它部分的依赖加以限制，这种特性能够让基于微服务架构的应用在应对 BUG 或是对新特性需求时，能够快速地进行变更。而传统的垂直架构：“要对应用程序中某个小部分进行变更，就必须对整体架构进行重新编译和构建，并且重新进行全量部署。”</p>\n<h1 id=\"3-微服务架构解析\"><a href=\"#3-微服务架构解析\" class=\"headerlink\" title=\"3 微服务架构解析\"></a>3 微服务架构解析</h1><p>微服务架构（MSA）是一种架构风格，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。对比图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_8.png\" alt=\"\"></p>\n<h2 id=\"3-1-微服务划分原则\"><a href=\"#3-1-微服务划分原则\" class=\"headerlink\" title=\"3.1 微服务划分原则\"></a>3.1 微服务划分原则</h2><p>通用的划分原则是：微服务通常是简单、原子的微型服务，它的功能单一，只负责处理一件事，与代码行数并没有直接关系，与需要处理的业务复杂度有关。有些复杂的功能，尽管功能单一，但是代码量可能成百上千行，因此不能以代码量作为划分微服务的维度。  </p>\n<p>“微”所表达的是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。</p>\n<h2 id=\"3-2-开发微服务\"><a href=\"#3-2-开发微服务\" class=\"headerlink\" title=\"3.2 开发微服务\"></a>3.2 开发微服务</h2><p>对于不同的微服务，虽然实现逻辑不同，但是开发方式、持续集成环境、测试策略和部署机制以及后续的上线运维都是类似的，为了满足 DRY 原则并消除浪费，需要搭建统一的开发打包和持续集成环境。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_9.png\" alt=\"\"></p>\n<h2 id=\"3-3-基于-Docker-容器部署微服务\"><a href=\"#3-3-基于-Docker-容器部署微服务\" class=\"headerlink\" title=\"3.3 基于 Docker 容器部署微服务\"></a>3.3 基于 Docker 容器部署微服务</h2><p>Docker 是一套开源工具，它能够以某种方式对现有的基于容器的虚拟化技术进行封装，使得它能够在更广阔的工程社区中得到应用，主要在于快速和可移植性。</p>\n<h3 id=\"3-3-1-快速\"><a href=\"#3-3-1-快速\" class=\"headerlink\" title=\"3.3.1 快速\"></a>3.3.1 快速</h3><p>普通的虚拟机在每次开机时都需要启动一个完整的新操作系统实例，而 Docker 容器能够通过内核共享的方式，共享一套托管操作系统。这意味着，Docker 容器的启动和停止只需要几百毫秒。这样就有更高的敏捷性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_10.png\" alt=\"\"><br>物理机 VS Docker VS 虚拟机 </p>\n<h3 id=\"3-3-2-可移植性\"><a href=\"#3-3-2-可移植性\" class=\"headerlink\" title=\"3.3.2 可移植性\"></a>3.3.2 可移植性</h3><ol>\n<li>线上线下环境等同性：本地模拟线上环境，定位 BUG 更快。</li>\n<li>与特定的云提供商解耦：参考 JVM。</li>\n<li>提升运维效率：Docker 对可移植的容器部署进行标准化，节省时间与精力。如果你在构建某个应用程序，你的选择包括物理机、虚拟化的本地基础设施、公有云和私有云，以及各种可用的 PaaS 选项。而通过 Docker 标准化的容器格式，任何一种提供商都可以实现一种统一的部署体验。</li>\n<li>敏捷性：快速启动，更敏捷。</li>\n</ol>\n<h2 id=\"3-4-治理和运维微服务\"><a href=\"#3-4-治理和运维微服务\" class=\"headerlink\" title=\"3.4 治理和运维微服务\"></a>3.4 治理和运维微服务</h2><p>微服务架构对运维和部署流水线要求非常高，服务拆分的粒度越细，运维和治理成本就越高，挑战总结如下：  </p>\n<ol>\n<li>监控度量问题：海量微服务的各种维度性能 KPI 采集、汇总和分析，实时和历史数据同比和环比，对采集模块的实时性、汇总模块的计算能力、前端运维 Portal 多维度展示能力要求非常高。</li>\n<li>分布式运维：服务拆分得越细，一个完整业务流程的调用链就越长，需要采集、汇总和计算的数据量就越大，分布式消息跟踪系统需要能够支撑大规模微服务化后带来的性能挑战。</li>\n<li>海量微服务对服务注册中心的处理能力、通知的实时性也带来了巨大挑战。</li>\n<li>微服务治理：微服务化之后，微服务相比于传统的 SOA 服务有了指数级增长，服务治理的展示界面、检索速度等需要能够支撑这种变化。</li>\n<li>量变引起质变：当需要运维的服务规模达到一定上限后，就由量变引起质变，传统的运维框架架构可能无法支撑，需要重构。</li>\n</ol>\n<p>解决微服务运维的主要措施就是：分布式和自动化。利用分布式系统的性能线性增长和弹性扩容能力，支撑大规模微服务对运维系统带来的性能冲击，包括：  </p>\n<ol>\n<li>分布式性能数据采集、日志采集 Agent。</li>\n<li>分布式汇总和计算框架。</li>\n<li>分布式文件存储服务。</li>\n<li>分布式日志检索服务。</li>\n<li>分布式报表展示框架。</li>\n</ol>\n<h2 id=\"3-5-特点总结\"><a href=\"#3-5-特点总结\" class=\"headerlink\" title=\"3.5 特点总结\"></a>3.5 特点总结</h2><ol>\n<li>单一职责原则：每个服务应该负责单独的功能。</li>\n<li>独立部署、升级、扩展和替换。</li>\n<li>支持异构/多语言。</li>\n<li>轻量级。</li>\n</ol>\n<p>因此优点如下：  </p>\n<ol>\n<li>开发、测试和运维更加简单。</li>\n<li>局部修改很容易部署，有利于持续集成和持续交付。</li>\n<li>技术选择更灵活，不与特定语言和工具绑定。</li>\n<li>有利于小团队作战，敏捷交付。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>微服务涉及到了组织架构、涉及、交付、运维等方面的变革，核心目标是为了解决系统的交付周期，降低维护成本和研发成本。<br>但是带来了运维成本、服务管理成本等。<br>不可脱离业务实际而强制使用微服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-微服务架构产生的历史背景\"><a href=\"#1-微服务架构产生的历史背景\" class=\"headerlink\" title=\"1 微服务架构产生的历史背景\"></a>1 微服务架构产生的历史背景</h1><h2 id=\"1-1-研发成本挑战\"><a href=\"#1-1-研发成本挑战\" class=\"headerlink\" title=\"1.1 研发成本挑战\"></a>1.1 研发成本挑战</h2><h3 id=\"1-1-1-代码重复率\"><a href=\"#1-1-1-代码重复率\" class=\"headerlink\" title=\"1.1.1 代码重复率\"></a>1.1.1 代码重复率</h3><ol>\n<li>从技术架构角度看，传统垂直架构的特点是本地 API 接口调用，不存在业务的拆分和互相调用，使用到什么功能就本地开发，非常方便，不需要过度依赖于其它功能模块。</li>\n<li>跨地域、跨开发小组协调很困难。</li>\n</ol>\n<h3 id=\"1-1-2-需求变更困难\"><a href=\"#1-1-2-需求变更困难\" class=\"headerlink\" title=\"1.1.2 需求变更困难\"></a>1.1.2 需求变更困难</h3><p>代码重复率变高之后，已有功能变更或者新需求加入都会非常困难，以充值缴费功能为例，不同的充值渠道开发了相同的限额保护功能，当限额保护功能发生变更之后，所有重复开发的限额保护功能都需要重新修改和测试，很容易出现修改不一致或者被遗漏，导致部分渠道充值功能正常：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_1.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_2.png\" alt=\"\"></p>\n<h2 id=\"1-2-运维成本高\"><a href=\"#1-2-运维成本高\" class=\"headerlink\" title=\"1.2 运维成本高\"></a>1.2 运维成本高</h2><h3 id=\"1-2-1-代码维护困难\"><a href=\"#1-2-1-代码维护困难\" class=\"headerlink\" title=\"1.2.1 代码维护困难\"></a>1.2.1 代码维护困难</h3><p>传统的业务流程是由一长串本地接口或者方法调用串联起来的，而且往往由一个负责开发和维护。随着业务的发展和需求变化，本地diamante在不断地迭代和变更，最后形成了一个个垂直的功能孤岛，只有原来的开发者才理解接口调用关系和功能需求，一旦原来的开发者离职或调到其它项目组，这些功能模块的运维就会变得非常困难：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_3.png\" alt=\"\"></p>\n<h3 id=\"1-2-2-部署效率低\"><a href=\"#1-2-2-部署效率低\" class=\"headerlink\" title=\"1.2.2 部署效率低\"></a>1.2.2 部署效率低</h3><ol>\n<li>业务没有拆分，很多功能模块都打到同一个 war 包中，一旦有一个功能发生变更，就需要重新打包和部署。</li>\n<li>测试工作量较大，因此存在大量重复的功能类库，需要针对所有调用方进行测试，测试工作量大。</li>\n</ol>\n<h2 id=\"1-3-新需求上线周期长\"><a href=\"#1-3-新需求上线周期长\" class=\"headerlink\" title=\"1.3 新需求上线周期长\"></a>1.3 新需求上线周期长</h2><ol>\n<li>新功能通常无法独立编译、打包、部署和上线，它可能混杂在老的系统中开发，很难剥离出来，这就无法通过服务灰度发布的形式快速上线。</li>\n<li>由于业务没有进行水平和垂直拆分，导致代码重复率高，新需求的开发、测试、打包和部署成本都比较高。</li>\n</ol>\n<h1 id=\"2-微服务架构带来的改变\"><a href=\"#2-微服务架构带来的改变\" class=\"headerlink\" title=\"2 微服务架构带来的改变\"></a>2 微服务架构带来的改变</h1><h2 id=\"2-1-应用解耦\"><a href=\"#2-1-应用解耦\" class=\"headerlink\" title=\"2.1 应用解耦\"></a>2.1 应用解耦</h2><p>微服务化之前，一个大型的应用系统通常会包含多个子应用，不同应用之间存在很多重复的公共代码，所有应用共用一套数据库，架构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_4.png\" alt=\"\"><br>将功能A 和功能B 服务化之后，应用作为消费者直接调用服务A 和服务B ，这样就实现了对原有重复代码的收编，同时系统之间的调用关系也更加清晰，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_5.png\" alt=\"\"><br>基于服务注册中心的定于发布机制，实现服务消费者和提供者之间的解耦。</p>\n<h2 id=\"2-2-分而治之\"><a href=\"#2-2-分而治之\" class=\"headerlink\" title=\"2.2 分而治之\"></a>2.2 分而治之</h2><p>将核心业务抽取出来，作为独立的服务，逐渐形成稳定的底层微服务。<br>应用的拆分分为水平拆分和垂直拆分两种，水平拆分以业务领域为维度，抽象出几个不同的业务域，每个业务域作为一个独立的服务中心对外提供服务。领域服务可以独立地伸缩和升级，快速地响应需求变化，同时与其它业务领域解耦。原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_6.png\" alt=\"\"><br>应用的垂直拆分主要包括前后台逻辑拆分、业务逻辑和数据访问层拆分，拆分之后的效果图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_7.png\" alt=\"\"></p>\n<h2 id=\"2-3-敏捷交付\"><a href=\"#2-3-敏捷交付\" class=\"headerlink\" title=\"2.3 敏捷交付\"></a>2.3 敏捷交付</h2><p>敏捷性的产生，是将运行中的系统解耦为一系列功能单一服务的结果。微服务架构能够对系统中其它部分的依赖加以限制，这种特性能够让基于微服务架构的应用在应对 BUG 或是对新特性需求时，能够快速地进行变更。而传统的垂直架构：“要对应用程序中某个小部分进行变更，就必须对整体架构进行重新编译和构建，并且重新进行全量部署。”</p>\n<h1 id=\"3-微服务架构解析\"><a href=\"#3-微服务架构解析\" class=\"headerlink\" title=\"3 微服务架构解析\"></a>3 微服务架构解析</h1><p>微服务架构（MSA）是一种架构风格，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。对比图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_8.png\" alt=\"\"></p>\n<h2 id=\"3-1-微服务划分原则\"><a href=\"#3-1-微服务划分原则\" class=\"headerlink\" title=\"3.1 微服务划分原则\"></a>3.1 微服务划分原则</h2><p>通用的划分原则是：微服务通常是简单、原子的微型服务，它的功能单一，只负责处理一件事，与代码行数并没有直接关系，与需要处理的业务复杂度有关。有些复杂的功能，尽管功能单一，但是代码量可能成百上千行，因此不能以代码量作为划分微服务的维度。  </p>\n<p>“微”所表达的是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。</p>\n<h2 id=\"3-2-开发微服务\"><a href=\"#3-2-开发微服务\" class=\"headerlink\" title=\"3.2 开发微服务\"></a>3.2 开发微服务</h2><p>对于不同的微服务，虽然实现逻辑不同，但是开发方式、持续集成环境、测试策略和部署机制以及后续的上线运维都是类似的，为了满足 DRY 原则并消除浪费，需要搭建统一的开发打包和持续集成环境。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_9.png\" alt=\"\"></p>\n<h2 id=\"3-3-基于-Docker-容器部署微服务\"><a href=\"#3-3-基于-Docker-容器部署微服务\" class=\"headerlink\" title=\"3.3 基于 Docker 容器部署微服务\"></a>3.3 基于 Docker 容器部署微服务</h2><p>Docker 是一套开源工具，它能够以某种方式对现有的基于容器的虚拟化技术进行封装，使得它能够在更广阔的工程社区中得到应用，主要在于快速和可移植性。</p>\n<h3 id=\"3-3-1-快速\"><a href=\"#3-3-1-快速\" class=\"headerlink\" title=\"3.3.1 快速\"></a>3.3.1 快速</h3><p>普通的虚拟机在每次开机时都需要启动一个完整的新操作系统实例，而 Docker 容器能够通过内核共享的方式，共享一套托管操作系统。这意味着，Docker 容器的启动和停止只需要几百毫秒。这样就有更高的敏捷性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_10.png\" alt=\"\"><br>物理机 VS Docker VS 虚拟机 </p>\n<h3 id=\"3-3-2-可移植性\"><a href=\"#3-3-2-可移植性\" class=\"headerlink\" title=\"3.3.2 可移植性\"></a>3.3.2 可移植性</h3><ol>\n<li>线上线下环境等同性：本地模拟线上环境，定位 BUG 更快。</li>\n<li>与特定的云提供商解耦：参考 JVM。</li>\n<li>提升运维效率：Docker 对可移植的容器部署进行标准化，节省时间与精力。如果你在构建某个应用程序，你的选择包括物理机、虚拟化的本地基础设施、公有云和私有云，以及各种可用的 PaaS 选项。而通过 Docker 标准化的容器格式，任何一种提供商都可以实现一种统一的部署体验。</li>\n<li>敏捷性：快速启动，更敏捷。</li>\n</ol>\n<h2 id=\"3-4-治理和运维微服务\"><a href=\"#3-4-治理和运维微服务\" class=\"headerlink\" title=\"3.4 治理和运维微服务\"></a>3.4 治理和运维微服务</h2><p>微服务架构对运维和部署流水线要求非常高，服务拆分的粒度越细，运维和治理成本就越高，挑战总结如下：  </p>\n<ol>\n<li>监控度量问题：海量微服务的各种维度性能 KPI 采集、汇总和分析，实时和历史数据同比和环比，对采集模块的实时性、汇总模块的计算能力、前端运维 Portal 多维度展示能力要求非常高。</li>\n<li>分布式运维：服务拆分得越细，一个完整业务流程的调用链就越长，需要采集、汇总和计算的数据量就越大，分布式消息跟踪系统需要能够支撑大规模微服务化后带来的性能挑战。</li>\n<li>海量微服务对服务注册中心的处理能力、通知的实时性也带来了巨大挑战。</li>\n<li>微服务治理：微服务化之后，微服务相比于传统的 SOA 服务有了指数级增长，服务治理的展示界面、检索速度等需要能够支撑这种变化。</li>\n<li>量变引起质变：当需要运维的服务规模达到一定上限后，就由量变引起质变，传统的运维框架架构可能无法支撑，需要重构。</li>\n</ol>\n<p>解决微服务运维的主要措施就是：分布式和自动化。利用分布式系统的性能线性增长和弹性扩容能力，支撑大规模微服务对运维系统带来的性能冲击，包括：  </p>\n<ol>\n<li>分布式性能数据采集、日志采集 Agent。</li>\n<li>分布式汇总和计算框架。</li>\n<li>分布式文件存储服务。</li>\n<li>分布式日志检索服务。</li>\n<li>分布式报表展示框架。</li>\n</ol>\n<h2 id=\"3-5-特点总结\"><a href=\"#3-5-特点总结\" class=\"headerlink\" title=\"3.5 特点总结\"></a>3.5 特点总结</h2><ol>\n<li>单一职责原则：每个服务应该负责单独的功能。</li>\n<li>独立部署、升级、扩展和替换。</li>\n<li>支持异构/多语言。</li>\n<li>轻量级。</li>\n</ol>\n<p>因此优点如下：  </p>\n<ol>\n<li>开发、测试和运维更加简单。</li>\n<li>局部修改很容易部署，有利于持续集成和持续交付。</li>\n<li>技术选择更灵活，不与特定语言和工具绑定。</li>\n<li>有利于小团队作战，敏捷交付。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>微服务涉及到了组织架构、涉及、交付、运维等方面的变革，核心目标是为了解决系统的交付周期，降低维护成本和研发成本。<br>但是带来了运维成本、服务管理成本等。<br>不可脱离业务实际而强制使用微服务。</p>\n"},{"title":"二、分布式服务框架入门","date":"2018-05-19T09:00:00.000Z","updated":"2018-05-12T10:15:00.000Z","comments":1,"_content":"\n# 1 分布式服务框架诞生背景\n\n## 1.1 集中式到分布式\n\n![][1]  \n\n1. 业务发展、应用规模变大，大型复杂应用的开发维护成本高，部署效率低，应用数量膨胀，数据库连接数变高。\n2. 代码复用低：由于公共模块都是进程内部的本地 API 调用，开发者按需开发，导致大量相同功能的 API 被重复开发。一旦涉及到公共模块的功能变更，所有重复实现都需要重新修改、编译和测试。\n3. 敏捷持续交付：想要在一个架构师都无法理解的巨无霸业务中新增或者修改一个功能，难度是非常大的。业务模块之间的循环依赖、重复 API 定义和开发、不合理的调用、冗长复杂的业务流程对新特性的上线简直是梦魇。  \n  \n大规模系统架构的设计一般就是尽可能的拆分，以达到更好的独立扩展、部署、开发效率等。  \n具体的拆分策略大体上可以分为横向拆分和纵向拆分。  \n  \n纵向拆分：不同业务模块独立部署，例如一个 CRM 系统就可以根据客户域、产品域、资源域、营销管理域等拆分。由大变小、分而治之。  \n![][2]  \n\n横向拆分：将核心的、公共的业务拆分出来，通过分布式服务框架对业务进行服务化，消费者通过标准的契约来消费这些服务。服务提供者独立打包、部署，与消费者解耦。  \n![][3]\n\n## 1.2 引入服务治理\n\n使用 RPC 框架对业务进行拆分之后，随着服务数的增多，急需一个服务治理框架，有效管控服务，提升服务运行期质量，防止业务服务代码架构腐化。因为，服务治理的主要应用如下：  \n1. 生命周期管理：服务上线下线通知机制规范化。\n2. 服务容量规划。\n3. 运行期治理：对非核心服务采取降级、限流措施；缓存失效时，系统压力转移到数据库，服务调用时延突然增大，业务失败率升高，需要在线调大服务调用超时时间，保证业务成功率。\n4. 服务安全。  \n  \n典型的 SOA 服务治理生命周期如下：  \n![][4]\n1. 计划：确定服务治理的重点。\n2. 定义：定义服务治理模型。\n3. 启用：实现并实施服务治理。\n4. 度量：根据实施效果，改进服务治理模型。\n\n# 2 业务分布式服务框架介绍\n\n## 2.1 阿里 Dubbo\n\n架构图如下：  \n![][5]  \n功能总结：  \n1. 根据服务提供者配置的 XML 文件将服务按照指定协议发布，完成服务的初始化工作。\n2. 服务提供者根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到服务注册中心。\n3. 消费者根据服务消费者 XML 配置文件的服务引用信息，连接注册中心，获取指定服务的地址等路由信息。\n4. 服务注册中心根据服务订阅关系，动态地向指定消费者推送服务地址信息。\n5. 消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择一个服务提供者，然后根据协议类型建立链路，跨进程调用服务提供者。  \n  \n原理图如下：  \n![][6]\n\n## 2.2 淘宝 HSF\n\n架构图如下：  \n![][7]  \n功能总结：  \n1. 配置 XML 方式发布和消费服务。\n2. 插件管理体系：平台与应用分开部署，运行期依赖，外部采用与应用独立的 classloader 隔离，内部采用 OSGI 隔离。\n3. 异步 NIO 通信。多种序列化方式。服务提供者和消费者之间采用长连接通信。\n4. 灵活的路由能力：客户端软负载，随机、轮询等多种路由策略，支持容灾和失效恢复等。\n5. 多协议支持：WebService、PB（Protocol buffer）和 Hession（HTTP）等。\n  \n整体结构图如下：  \n![][8]\n\n## 2.3 亚马逊 Coral Service\n\n# 3 分布式服务框架设计\n\n本章介绍分布式服务框架的架构原理和概要设计。\n\n## 3.1 架构原理\n\n![][10]  \n通常分布式服务框架的架构可以抽象为三层：  \n1. RPC 层：包括底层通信框架（例如 NIO 框架的封装、公有协议的封装等）、序列化和反序列化框架、用于屏蔽底层通信协议细节和序列化方式差异的 Remoting 框架。\n2. Filter Chain 层：服务调用职责链，提供多种服务调用切面供框架自身和使用者扩展，例如负责均衡、服务调用性能统计、服务调用完成通知机制、失败重发等。\n3. Service 层：主要包括 Java 动态代理，消费者使用，主要用于将服务提供者的接口封装成远程服务调用：Java 反射，服务提供者使用，根据消费者请求消息中的接口名、方法名、参数列表反射调用服务提供者的接口本地实现类。\n  \n从功能角度看，分布式服务框架通常会包含另外两个重要功能：服务治理中心和服务注册中心。\n\n## 3.2 功能特性\n\n1. 服务订阅发布之配置化发布和引用服务：支持通过 XML 配置的方式发布和导入服务，降低对业务代码的侵入。\n2. 服务订阅发布之服务自动发现机制：由注册中心推送服务地址，消费者不需要配置服务提供者地址，服务地址透明化。\n3. 服务订阅发布之服务在线注册和去注册：支持运行态注册新服务，也支持运行态取消某个服务的注册。\n4. 服务路由之默认提供随机路由、轮询、基于权重的路由策略等。\n5. 服务路由之粘滞连接：总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台。\n6. 服务路由之路由定制：支持用户自定义路由策略。\n7. 集群容错之 FailOver：失败自动切换，常用读操作；也可用于幂等性写操作。\n8. 集群容错之 Failback：失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。\n9. 集群容错之 Failfast：快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。\n10. 服务调用之同步调用：消费者发起服务调用之后，同步阻塞等待服务端响应。\n11. 服务调用之异步调用：消费者发起服务调用之后，不阻塞立即返回，由服务端返回应答后异步通知消费者。\n12. 服务调用之并行调用：消费者同时对多个服务提供者批量发起服务调用请求，批量发起请求，集中等待应答。\n13. 多协议之私有协议：支持二进制等私有协议，支持自定义。\n14. 多协议之公有协议：支持 Web Service 等公有协议，用于外部服务对象。\n15. 序列化方式之二进制类序列化：支持 Thrift、Protocol buffer 等二进制协议，提升序列化性能。\n16. 序列化方式之文本类序列化：支持 JSON、XML 等文本类型的序列化方式。\n17. 统一配置之本地静态配置：安装部署一次，运行态不修改的配置，可以存放到本地配置文件中。\n18. 统一配置之基于配置中心的动态配置：运行态需要调整的参数，统一放到配置中心，修改之后统一下发，实时生效。\n\n## 3.3 服务治理\n\n1. 服务运行态管控之服务路由：业务高峰期，通过动态修改路由策略实现导流。\n2. 服务运行态管控之服务限流：资源成为瓶颈时，服务端和消费者的动态流控。\n3. 服务运行态管控之服务迁入迁出：实现资源的动态分配。\n4. 服务运行态管控之服务降级：服务提供者故障时或者业务高峰期，进行服务强制或者容错降级，执行本地降级逻辑，保证系统平稳运行。\n5. 服务运行态管控之服务超时控制：动态调整超时时间，在业务高峰期保障业务调用成功率。\n6. 服务监控之性能统计：统计项包括服务调用时延、成功率、调用次数等。\n7. 服务监控之统计报表：提供多维度、实时和历史数据报表，同比、环比等性能对比数据，供运维、运营等使用。\n8. 服务监控之告警：指标异常，根据告警策略发送告警，包括但不限于短信、E-mail、记录日志等。\n9. 服务生命周期管理之上线审批：服务提供者不能随意线上发布服务，需要通过正规的审批流程批准之后才能上线。\n10. 服务生命周期管理之下线通知：服务提供者在下线某个服务之前一段时间，需要根据 SLA 策略，通知消费者。\n11. 服务生命周期管理之服务灰度发布：灰度环境划分原则、接口前向兼容性策略，以及消费者如何路由，都需要灰度发布引擎负责管理。\n12. 故障快速定界定位之分布式日志采集：支持在大规模分布式环境中实时采集容器、中间件和应用的各种日志。\n13. 故障快速定界定位之海量日志在线检索：支持分布式环境海量日志的在线检索，支持多维度索引和模糊查询。\n14. 故障快速定界定位之调用链可视化展示：通过分布式消息跟踪系统输出调用链，可视化、快速地进行故障定界。\n15. 故障快速定界定位之运行日志故障定位：通过调用链的故障关键字，在日志检索界面快速检索故障日志，用于故障的精确定位。\n16. 服务安全之敏感服务的授权策略：敏感服务如何授权，防止恶意调用。\n17. 服务安全之链路的安全防护“消费者和服务提供者之间的长连接，需要增加安全防护，例如基于 Token 的安全认证机制。\n\n# 4 个人总结\n\n分布式服务框架在原理、目标是类似的，因此不同的分布式服务框架原理也是相似的。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_8.png\n[10]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_10.png","source":"_posts/分布式服务框架原理与实践/第二章 分布式服务框架入门.md","raw":"---\ntitle: 二、分布式服务框架入门\ndate: 2018-05-19 17:00:00\nupdated: 2018-05-12 18:15:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/2.html    \n---\n\n# 1 分布式服务框架诞生背景\n\n## 1.1 集中式到分布式\n\n![][1]  \n\n1. 业务发展、应用规模变大，大型复杂应用的开发维护成本高，部署效率低，应用数量膨胀，数据库连接数变高。\n2. 代码复用低：由于公共模块都是进程内部的本地 API 调用，开发者按需开发，导致大量相同功能的 API 被重复开发。一旦涉及到公共模块的功能变更，所有重复实现都需要重新修改、编译和测试。\n3. 敏捷持续交付：想要在一个架构师都无法理解的巨无霸业务中新增或者修改一个功能，难度是非常大的。业务模块之间的循环依赖、重复 API 定义和开发、不合理的调用、冗长复杂的业务流程对新特性的上线简直是梦魇。  \n  \n大规模系统架构的设计一般就是尽可能的拆分，以达到更好的独立扩展、部署、开发效率等。  \n具体的拆分策略大体上可以分为横向拆分和纵向拆分。  \n  \n纵向拆分：不同业务模块独立部署，例如一个 CRM 系统就可以根据客户域、产品域、资源域、营销管理域等拆分。由大变小、分而治之。  \n![][2]  \n\n横向拆分：将核心的、公共的业务拆分出来，通过分布式服务框架对业务进行服务化，消费者通过标准的契约来消费这些服务。服务提供者独立打包、部署，与消费者解耦。  \n![][3]\n\n## 1.2 引入服务治理\n\n使用 RPC 框架对业务进行拆分之后，随着服务数的增多，急需一个服务治理框架，有效管控服务，提升服务运行期质量，防止业务服务代码架构腐化。因为，服务治理的主要应用如下：  \n1. 生命周期管理：服务上线下线通知机制规范化。\n2. 服务容量规划。\n3. 运行期治理：对非核心服务采取降级、限流措施；缓存失效时，系统压力转移到数据库，服务调用时延突然增大，业务失败率升高，需要在线调大服务调用超时时间，保证业务成功率。\n4. 服务安全。  \n  \n典型的 SOA 服务治理生命周期如下：  \n![][4]\n1. 计划：确定服务治理的重点。\n2. 定义：定义服务治理模型。\n3. 启用：实现并实施服务治理。\n4. 度量：根据实施效果，改进服务治理模型。\n\n# 2 业务分布式服务框架介绍\n\n## 2.1 阿里 Dubbo\n\n架构图如下：  \n![][5]  \n功能总结：  \n1. 根据服务提供者配置的 XML 文件将服务按照指定协议发布，完成服务的初始化工作。\n2. 服务提供者根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到服务注册中心。\n3. 消费者根据服务消费者 XML 配置文件的服务引用信息，连接注册中心，获取指定服务的地址等路由信息。\n4. 服务注册中心根据服务订阅关系，动态地向指定消费者推送服务地址信息。\n5. 消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择一个服务提供者，然后根据协议类型建立链路，跨进程调用服务提供者。  \n  \n原理图如下：  \n![][6]\n\n## 2.2 淘宝 HSF\n\n架构图如下：  \n![][7]  \n功能总结：  \n1. 配置 XML 方式发布和消费服务。\n2. 插件管理体系：平台与应用分开部署，运行期依赖，外部采用与应用独立的 classloader 隔离，内部采用 OSGI 隔离。\n3. 异步 NIO 通信。多种序列化方式。服务提供者和消费者之间采用长连接通信。\n4. 灵活的路由能力：客户端软负载，随机、轮询等多种路由策略，支持容灾和失效恢复等。\n5. 多协议支持：WebService、PB（Protocol buffer）和 Hession（HTTP）等。\n  \n整体结构图如下：  \n![][8]\n\n## 2.3 亚马逊 Coral Service\n\n# 3 分布式服务框架设计\n\n本章介绍分布式服务框架的架构原理和概要设计。\n\n## 3.1 架构原理\n\n![][10]  \n通常分布式服务框架的架构可以抽象为三层：  \n1. RPC 层：包括底层通信框架（例如 NIO 框架的封装、公有协议的封装等）、序列化和反序列化框架、用于屏蔽底层通信协议细节和序列化方式差异的 Remoting 框架。\n2. Filter Chain 层：服务调用职责链，提供多种服务调用切面供框架自身和使用者扩展，例如负责均衡、服务调用性能统计、服务调用完成通知机制、失败重发等。\n3. Service 层：主要包括 Java 动态代理，消费者使用，主要用于将服务提供者的接口封装成远程服务调用：Java 反射，服务提供者使用，根据消费者请求消息中的接口名、方法名、参数列表反射调用服务提供者的接口本地实现类。\n  \n从功能角度看，分布式服务框架通常会包含另外两个重要功能：服务治理中心和服务注册中心。\n\n## 3.2 功能特性\n\n1. 服务订阅发布之配置化发布和引用服务：支持通过 XML 配置的方式发布和导入服务，降低对业务代码的侵入。\n2. 服务订阅发布之服务自动发现机制：由注册中心推送服务地址，消费者不需要配置服务提供者地址，服务地址透明化。\n3. 服务订阅发布之服务在线注册和去注册：支持运行态注册新服务，也支持运行态取消某个服务的注册。\n4. 服务路由之默认提供随机路由、轮询、基于权重的路由策略等。\n5. 服务路由之粘滞连接：总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台。\n6. 服务路由之路由定制：支持用户自定义路由策略。\n7. 集群容错之 FailOver：失败自动切换，常用读操作；也可用于幂等性写操作。\n8. 集群容错之 Failback：失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。\n9. 集群容错之 Failfast：快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。\n10. 服务调用之同步调用：消费者发起服务调用之后，同步阻塞等待服务端响应。\n11. 服务调用之异步调用：消费者发起服务调用之后，不阻塞立即返回，由服务端返回应答后异步通知消费者。\n12. 服务调用之并行调用：消费者同时对多个服务提供者批量发起服务调用请求，批量发起请求，集中等待应答。\n13. 多协议之私有协议：支持二进制等私有协议，支持自定义。\n14. 多协议之公有协议：支持 Web Service 等公有协议，用于外部服务对象。\n15. 序列化方式之二进制类序列化：支持 Thrift、Protocol buffer 等二进制协议，提升序列化性能。\n16. 序列化方式之文本类序列化：支持 JSON、XML 等文本类型的序列化方式。\n17. 统一配置之本地静态配置：安装部署一次，运行态不修改的配置，可以存放到本地配置文件中。\n18. 统一配置之基于配置中心的动态配置：运行态需要调整的参数，统一放到配置中心，修改之后统一下发，实时生效。\n\n## 3.3 服务治理\n\n1. 服务运行态管控之服务路由：业务高峰期，通过动态修改路由策略实现导流。\n2. 服务运行态管控之服务限流：资源成为瓶颈时，服务端和消费者的动态流控。\n3. 服务运行态管控之服务迁入迁出：实现资源的动态分配。\n4. 服务运行态管控之服务降级：服务提供者故障时或者业务高峰期，进行服务强制或者容错降级，执行本地降级逻辑，保证系统平稳运行。\n5. 服务运行态管控之服务超时控制：动态调整超时时间，在业务高峰期保障业务调用成功率。\n6. 服务监控之性能统计：统计项包括服务调用时延、成功率、调用次数等。\n7. 服务监控之统计报表：提供多维度、实时和历史数据报表，同比、环比等性能对比数据，供运维、运营等使用。\n8. 服务监控之告警：指标异常，根据告警策略发送告警，包括但不限于短信、E-mail、记录日志等。\n9. 服务生命周期管理之上线审批：服务提供者不能随意线上发布服务，需要通过正规的审批流程批准之后才能上线。\n10. 服务生命周期管理之下线通知：服务提供者在下线某个服务之前一段时间，需要根据 SLA 策略，通知消费者。\n11. 服务生命周期管理之服务灰度发布：灰度环境划分原则、接口前向兼容性策略，以及消费者如何路由，都需要灰度发布引擎负责管理。\n12. 故障快速定界定位之分布式日志采集：支持在大规模分布式环境中实时采集容器、中间件和应用的各种日志。\n13. 故障快速定界定位之海量日志在线检索：支持分布式环境海量日志的在线检索，支持多维度索引和模糊查询。\n14. 故障快速定界定位之调用链可视化展示：通过分布式消息跟踪系统输出调用链，可视化、快速地进行故障定界。\n15. 故障快速定界定位之运行日志故障定位：通过调用链的故障关键字，在日志检索界面快速检索故障日志，用于故障的精确定位。\n16. 服务安全之敏感服务的授权策略：敏感服务如何授权，防止恶意调用。\n17. 服务安全之链路的安全防护“消费者和服务提供者之间的长连接，需要增加安全防护，例如基于 Token 的安全认证机制。\n\n# 4 个人总结\n\n分布式服务框架在原理、目标是类似的，因此不同的分布式服务框架原理也是相似的。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_8.png\n[10]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_10.png","slug":"distributed_principle_prictice/2.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkava001baxs6l3f983tf","content":"<h1 id=\"1-分布式服务框架诞生背景\"><a href=\"#1-分布式服务框架诞生背景\" class=\"headerlink\" title=\"1 分布式服务框架诞生背景\"></a>1 分布式服务框架诞生背景</h1><h2 id=\"1-1-集中式到分布式\"><a href=\"#1-1-集中式到分布式\" class=\"headerlink\" title=\"1.1 集中式到分布式\"></a>1.1 集中式到分布式</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_1.png\" alt=\"\">  </p>\n<ol>\n<li>业务发展、应用规模变大，大型复杂应用的开发维护成本高，部署效率低，应用数量膨胀，数据库连接数变高。</li>\n<li>代码复用低：由于公共模块都是进程内部的本地 API 调用，开发者按需开发，导致大量相同功能的 API 被重复开发。一旦涉及到公共模块的功能变更，所有重复实现都需要重新修改、编译和测试。</li>\n<li>敏捷持续交付：想要在一个架构师都无法理解的巨无霸业务中新增或者修改一个功能，难度是非常大的。业务模块之间的循环依赖、重复 API 定义和开发、不合理的调用、冗长复杂的业务流程对新特性的上线简直是梦魇。  </li>\n</ol>\n<p>大规模系统架构的设计一般就是尽可能的拆分，以达到更好的独立扩展、部署、开发效率等。<br>具体的拆分策略大体上可以分为横向拆分和纵向拆分。  </p>\n<p>纵向拆分：不同业务模块独立部署，例如一个 CRM 系统就可以根据客户域、产品域、资源域、营销管理域等拆分。由大变小、分而治之。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_2.png\" alt=\"\">  </p>\n<p>横向拆分：将核心的、公共的业务拆分出来，通过分布式服务框架对业务进行服务化，消费者通过标准的契约来消费这些服务。服务提供者独立打包、部署，与消费者解耦。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_3.png\" alt=\"\"></p>\n<h2 id=\"1-2-引入服务治理\"><a href=\"#1-2-引入服务治理\" class=\"headerlink\" title=\"1.2 引入服务治理\"></a>1.2 引入服务治理</h2><p>使用 RPC 框架对业务进行拆分之后，随着服务数的增多，急需一个服务治理框架，有效管控服务，提升服务运行期质量，防止业务服务代码架构腐化。因为，服务治理的主要应用如下：  </p>\n<ol>\n<li>生命周期管理：服务上线下线通知机制规范化。</li>\n<li>服务容量规划。</li>\n<li>运行期治理：对非核心服务采取降级、限流措施；缓存失效时，系统压力转移到数据库，服务调用时延突然增大，业务失败率升高，需要在线调大服务调用超时时间，保证业务成功率。</li>\n<li>服务安全。  </li>\n</ol>\n<p>典型的 SOA 服务治理生命周期如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_4.png\" alt=\"\"></p>\n<ol>\n<li>计划：确定服务治理的重点。</li>\n<li>定义：定义服务治理模型。</li>\n<li>启用：实现并实施服务治理。</li>\n<li>度量：根据实施效果，改进服务治理模型。</li>\n</ol>\n<h1 id=\"2-业务分布式服务框架介绍\"><a href=\"#2-业务分布式服务框架介绍\" class=\"headerlink\" title=\"2 业务分布式服务框架介绍\"></a>2 业务分布式服务框架介绍</h1><h2 id=\"2-1-阿里-Dubbo\"><a href=\"#2-1-阿里-Dubbo\" class=\"headerlink\" title=\"2.1 阿里 Dubbo\"></a>2.1 阿里 Dubbo</h2><p>架构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_5.png\" alt=\"\"><br>功能总结：  </p>\n<ol>\n<li>根据服务提供者配置的 XML 文件将服务按照指定协议发布，完成服务的初始化工作。</li>\n<li>服务提供者根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到服务注册中心。</li>\n<li>消费者根据服务消费者 XML 配置文件的服务引用信息，连接注册中心，获取指定服务的地址等路由信息。</li>\n<li>服务注册中心根据服务订阅关系，动态地向指定消费者推送服务地址信息。</li>\n<li>消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择一个服务提供者，然后根据协议类型建立链路，跨进程调用服务提供者。  </li>\n</ol>\n<p>原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_6.png\" alt=\"\"></p>\n<h2 id=\"2-2-淘宝-HSF\"><a href=\"#2-2-淘宝-HSF\" class=\"headerlink\" title=\"2.2 淘宝 HSF\"></a>2.2 淘宝 HSF</h2><p>架构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_7.png\" alt=\"\"><br>功能总结：  </p>\n<ol>\n<li>配置 XML 方式发布和消费服务。</li>\n<li>插件管理体系：平台与应用分开部署，运行期依赖，外部采用与应用独立的 classloader 隔离，内部采用 OSGI 隔离。</li>\n<li>异步 NIO 通信。多种序列化方式。服务提供者和消费者之间采用长连接通信。</li>\n<li>灵活的路由能力：客户端软负载，随机、轮询等多种路由策略，支持容灾和失效恢复等。</li>\n<li>多协议支持：WebService、PB（Protocol buffer）和 Hession（HTTP）等。</li>\n</ol>\n<p>整体结构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_8.png\" alt=\"\"></p>\n<h2 id=\"2-3-亚马逊-Coral-Service\"><a href=\"#2-3-亚马逊-Coral-Service\" class=\"headerlink\" title=\"2.3 亚马逊 Coral Service\"></a>2.3 亚马逊 Coral Service</h2><h1 id=\"3-分布式服务框架设计\"><a href=\"#3-分布式服务框架设计\" class=\"headerlink\" title=\"3 分布式服务框架设计\"></a>3 分布式服务框架设计</h1><p>本章介绍分布式服务框架的架构原理和概要设计。</p>\n<h2 id=\"3-1-架构原理\"><a href=\"#3-1-架构原理\" class=\"headerlink\" title=\"3.1 架构原理\"></a>3.1 架构原理</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_10.png\" alt=\"\"><br>通常分布式服务框架的架构可以抽象为三层：  </p>\n<ol>\n<li>RPC 层：包括底层通信框架（例如 NIO 框架的封装、公有协议的封装等）、序列化和反序列化框架、用于屏蔽底层通信协议细节和序列化方式差异的 Remoting 框架。</li>\n<li>Filter Chain 层：服务调用职责链，提供多种服务调用切面供框架自身和使用者扩展，例如负责均衡、服务调用性能统计、服务调用完成通知机制、失败重发等。</li>\n<li>Service 层：主要包括 Java 动态代理，消费者使用，主要用于将服务提供者的接口封装成远程服务调用：Java 反射，服务提供者使用，根据消费者请求消息中的接口名、方法名、参数列表反射调用服务提供者的接口本地实现类。</li>\n</ol>\n<p>从功能角度看，分布式服务框架通常会包含另外两个重要功能：服务治理中心和服务注册中心。</p>\n<h2 id=\"3-2-功能特性\"><a href=\"#3-2-功能特性\" class=\"headerlink\" title=\"3.2 功能特性\"></a>3.2 功能特性</h2><ol>\n<li>服务订阅发布之配置化发布和引用服务：支持通过 XML 配置的方式发布和导入服务，降低对业务代码的侵入。</li>\n<li>服务订阅发布之服务自动发现机制：由注册中心推送服务地址，消费者不需要配置服务提供者地址，服务地址透明化。</li>\n<li>服务订阅发布之服务在线注册和去注册：支持运行态注册新服务，也支持运行态取消某个服务的注册。</li>\n<li>服务路由之默认提供随机路由、轮询、基于权重的路由策略等。</li>\n<li>服务路由之粘滞连接：总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台。</li>\n<li>服务路由之路由定制：支持用户自定义路由策略。</li>\n<li>集群容错之 FailOver：失败自动切换，常用读操作；也可用于幂等性写操作。</li>\n<li>集群容错之 Failback：失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。</li>\n<li>集群容错之 Failfast：快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li>\n<li>服务调用之同步调用：消费者发起服务调用之后，同步阻塞等待服务端响应。</li>\n<li>服务调用之异步调用：消费者发起服务调用之后，不阻塞立即返回，由服务端返回应答后异步通知消费者。</li>\n<li>服务调用之并行调用：消费者同时对多个服务提供者批量发起服务调用请求，批量发起请求，集中等待应答。</li>\n<li>多协议之私有协议：支持二进制等私有协议，支持自定义。</li>\n<li>多协议之公有协议：支持 Web Service 等公有协议，用于外部服务对象。</li>\n<li>序列化方式之二进制类序列化：支持 Thrift、Protocol buffer 等二进制协议，提升序列化性能。</li>\n<li>序列化方式之文本类序列化：支持 JSON、XML 等文本类型的序列化方式。</li>\n<li>统一配置之本地静态配置：安装部署一次，运行态不修改的配置，可以存放到本地配置文件中。</li>\n<li>统一配置之基于配置中心的动态配置：运行态需要调整的参数，统一放到配置中心，修改之后统一下发，实时生效。</li>\n</ol>\n<h2 id=\"3-3-服务治理\"><a href=\"#3-3-服务治理\" class=\"headerlink\" title=\"3.3 服务治理\"></a>3.3 服务治理</h2><ol>\n<li>服务运行态管控之服务路由：业务高峰期，通过动态修改路由策略实现导流。</li>\n<li>服务运行态管控之服务限流：资源成为瓶颈时，服务端和消费者的动态流控。</li>\n<li>服务运行态管控之服务迁入迁出：实现资源的动态分配。</li>\n<li>服务运行态管控之服务降级：服务提供者故障时或者业务高峰期，进行服务强制或者容错降级，执行本地降级逻辑，保证系统平稳运行。</li>\n<li>服务运行态管控之服务超时控制：动态调整超时时间，在业务高峰期保障业务调用成功率。</li>\n<li>服务监控之性能统计：统计项包括服务调用时延、成功率、调用次数等。</li>\n<li>服务监控之统计报表：提供多维度、实时和历史数据报表，同比、环比等性能对比数据，供运维、运营等使用。</li>\n<li>服务监控之告警：指标异常，根据告警策略发送告警，包括但不限于短信、E-mail、记录日志等。</li>\n<li>服务生命周期管理之上线审批：服务提供者不能随意线上发布服务，需要通过正规的审批流程批准之后才能上线。</li>\n<li>服务生命周期管理之下线通知：服务提供者在下线某个服务之前一段时间，需要根据 SLA 策略，通知消费者。</li>\n<li>服务生命周期管理之服务灰度发布：灰度环境划分原则、接口前向兼容性策略，以及消费者如何路由，都需要灰度发布引擎负责管理。</li>\n<li>故障快速定界定位之分布式日志采集：支持在大规模分布式环境中实时采集容器、中间件和应用的各种日志。</li>\n<li>故障快速定界定位之海量日志在线检索：支持分布式环境海量日志的在线检索，支持多维度索引和模糊查询。</li>\n<li>故障快速定界定位之调用链可视化展示：通过分布式消息跟踪系统输出调用链，可视化、快速地进行故障定界。</li>\n<li>故障快速定界定位之运行日志故障定位：通过调用链的故障关键字，在日志检索界面快速检索故障日志，用于故障的精确定位。</li>\n<li>服务安全之敏感服务的授权策略：敏感服务如何授权，防止恶意调用。</li>\n<li>服务安全之链路的安全防护“消费者和服务提供者之间的长连接，需要增加安全防护，例如基于 Token 的安全认证机制。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>分布式服务框架在原理、目标是类似的，因此不同的分布式服务框架原理也是相似的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-分布式服务框架诞生背景\"><a href=\"#1-分布式服务框架诞生背景\" class=\"headerlink\" title=\"1 分布式服务框架诞生背景\"></a>1 分布式服务框架诞生背景</h1><h2 id=\"1-1-集中式到分布式\"><a href=\"#1-1-集中式到分布式\" class=\"headerlink\" title=\"1.1 集中式到分布式\"></a>1.1 集中式到分布式</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_1.png\" alt=\"\">  </p>\n<ol>\n<li>业务发展、应用规模变大，大型复杂应用的开发维护成本高，部署效率低，应用数量膨胀，数据库连接数变高。</li>\n<li>代码复用低：由于公共模块都是进程内部的本地 API 调用，开发者按需开发，导致大量相同功能的 API 被重复开发。一旦涉及到公共模块的功能变更，所有重复实现都需要重新修改、编译和测试。</li>\n<li>敏捷持续交付：想要在一个架构师都无法理解的巨无霸业务中新增或者修改一个功能，难度是非常大的。业务模块之间的循环依赖、重复 API 定义和开发、不合理的调用、冗长复杂的业务流程对新特性的上线简直是梦魇。  </li>\n</ol>\n<p>大规模系统架构的设计一般就是尽可能的拆分，以达到更好的独立扩展、部署、开发效率等。<br>具体的拆分策略大体上可以分为横向拆分和纵向拆分。  </p>\n<p>纵向拆分：不同业务模块独立部署，例如一个 CRM 系统就可以根据客户域、产品域、资源域、营销管理域等拆分。由大变小、分而治之。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_2.png\" alt=\"\">  </p>\n<p>横向拆分：将核心的、公共的业务拆分出来，通过分布式服务框架对业务进行服务化，消费者通过标准的契约来消费这些服务。服务提供者独立打包、部署，与消费者解耦。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_3.png\" alt=\"\"></p>\n<h2 id=\"1-2-引入服务治理\"><a href=\"#1-2-引入服务治理\" class=\"headerlink\" title=\"1.2 引入服务治理\"></a>1.2 引入服务治理</h2><p>使用 RPC 框架对业务进行拆分之后，随着服务数的增多，急需一个服务治理框架，有效管控服务，提升服务运行期质量，防止业务服务代码架构腐化。因为，服务治理的主要应用如下：  </p>\n<ol>\n<li>生命周期管理：服务上线下线通知机制规范化。</li>\n<li>服务容量规划。</li>\n<li>运行期治理：对非核心服务采取降级、限流措施；缓存失效时，系统压力转移到数据库，服务调用时延突然增大，业务失败率升高，需要在线调大服务调用超时时间，保证业务成功率。</li>\n<li>服务安全。  </li>\n</ol>\n<p>典型的 SOA 服务治理生命周期如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_4.png\" alt=\"\"></p>\n<ol>\n<li>计划：确定服务治理的重点。</li>\n<li>定义：定义服务治理模型。</li>\n<li>启用：实现并实施服务治理。</li>\n<li>度量：根据实施效果，改进服务治理模型。</li>\n</ol>\n<h1 id=\"2-业务分布式服务框架介绍\"><a href=\"#2-业务分布式服务框架介绍\" class=\"headerlink\" title=\"2 业务分布式服务框架介绍\"></a>2 业务分布式服务框架介绍</h1><h2 id=\"2-1-阿里-Dubbo\"><a href=\"#2-1-阿里-Dubbo\" class=\"headerlink\" title=\"2.1 阿里 Dubbo\"></a>2.1 阿里 Dubbo</h2><p>架构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_5.png\" alt=\"\"><br>功能总结：  </p>\n<ol>\n<li>根据服务提供者配置的 XML 文件将服务按照指定协议发布，完成服务的初始化工作。</li>\n<li>服务提供者根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到服务注册中心。</li>\n<li>消费者根据服务消费者 XML 配置文件的服务引用信息，连接注册中心，获取指定服务的地址等路由信息。</li>\n<li>服务注册中心根据服务订阅关系，动态地向指定消费者推送服务地址信息。</li>\n<li>消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择一个服务提供者，然后根据协议类型建立链路，跨进程调用服务提供者。  </li>\n</ol>\n<p>原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_6.png\" alt=\"\"></p>\n<h2 id=\"2-2-淘宝-HSF\"><a href=\"#2-2-淘宝-HSF\" class=\"headerlink\" title=\"2.2 淘宝 HSF\"></a>2.2 淘宝 HSF</h2><p>架构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_7.png\" alt=\"\"><br>功能总结：  </p>\n<ol>\n<li>配置 XML 方式发布和消费服务。</li>\n<li>插件管理体系：平台与应用分开部署，运行期依赖，外部采用与应用独立的 classloader 隔离，内部采用 OSGI 隔离。</li>\n<li>异步 NIO 通信。多种序列化方式。服务提供者和消费者之间采用长连接通信。</li>\n<li>灵活的路由能力：客户端软负载，随机、轮询等多种路由策略，支持容灾和失效恢复等。</li>\n<li>多协议支持：WebService、PB（Protocol buffer）和 Hession（HTTP）等。</li>\n</ol>\n<p>整体结构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_8.png\" alt=\"\"></p>\n<h2 id=\"2-3-亚马逊-Coral-Service\"><a href=\"#2-3-亚马逊-Coral-Service\" class=\"headerlink\" title=\"2.3 亚马逊 Coral Service\"></a>2.3 亚马逊 Coral Service</h2><h1 id=\"3-分布式服务框架设计\"><a href=\"#3-分布式服务框架设计\" class=\"headerlink\" title=\"3 分布式服务框架设计\"></a>3 分布式服务框架设计</h1><p>本章介绍分布式服务框架的架构原理和概要设计。</p>\n<h2 id=\"3-1-架构原理\"><a href=\"#3-1-架构原理\" class=\"headerlink\" title=\"3.1 架构原理\"></a>3.1 架构原理</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_10.png\" alt=\"\"><br>通常分布式服务框架的架构可以抽象为三层：  </p>\n<ol>\n<li>RPC 层：包括底层通信框架（例如 NIO 框架的封装、公有协议的封装等）、序列化和反序列化框架、用于屏蔽底层通信协议细节和序列化方式差异的 Remoting 框架。</li>\n<li>Filter Chain 层：服务调用职责链，提供多种服务调用切面供框架自身和使用者扩展，例如负责均衡、服务调用性能统计、服务调用完成通知机制、失败重发等。</li>\n<li>Service 层：主要包括 Java 动态代理，消费者使用，主要用于将服务提供者的接口封装成远程服务调用：Java 反射，服务提供者使用，根据消费者请求消息中的接口名、方法名、参数列表反射调用服务提供者的接口本地实现类。</li>\n</ol>\n<p>从功能角度看，分布式服务框架通常会包含另外两个重要功能：服务治理中心和服务注册中心。</p>\n<h2 id=\"3-2-功能特性\"><a href=\"#3-2-功能特性\" class=\"headerlink\" title=\"3.2 功能特性\"></a>3.2 功能特性</h2><ol>\n<li>服务订阅发布之配置化发布和引用服务：支持通过 XML 配置的方式发布和导入服务，降低对业务代码的侵入。</li>\n<li>服务订阅发布之服务自动发现机制：由注册中心推送服务地址，消费者不需要配置服务提供者地址，服务地址透明化。</li>\n<li>服务订阅发布之服务在线注册和去注册：支持运行态注册新服务，也支持运行态取消某个服务的注册。</li>\n<li>服务路由之默认提供随机路由、轮询、基于权重的路由策略等。</li>\n<li>服务路由之粘滞连接：总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台。</li>\n<li>服务路由之路由定制：支持用户自定义路由策略。</li>\n<li>集群容错之 FailOver：失败自动切换，常用读操作；也可用于幂等性写操作。</li>\n<li>集群容错之 Failback：失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。</li>\n<li>集群容错之 Failfast：快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li>\n<li>服务调用之同步调用：消费者发起服务调用之后，同步阻塞等待服务端响应。</li>\n<li>服务调用之异步调用：消费者发起服务调用之后，不阻塞立即返回，由服务端返回应答后异步通知消费者。</li>\n<li>服务调用之并行调用：消费者同时对多个服务提供者批量发起服务调用请求，批量发起请求，集中等待应答。</li>\n<li>多协议之私有协议：支持二进制等私有协议，支持自定义。</li>\n<li>多协议之公有协议：支持 Web Service 等公有协议，用于外部服务对象。</li>\n<li>序列化方式之二进制类序列化：支持 Thrift、Protocol buffer 等二进制协议，提升序列化性能。</li>\n<li>序列化方式之文本类序列化：支持 JSON、XML 等文本类型的序列化方式。</li>\n<li>统一配置之本地静态配置：安装部署一次，运行态不修改的配置，可以存放到本地配置文件中。</li>\n<li>统一配置之基于配置中心的动态配置：运行态需要调整的参数，统一放到配置中心，修改之后统一下发，实时生效。</li>\n</ol>\n<h2 id=\"3-3-服务治理\"><a href=\"#3-3-服务治理\" class=\"headerlink\" title=\"3.3 服务治理\"></a>3.3 服务治理</h2><ol>\n<li>服务运行态管控之服务路由：业务高峰期，通过动态修改路由策略实现导流。</li>\n<li>服务运行态管控之服务限流：资源成为瓶颈时，服务端和消费者的动态流控。</li>\n<li>服务运行态管控之服务迁入迁出：实现资源的动态分配。</li>\n<li>服务运行态管控之服务降级：服务提供者故障时或者业务高峰期，进行服务强制或者容错降级，执行本地降级逻辑，保证系统平稳运行。</li>\n<li>服务运行态管控之服务超时控制：动态调整超时时间，在业务高峰期保障业务调用成功率。</li>\n<li>服务监控之性能统计：统计项包括服务调用时延、成功率、调用次数等。</li>\n<li>服务监控之统计报表：提供多维度、实时和历史数据报表，同比、环比等性能对比数据，供运维、运营等使用。</li>\n<li>服务监控之告警：指标异常，根据告警策略发送告警，包括但不限于短信、E-mail、记录日志等。</li>\n<li>服务生命周期管理之上线审批：服务提供者不能随意线上发布服务，需要通过正规的审批流程批准之后才能上线。</li>\n<li>服务生命周期管理之下线通知：服务提供者在下线某个服务之前一段时间，需要根据 SLA 策略，通知消费者。</li>\n<li>服务生命周期管理之服务灰度发布：灰度环境划分原则、接口前向兼容性策略，以及消费者如何路由，都需要灰度发布引擎负责管理。</li>\n<li>故障快速定界定位之分布式日志采集：支持在大规模分布式环境中实时采集容器、中间件和应用的各种日志。</li>\n<li>故障快速定界定位之海量日志在线检索：支持分布式环境海量日志的在线检索，支持多维度索引和模糊查询。</li>\n<li>故障快速定界定位之调用链可视化展示：通过分布式消息跟踪系统输出调用链，可视化、快速地进行故障定界。</li>\n<li>故障快速定界定位之运行日志故障定位：通过调用链的故障关键字，在日志检索界面快速检索故障日志，用于故障的精确定位。</li>\n<li>服务安全之敏感服务的授权策略：敏感服务如何授权，防止恶意调用。</li>\n<li>服务安全之链路的安全防护“消费者和服务提供者之间的长连接，需要增加安全防护，例如基于 Token 的安全认证机制。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>分布式服务框架在原理、目标是类似的，因此不同的分布式服务框架原理也是相似的。</p>\n"},{"title":"五、协议栈","date":"2018-05-27T14:18:00.000Z","updated":"2018-05-28T16:08:00.000Z","comments":1,"_content":"\n# 1 关键技术点分析\n\n# 1.1 是否必须支持多协议\n\n分布式服务框架需要具备通过扩展的方式支持多协议的能力，协议栈应该作为一个架构扩展点开放出来。\n\n# 1.2 公有协议还是私有协议\n\n以 Web Service 公有协议为例，它的性能存在如下缺陷：  \n1. SOAP 消息使用 XML 进行序列化，相比于 PB 等二进制序列化框架，性能低很多。\n2. SOAP 通常由 HTTP 协议承载，HTTP 1.0 不支持双向全工通信，而且一般使用短连接通信，性能比较差。\n\n如果没有特殊需求，分布式服务框架默认使用性能更高、扩展性更好的私有协议（二进制）进行通信。对 HTTP/Restful 等公有协议进行扩展\n\n# 1.3 集成开元还是自研\n\n1. 如果已经有可以满足需求的框架，优先选择继承开源框架。\n2. 如果使用到的功能不多，或者对性能要求极高，可以考虑基于 Netty 自研。\n\n# 2 功能设计\n\n## 2.1 功能描述\n\n私有协议栈承载了业务内部各模块之间的消息交互和服务调用，主要功能如下：  \n1. 定义了私有协议的通信模型和消息定义。\n2. 支持服务提供者和消费者之间采用点对点长连接通信\n3. 基于 Java NIO 通信框架，提供高性能的异步通信能力。\n4. 提供可扩展的编解码框架，支持多种序列化格式。\n5. 握手和安全认证机制。\n6. 链路的高可靠性。\n\n## 2.2 通信模型\n\n私有协议栈通信模型如下：  \n![][1]  \n  \n1. 客户端发送握手请求消息，携带节点ID 等有效神风认证信息。\n2. 服务端对握手请求消息进行合法性校验，包括节点ID 有效性校验、节点重复登录校验和IP 地址合法性校验，校验通过后，返回登录成功的握手应答消息。\n3. 链路建立成功之后，客户端发送业务消息。\n4. 链路成功之后，服务端发送心跳消息。\n5. 链路建立成功之后，客户端发送心跳消息。\n6. 链路建立成功之后，服务端发送业务消息。\n7. 服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。\n\n## 2.3 协议消息定义\n\n通信协议栈的消息模型分为两部分，消息头和消息体。消息头存放协议公共字段和用户扩展字段，消息体则用于承载消息内容。以 HTTP 协议为例，请求消息头允许客户端向服务端传递请求的附加信息以及客户端自身的信息，常见的消息头关键字有 Accept、Authorization、Host 等。\n\n## 2.4 协议消息的序列化和反序列化\n\n消息的序列化分为两部分，消息头的序列化和消息体的序列化，两者采用的机制不一样。原因是协议栈可以由不同的序列化框架承载，标识序列化格式的字段在消息头中定义，因此我们必须首先对消息头做通用解码，获取序列化格式，然后根据类型再调用对应的解码器对消息体做解码。消息头是通用编解码。\n\n## 2.5 链路创建\n\n协议栈包括服务端和客户端，对于上层应用来说，一个节点可能既是服务端也是客户端。  \n考虑到安全，链路简历需要通过基于 IP 地址或者号段的黑白名单安全认证机制，以及通过秘钥等。\n\n## 2.6 链路关闭\n\n由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。以下情况，客户端和服务端需要关闭连接：  \n1. 当对方宕机或重启时，会主动关闭链路。\n2. 消息读写过程中，发生了 I/O 异常，需要主动关闭连接。\n3. 心跳消息读写过程中发生了 I/O 异常，需要主动关闭连接。\n4. 心跳超时，需要主动关闭连接。\n5. 发生编码异常或其它不可恢复错误时，需要主动关闭连接。\n\n# 3 可靠性分析\n\n## 3.1 客户端连接超时\n\n客户端业务需要、以及资源的长时间占有等，需要设置超时时间。\n\n## 3.2 客户端重连机制\n\n客户端通过链路关闭监听器监听链路状态，如果链路中断，等待 INTERVAL 时间后，由客户端发起重连操作，如果重连失败，间隔周期 INTERVAL 后再次发起重连，直到重连成功。  \n  \n为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。\n\n## 3.3 客户端重复握手保护\n\n当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复握手，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。  \n  \n服务端接收到客户端的握手请求消息之后，首先对IP 地址进行合法性检验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果已经登录，则拒绝登录，返回错误码 -1，同时关闭 TCP 链路，并在服务端的日志中打印握手失败的原因。  \n  \n客户端接收到握手失败的应答消息之后，关闭客户端的 TCP连接，等待 INTERVAL 时间之后，再次发起 TCP连接，直到认证成功。\n\n## 3.4 消息缓存重发\n\n无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。  \n  \n考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续向该队列添加新的消息。\n\n## 3.5 心跳机制\n\n在凌晨等业务低谷期时段，如果发生网络闪断、连接被 Hang 住等网络问题时，由于没有业务消息，应用金城很难发现。到了白天业务高峰期时，会发生大量的网络通信失败。为了解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络网络故障，立即关闭链路，主动重连。\n\n# 4 最佳实现--协议的前后兼容性\n\n考虑到协议的前向兼容性，核心的设计原则有2 个：  \n1. 消息头第一个字段中携带协议的版本号，用于标识消息协议版本。\n2. 消息头最后一个字段是 Map 类型的扩展字段，用于服务框架自身或者用户扩展消息头。\n\n# 5 个人总结\n\n协议栈描述了分布式服务框架的通信契约，序列化和反序列化框架用于协议消息对象和二进制数组之间的相互转换，通信框架在技术上承载协议，协议依赖通信。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/5_1.png","source":"_posts/分布式服务框架原理与实践/第五章 协议栈.md","raw":"---\ntitle: 五、协议栈\ndate: 2018-05-27 22:18:00\nupdated: 2018-05-29 00:08:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/5.html    \n---\n\n# 1 关键技术点分析\n\n# 1.1 是否必须支持多协议\n\n分布式服务框架需要具备通过扩展的方式支持多协议的能力，协议栈应该作为一个架构扩展点开放出来。\n\n# 1.2 公有协议还是私有协议\n\n以 Web Service 公有协议为例，它的性能存在如下缺陷：  \n1. SOAP 消息使用 XML 进行序列化，相比于 PB 等二进制序列化框架，性能低很多。\n2. SOAP 通常由 HTTP 协议承载，HTTP 1.0 不支持双向全工通信，而且一般使用短连接通信，性能比较差。\n\n如果没有特殊需求，分布式服务框架默认使用性能更高、扩展性更好的私有协议（二进制）进行通信。对 HTTP/Restful 等公有协议进行扩展\n\n# 1.3 集成开元还是自研\n\n1. 如果已经有可以满足需求的框架，优先选择继承开源框架。\n2. 如果使用到的功能不多，或者对性能要求极高，可以考虑基于 Netty 自研。\n\n# 2 功能设计\n\n## 2.1 功能描述\n\n私有协议栈承载了业务内部各模块之间的消息交互和服务调用，主要功能如下：  \n1. 定义了私有协议的通信模型和消息定义。\n2. 支持服务提供者和消费者之间采用点对点长连接通信\n3. 基于 Java NIO 通信框架，提供高性能的异步通信能力。\n4. 提供可扩展的编解码框架，支持多种序列化格式。\n5. 握手和安全认证机制。\n6. 链路的高可靠性。\n\n## 2.2 通信模型\n\n私有协议栈通信模型如下：  \n![][1]  \n  \n1. 客户端发送握手请求消息，携带节点ID 等有效神风认证信息。\n2. 服务端对握手请求消息进行合法性校验，包括节点ID 有效性校验、节点重复登录校验和IP 地址合法性校验，校验通过后，返回登录成功的握手应答消息。\n3. 链路建立成功之后，客户端发送业务消息。\n4. 链路成功之后，服务端发送心跳消息。\n5. 链路建立成功之后，客户端发送心跳消息。\n6. 链路建立成功之后，服务端发送业务消息。\n7. 服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。\n\n## 2.3 协议消息定义\n\n通信协议栈的消息模型分为两部分，消息头和消息体。消息头存放协议公共字段和用户扩展字段，消息体则用于承载消息内容。以 HTTP 协议为例，请求消息头允许客户端向服务端传递请求的附加信息以及客户端自身的信息，常见的消息头关键字有 Accept、Authorization、Host 等。\n\n## 2.4 协议消息的序列化和反序列化\n\n消息的序列化分为两部分，消息头的序列化和消息体的序列化，两者采用的机制不一样。原因是协议栈可以由不同的序列化框架承载，标识序列化格式的字段在消息头中定义，因此我们必须首先对消息头做通用解码，获取序列化格式，然后根据类型再调用对应的解码器对消息体做解码。消息头是通用编解码。\n\n## 2.5 链路创建\n\n协议栈包括服务端和客户端，对于上层应用来说，一个节点可能既是服务端也是客户端。  \n考虑到安全，链路简历需要通过基于 IP 地址或者号段的黑白名单安全认证机制，以及通过秘钥等。\n\n## 2.6 链路关闭\n\n由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。以下情况，客户端和服务端需要关闭连接：  \n1. 当对方宕机或重启时，会主动关闭链路。\n2. 消息读写过程中，发生了 I/O 异常，需要主动关闭连接。\n3. 心跳消息读写过程中发生了 I/O 异常，需要主动关闭连接。\n4. 心跳超时，需要主动关闭连接。\n5. 发生编码异常或其它不可恢复错误时，需要主动关闭连接。\n\n# 3 可靠性分析\n\n## 3.1 客户端连接超时\n\n客户端业务需要、以及资源的长时间占有等，需要设置超时时间。\n\n## 3.2 客户端重连机制\n\n客户端通过链路关闭监听器监听链路状态，如果链路中断，等待 INTERVAL 时间后，由客户端发起重连操作，如果重连失败，间隔周期 INTERVAL 后再次发起重连，直到重连成功。  \n  \n为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。\n\n## 3.3 客户端重复握手保护\n\n当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复握手，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。  \n  \n服务端接收到客户端的握手请求消息之后，首先对IP 地址进行合法性检验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果已经登录，则拒绝登录，返回错误码 -1，同时关闭 TCP 链路，并在服务端的日志中打印握手失败的原因。  \n  \n客户端接收到握手失败的应答消息之后，关闭客户端的 TCP连接，等待 INTERVAL 时间之后，再次发起 TCP连接，直到认证成功。\n\n## 3.4 消息缓存重发\n\n无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。  \n  \n考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续向该队列添加新的消息。\n\n## 3.5 心跳机制\n\n在凌晨等业务低谷期时段，如果发生网络闪断、连接被 Hang 住等网络问题时，由于没有业务消息，应用金城很难发现。到了白天业务高峰期时，会发生大量的网络通信失败。为了解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络网络故障，立即关闭链路，主动重连。\n\n# 4 最佳实现--协议的前后兼容性\n\n考虑到协议的前向兼容性，核心的设计原则有2 个：  \n1. 消息头第一个字段中携带协议的版本号，用于标识消息协议版本。\n2. 消息头最后一个字段是 Map 类型的扩展字段，用于服务框架自身或者用户扩展消息头。\n\n# 5 个人总结\n\n协议栈描述了分布式服务框架的通信契约，序列化和反序列化框架用于协议消息对象和二进制数组之间的相互转换，通信框架在技术上承载协议，协议依赖通信。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/5_1.png","slug":"distributed_principle_prictice/5.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavb001daxs67720jsjs","content":"<h1 id=\"1-关键技术点分析\"><a href=\"#1-关键技术点分析\" class=\"headerlink\" title=\"1 关键技术点分析\"></a>1 关键技术点分析</h1><h1 id=\"1-1-是否必须支持多协议\"><a href=\"#1-1-是否必须支持多协议\" class=\"headerlink\" title=\"1.1 是否必须支持多协议\"></a>1.1 是否必须支持多协议</h1><p>分布式服务框架需要具备通过扩展的方式支持多协议的能力，协议栈应该作为一个架构扩展点开放出来。</p>\n<h1 id=\"1-2-公有协议还是私有协议\"><a href=\"#1-2-公有协议还是私有协议\" class=\"headerlink\" title=\"1.2 公有协议还是私有协议\"></a>1.2 公有协议还是私有协议</h1><p>以 Web Service 公有协议为例，它的性能存在如下缺陷：  </p>\n<ol>\n<li>SOAP 消息使用 XML 进行序列化，相比于 PB 等二进制序列化框架，性能低很多。</li>\n<li>SOAP 通常由 HTTP 协议承载，HTTP 1.0 不支持双向全工通信，而且一般使用短连接通信，性能比较差。</li>\n</ol>\n<p>如果没有特殊需求，分布式服务框架默认使用性能更高、扩展性更好的私有协议（二进制）进行通信。对 HTTP/Restful 等公有协议进行扩展</p>\n<h1 id=\"1-3-集成开元还是自研\"><a href=\"#1-3-集成开元还是自研\" class=\"headerlink\" title=\"1.3 集成开元还是自研\"></a>1.3 集成开元还是自研</h1><ol>\n<li>如果已经有可以满足需求的框架，优先选择继承开源框架。</li>\n<li>如果使用到的功能不多，或者对性能要求极高，可以考虑基于 Netty 自研。</li>\n</ol>\n<h1 id=\"2-功能设计\"><a href=\"#2-功能设计\" class=\"headerlink\" title=\"2 功能设计\"></a>2 功能设计</h1><h2 id=\"2-1-功能描述\"><a href=\"#2-1-功能描述\" class=\"headerlink\" title=\"2.1 功能描述\"></a>2.1 功能描述</h2><p>私有协议栈承载了业务内部各模块之间的消息交互和服务调用，主要功能如下：  </p>\n<ol>\n<li>定义了私有协议的通信模型和消息定义。</li>\n<li>支持服务提供者和消费者之间采用点对点长连接通信</li>\n<li>基于 Java NIO 通信框架，提供高性能的异步通信能力。</li>\n<li>提供可扩展的编解码框架，支持多种序列化格式。</li>\n<li>握手和安全认证机制。</li>\n<li>链路的高可靠性。</li>\n</ol>\n<h2 id=\"2-2-通信模型\"><a href=\"#2-2-通信模型\" class=\"headerlink\" title=\"2.2 通信模型\"></a>2.2 通信模型</h2><p>私有协议栈通信模型如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/5_1.png\" alt=\"\">  </p>\n<ol>\n<li>客户端发送握手请求消息，携带节点ID 等有效神风认证信息。</li>\n<li>服务端对握手请求消息进行合法性校验，包括节点ID 有效性校验、节点重复登录校验和IP 地址合法性校验，校验通过后，返回登录成功的握手应答消息。</li>\n<li>链路建立成功之后，客户端发送业务消息。</li>\n<li>链路成功之后，服务端发送心跳消息。</li>\n<li>链路建立成功之后，客户端发送心跳消息。</li>\n<li>链路建立成功之后，服务端发送业务消息。</li>\n<li>服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。</li>\n</ol>\n<h2 id=\"2-3-协议消息定义\"><a href=\"#2-3-协议消息定义\" class=\"headerlink\" title=\"2.3 协议消息定义\"></a>2.3 协议消息定义</h2><p>通信协议栈的消息模型分为两部分，消息头和消息体。消息头存放协议公共字段和用户扩展字段，消息体则用于承载消息内容。以 HTTP 协议为例，请求消息头允许客户端向服务端传递请求的附加信息以及客户端自身的信息，常见的消息头关键字有 Accept、Authorization、Host 等。</p>\n<h2 id=\"2-4-协议消息的序列化和反序列化\"><a href=\"#2-4-协议消息的序列化和反序列化\" class=\"headerlink\" title=\"2.4 协议消息的序列化和反序列化\"></a>2.4 协议消息的序列化和反序列化</h2><p>消息的序列化分为两部分，消息头的序列化和消息体的序列化，两者采用的机制不一样。原因是协议栈可以由不同的序列化框架承载，标识序列化格式的字段在消息头中定义，因此我们必须首先对消息头做通用解码，获取序列化格式，然后根据类型再调用对应的解码器对消息体做解码。消息头是通用编解码。</p>\n<h2 id=\"2-5-链路创建\"><a href=\"#2-5-链路创建\" class=\"headerlink\" title=\"2.5 链路创建\"></a>2.5 链路创建</h2><p>协议栈包括服务端和客户端，对于上层应用来说，一个节点可能既是服务端也是客户端。<br>考虑到安全，链路简历需要通过基于 IP 地址或者号段的黑白名单安全认证机制，以及通过秘钥等。</p>\n<h2 id=\"2-6-链路关闭\"><a href=\"#2-6-链路关闭\" class=\"headerlink\" title=\"2.6 链路关闭\"></a>2.6 链路关闭</h2><p>由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。以下情况，客户端和服务端需要关闭连接：  </p>\n<ol>\n<li>当对方宕机或重启时，会主动关闭链路。</li>\n<li>消息读写过程中，发生了 I/O 异常，需要主动关闭连接。</li>\n<li>心跳消息读写过程中发生了 I/O 异常，需要主动关闭连接。</li>\n<li>心跳超时，需要主动关闭连接。</li>\n<li>发生编码异常或其它不可恢复错误时，需要主动关闭连接。</li>\n</ol>\n<h1 id=\"3-可靠性分析\"><a href=\"#3-可靠性分析\" class=\"headerlink\" title=\"3 可靠性分析\"></a>3 可靠性分析</h1><h2 id=\"3-1-客户端连接超时\"><a href=\"#3-1-客户端连接超时\" class=\"headerlink\" title=\"3.1 客户端连接超时\"></a>3.1 客户端连接超时</h2><p>客户端业务需要、以及资源的长时间占有等，需要设置超时时间。</p>\n<h2 id=\"3-2-客户端重连机制\"><a href=\"#3-2-客户端重连机制\" class=\"headerlink\" title=\"3.2 客户端重连机制\"></a>3.2 客户端重连机制</h2><p>客户端通过链路关闭监听器监听链路状态，如果链路中断，等待 INTERVAL 时间后，由客户端发起重连操作，如果重连失败，间隔周期 INTERVAL 后再次发起重连，直到重连成功。  </p>\n<p>为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。</p>\n<h2 id=\"3-3-客户端重复握手保护\"><a href=\"#3-3-客户端重复握手保护\" class=\"headerlink\" title=\"3.3 客户端重复握手保护\"></a>3.3 客户端重复握手保护</h2><p>当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复握手，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。  </p>\n<p>服务端接收到客户端的握手请求消息之后，首先对IP 地址进行合法性检验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果已经登录，则拒绝登录，返回错误码 -1，同时关闭 TCP 链路，并在服务端的日志中打印握手失败的原因。  </p>\n<p>客户端接收到握手失败的应答消息之后，关闭客户端的 TCP连接，等待 INTERVAL 时间之后，再次发起 TCP连接，直到认证成功。</p>\n<h2 id=\"3-4-消息缓存重发\"><a href=\"#3-4-消息缓存重发\" class=\"headerlink\" title=\"3.4 消息缓存重发\"></a>3.4 消息缓存重发</h2><p>无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。  </p>\n<p>考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续向该队列添加新的消息。</p>\n<h2 id=\"3-5-心跳机制\"><a href=\"#3-5-心跳机制\" class=\"headerlink\" title=\"3.5 心跳机制\"></a>3.5 心跳机制</h2><p>在凌晨等业务低谷期时段，如果发生网络闪断、连接被 Hang 住等网络问题时，由于没有业务消息，应用金城很难发现。到了白天业务高峰期时，会发生大量的网络通信失败。为了解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络网络故障，立即关闭链路，主动重连。</p>\n<h1 id=\"4-最佳实现–协议的前后兼容性\"><a href=\"#4-最佳实现–协议的前后兼容性\" class=\"headerlink\" title=\"4 最佳实现–协议的前后兼容性\"></a>4 最佳实现–协议的前后兼容性</h1><p>考虑到协议的前向兼容性，核心的设计原则有2 个：  </p>\n<ol>\n<li>消息头第一个字段中携带协议的版本号，用于标识消息协议版本。</li>\n<li>消息头最后一个字段是 Map 类型的扩展字段，用于服务框架自身或者用户扩展消息头。</li>\n</ol>\n<h1 id=\"5-个人总结\"><a href=\"#5-个人总结\" class=\"headerlink\" title=\"5 个人总结\"></a>5 个人总结</h1><p>协议栈描述了分布式服务框架的通信契约，序列化和反序列化框架用于协议消息对象和二进制数组之间的相互转换，通信框架在技术上承载协议，协议依赖通信。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-关键技术点分析\"><a href=\"#1-关键技术点分析\" class=\"headerlink\" title=\"1 关键技术点分析\"></a>1 关键技术点分析</h1><h1 id=\"1-1-是否必须支持多协议\"><a href=\"#1-1-是否必须支持多协议\" class=\"headerlink\" title=\"1.1 是否必须支持多协议\"></a>1.1 是否必须支持多协议</h1><p>分布式服务框架需要具备通过扩展的方式支持多协议的能力，协议栈应该作为一个架构扩展点开放出来。</p>\n<h1 id=\"1-2-公有协议还是私有协议\"><a href=\"#1-2-公有协议还是私有协议\" class=\"headerlink\" title=\"1.2 公有协议还是私有协议\"></a>1.2 公有协议还是私有协议</h1><p>以 Web Service 公有协议为例，它的性能存在如下缺陷：  </p>\n<ol>\n<li>SOAP 消息使用 XML 进行序列化，相比于 PB 等二进制序列化框架，性能低很多。</li>\n<li>SOAP 通常由 HTTP 协议承载，HTTP 1.0 不支持双向全工通信，而且一般使用短连接通信，性能比较差。</li>\n</ol>\n<p>如果没有特殊需求，分布式服务框架默认使用性能更高、扩展性更好的私有协议（二进制）进行通信。对 HTTP/Restful 等公有协议进行扩展</p>\n<h1 id=\"1-3-集成开元还是自研\"><a href=\"#1-3-集成开元还是自研\" class=\"headerlink\" title=\"1.3 集成开元还是自研\"></a>1.3 集成开元还是自研</h1><ol>\n<li>如果已经有可以满足需求的框架，优先选择继承开源框架。</li>\n<li>如果使用到的功能不多，或者对性能要求极高，可以考虑基于 Netty 自研。</li>\n</ol>\n<h1 id=\"2-功能设计\"><a href=\"#2-功能设计\" class=\"headerlink\" title=\"2 功能设计\"></a>2 功能设计</h1><h2 id=\"2-1-功能描述\"><a href=\"#2-1-功能描述\" class=\"headerlink\" title=\"2.1 功能描述\"></a>2.1 功能描述</h2><p>私有协议栈承载了业务内部各模块之间的消息交互和服务调用，主要功能如下：  </p>\n<ol>\n<li>定义了私有协议的通信模型和消息定义。</li>\n<li>支持服务提供者和消费者之间采用点对点长连接通信</li>\n<li>基于 Java NIO 通信框架，提供高性能的异步通信能力。</li>\n<li>提供可扩展的编解码框架，支持多种序列化格式。</li>\n<li>握手和安全认证机制。</li>\n<li>链路的高可靠性。</li>\n</ol>\n<h2 id=\"2-2-通信模型\"><a href=\"#2-2-通信模型\" class=\"headerlink\" title=\"2.2 通信模型\"></a>2.2 通信模型</h2><p>私有协议栈通信模型如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/5_1.png\" alt=\"\">  </p>\n<ol>\n<li>客户端发送握手请求消息，携带节点ID 等有效神风认证信息。</li>\n<li>服务端对握手请求消息进行合法性校验，包括节点ID 有效性校验、节点重复登录校验和IP 地址合法性校验，校验通过后，返回登录成功的握手应答消息。</li>\n<li>链路建立成功之后，客户端发送业务消息。</li>\n<li>链路成功之后，服务端发送心跳消息。</li>\n<li>链路建立成功之后，客户端发送心跳消息。</li>\n<li>链路建立成功之后，服务端发送业务消息。</li>\n<li>服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。</li>\n</ol>\n<h2 id=\"2-3-协议消息定义\"><a href=\"#2-3-协议消息定义\" class=\"headerlink\" title=\"2.3 协议消息定义\"></a>2.3 协议消息定义</h2><p>通信协议栈的消息模型分为两部分，消息头和消息体。消息头存放协议公共字段和用户扩展字段，消息体则用于承载消息内容。以 HTTP 协议为例，请求消息头允许客户端向服务端传递请求的附加信息以及客户端自身的信息，常见的消息头关键字有 Accept、Authorization、Host 等。</p>\n<h2 id=\"2-4-协议消息的序列化和反序列化\"><a href=\"#2-4-协议消息的序列化和反序列化\" class=\"headerlink\" title=\"2.4 协议消息的序列化和反序列化\"></a>2.4 协议消息的序列化和反序列化</h2><p>消息的序列化分为两部分，消息头的序列化和消息体的序列化，两者采用的机制不一样。原因是协议栈可以由不同的序列化框架承载，标识序列化格式的字段在消息头中定义，因此我们必须首先对消息头做通用解码，获取序列化格式，然后根据类型再调用对应的解码器对消息体做解码。消息头是通用编解码。</p>\n<h2 id=\"2-5-链路创建\"><a href=\"#2-5-链路创建\" class=\"headerlink\" title=\"2.5 链路创建\"></a>2.5 链路创建</h2><p>协议栈包括服务端和客户端，对于上层应用来说，一个节点可能既是服务端也是客户端。<br>考虑到安全，链路简历需要通过基于 IP 地址或者号段的黑白名单安全认证机制，以及通过秘钥等。</p>\n<h2 id=\"2-6-链路关闭\"><a href=\"#2-6-链路关闭\" class=\"headerlink\" title=\"2.6 链路关闭\"></a>2.6 链路关闭</h2><p>由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。以下情况，客户端和服务端需要关闭连接：  </p>\n<ol>\n<li>当对方宕机或重启时，会主动关闭链路。</li>\n<li>消息读写过程中，发生了 I/O 异常，需要主动关闭连接。</li>\n<li>心跳消息读写过程中发生了 I/O 异常，需要主动关闭连接。</li>\n<li>心跳超时，需要主动关闭连接。</li>\n<li>发生编码异常或其它不可恢复错误时，需要主动关闭连接。</li>\n</ol>\n<h1 id=\"3-可靠性分析\"><a href=\"#3-可靠性分析\" class=\"headerlink\" title=\"3 可靠性分析\"></a>3 可靠性分析</h1><h2 id=\"3-1-客户端连接超时\"><a href=\"#3-1-客户端连接超时\" class=\"headerlink\" title=\"3.1 客户端连接超时\"></a>3.1 客户端连接超时</h2><p>客户端业务需要、以及资源的长时间占有等，需要设置超时时间。</p>\n<h2 id=\"3-2-客户端重连机制\"><a href=\"#3-2-客户端重连机制\" class=\"headerlink\" title=\"3.2 客户端重连机制\"></a>3.2 客户端重连机制</h2><p>客户端通过链路关闭监听器监听链路状态，如果链路中断，等待 INTERVAL 时间后，由客户端发起重连操作，如果重连失败，间隔周期 INTERVAL 后再次发起重连，直到重连成功。  </p>\n<p>为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。</p>\n<h2 id=\"3-3-客户端重复握手保护\"><a href=\"#3-3-客户端重复握手保护\" class=\"headerlink\" title=\"3.3 客户端重复握手保护\"></a>3.3 客户端重复握手保护</h2><p>当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复握手，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。  </p>\n<p>服务端接收到客户端的握手请求消息之后，首先对IP 地址进行合法性检验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果已经登录，则拒绝登录，返回错误码 -1，同时关闭 TCP 链路，并在服务端的日志中打印握手失败的原因。  </p>\n<p>客户端接收到握手失败的应答消息之后，关闭客户端的 TCP连接，等待 INTERVAL 时间之后，再次发起 TCP连接，直到认证成功。</p>\n<h2 id=\"3-4-消息缓存重发\"><a href=\"#3-4-消息缓存重发\" class=\"headerlink\" title=\"3.4 消息缓存重发\"></a>3.4 消息缓存重发</h2><p>无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。  </p>\n<p>考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续向该队列添加新的消息。</p>\n<h2 id=\"3-5-心跳机制\"><a href=\"#3-5-心跳机制\" class=\"headerlink\" title=\"3.5 心跳机制\"></a>3.5 心跳机制</h2><p>在凌晨等业务低谷期时段，如果发生网络闪断、连接被 Hang 住等网络问题时，由于没有业务消息，应用金城很难发现。到了白天业务高峰期时，会发生大量的网络通信失败。为了解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络网络故障，立即关闭链路，主动重连。</p>\n<h1 id=\"4-最佳实现–协议的前后兼容性\"><a href=\"#4-最佳实现–协议的前后兼容性\" class=\"headerlink\" title=\"4 最佳实现–协议的前后兼容性\"></a>4 最佳实现–协议的前后兼容性</h1><p>考虑到协议的前向兼容性，核心的设计原则有2 个：  </p>\n<ol>\n<li>消息头第一个字段中携带协议的版本号，用于标识消息协议版本。</li>\n<li>消息头最后一个字段是 Map 类型的扩展字段，用于服务框架自身或者用户扩展消息头。</li>\n</ol>\n<h1 id=\"5-个人总结\"><a href=\"#5-个人总结\" class=\"headerlink\" title=\"5 个人总结\"></a>5 个人总结</h1><p>协议栈描述了分布式服务框架的通信契约，序列化和反序列化框架用于协议消息对象和二进制数组之间的相互转换，通信框架在技术上承载协议，协议依赖通信。</p>\n"},{"title":"六、服务路由","date":"2018-05-29T14:58:00.000Z","updated":"2018-05-30T15:14:06.000Z","comments":1,"_content":"\n分布式服务框架上线运行时都是集群组网，这意味着急群众存在某个服务的多实例部署，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。\n\n# 1 透明化路由\n\n## 1.1 基于服务注册中心的订阅发布\n\n在分布式服务框架中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不需要像之前那样在代码中硬编码服务提供者地址信息。消费者只需要知道当前系统发布了哪些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。它的工作原理就是基于服务注册中心（例如 ZooKeeper）的订阅发布机制。  \n服务注册中心的工作原理如下：  \n![][1]  \n  \n由于消费者可能由于服务提供者启动，或者系统运行过程中新增服务提供者，或者某个服务提供者宕机退出，就会导致注册中心发生服务提供者地址变更。注册中心检测到服务提供者列表变更之后，将变更内容主动推送到服务消费者，消费者根据变更列表，动态刷新本地缓存的服务提供者地址。\n\n## 1.2 消费者缓存服务提供者地址\n\n采用客户端缓存服务提供者地址的方案不仅仅能提升服务调用性能，还能保证系统的可靠性。当注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存的地址信息进行通信，只是影响新服务的注册和老服务的下线，不影响已经发布和运行的服务。\n\n# 2 负载均衡\n\n## 2.1 随机\n\n缺点：  \n1. 在一个截面上碰撞的概率较高。\n2. 非对等集群组网，或者硬件配置差异较大，会导致各节点负载均匀。\n\n## 2.2 轮询\n\n轮询，按公约后的权重设置轮询比率，到达边界之后，继续绕接。缺点：  \n1. 存在慢的提供者累计请求问题，例如第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\n# 2.3 服务调用时延\n\n消费者缓存所有服务提供者的服务调用时延，周期性的计算服务调用平均时延，然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积，  \n  \n该策略的特点就是要保证处理能力强的服务提供者接收到更多的消息，通过动态自动权重调整消除服务调用时延的振荡范围，使所有服务提供者服务调用时延接近平均值，实现负载均衡。  \n![][2] ![][3]\n\n# 2.4 一致性哈希\n\n相同参数的请求总是发到同一个服务提供者，当某一台提供者宕机时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。平台提供默认的虚拟节点数，可以通过配置参数进行修改。  \n一致性 Hash 环工作原理如下：  \n![][4]\n\n# 2.5 粘滞连接\n\n粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起服务调用，除非该提供者宕机，再连接另一台。由于服务通常被强烈建议设计成无状态的，因此，粘滞连接在实际项目中很少使用。  \n粘滞连接的实现比较简单，客户端首次跟服务端创建链路时，将该链路标记为粘滞连接，每次路由时直接选择粘滞连接，不执行负载均衡路由接口，当链路中断时，更新粘滞连接为不可用，重新寻找下一个可用的连接，将其标记为粘滞连接。\n\n# 3 本地路由优先策略\n\n## 3.1 injvm 模式\n\n在一些业务场景中，本地 JVM 内部也发布了需要消费的服务。该场景下，从性能、可靠性等角度考虑，需要优先调用本 JVM内部的服务提供者，这种本地优先的路由模式被称为 injvm模式。\n\n## 3.2 innative 模式\n\n如果物理机或者 VM配置较好，多个应用金城往往会选择合设。服务消费者和服务提供者可能会被部署到同一台机器上（VM）。服务路由时优先选择本机的服务提供者，如果找不到再重新发起远程服务调用，该模式被称为 innative模式。\n1. 首先看本进程 JVM内部是否有符合要求的服务提供者。\n2. JVM 内部没有，选择服务提供者 IP地址与本机 IP地址相同的本地合设的服务提供者进程，通过本地网卡回环调用服务提供则。\n3. 如果 VM内部没有，则发起远程调用。\n\n# 4 路由规则\n\n## 4.1 条件路由规则\n\n应用场景如下：\n1. 通过 IP条件表达式进行黑白名单访问控制，例如 comsumerIP != 192.168.1.1\n2. 流量引导，只暴露部分服务提供者，防止整个集群服务都被冲垮，导致其它服务也不可用，例如 providerIP = 192.168.3*\n3. 读写分离：method=find*,list*,get*,query*=>providerIP=192.168.1.*\n4. 前后台分离：app=web*=>providerIP=192.168.1.*,app=java*=>providerIP=192.168.2.*\n5. 灰度升级，将 Web前台应用路由到新的服务版本上：app=web*=>providerIP=192.168.1.*\n\n## 4.2 脚本路由规则\n\n使用脚本来实现路由规则，在于动态编译，修改实时生效，常见的脚本语言有 JavaScript、Groovy、MVEL 等。\n\n# 5 路由策略定制\n\n除了提供默认的路由策略之外，在架构上还需要支持业务扩展路由算法，实现业务自定义路由。  \n1. 灰度升级，用户需要按照业务规则进行灰度路由：例如按照用户省份路由、按照请求来源中断类型（IOS、Android）、按照手机号段等；不同的用户按照规则路由到不同的集群环境中，例如没有同步升级的用户路由到升级前的环境，同步配套升级的消费者请求路由到灰度升级后的新版本中。\n2. 服务故障、业务高峰期的导流：通过自定义路由，将异常的峰值流量导流到几台或者1 台服务器上，防止整个集群负载过重导致整个生产系统雪崩。\n\n路由扩展策略如下：  \n1. 提供接口。\n2. 提供配置 XML Schema定义。\n3. 通过 Spring Bean 方式的服务发布、通过 JDK 的 SPI 方式扩展，即 META-INF/services。\n\n# 6 配置化路由\n\n1. 本地配置：包括服务提供者和服务消费者、默认全局配置三种。\n2. 统一注册管理：无论是服务提供者还是消费者，本地配置的路由策略统一注册到服务注册中心，进行集中化配置管理。\n3. 动态下发：运维人员通过服务治理 Portal修改路由规则，更新后的路由规则被持久化到服务注册中心。\n  \n路由配置优先级：客户端配置>服务端配置>全局配置。\n\n# 7 最佳实践————多机房路由\n\n为了能够相互发现对方的服务，不同机房会共用同一个服务注册中心集群（异地容灾机房除外）。假如机房1 发布了服务A，机房2 同样也发布了服务A，此时服务注册中心就会将2 个不同机房的服务A 地址信息推送给消费者，无论是机房1 还是机房2 的消费者，都将看到两个不同机房的服务。  \n  \n如果仅仅依靠随机、轮询等负载均衡策略，消息将会被路由到两个机房，达不到不跨机房调用的目标。此时可以使用配置条件路由策略，通过网段条件匹配来实现地址过滤。  \n也可以使用虚拟分组策略，将整个集群系统的服务提供者（跨机房）逻辑分成若干个组，某个消费者只访问一个虚拟分组的服务提供者，防止跨组服务调用。\n\n# 8 个人总结\n\n服务路由需要既具备丰富的路由策略，还要具备扩展能力，是非常重要的分布式下的基础功能。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_4.png","source":"_posts/分布式服务框架原理与实践/第六章 服务路由.md","raw":"---\ntitle: 六、服务路由\ndate: 2018-05-29 22:58:00\nupdated: 2018-05-30 23:14:06\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/6.html    \n---\n\n分布式服务框架上线运行时都是集群组网，这意味着急群众存在某个服务的多实例部署，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。\n\n# 1 透明化路由\n\n## 1.1 基于服务注册中心的订阅发布\n\n在分布式服务框架中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不需要像之前那样在代码中硬编码服务提供者地址信息。消费者只需要知道当前系统发布了哪些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。它的工作原理就是基于服务注册中心（例如 ZooKeeper）的订阅发布机制。  \n服务注册中心的工作原理如下：  \n![][1]  \n  \n由于消费者可能由于服务提供者启动，或者系统运行过程中新增服务提供者，或者某个服务提供者宕机退出，就会导致注册中心发生服务提供者地址变更。注册中心检测到服务提供者列表变更之后，将变更内容主动推送到服务消费者，消费者根据变更列表，动态刷新本地缓存的服务提供者地址。\n\n## 1.2 消费者缓存服务提供者地址\n\n采用客户端缓存服务提供者地址的方案不仅仅能提升服务调用性能，还能保证系统的可靠性。当注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存的地址信息进行通信，只是影响新服务的注册和老服务的下线，不影响已经发布和运行的服务。\n\n# 2 负载均衡\n\n## 2.1 随机\n\n缺点：  \n1. 在一个截面上碰撞的概率较高。\n2. 非对等集群组网，或者硬件配置差异较大，会导致各节点负载均匀。\n\n## 2.2 轮询\n\n轮询，按公约后的权重设置轮询比率，到达边界之后，继续绕接。缺点：  \n1. 存在慢的提供者累计请求问题，例如第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\n# 2.3 服务调用时延\n\n消费者缓存所有服务提供者的服务调用时延，周期性的计算服务调用平均时延，然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积，  \n  \n该策略的特点就是要保证处理能力强的服务提供者接收到更多的消息，通过动态自动权重调整消除服务调用时延的振荡范围，使所有服务提供者服务调用时延接近平均值，实现负载均衡。  \n![][2] ![][3]\n\n# 2.4 一致性哈希\n\n相同参数的请求总是发到同一个服务提供者，当某一台提供者宕机时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。平台提供默认的虚拟节点数，可以通过配置参数进行修改。  \n一致性 Hash 环工作原理如下：  \n![][4]\n\n# 2.5 粘滞连接\n\n粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起服务调用，除非该提供者宕机，再连接另一台。由于服务通常被强烈建议设计成无状态的，因此，粘滞连接在实际项目中很少使用。  \n粘滞连接的实现比较简单，客户端首次跟服务端创建链路时，将该链路标记为粘滞连接，每次路由时直接选择粘滞连接，不执行负载均衡路由接口，当链路中断时，更新粘滞连接为不可用，重新寻找下一个可用的连接，将其标记为粘滞连接。\n\n# 3 本地路由优先策略\n\n## 3.1 injvm 模式\n\n在一些业务场景中，本地 JVM 内部也发布了需要消费的服务。该场景下，从性能、可靠性等角度考虑，需要优先调用本 JVM内部的服务提供者，这种本地优先的路由模式被称为 injvm模式。\n\n## 3.2 innative 模式\n\n如果物理机或者 VM配置较好，多个应用金城往往会选择合设。服务消费者和服务提供者可能会被部署到同一台机器上（VM）。服务路由时优先选择本机的服务提供者，如果找不到再重新发起远程服务调用，该模式被称为 innative模式。\n1. 首先看本进程 JVM内部是否有符合要求的服务提供者。\n2. JVM 内部没有，选择服务提供者 IP地址与本机 IP地址相同的本地合设的服务提供者进程，通过本地网卡回环调用服务提供则。\n3. 如果 VM内部没有，则发起远程调用。\n\n# 4 路由规则\n\n## 4.1 条件路由规则\n\n应用场景如下：\n1. 通过 IP条件表达式进行黑白名单访问控制，例如 comsumerIP != 192.168.1.1\n2. 流量引导，只暴露部分服务提供者，防止整个集群服务都被冲垮，导致其它服务也不可用，例如 providerIP = 192.168.3*\n3. 读写分离：method=find*,list*,get*,query*=>providerIP=192.168.1.*\n4. 前后台分离：app=web*=>providerIP=192.168.1.*,app=java*=>providerIP=192.168.2.*\n5. 灰度升级，将 Web前台应用路由到新的服务版本上：app=web*=>providerIP=192.168.1.*\n\n## 4.2 脚本路由规则\n\n使用脚本来实现路由规则，在于动态编译，修改实时生效，常见的脚本语言有 JavaScript、Groovy、MVEL 等。\n\n# 5 路由策略定制\n\n除了提供默认的路由策略之外，在架构上还需要支持业务扩展路由算法，实现业务自定义路由。  \n1. 灰度升级，用户需要按照业务规则进行灰度路由：例如按照用户省份路由、按照请求来源中断类型（IOS、Android）、按照手机号段等；不同的用户按照规则路由到不同的集群环境中，例如没有同步升级的用户路由到升级前的环境，同步配套升级的消费者请求路由到灰度升级后的新版本中。\n2. 服务故障、业务高峰期的导流：通过自定义路由，将异常的峰值流量导流到几台或者1 台服务器上，防止整个集群负载过重导致整个生产系统雪崩。\n\n路由扩展策略如下：  \n1. 提供接口。\n2. 提供配置 XML Schema定义。\n3. 通过 Spring Bean 方式的服务发布、通过 JDK 的 SPI 方式扩展，即 META-INF/services。\n\n# 6 配置化路由\n\n1. 本地配置：包括服务提供者和服务消费者、默认全局配置三种。\n2. 统一注册管理：无论是服务提供者还是消费者，本地配置的路由策略统一注册到服务注册中心，进行集中化配置管理。\n3. 动态下发：运维人员通过服务治理 Portal修改路由规则，更新后的路由规则被持久化到服务注册中心。\n  \n路由配置优先级：客户端配置>服务端配置>全局配置。\n\n# 7 最佳实践————多机房路由\n\n为了能够相互发现对方的服务，不同机房会共用同一个服务注册中心集群（异地容灾机房除外）。假如机房1 发布了服务A，机房2 同样也发布了服务A，此时服务注册中心就会将2 个不同机房的服务A 地址信息推送给消费者，无论是机房1 还是机房2 的消费者，都将看到两个不同机房的服务。  \n  \n如果仅仅依靠随机、轮询等负载均衡策略，消息将会被路由到两个机房，达不到不跨机房调用的目标。此时可以使用配置条件路由策略，通过网段条件匹配来实现地址过滤。  \n也可以使用虚拟分组策略，将整个集群系统的服务提供者（跨机房）逻辑分成若干个组，某个消费者只访问一个虚拟分组的服务提供者，防止跨组服务调用。\n\n# 8 个人总结\n\n服务路由需要既具备丰富的路由策略，还要具备扩展能力，是非常重要的分布式下的基础功能。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_4.png","slug":"distributed_principle_prictice/6.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavc001gaxs69g9zbdpo","content":"<p>分布式服务框架上线运行时都是集群组网，这意味着急群众存在某个服务的多实例部署，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。</p>\n<h1 id=\"1-透明化路由\"><a href=\"#1-透明化路由\" class=\"headerlink\" title=\"1 透明化路由\"></a>1 透明化路由</h1><h2 id=\"1-1-基于服务注册中心的订阅发布\"><a href=\"#1-1-基于服务注册中心的订阅发布\" class=\"headerlink\" title=\"1.1 基于服务注册中心的订阅发布\"></a>1.1 基于服务注册中心的订阅发布</h2><p>在分布式服务框架中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不需要像之前那样在代码中硬编码服务提供者地址信息。消费者只需要知道当前系统发布了哪些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。它的工作原理就是基于服务注册中心（例如 ZooKeeper）的订阅发布机制。<br>服务注册中心的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_1.png\" alt=\"\">  </p>\n<p>由于消费者可能由于服务提供者启动，或者系统运行过程中新增服务提供者，或者某个服务提供者宕机退出，就会导致注册中心发生服务提供者地址变更。注册中心检测到服务提供者列表变更之后，将变更内容主动推送到服务消费者，消费者根据变更列表，动态刷新本地缓存的服务提供者地址。</p>\n<h2 id=\"1-2-消费者缓存服务提供者地址\"><a href=\"#1-2-消费者缓存服务提供者地址\" class=\"headerlink\" title=\"1.2 消费者缓存服务提供者地址\"></a>1.2 消费者缓存服务提供者地址</h2><p>采用客户端缓存服务提供者地址的方案不仅仅能提升服务调用性能，还能保证系统的可靠性。当注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存的地址信息进行通信，只是影响新服务的注册和老服务的下线，不影响已经发布和运行的服务。</p>\n<h1 id=\"2-负载均衡\"><a href=\"#2-负载均衡\" class=\"headerlink\" title=\"2 负载均衡\"></a>2 负载均衡</h1><h2 id=\"2-1-随机\"><a href=\"#2-1-随机\" class=\"headerlink\" title=\"2.1 随机\"></a>2.1 随机</h2><p>缺点：  </p>\n<ol>\n<li>在一个截面上碰撞的概率较高。</li>\n<li>非对等集群组网，或者硬件配置差异较大，会导致各节点负载均匀。</li>\n</ol>\n<h2 id=\"2-2-轮询\"><a href=\"#2-2-轮询\" class=\"headerlink\" title=\"2.2 轮询\"></a>2.2 轮询</h2><p>轮询，按公约后的权重设置轮询比率，到达边界之后，继续绕接。缺点：  </p>\n<ol>\n<li>存在慢的提供者累计请求问题，例如第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>\n</ol>\n<h1 id=\"2-3-服务调用时延\"><a href=\"#2-3-服务调用时延\" class=\"headerlink\" title=\"2.3 服务调用时延\"></a>2.3 服务调用时延</h1><p>消费者缓存所有服务提供者的服务调用时延，周期性的计算服务调用平均时延，然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积，  </p>\n<p>该策略的特点就是要保证处理能力强的服务提供者接收到更多的消息，通过动态自动权重调整消除服务调用时延的振荡范围，使所有服务提供者服务调用时延接近平均值，实现负载均衡。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_2.png\" alt=\"\"> <img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_3.png\" alt=\"\"></p>\n<h1 id=\"2-4-一致性哈希\"><a href=\"#2-4-一致性哈希\" class=\"headerlink\" title=\"2.4 一致性哈希\"></a>2.4 一致性哈希</h1><p>相同参数的请求总是发到同一个服务提供者，当某一台提供者宕机时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。平台提供默认的虚拟节点数，可以通过配置参数进行修改。<br>一致性 Hash 环工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_4.png\" alt=\"\"></p>\n<h1 id=\"2-5-粘滞连接\"><a href=\"#2-5-粘滞连接\" class=\"headerlink\" title=\"2.5 粘滞连接\"></a>2.5 粘滞连接</h1><p>粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起服务调用，除非该提供者宕机，再连接另一台。由于服务通常被强烈建议设计成无状态的，因此，粘滞连接在实际项目中很少使用。<br>粘滞连接的实现比较简单，客户端首次跟服务端创建链路时，将该链路标记为粘滞连接，每次路由时直接选择粘滞连接，不执行负载均衡路由接口，当链路中断时，更新粘滞连接为不可用，重新寻找下一个可用的连接，将其标记为粘滞连接。</p>\n<h1 id=\"3-本地路由优先策略\"><a href=\"#3-本地路由优先策略\" class=\"headerlink\" title=\"3 本地路由优先策略\"></a>3 本地路由优先策略</h1><h2 id=\"3-1-injvm-模式\"><a href=\"#3-1-injvm-模式\" class=\"headerlink\" title=\"3.1 injvm 模式\"></a>3.1 injvm 模式</h2><p>在一些业务场景中，本地 JVM 内部也发布了需要消费的服务。该场景下，从性能、可靠性等角度考虑，需要优先调用本 JVM内部的服务提供者，这种本地优先的路由模式被称为 injvm模式。</p>\n<h2 id=\"3-2-innative-模式\"><a href=\"#3-2-innative-模式\" class=\"headerlink\" title=\"3.2 innative 模式\"></a>3.2 innative 模式</h2><p>如果物理机或者 VM配置较好，多个应用金城往往会选择合设。服务消费者和服务提供者可能会被部署到同一台机器上（VM）。服务路由时优先选择本机的服务提供者，如果找不到再重新发起远程服务调用，该模式被称为 innative模式。</p>\n<ol>\n<li>首先看本进程 JVM内部是否有符合要求的服务提供者。</li>\n<li>JVM 内部没有，选择服务提供者 IP地址与本机 IP地址相同的本地合设的服务提供者进程，通过本地网卡回环调用服务提供则。</li>\n<li>如果 VM内部没有，则发起远程调用。</li>\n</ol>\n<h1 id=\"4-路由规则\"><a href=\"#4-路由规则\" class=\"headerlink\" title=\"4 路由规则\"></a>4 路由规则</h1><h2 id=\"4-1-条件路由规则\"><a href=\"#4-1-条件路由规则\" class=\"headerlink\" title=\"4.1 条件路由规则\"></a>4.1 条件路由规则</h2><p>应用场景如下：</p>\n<ol>\n<li>通过 IP条件表达式进行黑白名单访问控制，例如 comsumerIP != 192.168.1.1</li>\n<li>流量引导，只暴露部分服务提供者，防止整个集群服务都被冲垮，导致其它服务也不可用，例如 providerIP = 192.168.3*</li>\n<li>读写分离：method=find<em>,list</em>,get<em>,query</em>=&gt;providerIP=192.168.1.*</li>\n<li>前后台分离：app=web<em>=&gt;providerIP=192.168.1.</em>,app=java<em>=&gt;providerIP=192.168.2.</em></li>\n<li>灰度升级，将 Web前台应用路由到新的服务版本上：app=web<em>=&gt;providerIP=192.168.1.</em></li>\n</ol>\n<h2 id=\"4-2-脚本路由规则\"><a href=\"#4-2-脚本路由规则\" class=\"headerlink\" title=\"4.2 脚本路由规则\"></a>4.2 脚本路由规则</h2><p>使用脚本来实现路由规则，在于动态编译，修改实时生效，常见的脚本语言有 JavaScript、Groovy、MVEL 等。</p>\n<h1 id=\"5-路由策略定制\"><a href=\"#5-路由策略定制\" class=\"headerlink\" title=\"5 路由策略定制\"></a>5 路由策略定制</h1><p>除了提供默认的路由策略之外，在架构上还需要支持业务扩展路由算法，实现业务自定义路由。  </p>\n<ol>\n<li>灰度升级，用户需要按照业务规则进行灰度路由：例如按照用户省份路由、按照请求来源中断类型（IOS、Android）、按照手机号段等；不同的用户按照规则路由到不同的集群环境中，例如没有同步升级的用户路由到升级前的环境，同步配套升级的消费者请求路由到灰度升级后的新版本中。</li>\n<li>服务故障、业务高峰期的导流：通过自定义路由，将异常的峰值流量导流到几台或者1 台服务器上，防止整个集群负载过重导致整个生产系统雪崩。</li>\n</ol>\n<p>路由扩展策略如下：  </p>\n<ol>\n<li>提供接口。</li>\n<li>提供配置 XML Schema定义。</li>\n<li>通过 Spring Bean 方式的服务发布、通过 JDK 的 SPI 方式扩展，即 META-INF/services。</li>\n</ol>\n<h1 id=\"6-配置化路由\"><a href=\"#6-配置化路由\" class=\"headerlink\" title=\"6 配置化路由\"></a>6 配置化路由</h1><ol>\n<li>本地配置：包括服务提供者和服务消费者、默认全局配置三种。</li>\n<li>统一注册管理：无论是服务提供者还是消费者，本地配置的路由策略统一注册到服务注册中心，进行集中化配置管理。</li>\n<li>动态下发：运维人员通过服务治理 Portal修改路由规则，更新后的路由规则被持久化到服务注册中心。</li>\n</ol>\n<p>路由配置优先级：客户端配置&gt;服务端配置&gt;全局配置。</p>\n<h1 id=\"7-最佳实践————多机房路由\"><a href=\"#7-最佳实践————多机房路由\" class=\"headerlink\" title=\"7 最佳实践————多机房路由\"></a>7 最佳实践————多机房路由</h1><p>为了能够相互发现对方的服务，不同机房会共用同一个服务注册中心集群（异地容灾机房除外）。假如机房1 发布了服务A，机房2 同样也发布了服务A，此时服务注册中心就会将2 个不同机房的服务A 地址信息推送给消费者，无论是机房1 还是机房2 的消费者，都将看到两个不同机房的服务。  </p>\n<p>如果仅仅依靠随机、轮询等负载均衡策略，消息将会被路由到两个机房，达不到不跨机房调用的目标。此时可以使用配置条件路由策略，通过网段条件匹配来实现地址过滤。<br>也可以使用虚拟分组策略，将整个集群系统的服务提供者（跨机房）逻辑分成若干个组，某个消费者只访问一个虚拟分组的服务提供者，防止跨组服务调用。</p>\n<h1 id=\"8-个人总结\"><a href=\"#8-个人总结\" class=\"headerlink\" title=\"8 个人总结\"></a>8 个人总结</h1><p>服务路由需要既具备丰富的路由策略，还要具备扩展能力，是非常重要的分布式下的基础功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>分布式服务框架上线运行时都是集群组网，这意味着急群众存在某个服务的多实例部署，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。</p>\n<h1 id=\"1-透明化路由\"><a href=\"#1-透明化路由\" class=\"headerlink\" title=\"1 透明化路由\"></a>1 透明化路由</h1><h2 id=\"1-1-基于服务注册中心的订阅发布\"><a href=\"#1-1-基于服务注册中心的订阅发布\" class=\"headerlink\" title=\"1.1 基于服务注册中心的订阅发布\"></a>1.1 基于服务注册中心的订阅发布</h2><p>在分布式服务框架中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不需要像之前那样在代码中硬编码服务提供者地址信息。消费者只需要知道当前系统发布了哪些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。它的工作原理就是基于服务注册中心（例如 ZooKeeper）的订阅发布机制。<br>服务注册中心的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_1.png\" alt=\"\">  </p>\n<p>由于消费者可能由于服务提供者启动，或者系统运行过程中新增服务提供者，或者某个服务提供者宕机退出，就会导致注册中心发生服务提供者地址变更。注册中心检测到服务提供者列表变更之后，将变更内容主动推送到服务消费者，消费者根据变更列表，动态刷新本地缓存的服务提供者地址。</p>\n<h2 id=\"1-2-消费者缓存服务提供者地址\"><a href=\"#1-2-消费者缓存服务提供者地址\" class=\"headerlink\" title=\"1.2 消费者缓存服务提供者地址\"></a>1.2 消费者缓存服务提供者地址</h2><p>采用客户端缓存服务提供者地址的方案不仅仅能提升服务调用性能，还能保证系统的可靠性。当注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存的地址信息进行通信，只是影响新服务的注册和老服务的下线，不影响已经发布和运行的服务。</p>\n<h1 id=\"2-负载均衡\"><a href=\"#2-负载均衡\" class=\"headerlink\" title=\"2 负载均衡\"></a>2 负载均衡</h1><h2 id=\"2-1-随机\"><a href=\"#2-1-随机\" class=\"headerlink\" title=\"2.1 随机\"></a>2.1 随机</h2><p>缺点：  </p>\n<ol>\n<li>在一个截面上碰撞的概率较高。</li>\n<li>非对等集群组网，或者硬件配置差异较大，会导致各节点负载均匀。</li>\n</ol>\n<h2 id=\"2-2-轮询\"><a href=\"#2-2-轮询\" class=\"headerlink\" title=\"2.2 轮询\"></a>2.2 轮询</h2><p>轮询，按公约后的权重设置轮询比率，到达边界之后，继续绕接。缺点：  </p>\n<ol>\n<li>存在慢的提供者累计请求问题，例如第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>\n</ol>\n<h1 id=\"2-3-服务调用时延\"><a href=\"#2-3-服务调用时延\" class=\"headerlink\" title=\"2.3 服务调用时延\"></a>2.3 服务调用时延</h1><p>消费者缓存所有服务提供者的服务调用时延，周期性的计算服务调用平均时延，然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积，  </p>\n<p>该策略的特点就是要保证处理能力强的服务提供者接收到更多的消息，通过动态自动权重调整消除服务调用时延的振荡范围，使所有服务提供者服务调用时延接近平均值，实现负载均衡。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_2.png\" alt=\"\"> <img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_3.png\" alt=\"\"></p>\n<h1 id=\"2-4-一致性哈希\"><a href=\"#2-4-一致性哈希\" class=\"headerlink\" title=\"2.4 一致性哈希\"></a>2.4 一致性哈希</h1><p>相同参数的请求总是发到同一个服务提供者，当某一台提供者宕机时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。平台提供默认的虚拟节点数，可以通过配置参数进行修改。<br>一致性 Hash 环工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_4.png\" alt=\"\"></p>\n<h1 id=\"2-5-粘滞连接\"><a href=\"#2-5-粘滞连接\" class=\"headerlink\" title=\"2.5 粘滞连接\"></a>2.5 粘滞连接</h1><p>粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起服务调用，除非该提供者宕机，再连接另一台。由于服务通常被强烈建议设计成无状态的，因此，粘滞连接在实际项目中很少使用。<br>粘滞连接的实现比较简单，客户端首次跟服务端创建链路时，将该链路标记为粘滞连接，每次路由时直接选择粘滞连接，不执行负载均衡路由接口，当链路中断时，更新粘滞连接为不可用，重新寻找下一个可用的连接，将其标记为粘滞连接。</p>\n<h1 id=\"3-本地路由优先策略\"><a href=\"#3-本地路由优先策略\" class=\"headerlink\" title=\"3 本地路由优先策略\"></a>3 本地路由优先策略</h1><h2 id=\"3-1-injvm-模式\"><a href=\"#3-1-injvm-模式\" class=\"headerlink\" title=\"3.1 injvm 模式\"></a>3.1 injvm 模式</h2><p>在一些业务场景中，本地 JVM 内部也发布了需要消费的服务。该场景下，从性能、可靠性等角度考虑，需要优先调用本 JVM内部的服务提供者，这种本地优先的路由模式被称为 injvm模式。</p>\n<h2 id=\"3-2-innative-模式\"><a href=\"#3-2-innative-模式\" class=\"headerlink\" title=\"3.2 innative 模式\"></a>3.2 innative 模式</h2><p>如果物理机或者 VM配置较好，多个应用金城往往会选择合设。服务消费者和服务提供者可能会被部署到同一台机器上（VM）。服务路由时优先选择本机的服务提供者，如果找不到再重新发起远程服务调用，该模式被称为 innative模式。</p>\n<ol>\n<li>首先看本进程 JVM内部是否有符合要求的服务提供者。</li>\n<li>JVM 内部没有，选择服务提供者 IP地址与本机 IP地址相同的本地合设的服务提供者进程，通过本地网卡回环调用服务提供则。</li>\n<li>如果 VM内部没有，则发起远程调用。</li>\n</ol>\n<h1 id=\"4-路由规则\"><a href=\"#4-路由规则\" class=\"headerlink\" title=\"4 路由规则\"></a>4 路由规则</h1><h2 id=\"4-1-条件路由规则\"><a href=\"#4-1-条件路由规则\" class=\"headerlink\" title=\"4.1 条件路由规则\"></a>4.1 条件路由规则</h2><p>应用场景如下：</p>\n<ol>\n<li>通过 IP条件表达式进行黑白名单访问控制，例如 comsumerIP != 192.168.1.1</li>\n<li>流量引导，只暴露部分服务提供者，防止整个集群服务都被冲垮，导致其它服务也不可用，例如 providerIP = 192.168.3*</li>\n<li>读写分离：method=find<em>,list</em>,get<em>,query</em>=&gt;providerIP=192.168.1.*</li>\n<li>前后台分离：app=web<em>=&gt;providerIP=192.168.1.</em>,app=java<em>=&gt;providerIP=192.168.2.</em></li>\n<li>灰度升级，将 Web前台应用路由到新的服务版本上：app=web<em>=&gt;providerIP=192.168.1.</em></li>\n</ol>\n<h2 id=\"4-2-脚本路由规则\"><a href=\"#4-2-脚本路由规则\" class=\"headerlink\" title=\"4.2 脚本路由规则\"></a>4.2 脚本路由规则</h2><p>使用脚本来实现路由规则，在于动态编译，修改实时生效，常见的脚本语言有 JavaScript、Groovy、MVEL 等。</p>\n<h1 id=\"5-路由策略定制\"><a href=\"#5-路由策略定制\" class=\"headerlink\" title=\"5 路由策略定制\"></a>5 路由策略定制</h1><p>除了提供默认的路由策略之外，在架构上还需要支持业务扩展路由算法，实现业务自定义路由。  </p>\n<ol>\n<li>灰度升级，用户需要按照业务规则进行灰度路由：例如按照用户省份路由、按照请求来源中断类型（IOS、Android）、按照手机号段等；不同的用户按照规则路由到不同的集群环境中，例如没有同步升级的用户路由到升级前的环境，同步配套升级的消费者请求路由到灰度升级后的新版本中。</li>\n<li>服务故障、业务高峰期的导流：通过自定义路由，将异常的峰值流量导流到几台或者1 台服务器上，防止整个集群负载过重导致整个生产系统雪崩。</li>\n</ol>\n<p>路由扩展策略如下：  </p>\n<ol>\n<li>提供接口。</li>\n<li>提供配置 XML Schema定义。</li>\n<li>通过 Spring Bean 方式的服务发布、通过 JDK 的 SPI 方式扩展，即 META-INF/services。</li>\n</ol>\n<h1 id=\"6-配置化路由\"><a href=\"#6-配置化路由\" class=\"headerlink\" title=\"6 配置化路由\"></a>6 配置化路由</h1><ol>\n<li>本地配置：包括服务提供者和服务消费者、默认全局配置三种。</li>\n<li>统一注册管理：无论是服务提供者还是消费者，本地配置的路由策略统一注册到服务注册中心，进行集中化配置管理。</li>\n<li>动态下发：运维人员通过服务治理 Portal修改路由规则，更新后的路由规则被持久化到服务注册中心。</li>\n</ol>\n<p>路由配置优先级：客户端配置&gt;服务端配置&gt;全局配置。</p>\n<h1 id=\"7-最佳实践————多机房路由\"><a href=\"#7-最佳实践————多机房路由\" class=\"headerlink\" title=\"7 最佳实践————多机房路由\"></a>7 最佳实践————多机房路由</h1><p>为了能够相互发现对方的服务，不同机房会共用同一个服务注册中心集群（异地容灾机房除外）。假如机房1 发布了服务A，机房2 同样也发布了服务A，此时服务注册中心就会将2 个不同机房的服务A 地址信息推送给消费者，无论是机房1 还是机房2 的消费者，都将看到两个不同机房的服务。  </p>\n<p>如果仅仅依靠随机、轮询等负载均衡策略，消息将会被路由到两个机房，达不到不跨机房调用的目标。此时可以使用配置条件路由策略，通过网段条件匹配来实现地址过滤。<br>也可以使用虚拟分组策略，将整个集群系统的服务提供者（跨机房）逻辑分成若干个组，某个消费者只访问一个虚拟分组的服务提供者，防止跨组服务调用。</p>\n<h1 id=\"8-个人总结\"><a href=\"#8-个人总结\" class=\"headerlink\" title=\"8 个人总结\"></a>8 个人总结</h1><p>服务路由需要既具备丰富的路由策略，还要具备扩展能力，是非常重要的分布式下的基础功能。</p>\n"},{"title":"十七、服务治理","date":"2018-06-13T16:45:00.000Z","updated":"2018-06-14T16:38:00.000Z","comments":1,"_content":"\n随着业务发展，服务越来越多，如何协调线上运行的各个服务，保障服务的 SLA，以及小服务资源浪费的问题，需要能够基于服务调用的性能 KPI数据进行容量管理，合理分配各个服务的资源占用。  \n线上业务发生故障，需要对故障业务做服务降级、流量控制，快速恢复业务。  \n为了满足服务线下管控、保障线上高效运行，需要有一个统一的服务治理框架对服务进行统一、有效管控，保障服务的高效、健康运行。\n\n# 1 服务治理技术的历史变迁\n\n1. 第一代服务治理 SOA Governance：以 IBM为首的 SOA解决方案提供商推出的针对企业 IT系统的服务治理框架，它主要聚焦在对企业 IT系统中异构服务的质量管理、服务发布审批流程管理和服务建模、开发、测试以及运行的全生命周期管理。\n2. 第二代以分布式服务框架为中心的服务治理：随着电商和移动互联网的快速发展，以阿里为首的基于同一分布式服务框架的全新服务治理理念诞生，它聚焦于对内部同构服务的线上治理，保障线上服务的运行质量。相对比传统 IT架构的服务治理，由于服务的开发模式、部署规模、组网类型、业务特点等差异巨大，因此服务治理的重点也从线下转移到了线上服务质量保障。\n3. 微服务架构+云端服务治理：2013年至今，随着云计算和微服务架构的发展，以 AWS为首的基于微服务架构+云服务化的云端服务治理体系诞生，它的核心理念是服务微自治，利用云调度的弹性和敏捷，逐渐消除人工治理。  \n  \n微服务架构可以实现服务一定程度的自治，例如服务独立打包、独立部署、独立升级和独立扩容。通过云计算的弹性伸缩、单点故障迁移、服务健康度管理和自动容量规划等措施，结合微服务治理，逐步实现微服务的自治。\n\n## 1.1 SOA Governance\n\nSOA Governance的定位：面向企业 IT系统异构服务的治理和服务生命周期管理，它治理的服务通常是 SOA服务。  \n传统的 SOA Governance包含以下四部分内容：  \n1. 服务建模：验证功能需求与业务需求，发现和评估当前服务，服务建模和性能需求，开发治理规范。\n2. 服务组装：创建服务更新计划，创建和修改服务以满足所有业务需求，根据治理策略评估服务，批准组装完成。\n3. 服务部署：确保服务的质量，措施包括功能测试、性能测试和满足度测试，批准服务部署。\n4. 服务管理：在整个生命周期内管理和监控服务，跟踪服务注册表中的服务，根据 SLA上报服务的性能 KPI数据进行服务质量管理。\n  \nSOA Governance 工作原理如下：  \n![][1]  \n传统 SOA Governance 缺点如下：  \n1. 分布式服务框架的发展，内部服务框架需要统一，服务治理也需要适应新的架构，能够由表及里，对服务进行细粒度的管控。\n2. 微服务架构的发展和业务规模的扩大，导致服务规模量变引起质变，服务治理的特点和难点也随之发生变化。\n3. 缺少服务运行时动态治理能力，面对突发的流量高峰和业务冲击，传统的服务治理在响应速度、故障快速恢复等方面存在不足，无法更敏捷地应对业务需求。\n\n## 1.2 分布式服务框架服务治理\n\n1. 分布式服务矿机的服务治理定位：面向互联网业务的服务治理，聚焦在对内部采用统一服务框架服务化的业务运行态、细粒度的敏捷治理体系。\n2. 治理的对象：基于统一分布式服务框架开发的业务服务，与协议本身无关，治理的可以是 SOA服务，也可以是基于内部服务框架私有协议开发的各种服务。\n3. 治理策略：针对互联网业务的特点，例如突发的流量高峰、网络延时、机房故障等，重点针对大规模跨机房的海量服务进行运行态治理，保障线上服务的高 SLA，满足用户的体验。常用的治理策略包括服务的限流降级、服务迁入迁出、服务动态路由和灰度发布等。\n  \n以分布式服务框架 Dubbo为例，它的服务治理体系如下：  \n![][2]\n\n## 1.3 AWS 云端微服务治理\n\n随着云计算的发展，Dev&Ops 逐渐流行起来，基础设施服务化（IaaS）为大规模、批量流水线式软件交付提供了便利，AWS 作为全球最大的云计算解决方案提供商，在微服务云化开发和治理方面积累了非常多的经验，具体总结如下：  \n1. 全公司统一服务化开发环境，统一简单化服务框架（Coral Service），统一运行平台，快速高效服务开发。\n2. 所有后端应用服务化，系统由多项服务化组件构成。\n3. 服务共享、原子化、重用。\n4. 服务由小研发团队负责服务开发、测试、部署和治理，运维整个生命周期支撑。\n5. 高度自动化和 Dev&Ops 支持，一键式服务部署和回退。\n6. 超大规模支持：后台几十万个服务，成千上万开发者同时使用，平均每秒钟有 1~2 个服务部署。\n7. 尝试基于 Docket 容器部署微服务。\n8. 服务治理是核心：服务性能 KPI统计、告警、服务健康度管理、灵活的弹性伸缩策略、故障自动迁移、服务限流和服务降级等多种治理手段，保障服务高质量运行。\n\n# 2 应用服务化后面临的挑战\n\n## 2.1 跨团队协作问题\n\n1. 服务提供者 S分布式部署，存在多个服务实例，如果做端点调试，路由模块会动态分发消息，随机路由，服务提供者 S无法确定要连接的 IP地址。\n2. 如果打断点，其它消费者也正在进行服务调用，调试会被干扰，需要通知所有的开发者不要调用服务 S，显然不可能。\n\n## 2.2 服务的上下线管控\n\n需要结束某些服务的生命周期，服务提供者直接将服务下线，导致依赖该服务的应用不能正常工作。服务下线时，应先标记为过时，然后通知调用方尽快修改调用，通过性能 KPI接口和调用链分析，确认没有消费者再调用此服务，才能下线。\n\n## 2.3 服务安全\n\n针对内部应用，服务框架通常采用长链接管理客户端连接，针对非信任的第三方应用，或者恶意消费者，需要具备黑白名单访问控制机制，防止客户端非法链路过多，占用大量的句柄、线程和缓存资源，影响服务提供者的运行质量。\n\n## 2.4 服务 SLA 保障\n\n由于非核心服务跟系统其它服务打包部署在同一个 Tomcat等容器进程中，一旦非核心服务需要停止，也影响其它合设的服务，如何高效的关停非核心服务，但又不影响其它合设的服务，需要服务治理框架统一考虑。  \n另外超时时间也要方便的在线可视化的修改，不需要重启即可动态生效。\n\n## 2.5 故障快速定界定位\n\n由于分布式和大规模的部署，导致服务的 SLA将很难有效保障。  \n![][3]\n\n# 3 服务治理\n\n分布式服务框架的服务治理目标如下：  \n1. 防止业务服务架构腐化：通过服务注册中心对服务强弱依赖进行分析，结合运行时服务调用链关系分析，梳理不合理的依赖和调用路径，优化服务化架构，防止代码腐化。\n2. 快速故障定界定位：通过 Flume 等分布式日志采集框架，实时收集服务调用链日志、服务性能 KPI数据、服务接口日志、运行日志等，实时汇总和在线分析，集中存储和展示，实现故障的自动发现、自动分析和在线条件检索，方便运维人员、研发人员进行实时故障诊断。\n3. 服务微管控：细粒度的运行期服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、统一配置、优先级调度和流量迁移等，提供方法级治理和动态生效功能，通过一系列细粒度的治理策略，在故障发生时可以多管齐下，在线调整，快速恢复业务。\n4. 服务生命周期管理：包括服务的上线审批、下线通知，服务的在线升级，以及线上和线下服务文档库的建设。\n\n## 3.1 服务治理架构设计\n\n分布式服务框架的服务治理分三层：  \n![][4]  \n第二层为服务治理 SDK层，主要由如下组成：  \n1. 服务治理元数据：服务治理元数据主要包括服务治理实体对象，包括服务模型、应用模型、治理组织模型、用户权限模型、数据展示模型等。元数据模型通过 DataMapper和模型扩展，向上层界面屏蔽底层服务框架的数据模型，实现展示层和服务架构的解耦，元数据也可以用于展示界面的定制扩展。\n2. 服务治理接口：服务治理 Portal调用服务治理接口，实现服务治理。例如服务降级接口、服务流控接口、服务路由权重调整接口、服务迁移接口等。服务接口与具体的协议无关，它通常基于分布式服务框架自身实现，可以是 Restful接口，也可以是内部的私有协议。\n3. 服务治理客户端类库：由于服务治理服务本身通常也是基于分布式服务框架开发，因此服务治理 Portal需要继承分布式服务框架的客户端类库，实现服务的自动发现和调用。\n4. 调用示例：客户端 SDK需要提供服务治理接口的参数说明、注意事项以及给出常见的调用示例，方便前端开发人员使用。\n5. 继承开发指南：服务治理 SDK需要提供继承开发指南。\n\n## 3.2 运行态服务治理功能设计\n\n运行态服务治理首先要做到可视：当前系统发布了哪些服务，这些服务部署在哪些机器上，性能 KPI数据如何，指标是否正常等。  \n由于性能 KPI数据的统计周期、统计指标和报表呈现方式差异比较大，因此服务框架很难抽象出一套放之四海而皆准的性能统计功能，因此在设计的时候需要注意以下两点：  \n1. 扩展性：服务性能 KPI数据采集由插件 Handler 负责，平台和业务均可以通过扩展性能统计插件 Handler的方式扩展采集指标和采集周期等。\n2. 原子性：服务提供者和消费者只负责原始数据的采集和上报，不在本节点内做复杂的汇总操作，汇总和计算由性能汇聚节点的 Spark等大数据流式框架负责。\n\n## 3.3 线下服务治理\n\n为了解决消费者提供者之间的文档过时、错误问题，需要简历服务文档中心，方便线上运维人员查看和多团队之间的协作，它的工作原理如下：  \n![][16]  \n基于 java DOC工具进行扩展，将规则内置到 IDE开发模板中，并通过 CI构建工具做编译检测，将不符合要求的服务接口输出到 CI构建报告并邮件发送给服务责任人。  \n服务的上线审批、下线通知机制需要建立并完善起来，工作原理如下：  \n![][17]\n\n## 3.4 安全和权限管理\n\n安全涉及到两个层面：  \n1. 服务的开放和鉴权机制。\n2. 服务治理的安全和权限管理。\n  \n服务治理的使用者通常分三类：  \n1. 开发或者测试：主要定位问题，协助运维人员做服务治理。\n2. 运维人员：主要日常运维巡检，查看服务性能 KPI是否正常，是否有报警，利用服务治理进行故障恢复。\n3. 管理者：主要关心运营层面的 KPI数据，只看不管。\n\n# 4 个人总结\n\n服务治理总体结构图如下：  \n![][23]\n\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_4.png\n[16]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_5.png\n[17]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_6.png\n[23]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_7.png","source":"_posts/分布式服务框架原理与实践/第十七章 服务治理.md","raw":"---\ntitle: 十七、服务治理\ndate: 2018-06-14 00:45:00\nupdated: 2018-06-15 00:38:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/17.html    \n---\n\n随着业务发展，服务越来越多，如何协调线上运行的各个服务，保障服务的 SLA，以及小服务资源浪费的问题，需要能够基于服务调用的性能 KPI数据进行容量管理，合理分配各个服务的资源占用。  \n线上业务发生故障，需要对故障业务做服务降级、流量控制，快速恢复业务。  \n为了满足服务线下管控、保障线上高效运行，需要有一个统一的服务治理框架对服务进行统一、有效管控，保障服务的高效、健康运行。\n\n# 1 服务治理技术的历史变迁\n\n1. 第一代服务治理 SOA Governance：以 IBM为首的 SOA解决方案提供商推出的针对企业 IT系统的服务治理框架，它主要聚焦在对企业 IT系统中异构服务的质量管理、服务发布审批流程管理和服务建模、开发、测试以及运行的全生命周期管理。\n2. 第二代以分布式服务框架为中心的服务治理：随着电商和移动互联网的快速发展，以阿里为首的基于同一分布式服务框架的全新服务治理理念诞生，它聚焦于对内部同构服务的线上治理，保障线上服务的运行质量。相对比传统 IT架构的服务治理，由于服务的开发模式、部署规模、组网类型、业务特点等差异巨大，因此服务治理的重点也从线下转移到了线上服务质量保障。\n3. 微服务架构+云端服务治理：2013年至今，随着云计算和微服务架构的发展，以 AWS为首的基于微服务架构+云服务化的云端服务治理体系诞生，它的核心理念是服务微自治，利用云调度的弹性和敏捷，逐渐消除人工治理。  \n  \n微服务架构可以实现服务一定程度的自治，例如服务独立打包、独立部署、独立升级和独立扩容。通过云计算的弹性伸缩、单点故障迁移、服务健康度管理和自动容量规划等措施，结合微服务治理，逐步实现微服务的自治。\n\n## 1.1 SOA Governance\n\nSOA Governance的定位：面向企业 IT系统异构服务的治理和服务生命周期管理，它治理的服务通常是 SOA服务。  \n传统的 SOA Governance包含以下四部分内容：  \n1. 服务建模：验证功能需求与业务需求，发现和评估当前服务，服务建模和性能需求，开发治理规范。\n2. 服务组装：创建服务更新计划，创建和修改服务以满足所有业务需求，根据治理策略评估服务，批准组装完成。\n3. 服务部署：确保服务的质量，措施包括功能测试、性能测试和满足度测试，批准服务部署。\n4. 服务管理：在整个生命周期内管理和监控服务，跟踪服务注册表中的服务，根据 SLA上报服务的性能 KPI数据进行服务质量管理。\n  \nSOA Governance 工作原理如下：  \n![][1]  \n传统 SOA Governance 缺点如下：  \n1. 分布式服务框架的发展，内部服务框架需要统一，服务治理也需要适应新的架构，能够由表及里，对服务进行细粒度的管控。\n2. 微服务架构的发展和业务规模的扩大，导致服务规模量变引起质变，服务治理的特点和难点也随之发生变化。\n3. 缺少服务运行时动态治理能力，面对突发的流量高峰和业务冲击，传统的服务治理在响应速度、故障快速恢复等方面存在不足，无法更敏捷地应对业务需求。\n\n## 1.2 分布式服务框架服务治理\n\n1. 分布式服务矿机的服务治理定位：面向互联网业务的服务治理，聚焦在对内部采用统一服务框架服务化的业务运行态、细粒度的敏捷治理体系。\n2. 治理的对象：基于统一分布式服务框架开发的业务服务，与协议本身无关，治理的可以是 SOA服务，也可以是基于内部服务框架私有协议开发的各种服务。\n3. 治理策略：针对互联网业务的特点，例如突发的流量高峰、网络延时、机房故障等，重点针对大规模跨机房的海量服务进行运行态治理，保障线上服务的高 SLA，满足用户的体验。常用的治理策略包括服务的限流降级、服务迁入迁出、服务动态路由和灰度发布等。\n  \n以分布式服务框架 Dubbo为例，它的服务治理体系如下：  \n![][2]\n\n## 1.3 AWS 云端微服务治理\n\n随着云计算的发展，Dev&Ops 逐渐流行起来，基础设施服务化（IaaS）为大规模、批量流水线式软件交付提供了便利，AWS 作为全球最大的云计算解决方案提供商，在微服务云化开发和治理方面积累了非常多的经验，具体总结如下：  \n1. 全公司统一服务化开发环境，统一简单化服务框架（Coral Service），统一运行平台，快速高效服务开发。\n2. 所有后端应用服务化，系统由多项服务化组件构成。\n3. 服务共享、原子化、重用。\n4. 服务由小研发团队负责服务开发、测试、部署和治理，运维整个生命周期支撑。\n5. 高度自动化和 Dev&Ops 支持，一键式服务部署和回退。\n6. 超大规模支持：后台几十万个服务，成千上万开发者同时使用，平均每秒钟有 1~2 个服务部署。\n7. 尝试基于 Docket 容器部署微服务。\n8. 服务治理是核心：服务性能 KPI统计、告警、服务健康度管理、灵活的弹性伸缩策略、故障自动迁移、服务限流和服务降级等多种治理手段，保障服务高质量运行。\n\n# 2 应用服务化后面临的挑战\n\n## 2.1 跨团队协作问题\n\n1. 服务提供者 S分布式部署，存在多个服务实例，如果做端点调试，路由模块会动态分发消息，随机路由，服务提供者 S无法确定要连接的 IP地址。\n2. 如果打断点，其它消费者也正在进行服务调用，调试会被干扰，需要通知所有的开发者不要调用服务 S，显然不可能。\n\n## 2.2 服务的上下线管控\n\n需要结束某些服务的生命周期，服务提供者直接将服务下线，导致依赖该服务的应用不能正常工作。服务下线时，应先标记为过时，然后通知调用方尽快修改调用，通过性能 KPI接口和调用链分析，确认没有消费者再调用此服务，才能下线。\n\n## 2.3 服务安全\n\n针对内部应用，服务框架通常采用长链接管理客户端连接，针对非信任的第三方应用，或者恶意消费者，需要具备黑白名单访问控制机制，防止客户端非法链路过多，占用大量的句柄、线程和缓存资源，影响服务提供者的运行质量。\n\n## 2.4 服务 SLA 保障\n\n由于非核心服务跟系统其它服务打包部署在同一个 Tomcat等容器进程中，一旦非核心服务需要停止，也影响其它合设的服务，如何高效的关停非核心服务，但又不影响其它合设的服务，需要服务治理框架统一考虑。  \n另外超时时间也要方便的在线可视化的修改，不需要重启即可动态生效。\n\n## 2.5 故障快速定界定位\n\n由于分布式和大规模的部署，导致服务的 SLA将很难有效保障。  \n![][3]\n\n# 3 服务治理\n\n分布式服务框架的服务治理目标如下：  \n1. 防止业务服务架构腐化：通过服务注册中心对服务强弱依赖进行分析，结合运行时服务调用链关系分析，梳理不合理的依赖和调用路径，优化服务化架构，防止代码腐化。\n2. 快速故障定界定位：通过 Flume 等分布式日志采集框架，实时收集服务调用链日志、服务性能 KPI数据、服务接口日志、运行日志等，实时汇总和在线分析，集中存储和展示，实现故障的自动发现、自动分析和在线条件检索，方便运维人员、研发人员进行实时故障诊断。\n3. 服务微管控：细粒度的运行期服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、统一配置、优先级调度和流量迁移等，提供方法级治理和动态生效功能，通过一系列细粒度的治理策略，在故障发生时可以多管齐下，在线调整，快速恢复业务。\n4. 服务生命周期管理：包括服务的上线审批、下线通知，服务的在线升级，以及线上和线下服务文档库的建设。\n\n## 3.1 服务治理架构设计\n\n分布式服务框架的服务治理分三层：  \n![][4]  \n第二层为服务治理 SDK层，主要由如下组成：  \n1. 服务治理元数据：服务治理元数据主要包括服务治理实体对象，包括服务模型、应用模型、治理组织模型、用户权限模型、数据展示模型等。元数据模型通过 DataMapper和模型扩展，向上层界面屏蔽底层服务框架的数据模型，实现展示层和服务架构的解耦，元数据也可以用于展示界面的定制扩展。\n2. 服务治理接口：服务治理 Portal调用服务治理接口，实现服务治理。例如服务降级接口、服务流控接口、服务路由权重调整接口、服务迁移接口等。服务接口与具体的协议无关，它通常基于分布式服务框架自身实现，可以是 Restful接口，也可以是内部的私有协议。\n3. 服务治理客户端类库：由于服务治理服务本身通常也是基于分布式服务框架开发，因此服务治理 Portal需要继承分布式服务框架的客户端类库，实现服务的自动发现和调用。\n4. 调用示例：客户端 SDK需要提供服务治理接口的参数说明、注意事项以及给出常见的调用示例，方便前端开发人员使用。\n5. 继承开发指南：服务治理 SDK需要提供继承开发指南。\n\n## 3.2 运行态服务治理功能设计\n\n运行态服务治理首先要做到可视：当前系统发布了哪些服务，这些服务部署在哪些机器上，性能 KPI数据如何，指标是否正常等。  \n由于性能 KPI数据的统计周期、统计指标和报表呈现方式差异比较大，因此服务框架很难抽象出一套放之四海而皆准的性能统计功能，因此在设计的时候需要注意以下两点：  \n1. 扩展性：服务性能 KPI数据采集由插件 Handler 负责，平台和业务均可以通过扩展性能统计插件 Handler的方式扩展采集指标和采集周期等。\n2. 原子性：服务提供者和消费者只负责原始数据的采集和上报，不在本节点内做复杂的汇总操作，汇总和计算由性能汇聚节点的 Spark等大数据流式框架负责。\n\n## 3.3 线下服务治理\n\n为了解决消费者提供者之间的文档过时、错误问题，需要简历服务文档中心，方便线上运维人员查看和多团队之间的协作，它的工作原理如下：  \n![][16]  \n基于 java DOC工具进行扩展，将规则内置到 IDE开发模板中，并通过 CI构建工具做编译检测，将不符合要求的服务接口输出到 CI构建报告并邮件发送给服务责任人。  \n服务的上线审批、下线通知机制需要建立并完善起来，工作原理如下：  \n![][17]\n\n## 3.4 安全和权限管理\n\n安全涉及到两个层面：  \n1. 服务的开放和鉴权机制。\n2. 服务治理的安全和权限管理。\n  \n服务治理的使用者通常分三类：  \n1. 开发或者测试：主要定位问题，协助运维人员做服务治理。\n2. 运维人员：主要日常运维巡检，查看服务性能 KPI是否正常，是否有报警，利用服务治理进行故障恢复。\n3. 管理者：主要关心运营层面的 KPI数据，只看不管。\n\n# 4 个人总结\n\n服务治理总体结构图如下：  \n![][23]\n\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_4.png\n[16]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_5.png\n[17]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_6.png\n[23]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_7.png","slug":"distributed_principle_prictice/17.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavd001iaxs6izbudul7","content":"<p>随着业务发展，服务越来越多，如何协调线上运行的各个服务，保障服务的 SLA，以及小服务资源浪费的问题，需要能够基于服务调用的性能 KPI数据进行容量管理，合理分配各个服务的资源占用。<br>线上业务发生故障，需要对故障业务做服务降级、流量控制，快速恢复业务。<br>为了满足服务线下管控、保障线上高效运行，需要有一个统一的服务治理框架对服务进行统一、有效管控，保障服务的高效、健康运行。</p>\n<h1 id=\"1-服务治理技术的历史变迁\"><a href=\"#1-服务治理技术的历史变迁\" class=\"headerlink\" title=\"1 服务治理技术的历史变迁\"></a>1 服务治理技术的历史变迁</h1><ol>\n<li>第一代服务治理 SOA Governance：以 IBM为首的 SOA解决方案提供商推出的针对企业 IT系统的服务治理框架，它主要聚焦在对企业 IT系统中异构服务的质量管理、服务发布审批流程管理和服务建模、开发、测试以及运行的全生命周期管理。</li>\n<li>第二代以分布式服务框架为中心的服务治理：随着电商和移动互联网的快速发展，以阿里为首的基于同一分布式服务框架的全新服务治理理念诞生，它聚焦于对内部同构服务的线上治理，保障线上服务的运行质量。相对比传统 IT架构的服务治理，由于服务的开发模式、部署规模、组网类型、业务特点等差异巨大，因此服务治理的重点也从线下转移到了线上服务质量保障。</li>\n<li>微服务架构+云端服务治理：2013年至今，随着云计算和微服务架构的发展，以 AWS为首的基于微服务架构+云服务化的云端服务治理体系诞生，它的核心理念是服务微自治，利用云调度的弹性和敏捷，逐渐消除人工治理。  </li>\n</ol>\n<p>微服务架构可以实现服务一定程度的自治，例如服务独立打包、独立部署、独立升级和独立扩容。通过云计算的弹性伸缩、单点故障迁移、服务健康度管理和自动容量规划等措施，结合微服务治理，逐步实现微服务的自治。</p>\n<h2 id=\"1-1-SOA-Governance\"><a href=\"#1-1-SOA-Governance\" class=\"headerlink\" title=\"1.1 SOA Governance\"></a>1.1 SOA Governance</h2><p>SOA Governance的定位：面向企业 IT系统异构服务的治理和服务生命周期管理，它治理的服务通常是 SOA服务。<br>传统的 SOA Governance包含以下四部分内容：  </p>\n<ol>\n<li>服务建模：验证功能需求与业务需求，发现和评估当前服务，服务建模和性能需求，开发治理规范。</li>\n<li>服务组装：创建服务更新计划，创建和修改服务以满足所有业务需求，根据治理策略评估服务，批准组装完成。</li>\n<li>服务部署：确保服务的质量，措施包括功能测试、性能测试和满足度测试，批准服务部署。</li>\n<li>服务管理：在整个生命周期内管理和监控服务，跟踪服务注册表中的服务，根据 SLA上报服务的性能 KPI数据进行服务质量管理。</li>\n</ol>\n<p>SOA Governance 工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_1.png\" alt=\"\"><br>传统 SOA Governance 缺点如下：  </p>\n<ol>\n<li>分布式服务框架的发展，内部服务框架需要统一，服务治理也需要适应新的架构，能够由表及里，对服务进行细粒度的管控。</li>\n<li>微服务架构的发展和业务规模的扩大，导致服务规模量变引起质变，服务治理的特点和难点也随之发生变化。</li>\n<li>缺少服务运行时动态治理能力，面对突发的流量高峰和业务冲击，传统的服务治理在响应速度、故障快速恢复等方面存在不足，无法更敏捷地应对业务需求。</li>\n</ol>\n<h2 id=\"1-2-分布式服务框架服务治理\"><a href=\"#1-2-分布式服务框架服务治理\" class=\"headerlink\" title=\"1.2 分布式服务框架服务治理\"></a>1.2 分布式服务框架服务治理</h2><ol>\n<li>分布式服务矿机的服务治理定位：面向互联网业务的服务治理，聚焦在对内部采用统一服务框架服务化的业务运行态、细粒度的敏捷治理体系。</li>\n<li>治理的对象：基于统一分布式服务框架开发的业务服务，与协议本身无关，治理的可以是 SOA服务，也可以是基于内部服务框架私有协议开发的各种服务。</li>\n<li>治理策略：针对互联网业务的特点，例如突发的流量高峰、网络延时、机房故障等，重点针对大规模跨机房的海量服务进行运行态治理，保障线上服务的高 SLA，满足用户的体验。常用的治理策略包括服务的限流降级、服务迁入迁出、服务动态路由和灰度发布等。</li>\n</ol>\n<p>以分布式服务框架 Dubbo为例，它的服务治理体系如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-AWS-云端微服务治理\"><a href=\"#1-3-AWS-云端微服务治理\" class=\"headerlink\" title=\"1.3 AWS 云端微服务治理\"></a>1.3 AWS 云端微服务治理</h2><p>随着云计算的发展，Dev&amp;Ops 逐渐流行起来，基础设施服务化（IaaS）为大规模、批量流水线式软件交付提供了便利，AWS 作为全球最大的云计算解决方案提供商，在微服务云化开发和治理方面积累了非常多的经验，具体总结如下：  </p>\n<ol>\n<li>全公司统一服务化开发环境，统一简单化服务框架（Coral Service），统一运行平台，快速高效服务开发。</li>\n<li>所有后端应用服务化，系统由多项服务化组件构成。</li>\n<li>服务共享、原子化、重用。</li>\n<li>服务由小研发团队负责服务开发、测试、部署和治理，运维整个生命周期支撑。</li>\n<li>高度自动化和 Dev&amp;Ops 支持，一键式服务部署和回退。</li>\n<li>超大规模支持：后台几十万个服务，成千上万开发者同时使用，平均每秒钟有 1~2 个服务部署。</li>\n<li>尝试基于 Docket 容器部署微服务。</li>\n<li>服务治理是核心：服务性能 KPI统计、告警、服务健康度管理、灵活的弹性伸缩策略、故障自动迁移、服务限流和服务降级等多种治理手段，保障服务高质量运行。</li>\n</ol>\n<h1 id=\"2-应用服务化后面临的挑战\"><a href=\"#2-应用服务化后面临的挑战\" class=\"headerlink\" title=\"2 应用服务化后面临的挑战\"></a>2 应用服务化后面临的挑战</h1><h2 id=\"2-1-跨团队协作问题\"><a href=\"#2-1-跨团队协作问题\" class=\"headerlink\" title=\"2.1 跨团队协作问题\"></a>2.1 跨团队协作问题</h2><ol>\n<li>服务提供者 S分布式部署，存在多个服务实例，如果做端点调试，路由模块会动态分发消息，随机路由，服务提供者 S无法确定要连接的 IP地址。</li>\n<li>如果打断点，其它消费者也正在进行服务调用，调试会被干扰，需要通知所有的开发者不要调用服务 S，显然不可能。</li>\n</ol>\n<h2 id=\"2-2-服务的上下线管控\"><a href=\"#2-2-服务的上下线管控\" class=\"headerlink\" title=\"2.2 服务的上下线管控\"></a>2.2 服务的上下线管控</h2><p>需要结束某些服务的生命周期，服务提供者直接将服务下线，导致依赖该服务的应用不能正常工作。服务下线时，应先标记为过时，然后通知调用方尽快修改调用，通过性能 KPI接口和调用链分析，确认没有消费者再调用此服务，才能下线。</p>\n<h2 id=\"2-3-服务安全\"><a href=\"#2-3-服务安全\" class=\"headerlink\" title=\"2.3 服务安全\"></a>2.3 服务安全</h2><p>针对内部应用，服务框架通常采用长链接管理客户端连接，针对非信任的第三方应用，或者恶意消费者，需要具备黑白名单访问控制机制，防止客户端非法链路过多，占用大量的句柄、线程和缓存资源，影响服务提供者的运行质量。</p>\n<h2 id=\"2-4-服务-SLA-保障\"><a href=\"#2-4-服务-SLA-保障\" class=\"headerlink\" title=\"2.4 服务 SLA 保障\"></a>2.4 服务 SLA 保障</h2><p>由于非核心服务跟系统其它服务打包部署在同一个 Tomcat等容器进程中，一旦非核心服务需要停止，也影响其它合设的服务，如何高效的关停非核心服务，但又不影响其它合设的服务，需要服务治理框架统一考虑。<br>另外超时时间也要方便的在线可视化的修改，不需要重启即可动态生效。</p>\n<h2 id=\"2-5-故障快速定界定位\"><a href=\"#2-5-故障快速定界定位\" class=\"headerlink\" title=\"2.5 故障快速定界定位\"></a>2.5 故障快速定界定位</h2><p>由于分布式和大规模的部署，导致服务的 SLA将很难有效保障。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_3.png\" alt=\"\"></p>\n<h1 id=\"3-服务治理\"><a href=\"#3-服务治理\" class=\"headerlink\" title=\"3 服务治理\"></a>3 服务治理</h1><p>分布式服务框架的服务治理目标如下：  </p>\n<ol>\n<li>防止业务服务架构腐化：通过服务注册中心对服务强弱依赖进行分析，结合运行时服务调用链关系分析，梳理不合理的依赖和调用路径，优化服务化架构，防止代码腐化。</li>\n<li>快速故障定界定位：通过 Flume 等分布式日志采集框架，实时收集服务调用链日志、服务性能 KPI数据、服务接口日志、运行日志等，实时汇总和在线分析，集中存储和展示，实现故障的自动发现、自动分析和在线条件检索，方便运维人员、研发人员进行实时故障诊断。</li>\n<li>服务微管控：细粒度的运行期服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、统一配置、优先级调度和流量迁移等，提供方法级治理和动态生效功能，通过一系列细粒度的治理策略，在故障发生时可以多管齐下，在线调整，快速恢复业务。</li>\n<li>服务生命周期管理：包括服务的上线审批、下线通知，服务的在线升级，以及线上和线下服务文档库的建设。</li>\n</ol>\n<h2 id=\"3-1-服务治理架构设计\"><a href=\"#3-1-服务治理架构设计\" class=\"headerlink\" title=\"3.1 服务治理架构设计\"></a>3.1 服务治理架构设计</h2><p>分布式服务框架的服务治理分三层：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_4.png\" alt=\"\"><br>第二层为服务治理 SDK层，主要由如下组成：  </p>\n<ol>\n<li>服务治理元数据：服务治理元数据主要包括服务治理实体对象，包括服务模型、应用模型、治理组织模型、用户权限模型、数据展示模型等。元数据模型通过 DataMapper和模型扩展，向上层界面屏蔽底层服务框架的数据模型，实现展示层和服务架构的解耦，元数据也可以用于展示界面的定制扩展。</li>\n<li>服务治理接口：服务治理 Portal调用服务治理接口，实现服务治理。例如服务降级接口、服务流控接口、服务路由权重调整接口、服务迁移接口等。服务接口与具体的协议无关，它通常基于分布式服务框架自身实现，可以是 Restful接口，也可以是内部的私有协议。</li>\n<li>服务治理客户端类库：由于服务治理服务本身通常也是基于分布式服务框架开发，因此服务治理 Portal需要继承分布式服务框架的客户端类库，实现服务的自动发现和调用。</li>\n<li>调用示例：客户端 SDK需要提供服务治理接口的参数说明、注意事项以及给出常见的调用示例，方便前端开发人员使用。</li>\n<li>继承开发指南：服务治理 SDK需要提供继承开发指南。</li>\n</ol>\n<h2 id=\"3-2-运行态服务治理功能设计\"><a href=\"#3-2-运行态服务治理功能设计\" class=\"headerlink\" title=\"3.2 运行态服务治理功能设计\"></a>3.2 运行态服务治理功能设计</h2><p>运行态服务治理首先要做到可视：当前系统发布了哪些服务，这些服务部署在哪些机器上，性能 KPI数据如何，指标是否正常等。<br>由于性能 KPI数据的统计周期、统计指标和报表呈现方式差异比较大，因此服务框架很难抽象出一套放之四海而皆准的性能统计功能，因此在设计的时候需要注意以下两点：  </p>\n<ol>\n<li>扩展性：服务性能 KPI数据采集由插件 Handler 负责，平台和业务均可以通过扩展性能统计插件 Handler的方式扩展采集指标和采集周期等。</li>\n<li>原子性：服务提供者和消费者只负责原始数据的采集和上报，不在本节点内做复杂的汇总操作，汇总和计算由性能汇聚节点的 Spark等大数据流式框架负责。</li>\n</ol>\n<h2 id=\"3-3-线下服务治理\"><a href=\"#3-3-线下服务治理\" class=\"headerlink\" title=\"3.3 线下服务治理\"></a>3.3 线下服务治理</h2><p>为了解决消费者提供者之间的文档过时、错误问题，需要简历服务文档中心，方便线上运维人员查看和多团队之间的协作，它的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_5.png\" alt=\"\"><br>基于 java DOC工具进行扩展，将规则内置到 IDE开发模板中，并通过 CI构建工具做编译检测，将不符合要求的服务接口输出到 CI构建报告并邮件发送给服务责任人。<br>服务的上线审批、下线通知机制需要建立并完善起来，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_6.png\" alt=\"\"></p>\n<h2 id=\"3-4-安全和权限管理\"><a href=\"#3-4-安全和权限管理\" class=\"headerlink\" title=\"3.4 安全和权限管理\"></a>3.4 安全和权限管理</h2><p>安全涉及到两个层面：  </p>\n<ol>\n<li>服务的开放和鉴权机制。</li>\n<li>服务治理的安全和权限管理。</li>\n</ol>\n<p>服务治理的使用者通常分三类：  </p>\n<ol>\n<li>开发或者测试：主要定位问题，协助运维人员做服务治理。</li>\n<li>运维人员：主要日常运维巡检，查看服务性能 KPI是否正常，是否有报警，利用服务治理进行故障恢复。</li>\n<li>管理者：主要关心运营层面的 KPI数据，只看不管。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>服务治理总体结构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_7.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>随着业务发展，服务越来越多，如何协调线上运行的各个服务，保障服务的 SLA，以及小服务资源浪费的问题，需要能够基于服务调用的性能 KPI数据进行容量管理，合理分配各个服务的资源占用。<br>线上业务发生故障，需要对故障业务做服务降级、流量控制，快速恢复业务。<br>为了满足服务线下管控、保障线上高效运行，需要有一个统一的服务治理框架对服务进行统一、有效管控，保障服务的高效、健康运行。</p>\n<h1 id=\"1-服务治理技术的历史变迁\"><a href=\"#1-服务治理技术的历史变迁\" class=\"headerlink\" title=\"1 服务治理技术的历史变迁\"></a>1 服务治理技术的历史变迁</h1><ol>\n<li>第一代服务治理 SOA Governance：以 IBM为首的 SOA解决方案提供商推出的针对企业 IT系统的服务治理框架，它主要聚焦在对企业 IT系统中异构服务的质量管理、服务发布审批流程管理和服务建模、开发、测试以及运行的全生命周期管理。</li>\n<li>第二代以分布式服务框架为中心的服务治理：随着电商和移动互联网的快速发展，以阿里为首的基于同一分布式服务框架的全新服务治理理念诞生，它聚焦于对内部同构服务的线上治理，保障线上服务的运行质量。相对比传统 IT架构的服务治理，由于服务的开发模式、部署规模、组网类型、业务特点等差异巨大，因此服务治理的重点也从线下转移到了线上服务质量保障。</li>\n<li>微服务架构+云端服务治理：2013年至今，随着云计算和微服务架构的发展，以 AWS为首的基于微服务架构+云服务化的云端服务治理体系诞生，它的核心理念是服务微自治，利用云调度的弹性和敏捷，逐渐消除人工治理。  </li>\n</ol>\n<p>微服务架构可以实现服务一定程度的自治，例如服务独立打包、独立部署、独立升级和独立扩容。通过云计算的弹性伸缩、单点故障迁移、服务健康度管理和自动容量规划等措施，结合微服务治理，逐步实现微服务的自治。</p>\n<h2 id=\"1-1-SOA-Governance\"><a href=\"#1-1-SOA-Governance\" class=\"headerlink\" title=\"1.1 SOA Governance\"></a>1.1 SOA Governance</h2><p>SOA Governance的定位：面向企业 IT系统异构服务的治理和服务生命周期管理，它治理的服务通常是 SOA服务。<br>传统的 SOA Governance包含以下四部分内容：  </p>\n<ol>\n<li>服务建模：验证功能需求与业务需求，发现和评估当前服务，服务建模和性能需求，开发治理规范。</li>\n<li>服务组装：创建服务更新计划，创建和修改服务以满足所有业务需求，根据治理策略评估服务，批准组装完成。</li>\n<li>服务部署：确保服务的质量，措施包括功能测试、性能测试和满足度测试，批准服务部署。</li>\n<li>服务管理：在整个生命周期内管理和监控服务，跟踪服务注册表中的服务，根据 SLA上报服务的性能 KPI数据进行服务质量管理。</li>\n</ol>\n<p>SOA Governance 工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_1.png\" alt=\"\"><br>传统 SOA Governance 缺点如下：  </p>\n<ol>\n<li>分布式服务框架的发展，内部服务框架需要统一，服务治理也需要适应新的架构，能够由表及里，对服务进行细粒度的管控。</li>\n<li>微服务架构的发展和业务规模的扩大，导致服务规模量变引起质变，服务治理的特点和难点也随之发生变化。</li>\n<li>缺少服务运行时动态治理能力，面对突发的流量高峰和业务冲击，传统的服务治理在响应速度、故障快速恢复等方面存在不足，无法更敏捷地应对业务需求。</li>\n</ol>\n<h2 id=\"1-2-分布式服务框架服务治理\"><a href=\"#1-2-分布式服务框架服务治理\" class=\"headerlink\" title=\"1.2 分布式服务框架服务治理\"></a>1.2 分布式服务框架服务治理</h2><ol>\n<li>分布式服务矿机的服务治理定位：面向互联网业务的服务治理，聚焦在对内部采用统一服务框架服务化的业务运行态、细粒度的敏捷治理体系。</li>\n<li>治理的对象：基于统一分布式服务框架开发的业务服务，与协议本身无关，治理的可以是 SOA服务，也可以是基于内部服务框架私有协议开发的各种服务。</li>\n<li>治理策略：针对互联网业务的特点，例如突发的流量高峰、网络延时、机房故障等，重点针对大规模跨机房的海量服务进行运行态治理，保障线上服务的高 SLA，满足用户的体验。常用的治理策略包括服务的限流降级、服务迁入迁出、服务动态路由和灰度发布等。</li>\n</ol>\n<p>以分布式服务框架 Dubbo为例，它的服务治理体系如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-AWS-云端微服务治理\"><a href=\"#1-3-AWS-云端微服务治理\" class=\"headerlink\" title=\"1.3 AWS 云端微服务治理\"></a>1.3 AWS 云端微服务治理</h2><p>随着云计算的发展，Dev&amp;Ops 逐渐流行起来，基础设施服务化（IaaS）为大规模、批量流水线式软件交付提供了便利，AWS 作为全球最大的云计算解决方案提供商，在微服务云化开发和治理方面积累了非常多的经验，具体总结如下：  </p>\n<ol>\n<li>全公司统一服务化开发环境，统一简单化服务框架（Coral Service），统一运行平台，快速高效服务开发。</li>\n<li>所有后端应用服务化，系统由多项服务化组件构成。</li>\n<li>服务共享、原子化、重用。</li>\n<li>服务由小研发团队负责服务开发、测试、部署和治理，运维整个生命周期支撑。</li>\n<li>高度自动化和 Dev&amp;Ops 支持，一键式服务部署和回退。</li>\n<li>超大规模支持：后台几十万个服务，成千上万开发者同时使用，平均每秒钟有 1~2 个服务部署。</li>\n<li>尝试基于 Docket 容器部署微服务。</li>\n<li>服务治理是核心：服务性能 KPI统计、告警、服务健康度管理、灵活的弹性伸缩策略、故障自动迁移、服务限流和服务降级等多种治理手段，保障服务高质量运行。</li>\n</ol>\n<h1 id=\"2-应用服务化后面临的挑战\"><a href=\"#2-应用服务化后面临的挑战\" class=\"headerlink\" title=\"2 应用服务化后面临的挑战\"></a>2 应用服务化后面临的挑战</h1><h2 id=\"2-1-跨团队协作问题\"><a href=\"#2-1-跨团队协作问题\" class=\"headerlink\" title=\"2.1 跨团队协作问题\"></a>2.1 跨团队协作问题</h2><ol>\n<li>服务提供者 S分布式部署，存在多个服务实例，如果做端点调试，路由模块会动态分发消息，随机路由，服务提供者 S无法确定要连接的 IP地址。</li>\n<li>如果打断点，其它消费者也正在进行服务调用，调试会被干扰，需要通知所有的开发者不要调用服务 S，显然不可能。</li>\n</ol>\n<h2 id=\"2-2-服务的上下线管控\"><a href=\"#2-2-服务的上下线管控\" class=\"headerlink\" title=\"2.2 服务的上下线管控\"></a>2.2 服务的上下线管控</h2><p>需要结束某些服务的生命周期，服务提供者直接将服务下线，导致依赖该服务的应用不能正常工作。服务下线时，应先标记为过时，然后通知调用方尽快修改调用，通过性能 KPI接口和调用链分析，确认没有消费者再调用此服务，才能下线。</p>\n<h2 id=\"2-3-服务安全\"><a href=\"#2-3-服务安全\" class=\"headerlink\" title=\"2.3 服务安全\"></a>2.3 服务安全</h2><p>针对内部应用，服务框架通常采用长链接管理客户端连接，针对非信任的第三方应用，或者恶意消费者，需要具备黑白名单访问控制机制，防止客户端非法链路过多，占用大量的句柄、线程和缓存资源，影响服务提供者的运行质量。</p>\n<h2 id=\"2-4-服务-SLA-保障\"><a href=\"#2-4-服务-SLA-保障\" class=\"headerlink\" title=\"2.4 服务 SLA 保障\"></a>2.4 服务 SLA 保障</h2><p>由于非核心服务跟系统其它服务打包部署在同一个 Tomcat等容器进程中，一旦非核心服务需要停止，也影响其它合设的服务，如何高效的关停非核心服务，但又不影响其它合设的服务，需要服务治理框架统一考虑。<br>另外超时时间也要方便的在线可视化的修改，不需要重启即可动态生效。</p>\n<h2 id=\"2-5-故障快速定界定位\"><a href=\"#2-5-故障快速定界定位\" class=\"headerlink\" title=\"2.5 故障快速定界定位\"></a>2.5 故障快速定界定位</h2><p>由于分布式和大规模的部署，导致服务的 SLA将很难有效保障。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_3.png\" alt=\"\"></p>\n<h1 id=\"3-服务治理\"><a href=\"#3-服务治理\" class=\"headerlink\" title=\"3 服务治理\"></a>3 服务治理</h1><p>分布式服务框架的服务治理目标如下：  </p>\n<ol>\n<li>防止业务服务架构腐化：通过服务注册中心对服务强弱依赖进行分析，结合运行时服务调用链关系分析，梳理不合理的依赖和调用路径，优化服务化架构，防止代码腐化。</li>\n<li>快速故障定界定位：通过 Flume 等分布式日志采集框架，实时收集服务调用链日志、服务性能 KPI数据、服务接口日志、运行日志等，实时汇总和在线分析，集中存储和展示，实现故障的自动发现、自动分析和在线条件检索，方便运维人员、研发人员进行实时故障诊断。</li>\n<li>服务微管控：细粒度的运行期服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、统一配置、优先级调度和流量迁移等，提供方法级治理和动态生效功能，通过一系列细粒度的治理策略，在故障发生时可以多管齐下，在线调整，快速恢复业务。</li>\n<li>服务生命周期管理：包括服务的上线审批、下线通知，服务的在线升级，以及线上和线下服务文档库的建设。</li>\n</ol>\n<h2 id=\"3-1-服务治理架构设计\"><a href=\"#3-1-服务治理架构设计\" class=\"headerlink\" title=\"3.1 服务治理架构设计\"></a>3.1 服务治理架构设计</h2><p>分布式服务框架的服务治理分三层：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_4.png\" alt=\"\"><br>第二层为服务治理 SDK层，主要由如下组成：  </p>\n<ol>\n<li>服务治理元数据：服务治理元数据主要包括服务治理实体对象，包括服务模型、应用模型、治理组织模型、用户权限模型、数据展示模型等。元数据模型通过 DataMapper和模型扩展，向上层界面屏蔽底层服务框架的数据模型，实现展示层和服务架构的解耦，元数据也可以用于展示界面的定制扩展。</li>\n<li>服务治理接口：服务治理 Portal调用服务治理接口，实现服务治理。例如服务降级接口、服务流控接口、服务路由权重调整接口、服务迁移接口等。服务接口与具体的协议无关，它通常基于分布式服务框架自身实现，可以是 Restful接口，也可以是内部的私有协议。</li>\n<li>服务治理客户端类库：由于服务治理服务本身通常也是基于分布式服务框架开发，因此服务治理 Portal需要继承分布式服务框架的客户端类库，实现服务的自动发现和调用。</li>\n<li>调用示例：客户端 SDK需要提供服务治理接口的参数说明、注意事项以及给出常见的调用示例，方便前端开发人员使用。</li>\n<li>继承开发指南：服务治理 SDK需要提供继承开发指南。</li>\n</ol>\n<h2 id=\"3-2-运行态服务治理功能设计\"><a href=\"#3-2-运行态服务治理功能设计\" class=\"headerlink\" title=\"3.2 运行态服务治理功能设计\"></a>3.2 运行态服务治理功能设计</h2><p>运行态服务治理首先要做到可视：当前系统发布了哪些服务，这些服务部署在哪些机器上，性能 KPI数据如何，指标是否正常等。<br>由于性能 KPI数据的统计周期、统计指标和报表呈现方式差异比较大，因此服务框架很难抽象出一套放之四海而皆准的性能统计功能，因此在设计的时候需要注意以下两点：  </p>\n<ol>\n<li>扩展性：服务性能 KPI数据采集由插件 Handler 负责，平台和业务均可以通过扩展性能统计插件 Handler的方式扩展采集指标和采集周期等。</li>\n<li>原子性：服务提供者和消费者只负责原始数据的采集和上报，不在本节点内做复杂的汇总操作，汇总和计算由性能汇聚节点的 Spark等大数据流式框架负责。</li>\n</ol>\n<h2 id=\"3-3-线下服务治理\"><a href=\"#3-3-线下服务治理\" class=\"headerlink\" title=\"3.3 线下服务治理\"></a>3.3 线下服务治理</h2><p>为了解决消费者提供者之间的文档过时、错误问题，需要简历服务文档中心，方便线上运维人员查看和多团队之间的协作，它的工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_5.png\" alt=\"\"><br>基于 java DOC工具进行扩展，将规则内置到 IDE开发模板中，并通过 CI构建工具做编译检测，将不符合要求的服务接口输出到 CI构建报告并邮件发送给服务责任人。<br>服务的上线审批、下线通知机制需要建立并完善起来，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_6.png\" alt=\"\"></p>\n<h2 id=\"3-4-安全和权限管理\"><a href=\"#3-4-安全和权限管理\" class=\"headerlink\" title=\"3.4 安全和权限管理\"></a>3.4 安全和权限管理</h2><p>安全涉及到两个层面：  </p>\n<ol>\n<li>服务的开放和鉴权机制。</li>\n<li>服务治理的安全和权限管理。</li>\n</ol>\n<p>服务治理的使用者通常分三类：  </p>\n<ol>\n<li>开发或者测试：主要定位问题，协助运维人员做服务治理。</li>\n<li>运维人员：主要日常运维巡检，查看服务性能 KPI是否正常，是否有报警，利用服务治理进行故障恢复。</li>\n<li>管理者：主要关心运营层面的 KPI数据，只看不管。</li>\n</ol>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>服务治理总体结构图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_7.png\" alt=\"\"></p>\n"},{"title":"十三、服务多版本","date":"2018-06-06T13:24:00.000Z","updated":"2018-06-07T14:30:00.000Z","comments":1,"_content":"\n服务上线之后，由于功能变更、BUG修复，以及服务升级，需要对服务采用多版本管理。\n\n# 1 服务多版本管理设计\n\n管理的对象包括服务提供者和消费者：  \n1. 服务提供者：发布服务的时候，支持指定服务的版本号。\n2. 服务消费者：消费服务的时候，支持指定引用的服务版本号或者版本范围。\n\n## 1.1 服务版本号管理\n\n服务的版本号是有序的，在服务名相同的情况下，两个相同服务名的不同服务版本的版本号可以比较大小。完整的版本号由“主版本号（Major）+副版本号（Minor）+微版本号（Micro）”构成：  \n1. 主版本号：表示重大特性或者功能变更，接口或功能可能会不兼容。\n2. 副版本号：发生了少部分功能变更，或者新增了一些功能。\n3. 微版本号：主要用于 BUG修改，对应于常见的 SP补丁包。\n\n## 1.2 服务提供者\n\n服务开发完成之后，需要将一个或者多个服务打包成一个 jar/war 包，为了便于对服务进行物理管理，打包后的名称中会包含服务的版本号信息，例如 com.huawei.orderService_1.0.1.jar。  \n在微服务架构中，微服务独立开发、打包、部署和升级，因此微服务的版本和软件包的版本可以一一映射。但是在实际开发中，尤其是大规模企业应用开发，单独为每个服务打包和部署目前尚未成为主流，它会增加服务软件包的管理和线上治理成本，因此目前的主流模式仍然是多个服务提供者合一个大的 jar/war 包，这就会存在一个问题：项目开发后期，有些服务进行了版本升级，有些服务没有，这样当它们被打包成同一个软件包时，就会导致版本号不一致。  \n  \n每个服务都指定一个版本号，对开发而言也比较麻烦。一个比较好的实践就是微服务+全局版本模式。对于经常发生功能变更、需要独立升级的服务，将其独立拆分出来进行微服务化，实现单个微服务级的打包和部署。  \n  \n对于其它服务，服务框架提供全局版本功能，在 Maven组件工程开发时，只需要为整个工程配置一个版本号，该组件工程包含的所有服务都共用该版本号。如果组件工程包含的某个服务发生了版本变更，就统一升级全局版本号，其它未发生功能变更但是打包在一起的服务做级联升级。这样做的一个原因是服务被打包在一起后，无论其它服务是否需要升级，只要软件包中的一个服务发生了版本升级，其它合设的服务也必须与其一起打包升级，它们之间存在物理上的耦合，这也是为什么微服务架构提倡微服务独立打包、部署和升级的原因。\n\n## 1.3 服务消费者\n\n与服务提供者不同，服务消费者往往不需要指定具体依赖的服务版本，而是一版本范围，例如：version=“[1.0.1, 2.0.8]”。  \n1. 消费者关心的是某个新特性从哪个服务版本中开始提供，它并不关系服务提供者的版本演进以及具体的版本号。\n2. 消费者想使用当前环境中服务的最新版本，但不清楚具体的版本号，希望自动适配最新的服务版本。\n  \n当然需要指定一个默认的服务提供者版本号。\n\n## 1.4 基于版本号的服务路由\n\n服务提供者将服务注册到服务注册中心时，将服务名+服务版本号+服务分组作为路由关键信息存放到注册中心，服务消费者在发起服务调用时，除了携带服务名、方法名、参数列表之外，还需要携带要消费的服务版本信息，由路由接口负责服务版本过滤，如下图：  \n![][1]\n\n## 1.5 服务热升级\n\n在业务不中断的情况下，实现系统的平滑升级，考虑到版本升级的风险，往往需要做多次滚动升级，最终根据升级之后新版本服务的运行状况决定是继续升级还是回退。这就意味着在同一时刻，整个集群环境中会同时存在服务的多个版本咋线运行，这就是热升级相比于传统 AB Test等升级方式的差异，如下图：  \n![][2]  \n核心点如下：\n1. 升级的节点需要重启，由于自动发现机制，停机升级的节点自动被隔离，停机并不会中断业务。\n2. 服务路由规则的定制：如果是滚动式的灰度发布，在相当长的一段时间（例如一周）内线上都会存在服务的多个版本。哪些用户或者业务需要路由到新版本上，需要通过路由策略和规则进行制定，服务框架应该支持用户配置自定义的路由规则来支持灵活的路由策略。\n3. 滚动升级和回退机制：为了降低服务热升级对业务的影响，同时考虑到可靠性，在实际工作中往往采用滚动升级的方式，分批次进行服务的热升级，实现敏捷的特性交付，滚动升级如下图：  \n![][3]\n\n# 2 与 OSGI 的对比\n\nOSGI，成立于 1999年，全名原为：Open Services Gateway initiative，但现在这个全名已经废弃。  \n致力于家用设备、汽车、手机、桌面、其它环境指定下一代网络服务标准的领导者，推出了 OSGI 服务平台规范，用于提供开放和通用的架构，使得服务提供商、开发人员、软件提供商、网关操作者和设备提供商以统一的方式开发、部署和管理服务。  \n  \n目前最广泛和应用是 OSGI规范5（Release 5），共由核心规范、标准服务（Standard Services）、框架服务（Framework Services）、系统服务（System Services）、协议服务（Protocol Services）、混合服务（Miscellaneous Services）等几部分共同组成。  \n核心规范通过一个分层的框架，实现了 OSGI最为成功的动态插件机制，它主要提供了：\n1. OSGI Bundle 的运行环境。\n2. OSGI Bundle 间的依赖管理。\n3. OSGI Bundle 的生命周期管理。\n4. OSGI 服务的动态交互模型。\n  \nOSGI 两个最核心的特性就是模块化和热插拔机制，分布式服务框架的服务多版本管理和热升级是否可以基于 OSGI来实现？下面围绕着模块化和插件热插拔这两个特性进行详细分析。\n\n## 2.1 模块化开发\n\n在 OSGI中，我们以模块化的方式去开发一个系统，每个模块被称为 Bundle，OSGI 提供了对 Bundle的整个生命周期管理，包括打包、部署、运行、升级、停止等。  \n模块化的核心并不是简单地把系统拆分成不同的模块，如果仅仅是拆分，原生的 Jar包+Eclipse工程就能够解决问题。更为重要的是要考虑到模块中接口的导出、隐藏、依赖、版本管理、打包、部署、运行和升级等全生命周期管理，这些对于原生的 Jar包而言是不支持的。  \n传统开发的模块划分通常由两种方式：  \n1. 使用 package来进行隔离。\n2. 定义多个子工程，工程之间通过工程引用的方式进行依赖管理。  \n存在的问题：无法实现资源的精细划分和对依赖做统一管理。以 Jar包依赖为例，依赖一个 Jar包就意味着这个 Jar包中所有 public的资源都可能被引用，但事实上也许只需要依赖该 Jar包中的某几个 public接口。无法对资源做细粒度、精确的管控，不知道 public的接口都被哪些模块依赖和使用，消费者是谁，更为复杂的场景是如果消费者需要依赖不同的接口版本，那该肿么办？  \n  \nOSGI 很好地解决了这个问题，每个 OSGI工程是一个标准的插件工程，实际就是一个 Bundle。实现了 package级的管理依赖关系，而 Maven则是 Jar包级的管理依赖。  \n而分布式服务：\n1. 服务提供者通过 service export将某个服务接口发布出去，供消费者使用。\n2. 服务消费者通过 service import导入某个服务接口，它不关心服务提供者的具体位置，也不关心服务的具体实现细节。  \n这样就比 OSGI的 package导入导出功能粒度更细。  \n利用 Maven的模块化管理 + 分布式服务框架自身的服务接口导入导出功能，解决了模块化开发和精细化依赖管理难题，完成可以替代 OSGI的相关功能，\n\n## 2.2 插件热部署和热升级\n\nOSGI 另外一个非常酷的特性就是动态性，即插件的热部署和热升级，它可以在不重启 JVM的情况下安装部署一个插件，实现升级不中断业务。  \nOSGI 的插件热部署和热升级原理就是基于自身的网状类加载机制实现的，下面我们分析在分布式服务框架中，如何实现服务热部署和热升级：  \n1. 服务是分布式集群部署的，通常也是无状态的，停掉其中某一个服务节点，并不会影响系统整体的运行质量。\n2. 服务自动发现和隔离机制，当有新的服务节点加入时，服务注册中心会向消费者集群推送新的服务地址信息；当有服务节点宕机或重启时，服务注册中心会发送服务下线通知消息给消费者集群，消费者会将下线服务自动隔离。\n3. 优雅停机功能，在进程退出之前，处理完消息队列积压的消息，不再接受新的消息，最大限度保障丢失消息。\n4. 集群容错功能，如果服务提供者正在等待应答消息时系统推出了，消费者会发生服务调用超时，集群容错功能会根据策略重试其它正常的服务节点，保证流程不会因为某个服务实例宕机而中断。\n5. 服务多版本管理，支持集群中同一个服务的多个版本同时运行，支持路由规则定制，不同的消费者可以消费不同的服务版本。\n\n相比于 OSGI在 JVM内部通过定制类加载机制实现插件的多版本运行和升级，使用分布式服务框架自身的分布式集群特性实现服务的热部署和热升级，更加简单、灵活和可控。\n\n# 3 个人总结\n\n服务多版本在实际项目中非常实用，用于实现服务的热部署和热升级，同时支持按照消费者做差异化路由，同时也方便演进到微服务架构，来迁移到服务的独立打包、部署、运行和运维。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_3.png","source":"_posts/分布式服务框架原理与实践/第十三章 服务多版本.md","raw":"---\ntitle: 十三、服务多版本\ndate: 2018-06-06 21:24:00\nupdated: 2018-06-07 22:30:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/13.html    \n---\n\n服务上线之后，由于功能变更、BUG修复，以及服务升级，需要对服务采用多版本管理。\n\n# 1 服务多版本管理设计\n\n管理的对象包括服务提供者和消费者：  \n1. 服务提供者：发布服务的时候，支持指定服务的版本号。\n2. 服务消费者：消费服务的时候，支持指定引用的服务版本号或者版本范围。\n\n## 1.1 服务版本号管理\n\n服务的版本号是有序的，在服务名相同的情况下，两个相同服务名的不同服务版本的版本号可以比较大小。完整的版本号由“主版本号（Major）+副版本号（Minor）+微版本号（Micro）”构成：  \n1. 主版本号：表示重大特性或者功能变更，接口或功能可能会不兼容。\n2. 副版本号：发生了少部分功能变更，或者新增了一些功能。\n3. 微版本号：主要用于 BUG修改，对应于常见的 SP补丁包。\n\n## 1.2 服务提供者\n\n服务开发完成之后，需要将一个或者多个服务打包成一个 jar/war 包，为了便于对服务进行物理管理，打包后的名称中会包含服务的版本号信息，例如 com.huawei.orderService_1.0.1.jar。  \n在微服务架构中，微服务独立开发、打包、部署和升级，因此微服务的版本和软件包的版本可以一一映射。但是在实际开发中，尤其是大规模企业应用开发，单独为每个服务打包和部署目前尚未成为主流，它会增加服务软件包的管理和线上治理成本，因此目前的主流模式仍然是多个服务提供者合一个大的 jar/war 包，这就会存在一个问题：项目开发后期，有些服务进行了版本升级，有些服务没有，这样当它们被打包成同一个软件包时，就会导致版本号不一致。  \n  \n每个服务都指定一个版本号，对开发而言也比较麻烦。一个比较好的实践就是微服务+全局版本模式。对于经常发生功能变更、需要独立升级的服务，将其独立拆分出来进行微服务化，实现单个微服务级的打包和部署。  \n  \n对于其它服务，服务框架提供全局版本功能，在 Maven组件工程开发时，只需要为整个工程配置一个版本号，该组件工程包含的所有服务都共用该版本号。如果组件工程包含的某个服务发生了版本变更，就统一升级全局版本号，其它未发生功能变更但是打包在一起的服务做级联升级。这样做的一个原因是服务被打包在一起后，无论其它服务是否需要升级，只要软件包中的一个服务发生了版本升级，其它合设的服务也必须与其一起打包升级，它们之间存在物理上的耦合，这也是为什么微服务架构提倡微服务独立打包、部署和升级的原因。\n\n## 1.3 服务消费者\n\n与服务提供者不同，服务消费者往往不需要指定具体依赖的服务版本，而是一版本范围，例如：version=“[1.0.1, 2.0.8]”。  \n1. 消费者关心的是某个新特性从哪个服务版本中开始提供，它并不关系服务提供者的版本演进以及具体的版本号。\n2. 消费者想使用当前环境中服务的最新版本，但不清楚具体的版本号，希望自动适配最新的服务版本。\n  \n当然需要指定一个默认的服务提供者版本号。\n\n## 1.4 基于版本号的服务路由\n\n服务提供者将服务注册到服务注册中心时，将服务名+服务版本号+服务分组作为路由关键信息存放到注册中心，服务消费者在发起服务调用时，除了携带服务名、方法名、参数列表之外，还需要携带要消费的服务版本信息，由路由接口负责服务版本过滤，如下图：  \n![][1]\n\n## 1.5 服务热升级\n\n在业务不中断的情况下，实现系统的平滑升级，考虑到版本升级的风险，往往需要做多次滚动升级，最终根据升级之后新版本服务的运行状况决定是继续升级还是回退。这就意味着在同一时刻，整个集群环境中会同时存在服务的多个版本咋线运行，这就是热升级相比于传统 AB Test等升级方式的差异，如下图：  \n![][2]  \n核心点如下：\n1. 升级的节点需要重启，由于自动发现机制，停机升级的节点自动被隔离，停机并不会中断业务。\n2. 服务路由规则的定制：如果是滚动式的灰度发布，在相当长的一段时间（例如一周）内线上都会存在服务的多个版本。哪些用户或者业务需要路由到新版本上，需要通过路由策略和规则进行制定，服务框架应该支持用户配置自定义的路由规则来支持灵活的路由策略。\n3. 滚动升级和回退机制：为了降低服务热升级对业务的影响，同时考虑到可靠性，在实际工作中往往采用滚动升级的方式，分批次进行服务的热升级，实现敏捷的特性交付，滚动升级如下图：  \n![][3]\n\n# 2 与 OSGI 的对比\n\nOSGI，成立于 1999年，全名原为：Open Services Gateway initiative，但现在这个全名已经废弃。  \n致力于家用设备、汽车、手机、桌面、其它环境指定下一代网络服务标准的领导者，推出了 OSGI 服务平台规范，用于提供开放和通用的架构，使得服务提供商、开发人员、软件提供商、网关操作者和设备提供商以统一的方式开发、部署和管理服务。  \n  \n目前最广泛和应用是 OSGI规范5（Release 5），共由核心规范、标准服务（Standard Services）、框架服务（Framework Services）、系统服务（System Services）、协议服务（Protocol Services）、混合服务（Miscellaneous Services）等几部分共同组成。  \n核心规范通过一个分层的框架，实现了 OSGI最为成功的动态插件机制，它主要提供了：\n1. OSGI Bundle 的运行环境。\n2. OSGI Bundle 间的依赖管理。\n3. OSGI Bundle 的生命周期管理。\n4. OSGI 服务的动态交互模型。\n  \nOSGI 两个最核心的特性就是模块化和热插拔机制，分布式服务框架的服务多版本管理和热升级是否可以基于 OSGI来实现？下面围绕着模块化和插件热插拔这两个特性进行详细分析。\n\n## 2.1 模块化开发\n\n在 OSGI中，我们以模块化的方式去开发一个系统，每个模块被称为 Bundle，OSGI 提供了对 Bundle的整个生命周期管理，包括打包、部署、运行、升级、停止等。  \n模块化的核心并不是简单地把系统拆分成不同的模块，如果仅仅是拆分，原生的 Jar包+Eclipse工程就能够解决问题。更为重要的是要考虑到模块中接口的导出、隐藏、依赖、版本管理、打包、部署、运行和升级等全生命周期管理，这些对于原生的 Jar包而言是不支持的。  \n传统开发的模块划分通常由两种方式：  \n1. 使用 package来进行隔离。\n2. 定义多个子工程，工程之间通过工程引用的方式进行依赖管理。  \n存在的问题：无法实现资源的精细划分和对依赖做统一管理。以 Jar包依赖为例，依赖一个 Jar包就意味着这个 Jar包中所有 public的资源都可能被引用，但事实上也许只需要依赖该 Jar包中的某几个 public接口。无法对资源做细粒度、精确的管控，不知道 public的接口都被哪些模块依赖和使用，消费者是谁，更为复杂的场景是如果消费者需要依赖不同的接口版本，那该肿么办？  \n  \nOSGI 很好地解决了这个问题，每个 OSGI工程是一个标准的插件工程，实际就是一个 Bundle。实现了 package级的管理依赖关系，而 Maven则是 Jar包级的管理依赖。  \n而分布式服务：\n1. 服务提供者通过 service export将某个服务接口发布出去，供消费者使用。\n2. 服务消费者通过 service import导入某个服务接口，它不关心服务提供者的具体位置，也不关心服务的具体实现细节。  \n这样就比 OSGI的 package导入导出功能粒度更细。  \n利用 Maven的模块化管理 + 分布式服务框架自身的服务接口导入导出功能，解决了模块化开发和精细化依赖管理难题，完成可以替代 OSGI的相关功能，\n\n## 2.2 插件热部署和热升级\n\nOSGI 另外一个非常酷的特性就是动态性，即插件的热部署和热升级，它可以在不重启 JVM的情况下安装部署一个插件，实现升级不中断业务。  \nOSGI 的插件热部署和热升级原理就是基于自身的网状类加载机制实现的，下面我们分析在分布式服务框架中，如何实现服务热部署和热升级：  \n1. 服务是分布式集群部署的，通常也是无状态的，停掉其中某一个服务节点，并不会影响系统整体的运行质量。\n2. 服务自动发现和隔离机制，当有新的服务节点加入时，服务注册中心会向消费者集群推送新的服务地址信息；当有服务节点宕机或重启时，服务注册中心会发送服务下线通知消息给消费者集群，消费者会将下线服务自动隔离。\n3. 优雅停机功能，在进程退出之前，处理完消息队列积压的消息，不再接受新的消息，最大限度保障丢失消息。\n4. 集群容错功能，如果服务提供者正在等待应答消息时系统推出了，消费者会发生服务调用超时，集群容错功能会根据策略重试其它正常的服务节点，保证流程不会因为某个服务实例宕机而中断。\n5. 服务多版本管理，支持集群中同一个服务的多个版本同时运行，支持路由规则定制，不同的消费者可以消费不同的服务版本。\n\n相比于 OSGI在 JVM内部通过定制类加载机制实现插件的多版本运行和升级，使用分布式服务框架自身的分布式集群特性实现服务的热部署和热升级，更加简单、灵活和可控。\n\n# 3 个人总结\n\n服务多版本在实际项目中非常实用，用于实现服务的热部署和热升级，同时支持按照消费者做差异化路由，同时也方便演进到微服务架构，来迁移到服务的独立打包、部署、运行和运维。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_3.png","slug":"distributed_principle_prictice/13.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavf001laxs66jkxaye8","content":"<p>服务上线之后，由于功能变更、BUG修复，以及服务升级，需要对服务采用多版本管理。</p>\n<h1 id=\"1-服务多版本管理设计\"><a href=\"#1-服务多版本管理设计\" class=\"headerlink\" title=\"1 服务多版本管理设计\"></a>1 服务多版本管理设计</h1><p>管理的对象包括服务提供者和消费者：  </p>\n<ol>\n<li>服务提供者：发布服务的时候，支持指定服务的版本号。</li>\n<li>服务消费者：消费服务的时候，支持指定引用的服务版本号或者版本范围。</li>\n</ol>\n<h2 id=\"1-1-服务版本号管理\"><a href=\"#1-1-服务版本号管理\" class=\"headerlink\" title=\"1.1 服务版本号管理\"></a>1.1 服务版本号管理</h2><p>服务的版本号是有序的，在服务名相同的情况下，两个相同服务名的不同服务版本的版本号可以比较大小。完整的版本号由“主版本号（Major）+副版本号（Minor）+微版本号（Micro）”构成：  </p>\n<ol>\n<li>主版本号：表示重大特性或者功能变更，接口或功能可能会不兼容。</li>\n<li>副版本号：发生了少部分功能变更，或者新增了一些功能。</li>\n<li>微版本号：主要用于 BUG修改，对应于常见的 SP补丁包。</li>\n</ol>\n<h2 id=\"1-2-服务提供者\"><a href=\"#1-2-服务提供者\" class=\"headerlink\" title=\"1.2 服务提供者\"></a>1.2 服务提供者</h2><p>服务开发完成之后，需要将一个或者多个服务打包成一个 jar/war 包，为了便于对服务进行物理管理，打包后的名称中会包含服务的版本号信息，例如 com.huawei.orderService_1.0.1.jar。<br>在微服务架构中，微服务独立开发、打包、部署和升级，因此微服务的版本和软件包的版本可以一一映射。但是在实际开发中，尤其是大规模企业应用开发，单独为每个服务打包和部署目前尚未成为主流，它会增加服务软件包的管理和线上治理成本，因此目前的主流模式仍然是多个服务提供者合一个大的 jar/war 包，这就会存在一个问题：项目开发后期，有些服务进行了版本升级，有些服务没有，这样当它们被打包成同一个软件包时，就会导致版本号不一致。  </p>\n<p>每个服务都指定一个版本号，对开发而言也比较麻烦。一个比较好的实践就是微服务+全局版本模式。对于经常发生功能变更、需要独立升级的服务，将其独立拆分出来进行微服务化，实现单个微服务级的打包和部署。  </p>\n<p>对于其它服务，服务框架提供全局版本功能，在 Maven组件工程开发时，只需要为整个工程配置一个版本号，该组件工程包含的所有服务都共用该版本号。如果组件工程包含的某个服务发生了版本变更，就统一升级全局版本号，其它未发生功能变更但是打包在一起的服务做级联升级。这样做的一个原因是服务被打包在一起后，无论其它服务是否需要升级，只要软件包中的一个服务发生了版本升级，其它合设的服务也必须与其一起打包升级，它们之间存在物理上的耦合，这也是为什么微服务架构提倡微服务独立打包、部署和升级的原因。</p>\n<h2 id=\"1-3-服务消费者\"><a href=\"#1-3-服务消费者\" class=\"headerlink\" title=\"1.3 服务消费者\"></a>1.3 服务消费者</h2><p>与服务提供者不同，服务消费者往往不需要指定具体依赖的服务版本，而是一版本范围，例如：version=“[1.0.1, 2.0.8]”。  </p>\n<ol>\n<li>消费者关心的是某个新特性从哪个服务版本中开始提供，它并不关系服务提供者的版本演进以及具体的版本号。</li>\n<li>消费者想使用当前环境中服务的最新版本，但不清楚具体的版本号，希望自动适配最新的服务版本。</li>\n</ol>\n<p>当然需要指定一个默认的服务提供者版本号。</p>\n<h2 id=\"1-4-基于版本号的服务路由\"><a href=\"#1-4-基于版本号的服务路由\" class=\"headerlink\" title=\"1.4 基于版本号的服务路由\"></a>1.4 基于版本号的服务路由</h2><p>服务提供者将服务注册到服务注册中心时，将服务名+服务版本号+服务分组作为路由关键信息存放到注册中心，服务消费者在发起服务调用时，除了携带服务名、方法名、参数列表之外，还需要携带要消费的服务版本信息，由路由接口负责服务版本过滤，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_1.png\" alt=\"\"></p>\n<h2 id=\"1-5-服务热升级\"><a href=\"#1-5-服务热升级\" class=\"headerlink\" title=\"1.5 服务热升级\"></a>1.5 服务热升级</h2><p>在业务不中断的情况下，实现系统的平滑升级，考虑到版本升级的风险，往往需要做多次滚动升级，最终根据升级之后新版本服务的运行状况决定是继续升级还是回退。这就意味着在同一时刻，整个集群环境中会同时存在服务的多个版本咋线运行，这就是热升级相比于传统 AB Test等升级方式的差异，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_2.png\" alt=\"\"><br>核心点如下：</p>\n<ol>\n<li>升级的节点需要重启，由于自动发现机制，停机升级的节点自动被隔离，停机并不会中断业务。</li>\n<li>服务路由规则的定制：如果是滚动式的灰度发布，在相当长的一段时间（例如一周）内线上都会存在服务的多个版本。哪些用户或者业务需要路由到新版本上，需要通过路由策略和规则进行制定，服务框架应该支持用户配置自定义的路由规则来支持灵活的路由策略。</li>\n<li>滚动升级和回退机制：为了降低服务热升级对业务的影响，同时考虑到可靠性，在实际工作中往往采用滚动升级的方式，分批次进行服务的热升级，实现敏捷的特性交付，滚动升级如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_3.png\" alt=\"\"></li>\n</ol>\n<h1 id=\"2-与-OSGI-的对比\"><a href=\"#2-与-OSGI-的对比\" class=\"headerlink\" title=\"2 与 OSGI 的对比\"></a>2 与 OSGI 的对比</h1><p>OSGI，成立于 1999年，全名原为：Open Services Gateway initiative，但现在这个全名已经废弃。<br>致力于家用设备、汽车、手机、桌面、其它环境指定下一代网络服务标准的领导者，推出了 OSGI 服务平台规范，用于提供开放和通用的架构，使得服务提供商、开发人员、软件提供商、网关操作者和设备提供商以统一的方式开发、部署和管理服务。  </p>\n<p>目前最广泛和应用是 OSGI规范5（Release 5），共由核心规范、标准服务（Standard Services）、框架服务（Framework Services）、系统服务（System Services）、协议服务（Protocol Services）、混合服务（Miscellaneous Services）等几部分共同组成。<br>核心规范通过一个分层的框架，实现了 OSGI最为成功的动态插件机制，它主要提供了：</p>\n<ol>\n<li>OSGI Bundle 的运行环境。</li>\n<li>OSGI Bundle 间的依赖管理。</li>\n<li>OSGI Bundle 的生命周期管理。</li>\n<li>OSGI 服务的动态交互模型。</li>\n</ol>\n<p>OSGI 两个最核心的特性就是模块化和热插拔机制，分布式服务框架的服务多版本管理和热升级是否可以基于 OSGI来实现？下面围绕着模块化和插件热插拔这两个特性进行详细分析。</p>\n<h2 id=\"2-1-模块化开发\"><a href=\"#2-1-模块化开发\" class=\"headerlink\" title=\"2.1 模块化开发\"></a>2.1 模块化开发</h2><p>在 OSGI中，我们以模块化的方式去开发一个系统，每个模块被称为 Bundle，OSGI 提供了对 Bundle的整个生命周期管理，包括打包、部署、运行、升级、停止等。<br>模块化的核心并不是简单地把系统拆分成不同的模块，如果仅仅是拆分，原生的 Jar包+Eclipse工程就能够解决问题。更为重要的是要考虑到模块中接口的导出、隐藏、依赖、版本管理、打包、部署、运行和升级等全生命周期管理，这些对于原生的 Jar包而言是不支持的。<br>传统开发的模块划分通常由两种方式：  </p>\n<ol>\n<li>使用 package来进行隔离。</li>\n<li>定义多个子工程，工程之间通过工程引用的方式进行依赖管理。<br>存在的问题：无法实现资源的精细划分和对依赖做统一管理。以 Jar包依赖为例，依赖一个 Jar包就意味着这个 Jar包中所有 public的资源都可能被引用，但事实上也许只需要依赖该 Jar包中的某几个 public接口。无法对资源做细粒度、精确的管控，不知道 public的接口都被哪些模块依赖和使用，消费者是谁，更为复杂的场景是如果消费者需要依赖不同的接口版本，那该肿么办？  </li>\n</ol>\n<p>OSGI 很好地解决了这个问题，每个 OSGI工程是一个标准的插件工程，实际就是一个 Bundle。实现了 package级的管理依赖关系，而 Maven则是 Jar包级的管理依赖。<br>而分布式服务：</p>\n<ol>\n<li>服务提供者通过 service export将某个服务接口发布出去，供消费者使用。</li>\n<li>服务消费者通过 service import导入某个服务接口，它不关心服务提供者的具体位置，也不关心服务的具体实现细节。<br>这样就比 OSGI的 package导入导出功能粒度更细。<br>利用 Maven的模块化管理 + 分布式服务框架自身的服务接口导入导出功能，解决了模块化开发和精细化依赖管理难题，完成可以替代 OSGI的相关功能，</li>\n</ol>\n<h2 id=\"2-2-插件热部署和热升级\"><a href=\"#2-2-插件热部署和热升级\" class=\"headerlink\" title=\"2.2 插件热部署和热升级\"></a>2.2 插件热部署和热升级</h2><p>OSGI 另外一个非常酷的特性就是动态性，即插件的热部署和热升级，它可以在不重启 JVM的情况下安装部署一个插件，实现升级不中断业务。<br>OSGI 的插件热部署和热升级原理就是基于自身的网状类加载机制实现的，下面我们分析在分布式服务框架中，如何实现服务热部署和热升级：  </p>\n<ol>\n<li>服务是分布式集群部署的，通常也是无状态的，停掉其中某一个服务节点，并不会影响系统整体的运行质量。</li>\n<li>服务自动发现和隔离机制，当有新的服务节点加入时，服务注册中心会向消费者集群推送新的服务地址信息；当有服务节点宕机或重启时，服务注册中心会发送服务下线通知消息给消费者集群，消费者会将下线服务自动隔离。</li>\n<li>优雅停机功能，在进程退出之前，处理完消息队列积压的消息，不再接受新的消息，最大限度保障丢失消息。</li>\n<li>集群容错功能，如果服务提供者正在等待应答消息时系统推出了，消费者会发生服务调用超时，集群容错功能会根据策略重试其它正常的服务节点，保证流程不会因为某个服务实例宕机而中断。</li>\n<li>服务多版本管理，支持集群中同一个服务的多个版本同时运行，支持路由规则定制，不同的消费者可以消费不同的服务版本。</li>\n</ol>\n<p>相比于 OSGI在 JVM内部通过定制类加载机制实现插件的多版本运行和升级，使用分布式服务框架自身的分布式集群特性实现服务的热部署和热升级，更加简单、灵活和可控。</p>\n<h1 id=\"3-个人总结\"><a href=\"#3-个人总结\" class=\"headerlink\" title=\"3 个人总结\"></a>3 个人总结</h1><p>服务多版本在实际项目中非常实用，用于实现服务的热部署和热升级，同时支持按照消费者做差异化路由，同时也方便演进到微服务架构，来迁移到服务的独立打包、部署、运行和运维。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>服务上线之后，由于功能变更、BUG修复，以及服务升级，需要对服务采用多版本管理。</p>\n<h1 id=\"1-服务多版本管理设计\"><a href=\"#1-服务多版本管理设计\" class=\"headerlink\" title=\"1 服务多版本管理设计\"></a>1 服务多版本管理设计</h1><p>管理的对象包括服务提供者和消费者：  </p>\n<ol>\n<li>服务提供者：发布服务的时候，支持指定服务的版本号。</li>\n<li>服务消费者：消费服务的时候，支持指定引用的服务版本号或者版本范围。</li>\n</ol>\n<h2 id=\"1-1-服务版本号管理\"><a href=\"#1-1-服务版本号管理\" class=\"headerlink\" title=\"1.1 服务版本号管理\"></a>1.1 服务版本号管理</h2><p>服务的版本号是有序的，在服务名相同的情况下，两个相同服务名的不同服务版本的版本号可以比较大小。完整的版本号由“主版本号（Major）+副版本号（Minor）+微版本号（Micro）”构成：  </p>\n<ol>\n<li>主版本号：表示重大特性或者功能变更，接口或功能可能会不兼容。</li>\n<li>副版本号：发生了少部分功能变更，或者新增了一些功能。</li>\n<li>微版本号：主要用于 BUG修改，对应于常见的 SP补丁包。</li>\n</ol>\n<h2 id=\"1-2-服务提供者\"><a href=\"#1-2-服务提供者\" class=\"headerlink\" title=\"1.2 服务提供者\"></a>1.2 服务提供者</h2><p>服务开发完成之后，需要将一个或者多个服务打包成一个 jar/war 包，为了便于对服务进行物理管理，打包后的名称中会包含服务的版本号信息，例如 com.huawei.orderService_1.0.1.jar。<br>在微服务架构中，微服务独立开发、打包、部署和升级，因此微服务的版本和软件包的版本可以一一映射。但是在实际开发中，尤其是大规模企业应用开发，单独为每个服务打包和部署目前尚未成为主流，它会增加服务软件包的管理和线上治理成本，因此目前的主流模式仍然是多个服务提供者合一个大的 jar/war 包，这就会存在一个问题：项目开发后期，有些服务进行了版本升级，有些服务没有，这样当它们被打包成同一个软件包时，就会导致版本号不一致。  </p>\n<p>每个服务都指定一个版本号，对开发而言也比较麻烦。一个比较好的实践就是微服务+全局版本模式。对于经常发生功能变更、需要独立升级的服务，将其独立拆分出来进行微服务化，实现单个微服务级的打包和部署。  </p>\n<p>对于其它服务，服务框架提供全局版本功能，在 Maven组件工程开发时，只需要为整个工程配置一个版本号，该组件工程包含的所有服务都共用该版本号。如果组件工程包含的某个服务发生了版本变更，就统一升级全局版本号，其它未发生功能变更但是打包在一起的服务做级联升级。这样做的一个原因是服务被打包在一起后，无论其它服务是否需要升级，只要软件包中的一个服务发生了版本升级，其它合设的服务也必须与其一起打包升级，它们之间存在物理上的耦合，这也是为什么微服务架构提倡微服务独立打包、部署和升级的原因。</p>\n<h2 id=\"1-3-服务消费者\"><a href=\"#1-3-服务消费者\" class=\"headerlink\" title=\"1.3 服务消费者\"></a>1.3 服务消费者</h2><p>与服务提供者不同，服务消费者往往不需要指定具体依赖的服务版本，而是一版本范围，例如：version=“[1.0.1, 2.0.8]”。  </p>\n<ol>\n<li>消费者关心的是某个新特性从哪个服务版本中开始提供，它并不关系服务提供者的版本演进以及具体的版本号。</li>\n<li>消费者想使用当前环境中服务的最新版本，但不清楚具体的版本号，希望自动适配最新的服务版本。</li>\n</ol>\n<p>当然需要指定一个默认的服务提供者版本号。</p>\n<h2 id=\"1-4-基于版本号的服务路由\"><a href=\"#1-4-基于版本号的服务路由\" class=\"headerlink\" title=\"1.4 基于版本号的服务路由\"></a>1.4 基于版本号的服务路由</h2><p>服务提供者将服务注册到服务注册中心时，将服务名+服务版本号+服务分组作为路由关键信息存放到注册中心，服务消费者在发起服务调用时，除了携带服务名、方法名、参数列表之外，还需要携带要消费的服务版本信息，由路由接口负责服务版本过滤，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_1.png\" alt=\"\"></p>\n<h2 id=\"1-5-服务热升级\"><a href=\"#1-5-服务热升级\" class=\"headerlink\" title=\"1.5 服务热升级\"></a>1.5 服务热升级</h2><p>在业务不中断的情况下，实现系统的平滑升级，考虑到版本升级的风险，往往需要做多次滚动升级，最终根据升级之后新版本服务的运行状况决定是继续升级还是回退。这就意味着在同一时刻，整个集群环境中会同时存在服务的多个版本咋线运行，这就是热升级相比于传统 AB Test等升级方式的差异，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_2.png\" alt=\"\"><br>核心点如下：</p>\n<ol>\n<li>升级的节点需要重启，由于自动发现机制，停机升级的节点自动被隔离，停机并不会中断业务。</li>\n<li>服务路由规则的定制：如果是滚动式的灰度发布，在相当长的一段时间（例如一周）内线上都会存在服务的多个版本。哪些用户或者业务需要路由到新版本上，需要通过路由策略和规则进行制定，服务框架应该支持用户配置自定义的路由规则来支持灵活的路由策略。</li>\n<li>滚动升级和回退机制：为了降低服务热升级对业务的影响，同时考虑到可靠性，在实际工作中往往采用滚动升级的方式，分批次进行服务的热升级，实现敏捷的特性交付，滚动升级如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_3.png\" alt=\"\"></li>\n</ol>\n<h1 id=\"2-与-OSGI-的对比\"><a href=\"#2-与-OSGI-的对比\" class=\"headerlink\" title=\"2 与 OSGI 的对比\"></a>2 与 OSGI 的对比</h1><p>OSGI，成立于 1999年，全名原为：Open Services Gateway initiative，但现在这个全名已经废弃。<br>致力于家用设备、汽车、手机、桌面、其它环境指定下一代网络服务标准的领导者，推出了 OSGI 服务平台规范，用于提供开放和通用的架构，使得服务提供商、开发人员、软件提供商、网关操作者和设备提供商以统一的方式开发、部署和管理服务。  </p>\n<p>目前最广泛和应用是 OSGI规范5（Release 5），共由核心规范、标准服务（Standard Services）、框架服务（Framework Services）、系统服务（System Services）、协议服务（Protocol Services）、混合服务（Miscellaneous Services）等几部分共同组成。<br>核心规范通过一个分层的框架，实现了 OSGI最为成功的动态插件机制，它主要提供了：</p>\n<ol>\n<li>OSGI Bundle 的运行环境。</li>\n<li>OSGI Bundle 间的依赖管理。</li>\n<li>OSGI Bundle 的生命周期管理。</li>\n<li>OSGI 服务的动态交互模型。</li>\n</ol>\n<p>OSGI 两个最核心的特性就是模块化和热插拔机制，分布式服务框架的服务多版本管理和热升级是否可以基于 OSGI来实现？下面围绕着模块化和插件热插拔这两个特性进行详细分析。</p>\n<h2 id=\"2-1-模块化开发\"><a href=\"#2-1-模块化开发\" class=\"headerlink\" title=\"2.1 模块化开发\"></a>2.1 模块化开发</h2><p>在 OSGI中，我们以模块化的方式去开发一个系统，每个模块被称为 Bundle，OSGI 提供了对 Bundle的整个生命周期管理，包括打包、部署、运行、升级、停止等。<br>模块化的核心并不是简单地把系统拆分成不同的模块，如果仅仅是拆分，原生的 Jar包+Eclipse工程就能够解决问题。更为重要的是要考虑到模块中接口的导出、隐藏、依赖、版本管理、打包、部署、运行和升级等全生命周期管理，这些对于原生的 Jar包而言是不支持的。<br>传统开发的模块划分通常由两种方式：  </p>\n<ol>\n<li>使用 package来进行隔离。</li>\n<li>定义多个子工程，工程之间通过工程引用的方式进行依赖管理。<br>存在的问题：无法实现资源的精细划分和对依赖做统一管理。以 Jar包依赖为例，依赖一个 Jar包就意味着这个 Jar包中所有 public的资源都可能被引用，但事实上也许只需要依赖该 Jar包中的某几个 public接口。无法对资源做细粒度、精确的管控，不知道 public的接口都被哪些模块依赖和使用，消费者是谁，更为复杂的场景是如果消费者需要依赖不同的接口版本，那该肿么办？  </li>\n</ol>\n<p>OSGI 很好地解决了这个问题，每个 OSGI工程是一个标准的插件工程，实际就是一个 Bundle。实现了 package级的管理依赖关系，而 Maven则是 Jar包级的管理依赖。<br>而分布式服务：</p>\n<ol>\n<li>服务提供者通过 service export将某个服务接口发布出去，供消费者使用。</li>\n<li>服务消费者通过 service import导入某个服务接口，它不关心服务提供者的具体位置，也不关心服务的具体实现细节。<br>这样就比 OSGI的 package导入导出功能粒度更细。<br>利用 Maven的模块化管理 + 分布式服务框架自身的服务接口导入导出功能，解决了模块化开发和精细化依赖管理难题，完成可以替代 OSGI的相关功能，</li>\n</ol>\n<h2 id=\"2-2-插件热部署和热升级\"><a href=\"#2-2-插件热部署和热升级\" class=\"headerlink\" title=\"2.2 插件热部署和热升级\"></a>2.2 插件热部署和热升级</h2><p>OSGI 另外一个非常酷的特性就是动态性，即插件的热部署和热升级，它可以在不重启 JVM的情况下安装部署一个插件，实现升级不中断业务。<br>OSGI 的插件热部署和热升级原理就是基于自身的网状类加载机制实现的，下面我们分析在分布式服务框架中，如何实现服务热部署和热升级：  </p>\n<ol>\n<li>服务是分布式集群部署的，通常也是无状态的，停掉其中某一个服务节点，并不会影响系统整体的运行质量。</li>\n<li>服务自动发现和隔离机制，当有新的服务节点加入时，服务注册中心会向消费者集群推送新的服务地址信息；当有服务节点宕机或重启时，服务注册中心会发送服务下线通知消息给消费者集群，消费者会将下线服务自动隔离。</li>\n<li>优雅停机功能，在进程退出之前，处理完消息队列积压的消息，不再接受新的消息，最大限度保障丢失消息。</li>\n<li>集群容错功能，如果服务提供者正在等待应答消息时系统推出了，消费者会发生服务调用超时，集群容错功能会根据策略重试其它正常的服务节点，保证流程不会因为某个服务实例宕机而中断。</li>\n<li>服务多版本管理，支持集群中同一个服务的多个版本同时运行，支持路由规则定制，不同的消费者可以消费不同的服务版本。</li>\n</ol>\n<p>相比于 OSGI在 JVM内部通过定制类加载机制实现插件的多版本运行和升级，使用分布式服务框架自身的分布式集群特性实现服务的热部署和热升级，更加简单、灵活和可控。</p>\n<h1 id=\"3-个人总结\"><a href=\"#3-个人总结\" class=\"headerlink\" title=\"3 个人总结\"></a>3 个人总结</h1><p>服务多版本在实际项目中非常实用，用于实现服务的热部署和热升级，同时支持按照消费者做差异化路由，同时也方便演进到微服务架构，来迁移到服务的独立打包、部署、运行和运维。</p>\n"},{"title":"十九、可靠性设计","date":"2018-06-19T17:51:00.000Z","updated":"2018-06-20T16:44:00.000Z","comments":1,"_content":"\n相对于传统的本地 Java API 调用，跨进程的分布式服务调用面临的故障风险更高：  \n1. 网络类故障：链路闪断、读写超时等。\n2. 序列化和反序列化失败。\n3. 畸形码流。\n4. 服务端流控和拥塞保护导致的服务调用失败。\n5. 其它异常。\n  \n对于应用而言，分布式服务框架需要具备足够的健壮性，在平台底层能够拦截并向上屏蔽故障，业务只需要配置容错策略，即可实现高可靠性。\n\n# 1 服务状态监测\n\n在分布式服务调用时，某个服务提供者可能已经宕机，如果采用随机路由策略，消息会继续发送给已经宕机的服务提供者，导致消息发送失败。为了保证路由的正确性，消费者需要能够实时获取服务提供者的状态，当某个服务提供者不可用时，将它从缓存的路由表中删除掉，不再向其发送消息，直到对方恢复正常。\n\n## 1.1 基于服务注册中心状态监测\n\n以 ZooKeeper 为例，ZooKeeper 服务端利用与 ZooKeeper 客户端之间的长链接会话做心跳检测。  \n![][1]\n\n## 1.2 链路有效性状态监测机制\n\n分布式服务框架的服务消费者和提供者之间默认往往采用长链接，并且通过双向心跳检测保障链路的可靠性。  \n在一些特殊的场景中，服务提供者和注册中心之间网络可达，服务消费者和注册中心网络也可达，但是服务提供者和消费者之间网络不可达，或者服务提供者和消费者之间链路已经断连。此时，服务注册中心并不能检测到服务提供者异常，但是如果消费者仍旧向链路中断的提供者发送消息，写操作将会失败。  \n  \n为了解决该问题，通常需要使用服务注册中心检测 + 服务提供者和消费者之间的链路有效性检测双重检测来保障系统的可靠性，它工作原理如下：  \n![][2]  \n当消费者通过双向心跳检测发现链路故障之后，会主动释放链接，并将对应的服务提供者从路由缓存表中删除。当链路恢复之后，重新将恢复的故障服务提供者地址信息加入地址缓存表中。\n\n# 2 服务健康度监测\n\n在集群组网环境下，由于硬件性能差异、各服务提供者的负载不均等原因，如果采用随机路由分发策略，会导致负载较重的服务提供者不堪重负被压垮。  \n利用服务的健康度监测，可以对集群的所有服务实例进行体检，根据体检加过对健康度做打分，得分较低的亚健康服务节点，路由权重会被自动调低，发送到对应节点的消息会少很多。这样实现“能者多劳、按需分配”，实现更合理的资源分配和路由调度。  \n  \n服务的健康度监测通常需要采集如下性能 KPI 指标：  \n1. 服务调用时延。\n2. 服务 QPS。\n3. 服务调用成功率。\n4. 基础资源使用情况，例如堆内存、CPU 使用率等。\n  \n原理如下：  \n![][3]\n\n# 3 服务故障隔离\n\n分为四个层次：  \n1. 进程级故障隔离\n2. VM 级故障隔离\n3. 物理机故障隔离\n4. 机房故障隔离\n\n## 3.1 进程级故障隔离\n\n个人理解为线程级。即通过将服务部署到不同的线程池实现故障隔离。对于订单、购物车等核心服务可以独立部署到一个线程池中，与其它服务做线程调度隔离。对于非核心服务，可以合设共享同一个/多个线程池，防止因为服务数过多导致线程数过度膨胀。  \n  \n服务发布的时候，可以指定服务发布到哪个线程池中，分布式服务框架拦截 Spring 容器的启动，解析 XML 标签，生成服务和线程池的映射关系，通信框架将解码后的消息投递到后端时，根据服务名选择对应的线程池，将消息投递到映射线程池的消息队列中。  \n原理图如下：  \n![][4]  \n如果故障服务发生了内存泄漏异常，它会导致整个进程不可用。\n\n## 3.2 VM 级故障隔离\n\n将基础设施层虚拟化、服务化，将应用部署到不同的 VM 中，利用 VM 对资源层的隔离，实现高层次的服务故障隔离，工作原理如下：  \n![][5]\n\n## 3.3 物理机故障隔离\n\n当组网规模足够大、硬件足够多的时候，硬件的故障就由小概率事件转变为普通事件。如何保证在物理机故障时，应用能够正常工作，是一个不小的挑战。  \n利用分布式服务框架的集群容错功能，可以实现位置无关的自动容错，工作原理如下：  \n![][6]\n  \n如果要保证当前服务器宕机时不影响部署在上面运行的服务，需要采用分布式集群部署，而且要采用非亲和性安装：即服务实例需要部署到不同的物理机上，通常至少需要 3 台物理机，假如单台物理机的故障发生概率为 0.1 %，则 3 台同时发生故障的概率为 0.001%，服务的可靠性将会达到 99.999%，完全可以满足大多数应用场景的可靠性要求。  \n物理机故障重启之后，通过扩展插件通知 Watch Dog 重新将应用拉起，应用启动时会重新发布服务，服务发布成功之后，故障服务器节点就能重新恢复正常工作。 ·`      \n## 3.4 机房故障隔离\n\n同城容灾时，都需要使用多个机房，下面针对跨机房的容灾和故障隔离方案进行探讨。  \n![][7]\n机房1 和机房2 对等部署了2套应用集群，每个机房部署一套服务注册中心集群，服务订阅和发布同时针对两个注册中心，对于机房1 或者机房2 的 Web 应用，可以同时看到两个机房的服务提供者列表。  \n理由时，优先访问同一个机房的服务提供者，当本机房的服务提供者大面积不可用或者全部不可用时，根据跨机房路由策略，访问另一个机房的服务提供者，待本机房服务提供者集群恢复到正常状态之后，重新切换到本机房访问模式。  \n当整个机房宕机之后，由前端的 SLB\\F5 负载均衡器自动将流量切换到容灾机房，由于主机房整个瘫掉了，容灾机房的消费者通过服务状态监测将主机房的所有服务提供者从路由缓存表中删除，服务调用会自动切换到本机房调用模式，实现故障的自动容灾切换。  \n  \n上面的方案需要分布式服务框架支持多注册中心，同一个服务实例，可以同时注册到多个服务注册中心中，实现跨机房的服务调用。两个机房共用一套服务注册中心也可以，但是如果服务注册中心所在的机房整个宕掉，则分布式服务框架的服务注册中心将不可用。已有的服务调用不受影响，新的依赖服务注册中心的操作江辉失败，例如服务治理、运行期参数调整、服务的状态监测等功能将不可用。\n\n# 4 其它可靠性特性\n\n## 4.1 服务注册中心\n\n服务注册中心需要采用对等集群设计，任意一台宕机之后，需要能够自动切换到下一台可用的注册中心。例如 ZooKeeper ，如果某个 Leader 节点宕机，通过选举算法会重新选举出一个新的 Leader，只要集群组网实例数不小于 3，整个集群就能够正常工作。\n\n## 4.2 监控中心\n\n监控中心集群宕机之后，只丢失部分采样数据，依赖性能 KPI 采样数据的服务健康度监测功能不能正常使用，服务提供者和消费者依然能够正常运行，业务不会中断。\n\n## 4.3 服务提供者\n\n某个服务提供者宕机之后，利用集群容错策略，会舱室不同的容错恢复手段，例如使用 FailOver 容错策略，自动切换到下一个可用的服务，直到找到可用的服务为止。  \n如果整个服务提供者集群都宕机，可以利用服务放通、故障引流、容灾切换等手段。\n\n# 5 个人总结\n\n任何假设的宕机情况都会出现，解决手段不外乎：\n1. 对等集群（例如跨机房）。\n2. 服务放通（远程错误直接切换为本地调用）。\n3. 隔离。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_5.png\n[6]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_6.png\n[7]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_7.png","source":"_posts/分布式服务框架原理与实践/第十九章 可靠性设计.md","raw":"---\ntitle: 十九、可靠性设计\ndate: 2018-06-20 01:51:00\nupdated: 2018-06-21 00:44:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/19.html    \n---\n\n相对于传统的本地 Java API 调用，跨进程的分布式服务调用面临的故障风险更高：  \n1. 网络类故障：链路闪断、读写超时等。\n2. 序列化和反序列化失败。\n3. 畸形码流。\n4. 服务端流控和拥塞保护导致的服务调用失败。\n5. 其它异常。\n  \n对于应用而言，分布式服务框架需要具备足够的健壮性，在平台底层能够拦截并向上屏蔽故障，业务只需要配置容错策略，即可实现高可靠性。\n\n# 1 服务状态监测\n\n在分布式服务调用时，某个服务提供者可能已经宕机，如果采用随机路由策略，消息会继续发送给已经宕机的服务提供者，导致消息发送失败。为了保证路由的正确性，消费者需要能够实时获取服务提供者的状态，当某个服务提供者不可用时，将它从缓存的路由表中删除掉，不再向其发送消息，直到对方恢复正常。\n\n## 1.1 基于服务注册中心状态监测\n\n以 ZooKeeper 为例，ZooKeeper 服务端利用与 ZooKeeper 客户端之间的长链接会话做心跳检测。  \n![][1]\n\n## 1.2 链路有效性状态监测机制\n\n分布式服务框架的服务消费者和提供者之间默认往往采用长链接，并且通过双向心跳检测保障链路的可靠性。  \n在一些特殊的场景中，服务提供者和注册中心之间网络可达，服务消费者和注册中心网络也可达，但是服务提供者和消费者之间网络不可达，或者服务提供者和消费者之间链路已经断连。此时，服务注册中心并不能检测到服务提供者异常，但是如果消费者仍旧向链路中断的提供者发送消息，写操作将会失败。  \n  \n为了解决该问题，通常需要使用服务注册中心检测 + 服务提供者和消费者之间的链路有效性检测双重检测来保障系统的可靠性，它工作原理如下：  \n![][2]  \n当消费者通过双向心跳检测发现链路故障之后，会主动释放链接，并将对应的服务提供者从路由缓存表中删除。当链路恢复之后，重新将恢复的故障服务提供者地址信息加入地址缓存表中。\n\n# 2 服务健康度监测\n\n在集群组网环境下，由于硬件性能差异、各服务提供者的负载不均等原因，如果采用随机路由分发策略，会导致负载较重的服务提供者不堪重负被压垮。  \n利用服务的健康度监测，可以对集群的所有服务实例进行体检，根据体检加过对健康度做打分，得分较低的亚健康服务节点，路由权重会被自动调低，发送到对应节点的消息会少很多。这样实现“能者多劳、按需分配”，实现更合理的资源分配和路由调度。  \n  \n服务的健康度监测通常需要采集如下性能 KPI 指标：  \n1. 服务调用时延。\n2. 服务 QPS。\n3. 服务调用成功率。\n4. 基础资源使用情况，例如堆内存、CPU 使用率等。\n  \n原理如下：  \n![][3]\n\n# 3 服务故障隔离\n\n分为四个层次：  \n1. 进程级故障隔离\n2. VM 级故障隔离\n3. 物理机故障隔离\n4. 机房故障隔离\n\n## 3.1 进程级故障隔离\n\n个人理解为线程级。即通过将服务部署到不同的线程池实现故障隔离。对于订单、购物车等核心服务可以独立部署到一个线程池中，与其它服务做线程调度隔离。对于非核心服务，可以合设共享同一个/多个线程池，防止因为服务数过多导致线程数过度膨胀。  \n  \n服务发布的时候，可以指定服务发布到哪个线程池中，分布式服务框架拦截 Spring 容器的启动，解析 XML 标签，生成服务和线程池的映射关系，通信框架将解码后的消息投递到后端时，根据服务名选择对应的线程池，将消息投递到映射线程池的消息队列中。  \n原理图如下：  \n![][4]  \n如果故障服务发生了内存泄漏异常，它会导致整个进程不可用。\n\n## 3.2 VM 级故障隔离\n\n将基础设施层虚拟化、服务化，将应用部署到不同的 VM 中，利用 VM 对资源层的隔离，实现高层次的服务故障隔离，工作原理如下：  \n![][5]\n\n## 3.3 物理机故障隔离\n\n当组网规模足够大、硬件足够多的时候，硬件的故障就由小概率事件转变为普通事件。如何保证在物理机故障时，应用能够正常工作，是一个不小的挑战。  \n利用分布式服务框架的集群容错功能，可以实现位置无关的自动容错，工作原理如下：  \n![][6]\n  \n如果要保证当前服务器宕机时不影响部署在上面运行的服务，需要采用分布式集群部署，而且要采用非亲和性安装：即服务实例需要部署到不同的物理机上，通常至少需要 3 台物理机，假如单台物理机的故障发生概率为 0.1 %，则 3 台同时发生故障的概率为 0.001%，服务的可靠性将会达到 99.999%，完全可以满足大多数应用场景的可靠性要求。  \n物理机故障重启之后，通过扩展插件通知 Watch Dog 重新将应用拉起，应用启动时会重新发布服务，服务发布成功之后，故障服务器节点就能重新恢复正常工作。 ·`      \n## 3.4 机房故障隔离\n\n同城容灾时，都需要使用多个机房，下面针对跨机房的容灾和故障隔离方案进行探讨。  \n![][7]\n机房1 和机房2 对等部署了2套应用集群，每个机房部署一套服务注册中心集群，服务订阅和发布同时针对两个注册中心，对于机房1 或者机房2 的 Web 应用，可以同时看到两个机房的服务提供者列表。  \n理由时，优先访问同一个机房的服务提供者，当本机房的服务提供者大面积不可用或者全部不可用时，根据跨机房路由策略，访问另一个机房的服务提供者，待本机房服务提供者集群恢复到正常状态之后，重新切换到本机房访问模式。  \n当整个机房宕机之后，由前端的 SLB\\F5 负载均衡器自动将流量切换到容灾机房，由于主机房整个瘫掉了，容灾机房的消费者通过服务状态监测将主机房的所有服务提供者从路由缓存表中删除，服务调用会自动切换到本机房调用模式，实现故障的自动容灾切换。  \n  \n上面的方案需要分布式服务框架支持多注册中心，同一个服务实例，可以同时注册到多个服务注册中心中，实现跨机房的服务调用。两个机房共用一套服务注册中心也可以，但是如果服务注册中心所在的机房整个宕掉，则分布式服务框架的服务注册中心将不可用。已有的服务调用不受影响，新的依赖服务注册中心的操作江辉失败，例如服务治理、运行期参数调整、服务的状态监测等功能将不可用。\n\n# 4 其它可靠性特性\n\n## 4.1 服务注册中心\n\n服务注册中心需要采用对等集群设计，任意一台宕机之后，需要能够自动切换到下一台可用的注册中心。例如 ZooKeeper ，如果某个 Leader 节点宕机，通过选举算法会重新选举出一个新的 Leader，只要集群组网实例数不小于 3，整个集群就能够正常工作。\n\n## 4.2 监控中心\n\n监控中心集群宕机之后，只丢失部分采样数据，依赖性能 KPI 采样数据的服务健康度监测功能不能正常使用，服务提供者和消费者依然能够正常运行，业务不会中断。\n\n## 4.3 服务提供者\n\n某个服务提供者宕机之后，利用集群容错策略，会舱室不同的容错恢复手段，例如使用 FailOver 容错策略，自动切换到下一个可用的服务，直到找到可用的服务为止。  \n如果整个服务提供者集群都宕机，可以利用服务放通、故障引流、容灾切换等手段。\n\n# 5 个人总结\n\n任何假设的宕机情况都会出现，解决手段不外乎：\n1. 对等集群（例如跨机房）。\n2. 服务放通（远程错误直接切换为本地调用）。\n3. 隔离。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_5.png\n[6]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_6.png\n[7]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_7.png","slug":"distributed_principle_prictice/19.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavg001naxs6kr6lr7nt","content":"<p>相对于传统的本地 Java API 调用，跨进程的分布式服务调用面临的故障风险更高：  </p>\n<ol>\n<li>网络类故障：链路闪断、读写超时等。</li>\n<li>序列化和反序列化失败。</li>\n<li>畸形码流。</li>\n<li>服务端流控和拥塞保护导致的服务调用失败。</li>\n<li>其它异常。</li>\n</ol>\n<p>对于应用而言，分布式服务框架需要具备足够的健壮性，在平台底层能够拦截并向上屏蔽故障，业务只需要配置容错策略，即可实现高可靠性。</p>\n<h1 id=\"1-服务状态监测\"><a href=\"#1-服务状态监测\" class=\"headerlink\" title=\"1 服务状态监测\"></a>1 服务状态监测</h1><p>在分布式服务调用时，某个服务提供者可能已经宕机，如果采用随机路由策略，消息会继续发送给已经宕机的服务提供者，导致消息发送失败。为了保证路由的正确性，消费者需要能够实时获取服务提供者的状态，当某个服务提供者不可用时，将它从缓存的路由表中删除掉，不再向其发送消息，直到对方恢复正常。</p>\n<h2 id=\"1-1-基于服务注册中心状态监测\"><a href=\"#1-1-基于服务注册中心状态监测\" class=\"headerlink\" title=\"1.1 基于服务注册中心状态监测\"></a>1.1 基于服务注册中心状态监测</h2><p>以 ZooKeeper 为例，ZooKeeper 服务端利用与 ZooKeeper 客户端之间的长链接会话做心跳检测。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_1.png\" alt=\"\"></p>\n<h2 id=\"1-2-链路有效性状态监测机制\"><a href=\"#1-2-链路有效性状态监测机制\" class=\"headerlink\" title=\"1.2 链路有效性状态监测机制\"></a>1.2 链路有效性状态监测机制</h2><p>分布式服务框架的服务消费者和提供者之间默认往往采用长链接，并且通过双向心跳检测保障链路的可靠性。<br>在一些特殊的场景中，服务提供者和注册中心之间网络可达，服务消费者和注册中心网络也可达，但是服务提供者和消费者之间网络不可达，或者服务提供者和消费者之间链路已经断连。此时，服务注册中心并不能检测到服务提供者异常，但是如果消费者仍旧向链路中断的提供者发送消息，写操作将会失败。  </p>\n<p>为了解决该问题，通常需要使用服务注册中心检测 + 服务提供者和消费者之间的链路有效性检测双重检测来保障系统的可靠性，它工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_2.png\" alt=\"\"><br>当消费者通过双向心跳检测发现链路故障之后，会主动释放链接，并将对应的服务提供者从路由缓存表中删除。当链路恢复之后，重新将恢复的故障服务提供者地址信息加入地址缓存表中。</p>\n<h1 id=\"2-服务健康度监测\"><a href=\"#2-服务健康度监测\" class=\"headerlink\" title=\"2 服务健康度监测\"></a>2 服务健康度监测</h1><p>在集群组网环境下，由于硬件性能差异、各服务提供者的负载不均等原因，如果采用随机路由分发策略，会导致负载较重的服务提供者不堪重负被压垮。<br>利用服务的健康度监测，可以对集群的所有服务实例进行体检，根据体检加过对健康度做打分，得分较低的亚健康服务节点，路由权重会被自动调低，发送到对应节点的消息会少很多。这样实现“能者多劳、按需分配”，实现更合理的资源分配和路由调度。  </p>\n<p>服务的健康度监测通常需要采集如下性能 KPI 指标：  </p>\n<ol>\n<li>服务调用时延。</li>\n<li>服务 QPS。</li>\n<li>服务调用成功率。</li>\n<li>基础资源使用情况，例如堆内存、CPU 使用率等。</li>\n</ol>\n<p>原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_3.png\" alt=\"\"></p>\n<h1 id=\"3-服务故障隔离\"><a href=\"#3-服务故障隔离\" class=\"headerlink\" title=\"3 服务故障隔离\"></a>3 服务故障隔离</h1><p>分为四个层次：  </p>\n<ol>\n<li>进程级故障隔离</li>\n<li>VM 级故障隔离</li>\n<li>物理机故障隔离</li>\n<li>机房故障隔离</li>\n</ol>\n<h2 id=\"3-1-进程级故障隔离\"><a href=\"#3-1-进程级故障隔离\" class=\"headerlink\" title=\"3.1 进程级故障隔离\"></a>3.1 进程级故障隔离</h2><p>个人理解为线程级。即通过将服务部署到不同的线程池实现故障隔离。对于订单、购物车等核心服务可以独立部署到一个线程池中，与其它服务做线程调度隔离。对于非核心服务，可以合设共享同一个/多个线程池，防止因为服务数过多导致线程数过度膨胀。  </p>\n<p>服务发布的时候，可以指定服务发布到哪个线程池中，分布式服务框架拦截 Spring 容器的启动，解析 XML 标签，生成服务和线程池的映射关系，通信框架将解码后的消息投递到后端时，根据服务名选择对应的线程池，将消息投递到映射线程池的消息队列中。<br>原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_4.png\" alt=\"\"><br>如果故障服务发生了内存泄漏异常，它会导致整个进程不可用。</p>\n<h2 id=\"3-2-VM-级故障隔离\"><a href=\"#3-2-VM-级故障隔离\" class=\"headerlink\" title=\"3.2 VM 级故障隔离\"></a>3.2 VM 级故障隔离</h2><p>将基础设施层虚拟化、服务化，将应用部署到不同的 VM 中，利用 VM 对资源层的隔离，实现高层次的服务故障隔离，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_5.png\" alt=\"\"></p>\n<h2 id=\"3-3-物理机故障隔离\"><a href=\"#3-3-物理机故障隔离\" class=\"headerlink\" title=\"3.3 物理机故障隔离\"></a>3.3 物理机故障隔离</h2><p>当组网规模足够大、硬件足够多的时候，硬件的故障就由小概率事件转变为普通事件。如何保证在物理机故障时，应用能够正常工作，是一个不小的挑战。<br>利用分布式服务框架的集群容错功能，可以实现位置无关的自动容错，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_6.png\" alt=\"\"></p>\n<p>如果要保证当前服务器宕机时不影响部署在上面运行的服务，需要采用分布式集群部署，而且要采用非亲和性安装：即服务实例需要部署到不同的物理机上，通常至少需要 3 台物理机，假如单台物理机的故障发生概率为 0.1 %，则 3 台同时发生故障的概率为 0.001%，服务的可靠性将会达到 99.999%，完全可以满足大多数应用场景的可靠性要求。<br>物理机故障重启之后，通过扩展插件通知 Watch Dog 重新将应用拉起，应用启动时会重新发布服务，服务发布成功之后，故障服务器节点就能重新恢复正常工作。 ·`      </p>\n<h2 id=\"3-4-机房故障隔离\"><a href=\"#3-4-机房故障隔离\" class=\"headerlink\" title=\"3.4 机房故障隔离\"></a>3.4 机房故障隔离</h2><p>同城容灾时，都需要使用多个机房，下面针对跨机房的容灾和故障隔离方案进行探讨。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_7.png\" alt=\"\"><br>机房1 和机房2 对等部署了2套应用集群，每个机房部署一套服务注册中心集群，服务订阅和发布同时针对两个注册中心，对于机房1 或者机房2 的 Web 应用，可以同时看到两个机房的服务提供者列表。<br>理由时，优先访问同一个机房的服务提供者，当本机房的服务提供者大面积不可用或者全部不可用时，根据跨机房路由策略，访问另一个机房的服务提供者，待本机房服务提供者集群恢复到正常状态之后，重新切换到本机房访问模式。<br>当整个机房宕机之后，由前端的 SLB\\F5 负载均衡器自动将流量切换到容灾机房，由于主机房整个瘫掉了，容灾机房的消费者通过服务状态监测将主机房的所有服务提供者从路由缓存表中删除，服务调用会自动切换到本机房调用模式，实现故障的自动容灾切换。  </p>\n<p>上面的方案需要分布式服务框架支持多注册中心，同一个服务实例，可以同时注册到多个服务注册中心中，实现跨机房的服务调用。两个机房共用一套服务注册中心也可以，但是如果服务注册中心所在的机房整个宕掉，则分布式服务框架的服务注册中心将不可用。已有的服务调用不受影响，新的依赖服务注册中心的操作江辉失败，例如服务治理、运行期参数调整、服务的状态监测等功能将不可用。</p>\n<h1 id=\"4-其它可靠性特性\"><a href=\"#4-其它可靠性特性\" class=\"headerlink\" title=\"4 其它可靠性特性\"></a>4 其它可靠性特性</h1><h2 id=\"4-1-服务注册中心\"><a href=\"#4-1-服务注册中心\" class=\"headerlink\" title=\"4.1 服务注册中心\"></a>4.1 服务注册中心</h2><p>服务注册中心需要采用对等集群设计，任意一台宕机之后，需要能够自动切换到下一台可用的注册中心。例如 ZooKeeper ，如果某个 Leader 节点宕机，通过选举算法会重新选举出一个新的 Leader，只要集群组网实例数不小于 3，整个集群就能够正常工作。</p>\n<h2 id=\"4-2-监控中心\"><a href=\"#4-2-监控中心\" class=\"headerlink\" title=\"4.2 监控中心\"></a>4.2 监控中心</h2><p>监控中心集群宕机之后，只丢失部分采样数据，依赖性能 KPI 采样数据的服务健康度监测功能不能正常使用，服务提供者和消费者依然能够正常运行，业务不会中断。</p>\n<h2 id=\"4-3-服务提供者\"><a href=\"#4-3-服务提供者\" class=\"headerlink\" title=\"4.3 服务提供者\"></a>4.3 服务提供者</h2><p>某个服务提供者宕机之后，利用集群容错策略，会舱室不同的容错恢复手段，例如使用 FailOver 容错策略，自动切换到下一个可用的服务，直到找到可用的服务为止。<br>如果整个服务提供者集群都宕机，可以利用服务放通、故障引流、容灾切换等手段。</p>\n<h1 id=\"5-个人总结\"><a href=\"#5-个人总结\" class=\"headerlink\" title=\"5 个人总结\"></a>5 个人总结</h1><p>任何假设的宕机情况都会出现，解决手段不外乎：</p>\n<ol>\n<li>对等集群（例如跨机房）。</li>\n<li>服务放通（远程错误直接切换为本地调用）。</li>\n<li>隔离。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>相对于传统的本地 Java API 调用，跨进程的分布式服务调用面临的故障风险更高：  </p>\n<ol>\n<li>网络类故障：链路闪断、读写超时等。</li>\n<li>序列化和反序列化失败。</li>\n<li>畸形码流。</li>\n<li>服务端流控和拥塞保护导致的服务调用失败。</li>\n<li>其它异常。</li>\n</ol>\n<p>对于应用而言，分布式服务框架需要具备足够的健壮性，在平台底层能够拦截并向上屏蔽故障，业务只需要配置容错策略，即可实现高可靠性。</p>\n<h1 id=\"1-服务状态监测\"><a href=\"#1-服务状态监测\" class=\"headerlink\" title=\"1 服务状态监测\"></a>1 服务状态监测</h1><p>在分布式服务调用时，某个服务提供者可能已经宕机，如果采用随机路由策略，消息会继续发送给已经宕机的服务提供者，导致消息发送失败。为了保证路由的正确性，消费者需要能够实时获取服务提供者的状态，当某个服务提供者不可用时，将它从缓存的路由表中删除掉，不再向其发送消息，直到对方恢复正常。</p>\n<h2 id=\"1-1-基于服务注册中心状态监测\"><a href=\"#1-1-基于服务注册中心状态监测\" class=\"headerlink\" title=\"1.1 基于服务注册中心状态监测\"></a>1.1 基于服务注册中心状态监测</h2><p>以 ZooKeeper 为例，ZooKeeper 服务端利用与 ZooKeeper 客户端之间的长链接会话做心跳检测。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_1.png\" alt=\"\"></p>\n<h2 id=\"1-2-链路有效性状态监测机制\"><a href=\"#1-2-链路有效性状态监测机制\" class=\"headerlink\" title=\"1.2 链路有效性状态监测机制\"></a>1.2 链路有效性状态监测机制</h2><p>分布式服务框架的服务消费者和提供者之间默认往往采用长链接，并且通过双向心跳检测保障链路的可靠性。<br>在一些特殊的场景中，服务提供者和注册中心之间网络可达，服务消费者和注册中心网络也可达，但是服务提供者和消费者之间网络不可达，或者服务提供者和消费者之间链路已经断连。此时，服务注册中心并不能检测到服务提供者异常，但是如果消费者仍旧向链路中断的提供者发送消息，写操作将会失败。  </p>\n<p>为了解决该问题，通常需要使用服务注册中心检测 + 服务提供者和消费者之间的链路有效性检测双重检测来保障系统的可靠性，它工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_2.png\" alt=\"\"><br>当消费者通过双向心跳检测发现链路故障之后，会主动释放链接，并将对应的服务提供者从路由缓存表中删除。当链路恢复之后，重新将恢复的故障服务提供者地址信息加入地址缓存表中。</p>\n<h1 id=\"2-服务健康度监测\"><a href=\"#2-服务健康度监测\" class=\"headerlink\" title=\"2 服务健康度监测\"></a>2 服务健康度监测</h1><p>在集群组网环境下，由于硬件性能差异、各服务提供者的负载不均等原因，如果采用随机路由分发策略，会导致负载较重的服务提供者不堪重负被压垮。<br>利用服务的健康度监测，可以对集群的所有服务实例进行体检，根据体检加过对健康度做打分，得分较低的亚健康服务节点，路由权重会被自动调低，发送到对应节点的消息会少很多。这样实现“能者多劳、按需分配”，实现更合理的资源分配和路由调度。  </p>\n<p>服务的健康度监测通常需要采集如下性能 KPI 指标：  </p>\n<ol>\n<li>服务调用时延。</li>\n<li>服务 QPS。</li>\n<li>服务调用成功率。</li>\n<li>基础资源使用情况，例如堆内存、CPU 使用率等。</li>\n</ol>\n<p>原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_3.png\" alt=\"\"></p>\n<h1 id=\"3-服务故障隔离\"><a href=\"#3-服务故障隔离\" class=\"headerlink\" title=\"3 服务故障隔离\"></a>3 服务故障隔离</h1><p>分为四个层次：  </p>\n<ol>\n<li>进程级故障隔离</li>\n<li>VM 级故障隔离</li>\n<li>物理机故障隔离</li>\n<li>机房故障隔离</li>\n</ol>\n<h2 id=\"3-1-进程级故障隔离\"><a href=\"#3-1-进程级故障隔离\" class=\"headerlink\" title=\"3.1 进程级故障隔离\"></a>3.1 进程级故障隔离</h2><p>个人理解为线程级。即通过将服务部署到不同的线程池实现故障隔离。对于订单、购物车等核心服务可以独立部署到一个线程池中，与其它服务做线程调度隔离。对于非核心服务，可以合设共享同一个/多个线程池，防止因为服务数过多导致线程数过度膨胀。  </p>\n<p>服务发布的时候，可以指定服务发布到哪个线程池中，分布式服务框架拦截 Spring 容器的启动，解析 XML 标签，生成服务和线程池的映射关系，通信框架将解码后的消息投递到后端时，根据服务名选择对应的线程池，将消息投递到映射线程池的消息队列中。<br>原理图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_4.png\" alt=\"\"><br>如果故障服务发生了内存泄漏异常，它会导致整个进程不可用。</p>\n<h2 id=\"3-2-VM-级故障隔离\"><a href=\"#3-2-VM-级故障隔离\" class=\"headerlink\" title=\"3.2 VM 级故障隔离\"></a>3.2 VM 级故障隔离</h2><p>将基础设施层虚拟化、服务化，将应用部署到不同的 VM 中，利用 VM 对资源层的隔离，实现高层次的服务故障隔离，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_5.png\" alt=\"\"></p>\n<h2 id=\"3-3-物理机故障隔离\"><a href=\"#3-3-物理机故障隔离\" class=\"headerlink\" title=\"3.3 物理机故障隔离\"></a>3.3 物理机故障隔离</h2><p>当组网规模足够大、硬件足够多的时候，硬件的故障就由小概率事件转变为普通事件。如何保证在物理机故障时，应用能够正常工作，是一个不小的挑战。<br>利用分布式服务框架的集群容错功能，可以实现位置无关的自动容错，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_6.png\" alt=\"\"></p>\n<p>如果要保证当前服务器宕机时不影响部署在上面运行的服务，需要采用分布式集群部署，而且要采用非亲和性安装：即服务实例需要部署到不同的物理机上，通常至少需要 3 台物理机，假如单台物理机的故障发生概率为 0.1 %，则 3 台同时发生故障的概率为 0.001%，服务的可靠性将会达到 99.999%，完全可以满足大多数应用场景的可靠性要求。<br>物理机故障重启之后，通过扩展插件通知 Watch Dog 重新将应用拉起，应用启动时会重新发布服务，服务发布成功之后，故障服务器节点就能重新恢复正常工作。 ·`      </p>\n<h2 id=\"3-4-机房故障隔离\"><a href=\"#3-4-机房故障隔离\" class=\"headerlink\" title=\"3.4 机房故障隔离\"></a>3.4 机房故障隔离</h2><p>同城容灾时，都需要使用多个机房，下面针对跨机房的容灾和故障隔离方案进行探讨。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_7.png\" alt=\"\"><br>机房1 和机房2 对等部署了2套应用集群，每个机房部署一套服务注册中心集群，服务订阅和发布同时针对两个注册中心，对于机房1 或者机房2 的 Web 应用，可以同时看到两个机房的服务提供者列表。<br>理由时，优先访问同一个机房的服务提供者，当本机房的服务提供者大面积不可用或者全部不可用时，根据跨机房路由策略，访问另一个机房的服务提供者，待本机房服务提供者集群恢复到正常状态之后，重新切换到本机房访问模式。<br>当整个机房宕机之后，由前端的 SLB\\F5 负载均衡器自动将流量切换到容灾机房，由于主机房整个瘫掉了，容灾机房的消费者通过服务状态监测将主机房的所有服务提供者从路由缓存表中删除，服务调用会自动切换到本机房调用模式，实现故障的自动容灾切换。  </p>\n<p>上面的方案需要分布式服务框架支持多注册中心，同一个服务实例，可以同时注册到多个服务注册中心中，实现跨机房的服务调用。两个机房共用一套服务注册中心也可以，但是如果服务注册中心所在的机房整个宕掉，则分布式服务框架的服务注册中心将不可用。已有的服务调用不受影响，新的依赖服务注册中心的操作江辉失败，例如服务治理、运行期参数调整、服务的状态监测等功能将不可用。</p>\n<h1 id=\"4-其它可靠性特性\"><a href=\"#4-其它可靠性特性\" class=\"headerlink\" title=\"4 其它可靠性特性\"></a>4 其它可靠性特性</h1><h2 id=\"4-1-服务注册中心\"><a href=\"#4-1-服务注册中心\" class=\"headerlink\" title=\"4.1 服务注册中心\"></a>4.1 服务注册中心</h2><p>服务注册中心需要采用对等集群设计，任意一台宕机之后，需要能够自动切换到下一台可用的注册中心。例如 ZooKeeper ，如果某个 Leader 节点宕机，通过选举算法会重新选举出一个新的 Leader，只要集群组网实例数不小于 3，整个集群就能够正常工作。</p>\n<h2 id=\"4-2-监控中心\"><a href=\"#4-2-监控中心\" class=\"headerlink\" title=\"4.2 监控中心\"></a>4.2 监控中心</h2><p>监控中心集群宕机之后，只丢失部分采样数据，依赖性能 KPI 采样数据的服务健康度监测功能不能正常使用，服务提供者和消费者依然能够正常运行，业务不会中断。</p>\n<h2 id=\"4-3-服务提供者\"><a href=\"#4-3-服务提供者\" class=\"headerlink\" title=\"4.3 服务提供者\"></a>4.3 服务提供者</h2><p>某个服务提供者宕机之后，利用集群容错策略，会舱室不同的容错恢复手段，例如使用 FailOver 容错策略，自动切换到下一个可用的服务，直到找到可用的服务为止。<br>如果整个服务提供者集群都宕机，可以利用服务放通、故障引流、容灾切换等手段。</p>\n<h1 id=\"5-个人总结\"><a href=\"#5-个人总结\" class=\"headerlink\" title=\"5 个人总结\"></a>5 个人总结</h1><p>任何假设的宕机情况都会出现，解决手段不外乎：</p>\n<ol>\n<li>对等集群（例如跨机房）。</li>\n<li>服务放通（远程错误直接切换为本地调用）。</li>\n<li>隔离。</li>\n</ol>\n"},{"title":"十一、服务灰度发布","date":"2018-06-04T15:51:00.000Z","updated":"2018-06-05T14:22:00.000Z","comments":1,"_content":"\n灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test 就是一种灰度发布方式：让一部分用户继续用 A，一部分用户开始用 B；如果用户对 B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。\n\n# 1 服务灰度发布流程设计\n\n服务灰度发布的主要作用如下：  \n1. 解决服务升级不兼容问题。\n2. 及早获得用户的意见反馈，完善产品功能，提升服务质量。\n3. 缩小服务升级所影响的用户范围，降低升级风险。\n4. 让用户及早参与产品测试，加强用户互动。\n\n## 1.1 灰度环境准备\n\n![][1]  \n1. 系统运维人员通过管理员账号登录灰度发布 Portal或者进入服务治理的灰度发布界面。\n2. 在生产环境中圈定本轮灰度发布的范围，它通常是一个应用集群，包括前后台服务，当然可能是单个服务。\n3. 将选择的服务灰度发布范围信息保存到服务注册中心，用于后续的规则下发和灰度升级历史记录查询等。\n4. 通知灰度升级查询内的服务实例下线，通常会采用优雅停机的方式让待升级的服务下线，保证升级不中断业务。\n5. 应用金城接收到优雅停机指令后，将本进程内缓存的消息处理完，然后优雅退出。\n6. 从软件仓库选择需要升级的服务安装镜像包，用于灰度环境的版本升级。\n7. 将升级包批量上传到灰度环境中，把原来的业务软件包做本地备份之后，升级服务版本。\n8. 灰度环境升级部署成功之后，返回灰度环境部署成功消息给灰度发布管理控制台，然后进行后续的灰度发布操作。\n\n## 1.2 灰度规则设置\n\n灰度环境准备完成之后，运维人员对灰度规则进行配置，灰度规则主要用于服务路由。  \n\b\b按照规则的不同，部分用户将调用老的服务，另一部分用户则会调用灰度环境中新发布的服务，常用的灰度规则分类如下：  \n1. 按照接入门户类型分类，例如网上营业厅、手机客户端、营业厅实体店、自主业务办理终端等。\n2. 按照终端类型分类，例如 Android、IOS、Windows Phone 等。\n3. 按照区域进行划分，例如东北、华北、华中等。\n4. 其它策略。\n\n![][2]\n\n## 1.3 灰度规则下发\n\n灰度规则设置完成之后，需要将规则下发给参与消费路由的软负载均衡器 SLB、Web前台和后台服务，它的处理流程如下图：  \n![][3]  \n灰度规则下发，主要由服务注册中心负责推送，推送的目标包括前端的 SLB负载均衡器、Web 前台集群和 App 后台服务集群，各节点将灰度规则缓存到本地内存中；消息或者服务路由时，通过路由插件解析灰度规则，将消息路由到指定到服务版本中。需要指出的是，灰度规则的通知范围是整个生产环境集群，包括灰度发布环境和非灰度生产环境。\n\n## 1.4 灰度路由\n\n通过 SLB定制的灰度发布插件，可以将 HTTP消息按照规则分发到不同的 Web前台；Web前台根据内置的服务框架 SDK，通过客户端灰度路由插件，解析灰度规则，将服务路由到灰度或者非灰度环境，实现服务的灰度路由。  \n灰度路由的流程如下图：  \n![][4]  \n需要指出的是，如果灰度规则解析失败，实际上就无法区分哪些服务应该路由到灰度环境，这种场景下比较合适的做法就是将服务路由到非灰度环境。如果服务提供者无法处理或者处理失败，则需要对灰度发布做回退处理，并通知所有受影响的服务消费者。\n\n## 1.5 失败回滚\n\n\b失败回滚的流程如下：  \n![][5]\n\n## 1.6 灰度发布总结\n\n灰度发布之后，需要对灰度发布之后的服务运行和运营情况进行分析，包括服务调用来源分析、服务性能 KPI数据、用户行为分析报告、用户问卷调查等，通过对这些数据进行分析来改进服务功能，完善产品，为新一轮灰度发布做铺垫。\n\n# 2 个人总结\n\n互联网产品在于不停地升级、升级，再升级，但是升级伴随着风险，新旧版本兼容的风险，用户使用习惯突然改变而造成用户流失的风险，系统宕机的风险等。为了避免这些风险，很多产品都采用了灰度发布的策略，其主要思想就是把影响集中到一个点，然后再发散到一个面，出现意外情况后就容易回退。  \n分布式服务框架支持服务的灰度发布，可以实现业务的快速试错和敏捷交付。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_5.png","source":"_posts/分布式服务框架原理与实践/第十一章 服务灰度发布.md","raw":"---\ntitle: 十一、服务灰度发布\ndate: 2018-06-04 23:51:00\nupdated: 2018-06-05 22:22:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/11.html    \n---\n\n灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test 就是一种灰度发布方式：让一部分用户继续用 A，一部分用户开始用 B；如果用户对 B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。\n\n# 1 服务灰度发布流程设计\n\n服务灰度发布的主要作用如下：  \n1. 解决服务升级不兼容问题。\n2. 及早获得用户的意见反馈，完善产品功能，提升服务质量。\n3. 缩小服务升级所影响的用户范围，降低升级风险。\n4. 让用户及早参与产品测试，加强用户互动。\n\n## 1.1 灰度环境准备\n\n![][1]  \n1. 系统运维人员通过管理员账号登录灰度发布 Portal或者进入服务治理的灰度发布界面。\n2. 在生产环境中圈定本轮灰度发布的范围，它通常是一个应用集群，包括前后台服务，当然可能是单个服务。\n3. 将选择的服务灰度发布范围信息保存到服务注册中心，用于后续的规则下发和灰度升级历史记录查询等。\n4. 通知灰度升级查询内的服务实例下线，通常会采用优雅停机的方式让待升级的服务下线，保证升级不中断业务。\n5. 应用金城接收到优雅停机指令后，将本进程内缓存的消息处理完，然后优雅退出。\n6. 从软件仓库选择需要升级的服务安装镜像包，用于灰度环境的版本升级。\n7. 将升级包批量上传到灰度环境中，把原来的业务软件包做本地备份之后，升级服务版本。\n8. 灰度环境升级部署成功之后，返回灰度环境部署成功消息给灰度发布管理控制台，然后进行后续的灰度发布操作。\n\n## 1.2 灰度规则设置\n\n灰度环境准备完成之后，运维人员对灰度规则进行配置，灰度规则主要用于服务路由。  \n\b\b按照规则的不同，部分用户将调用老的服务，另一部分用户则会调用灰度环境中新发布的服务，常用的灰度规则分类如下：  \n1. 按照接入门户类型分类，例如网上营业厅、手机客户端、营业厅实体店、自主业务办理终端等。\n2. 按照终端类型分类，例如 Android、IOS、Windows Phone 等。\n3. 按照区域进行划分，例如东北、华北、华中等。\n4. 其它策略。\n\n![][2]\n\n## 1.3 灰度规则下发\n\n灰度规则设置完成之后，需要将规则下发给参与消费路由的软负载均衡器 SLB、Web前台和后台服务，它的处理流程如下图：  \n![][3]  \n灰度规则下发，主要由服务注册中心负责推送，推送的目标包括前端的 SLB负载均衡器、Web 前台集群和 App 后台服务集群，各节点将灰度规则缓存到本地内存中；消息或者服务路由时，通过路由插件解析灰度规则，将消息路由到指定到服务版本中。需要指出的是，灰度规则的通知范围是整个生产环境集群，包括灰度发布环境和非灰度生产环境。\n\n## 1.4 灰度路由\n\n通过 SLB定制的灰度发布插件，可以将 HTTP消息按照规则分发到不同的 Web前台；Web前台根据内置的服务框架 SDK，通过客户端灰度路由插件，解析灰度规则，将服务路由到灰度或者非灰度环境，实现服务的灰度路由。  \n灰度路由的流程如下图：  \n![][4]  \n需要指出的是，如果灰度规则解析失败，实际上就无法区分哪些服务应该路由到灰度环境，这种场景下比较合适的做法就是将服务路由到非灰度环境。如果服务提供者无法处理或者处理失败，则需要对灰度发布做回退处理，并通知所有受影响的服务消费者。\n\n## 1.5 失败回滚\n\n\b失败回滚的流程如下：  \n![][5]\n\n## 1.6 灰度发布总结\n\n灰度发布之后，需要对灰度发布之后的服务运行和运营情况进行分析，包括服务调用来源分析、服务性能 KPI数据、用户行为分析报告、用户问卷调查等，通过对这些数据进行分析来改进服务功能，完善产品，为新一轮灰度发布做铺垫。\n\n# 2 个人总结\n\n互联网产品在于不停地升级、升级，再升级，但是升级伴随着风险，新旧版本兼容的风险，用户使用习惯突然改变而造成用户流失的风险，系统宕机的风险等。为了避免这些风险，很多产品都采用了灰度发布的策略，其主要思想就是把影响集中到一个点，然后再发散到一个面，出现意外情况后就容易回退。  \n分布式服务框架支持服务的灰度发布，可以实现业务的快速试错和敏捷交付。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_5.png","slug":"distributed_principle_prictice/11.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavg001paxs641jsduh5","content":"<p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test 就是一种灰度发布方式：让一部分用户继续用 A，一部分用户开始用 B；如果用户对 B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p>\n<h1 id=\"1-服务灰度发布流程设计\"><a href=\"#1-服务灰度发布流程设计\" class=\"headerlink\" title=\"1 服务灰度发布流程设计\"></a>1 服务灰度发布流程设计</h1><p>服务灰度发布的主要作用如下：  </p>\n<ol>\n<li>解决服务升级不兼容问题。</li>\n<li>及早获得用户的意见反馈，完善产品功能，提升服务质量。</li>\n<li>缩小服务升级所影响的用户范围，降低升级风险。</li>\n<li>让用户及早参与产品测试，加强用户互动。</li>\n</ol>\n<h2 id=\"1-1-灰度环境准备\"><a href=\"#1-1-灰度环境准备\" class=\"headerlink\" title=\"1.1 灰度环境准备\"></a>1.1 灰度环境准备</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_1.png\" alt=\"\">  </p>\n<ol>\n<li>系统运维人员通过管理员账号登录灰度发布 Portal或者进入服务治理的灰度发布界面。</li>\n<li>在生产环境中圈定本轮灰度发布的范围，它通常是一个应用集群，包括前后台服务，当然可能是单个服务。</li>\n<li>将选择的服务灰度发布范围信息保存到服务注册中心，用于后续的规则下发和灰度升级历史记录查询等。</li>\n<li>通知灰度升级查询内的服务实例下线，通常会采用优雅停机的方式让待升级的服务下线，保证升级不中断业务。</li>\n<li>应用金城接收到优雅停机指令后，将本进程内缓存的消息处理完，然后优雅退出。</li>\n<li>从软件仓库选择需要升级的服务安装镜像包，用于灰度环境的版本升级。</li>\n<li>将升级包批量上传到灰度环境中，把原来的业务软件包做本地备份之后，升级服务版本。</li>\n<li>灰度环境升级部署成功之后，返回灰度环境部署成功消息给灰度发布管理控制台，然后进行后续的灰度发布操作。</li>\n</ol>\n<h2 id=\"1-2-灰度规则设置\"><a href=\"#1-2-灰度规则设置\" class=\"headerlink\" title=\"1.2 灰度规则设置\"></a>1.2 灰度规则设置</h2><p>灰度环境准备完成之后，运维人员对灰度规则进行配置，灰度规则主要用于服务路由。<br>\b\b按照规则的不同，部分用户将调用老的服务，另一部分用户则会调用灰度环境中新发布的服务，常用的灰度规则分类如下：  </p>\n<ol>\n<li>按照接入门户类型分类，例如网上营业厅、手机客户端、营业厅实体店、自主业务办理终端等。</li>\n<li>按照终端类型分类，例如 Android、IOS、Windows Phone 等。</li>\n<li>按照区域进行划分，例如东北、华北、华中等。</li>\n<li>其它策略。</li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-灰度规则下发\"><a href=\"#1-3-灰度规则下发\" class=\"headerlink\" title=\"1.3 灰度规则下发\"></a>1.3 灰度规则下发</h2><p>灰度规则设置完成之后，需要将规则下发给参与消费路由的软负载均衡器 SLB、Web前台和后台服务，它的处理流程如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_3.png\" alt=\"\"><br>灰度规则下发，主要由服务注册中心负责推送，推送的目标包括前端的 SLB负载均衡器、Web 前台集群和 App 后台服务集群，各节点将灰度规则缓存到本地内存中；消息或者服务路由时，通过路由插件解析灰度规则，将消息路由到指定到服务版本中。需要指出的是，灰度规则的通知范围是整个生产环境集群，包括灰度发布环境和非灰度生产环境。</p>\n<h2 id=\"1-4-灰度路由\"><a href=\"#1-4-灰度路由\" class=\"headerlink\" title=\"1.4 灰度路由\"></a>1.4 灰度路由</h2><p>通过 SLB定制的灰度发布插件，可以将 HTTP消息按照规则分发到不同的 Web前台；Web前台根据内置的服务框架 SDK，通过客户端灰度路由插件，解析灰度规则，将服务路由到灰度或者非灰度环境，实现服务的灰度路由。<br>灰度路由的流程如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_4.png\" alt=\"\"><br>需要指出的是，如果灰度规则解析失败，实际上就无法区分哪些服务应该路由到灰度环境，这种场景下比较合适的做法就是将服务路由到非灰度环境。如果服务提供者无法处理或者处理失败，则需要对灰度发布做回退处理，并通知所有受影响的服务消费者。</p>\n<h2 id=\"1-5-失败回滚\"><a href=\"#1-5-失败回滚\" class=\"headerlink\" title=\"1.5 失败回滚\"></a>1.5 失败回滚</h2><p>\b失败回滚的流程如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_5.png\" alt=\"\"></p>\n<h2 id=\"1-6-灰度发布总结\"><a href=\"#1-6-灰度发布总结\" class=\"headerlink\" title=\"1.6 灰度发布总结\"></a>1.6 灰度发布总结</h2><p>灰度发布之后，需要对灰度发布之后的服务运行和运营情况进行分析，包括服务调用来源分析、服务性能 KPI数据、用户行为分析报告、用户问卷调查等，通过对这些数据进行分析来改进服务功能，完善产品，为新一轮灰度发布做铺垫。</p>\n<h1 id=\"2-个人总结\"><a href=\"#2-个人总结\" class=\"headerlink\" title=\"2 个人总结\"></a>2 个人总结</h1><p>互联网产品在于不停地升级、升级，再升级，但是升级伴随着风险，新旧版本兼容的风险，用户使用习惯突然改变而造成用户流失的风险，系统宕机的风险等。为了避免这些风险，很多产品都采用了灰度发布的策略，其主要思想就是把影响集中到一个点，然后再发散到一个面，出现意外情况后就容易回退。<br>分布式服务框架支持服务的灰度发布，可以实现业务的快速试错和敏捷交付。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test 就是一种灰度发布方式：让一部分用户继续用 A，一部分用户开始用 B；如果用户对 B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p>\n<h1 id=\"1-服务灰度发布流程设计\"><a href=\"#1-服务灰度发布流程设计\" class=\"headerlink\" title=\"1 服务灰度发布流程设计\"></a>1 服务灰度发布流程设计</h1><p>服务灰度发布的主要作用如下：  </p>\n<ol>\n<li>解决服务升级不兼容问题。</li>\n<li>及早获得用户的意见反馈，完善产品功能，提升服务质量。</li>\n<li>缩小服务升级所影响的用户范围，降低升级风险。</li>\n<li>让用户及早参与产品测试，加强用户互动。</li>\n</ol>\n<h2 id=\"1-1-灰度环境准备\"><a href=\"#1-1-灰度环境准备\" class=\"headerlink\" title=\"1.1 灰度环境准备\"></a>1.1 灰度环境准备</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_1.png\" alt=\"\">  </p>\n<ol>\n<li>系统运维人员通过管理员账号登录灰度发布 Portal或者进入服务治理的灰度发布界面。</li>\n<li>在生产环境中圈定本轮灰度发布的范围，它通常是一个应用集群，包括前后台服务，当然可能是单个服务。</li>\n<li>将选择的服务灰度发布范围信息保存到服务注册中心，用于后续的规则下发和灰度升级历史记录查询等。</li>\n<li>通知灰度升级查询内的服务实例下线，通常会采用优雅停机的方式让待升级的服务下线，保证升级不中断业务。</li>\n<li>应用金城接收到优雅停机指令后，将本进程内缓存的消息处理完，然后优雅退出。</li>\n<li>从软件仓库选择需要升级的服务安装镜像包，用于灰度环境的版本升级。</li>\n<li>将升级包批量上传到灰度环境中，把原来的业务软件包做本地备份之后，升级服务版本。</li>\n<li>灰度环境升级部署成功之后，返回灰度环境部署成功消息给灰度发布管理控制台，然后进行后续的灰度发布操作。</li>\n</ol>\n<h2 id=\"1-2-灰度规则设置\"><a href=\"#1-2-灰度规则设置\" class=\"headerlink\" title=\"1.2 灰度规则设置\"></a>1.2 灰度规则设置</h2><p>灰度环境准备完成之后，运维人员对灰度规则进行配置，灰度规则主要用于服务路由。<br>\b\b按照规则的不同，部分用户将调用老的服务，另一部分用户则会调用灰度环境中新发布的服务，常用的灰度规则分类如下：  </p>\n<ol>\n<li>按照接入门户类型分类，例如网上营业厅、手机客户端、营业厅实体店、自主业务办理终端等。</li>\n<li>按照终端类型分类，例如 Android、IOS、Windows Phone 等。</li>\n<li>按照区域进行划分，例如东北、华北、华中等。</li>\n<li>其它策略。</li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-灰度规则下发\"><a href=\"#1-3-灰度规则下发\" class=\"headerlink\" title=\"1.3 灰度规则下发\"></a>1.3 灰度规则下发</h2><p>灰度规则设置完成之后，需要将规则下发给参与消费路由的软负载均衡器 SLB、Web前台和后台服务，它的处理流程如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_3.png\" alt=\"\"><br>灰度规则下发，主要由服务注册中心负责推送，推送的目标包括前端的 SLB负载均衡器、Web 前台集群和 App 后台服务集群，各节点将灰度规则缓存到本地内存中；消息或者服务路由时，通过路由插件解析灰度规则，将消息路由到指定到服务版本中。需要指出的是，灰度规则的通知范围是整个生产环境集群，包括灰度发布环境和非灰度生产环境。</p>\n<h2 id=\"1-4-灰度路由\"><a href=\"#1-4-灰度路由\" class=\"headerlink\" title=\"1.4 灰度路由\"></a>1.4 灰度路由</h2><p>通过 SLB定制的灰度发布插件，可以将 HTTP消息按照规则分发到不同的 Web前台；Web前台根据内置的服务框架 SDK，通过客户端灰度路由插件，解析灰度规则，将服务路由到灰度或者非灰度环境，实现服务的灰度路由。<br>灰度路由的流程如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_4.png\" alt=\"\"><br>需要指出的是，如果灰度规则解析失败，实际上就无法区分哪些服务应该路由到灰度环境，这种场景下比较合适的做法就是将服务路由到非灰度环境。如果服务提供者无法处理或者处理失败，则需要对灰度发布做回退处理，并通知所有受影响的服务消费者。</p>\n<h2 id=\"1-5-失败回滚\"><a href=\"#1-5-失败回滚\" class=\"headerlink\" title=\"1.5 失败回滚\"></a>1.5 失败回滚</h2><p>\b失败回滚的流程如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_5.png\" alt=\"\"></p>\n<h2 id=\"1-6-灰度发布总结\"><a href=\"#1-6-灰度发布总结\" class=\"headerlink\" title=\"1.6 灰度发布总结\"></a>1.6 灰度发布总结</h2><p>灰度发布之后，需要对灰度发布之后的服务运行和运营情况进行分析，包括服务调用来源分析、服务性能 KPI数据、用户行为分析报告、用户问卷调查等，通过对这些数据进行分析来改进服务功能，完善产品，为新一轮灰度发布做铺垫。</p>\n<h1 id=\"2-个人总结\"><a href=\"#2-个人总结\" class=\"headerlink\" title=\"2 个人总结\"></a>2 个人总结</h1><p>互联网产品在于不停地升级、升级，再升级，但是升级伴随着风险，新旧版本兼容的风险，用户使用习惯突然改变而造成用户流失的风险，系统宕机的风险等。为了避免这些风险，很多产品都采用了灰度发布的策略，其主要思想就是把影响集中到一个点，然后再发散到一个面，出现意外情况后就容易回退。<br>分布式服务框架支持服务的灰度发布，可以实现业务的快速试错和敏捷交付。</p>\n"},{"title":"十二、参数传递","date":"2018-06-05T14:28:00.000Z","updated":"2018-06-06T13:24:00.000Z","comments":1,"_content":"\n服务消费者和提供者之间进行通信时，除了接口定义的请求参数，往往还需要携带一些额外参数，例如消费提供者的 IP地址、消息调用链的跟踪 ID等；这些参数不能通过业务接口来进行传递，需要底层的分布式服务框架支持这种参数传递方式。\n\n# 1 内部参数\n\n## 1.1 业务内部参数传递\n\n1. 硬编码，在业务逻辑中进行 API调用，参数通过 API接口进行引用传参。\n2. 业务编排引擎对业务流程进行编排，参数往往通过抽象的编排上下文进行传递。\n3. 通过专业的 BPM流程引擎进行业务逻辑编排，参数通过流程上下文进行传递。\n  \n硬编码通常会直接通过方法参数进行参数传递，如下图：  \n![][1]  \n还有一种比较常用的方法就是通过线程上下文进行参数传递。通常情况下业务逻辑处理过程很少发生线程切换，因此通过线程上下文进行隐式传参可以不与某个具体方法接口耦合，对业务解耦接口没有侵入性。例如 Spring 的资源和事务线程绑定机制，利用的就是 JDK 提供的线程上下文。使用线程上下文传参是一种隐式传参，上面的方法调用可以简化成如下图：  \n![][2]  \n最后一种方式就是 BPM流程引擎，流程引擎通过流程上下文进行参数传递，用户可以在流程编排界面声明流程级参数和全局参数，流程引擎通过流程上下文进行参数传递。\n\n## 1.2 服务框架内部参数擦混地\n\n服务框架内部由多个模块组成，模块之间的调用通常会发生线程切换；另外，当服务框架通过反射调用服务接口实现类时，也需要向业务代码传递一些额外的参数，这些参数如何传递？下面我们分别对这两类场景进行分析：  \n1. 通信框架将数据报反序列化成业务请求对象之后，需要将消息封装成 Task，丢到后面的业务线程池中执行，此时会发生线程切换，如下图：  \n![][4]\n由于发生了线程切换，如果通过线程变量的方式传递参数，需要遍历线程上下文，将线程变量复制到业务线程池的线程变量中，非常麻烦。如果后续新增系统参数，往往会忘记复制，导致参数不一致。  \n这种场景中，一般会选择通过消息上下文进行参数传递，例如在业务请求参数中定义了 Map 扩展参数，用于跨线程的参数传递。  \n2. 当服务框架回调业务接口实现类时，由于是通过反射调用，业务接口的参数已经定义好了，无法传递其它参数（例如消费者的 IP地址、调用链 ID等参数）。为了解决这个问题，需要利用线程变量，因为平台调用服务实现类不会发生线程切换，所以通过线程变量传参是安全的。\n\n# 2 外部参数\n\n主要用途：\n1. 服务框架自身的参数传递，例如分布式事务中事务上下文信息传递。\n2. 业务之间的参数传递，例如业务调用链 ID的传递，用于唯一表示某个完整业务流程。\n\n## 2.1 通信协议支持\n\n消费者的自定义参数传递到服务端，需要有一个载体，它就是通信协议。一个设计良好的协议，往往支持用户自定义扩展消息头，在协议消息头中，可以预留一个 Map<String, byte[]> 类型的字段，用于服务框架或者用户自定义参数扩展。\n\n## 2.2 传参接口定义\n\n服务框架需要提供参数设置 API接口，用于业务跨进程的参数传递。建议使用线程变量，例如平台定义一个 RPCContext 线程变量供业务传参使用。  \n服务框架在业务请求参数传递到通信框架时，需要遍历 RPCContext，将框架和业务设置的参数复制到通信线程中，由通信线程在序列化时将请求参数设置到消息头中，传递到通信对端，如下图：  \n![][5]\n\n# 3 最佳实践\n\n## 3.1 防止参数互相覆盖\n\n由于使用的是 Map 或线程变量，因此需要防止参数互相覆盖：  \n1. 服务框架系统参数和业务参数的互相覆盖。\n2. 业务之间的参数覆盖。\n  \n一些系统参数往往默认会被平台占用，例如 IP、timeStamp、Host、ServiceName、Group 等常见字段。因此系统平台需要规范，对于业务来说需要有一个全局的业务传参规则。\n\n## 3.2 参数声明周期管理\n\n预防内存泄漏！通常，服务框架能对参数生命周期进行自动管理，例如对于服务端，服务调用前设置参数，服务调用后清空参数。  \n但是对于消费者比较复杂，如果在将参数序列化到请求头发送之后自动清空参数，后续应答返回之后消费者可能需要继续访问之前的参数，但是有可能后续不使用该参数或者忘记删除该参数就会导致参数堆积。如果参数名每次都不同，则会发生内存泄漏。  \n  \n最好的方式就是平台的提供一个删除模式参数的 API，允许用户手动删除，如果用户不指定就自动删除。\n\n# 4 个人总结\n\n参数传递涉及到上下文、通信框架的线程切换、以及自动删除的自动管理等，而服务框架需要提供不同的参数传递模式以适应业务。\n\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_2.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_5.png","source":"_posts/分布式服务框架原理与实践/第十二章 参数传递.md","raw":"---\ntitle: 十二、参数传递\ndate: 2018-06-05 22:28:00\nupdated: 2018-06-06 21:24:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/12.html    \n---\n\n服务消费者和提供者之间进行通信时，除了接口定义的请求参数，往往还需要携带一些额外参数，例如消费提供者的 IP地址、消息调用链的跟踪 ID等；这些参数不能通过业务接口来进行传递，需要底层的分布式服务框架支持这种参数传递方式。\n\n# 1 内部参数\n\n## 1.1 业务内部参数传递\n\n1. 硬编码，在业务逻辑中进行 API调用，参数通过 API接口进行引用传参。\n2. 业务编排引擎对业务流程进行编排，参数往往通过抽象的编排上下文进行传递。\n3. 通过专业的 BPM流程引擎进行业务逻辑编排，参数通过流程上下文进行传递。\n  \n硬编码通常会直接通过方法参数进行参数传递，如下图：  \n![][1]  \n还有一种比较常用的方法就是通过线程上下文进行参数传递。通常情况下业务逻辑处理过程很少发生线程切换，因此通过线程上下文进行隐式传参可以不与某个具体方法接口耦合，对业务解耦接口没有侵入性。例如 Spring 的资源和事务线程绑定机制，利用的就是 JDK 提供的线程上下文。使用线程上下文传参是一种隐式传参，上面的方法调用可以简化成如下图：  \n![][2]  \n最后一种方式就是 BPM流程引擎，流程引擎通过流程上下文进行参数传递，用户可以在流程编排界面声明流程级参数和全局参数，流程引擎通过流程上下文进行参数传递。\n\n## 1.2 服务框架内部参数擦混地\n\n服务框架内部由多个模块组成，模块之间的调用通常会发生线程切换；另外，当服务框架通过反射调用服务接口实现类时，也需要向业务代码传递一些额外的参数，这些参数如何传递？下面我们分别对这两类场景进行分析：  \n1. 通信框架将数据报反序列化成业务请求对象之后，需要将消息封装成 Task，丢到后面的业务线程池中执行，此时会发生线程切换，如下图：  \n![][4]\n由于发生了线程切换，如果通过线程变量的方式传递参数，需要遍历线程上下文，将线程变量复制到业务线程池的线程变量中，非常麻烦。如果后续新增系统参数，往往会忘记复制，导致参数不一致。  \n这种场景中，一般会选择通过消息上下文进行参数传递，例如在业务请求参数中定义了 Map 扩展参数，用于跨线程的参数传递。  \n2. 当服务框架回调业务接口实现类时，由于是通过反射调用，业务接口的参数已经定义好了，无法传递其它参数（例如消费者的 IP地址、调用链 ID等参数）。为了解决这个问题，需要利用线程变量，因为平台调用服务实现类不会发生线程切换，所以通过线程变量传参是安全的。\n\n# 2 外部参数\n\n主要用途：\n1. 服务框架自身的参数传递，例如分布式事务中事务上下文信息传递。\n2. 业务之间的参数传递，例如业务调用链 ID的传递，用于唯一表示某个完整业务流程。\n\n## 2.1 通信协议支持\n\n消费者的自定义参数传递到服务端，需要有一个载体，它就是通信协议。一个设计良好的协议，往往支持用户自定义扩展消息头，在协议消息头中，可以预留一个 Map<String, byte[]> 类型的字段，用于服务框架或者用户自定义参数扩展。\n\n## 2.2 传参接口定义\n\n服务框架需要提供参数设置 API接口，用于业务跨进程的参数传递。建议使用线程变量，例如平台定义一个 RPCContext 线程变量供业务传参使用。  \n服务框架在业务请求参数传递到通信框架时，需要遍历 RPCContext，将框架和业务设置的参数复制到通信线程中，由通信线程在序列化时将请求参数设置到消息头中，传递到通信对端，如下图：  \n![][5]\n\n# 3 最佳实践\n\n## 3.1 防止参数互相覆盖\n\n由于使用的是 Map 或线程变量，因此需要防止参数互相覆盖：  \n1. 服务框架系统参数和业务参数的互相覆盖。\n2. 业务之间的参数覆盖。\n  \n一些系统参数往往默认会被平台占用，例如 IP、timeStamp、Host、ServiceName、Group 等常见字段。因此系统平台需要规范，对于业务来说需要有一个全局的业务传参规则。\n\n## 3.2 参数声明周期管理\n\n预防内存泄漏！通常，服务框架能对参数生命周期进行自动管理，例如对于服务端，服务调用前设置参数，服务调用后清空参数。  \n但是对于消费者比较复杂，如果在将参数序列化到请求头发送之后自动清空参数，后续应答返回之后消费者可能需要继续访问之前的参数，但是有可能后续不使用该参数或者忘记删除该参数就会导致参数堆积。如果参数名每次都不同，则会发生内存泄漏。  \n  \n最好的方式就是平台的提供一个删除模式参数的 API，允许用户手动删除，如果用户不指定就自动删除。\n\n# 4 个人总结\n\n参数传递涉及到上下文、通信框架的线程切换、以及自动删除的自动管理等，而服务框架需要提供不同的参数传递模式以适应业务。\n\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_2.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_5.png","slug":"distributed_principle_prictice/12.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavi001saxs6dncmqtkx","content":"<p>服务消费者和提供者之间进行通信时，除了接口定义的请求参数，往往还需要携带一些额外参数，例如消费提供者的 IP地址、消息调用链的跟踪 ID等；这些参数不能通过业务接口来进行传递，需要底层的分布式服务框架支持这种参数传递方式。</p>\n<h1 id=\"1-内部参数\"><a href=\"#1-内部参数\" class=\"headerlink\" title=\"1 内部参数\"></a>1 内部参数</h1><h2 id=\"1-1-业务内部参数传递\"><a href=\"#1-1-业务内部参数传递\" class=\"headerlink\" title=\"1.1 业务内部参数传递\"></a>1.1 业务内部参数传递</h2><ol>\n<li>硬编码，在业务逻辑中进行 API调用，参数通过 API接口进行引用传参。</li>\n<li>业务编排引擎对业务流程进行编排，参数往往通过抽象的编排上下文进行传递。</li>\n<li>通过专业的 BPM流程引擎进行业务逻辑编排，参数通过流程上下文进行传递。</li>\n</ol>\n<p>硬编码通常会直接通过方法参数进行参数传递，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_1.png\" alt=\"\"><br>还有一种比较常用的方法就是通过线程上下文进行参数传递。通常情况下业务逻辑处理过程很少发生线程切换，因此通过线程上下文进行隐式传参可以不与某个具体方法接口耦合，对业务解耦接口没有侵入性。例如 Spring 的资源和事务线程绑定机制，利用的就是 JDK 提供的线程上下文。使用线程上下文传参是一种隐式传参，上面的方法调用可以简化成如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_2.png\" alt=\"\"><br>最后一种方式就是 BPM流程引擎，流程引擎通过流程上下文进行参数传递，用户可以在流程编排界面声明流程级参数和全局参数，流程引擎通过流程上下文进行参数传递。</p>\n<h2 id=\"1-2-服务框架内部参数擦混地\"><a href=\"#1-2-服务框架内部参数擦混地\" class=\"headerlink\" title=\"1.2 服务框架内部参数擦混地\"></a>1.2 服务框架内部参数擦混地</h2><p>服务框架内部由多个模块组成，模块之间的调用通常会发生线程切换；另外，当服务框架通过反射调用服务接口实现类时，也需要向业务代码传递一些额外的参数，这些参数如何传递？下面我们分别对这两类场景进行分析：  </p>\n<ol>\n<li>通信框架将数据报反序列化成业务请求对象之后，需要将消息封装成 Task，丢到后面的业务线程池中执行，此时会发生线程切换，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_4.png\" alt=\"\"><br>由于发生了线程切换，如果通过线程变量的方式传递参数，需要遍历线程上下文，将线程变量复制到业务线程池的线程变量中，非常麻烦。如果后续新增系统参数，往往会忘记复制，导致参数不一致。<br>这种场景中，一般会选择通过消息上下文进行参数传递，例如在业务请求参数中定义了 Map 扩展参数，用于跨线程的参数传递。  </li>\n<li>当服务框架回调业务接口实现类时，由于是通过反射调用，业务接口的参数已经定义好了，无法传递其它参数（例如消费者的 IP地址、调用链 ID等参数）。为了解决这个问题，需要利用线程变量，因为平台调用服务实现类不会发生线程切换，所以通过线程变量传参是安全的。</li>\n</ol>\n<h1 id=\"2-外部参数\"><a href=\"#2-外部参数\" class=\"headerlink\" title=\"2 外部参数\"></a>2 外部参数</h1><p>主要用途：</p>\n<ol>\n<li>服务框架自身的参数传递，例如分布式事务中事务上下文信息传递。</li>\n<li>业务之间的参数传递，例如业务调用链 ID的传递，用于唯一表示某个完整业务流程。</li>\n</ol>\n<h2 id=\"2-1-通信协议支持\"><a href=\"#2-1-通信协议支持\" class=\"headerlink\" title=\"2.1 通信协议支持\"></a>2.1 通信协议支持</h2><p>消费者的自定义参数传递到服务端，需要有一个载体，它就是通信协议。一个设计良好的协议，往往支持用户自定义扩展消息头，在协议消息头中，可以预留一个 Map&lt;String, byte[]&gt; 类型的字段，用于服务框架或者用户自定义参数扩展。</p>\n<h2 id=\"2-2-传参接口定义\"><a href=\"#2-2-传参接口定义\" class=\"headerlink\" title=\"2.2 传参接口定义\"></a>2.2 传参接口定义</h2><p>服务框架需要提供参数设置 API接口，用于业务跨进程的参数传递。建议使用线程变量，例如平台定义一个 RPCContext 线程变量供业务传参使用。<br>服务框架在业务请求参数传递到通信框架时，需要遍历 RPCContext，将框架和业务设置的参数复制到通信线程中，由通信线程在序列化时将请求参数设置到消息头中，传递到通信对端，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_5.png\" alt=\"\"></p>\n<h1 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3 最佳实践\"></a>3 最佳实践</h1><h2 id=\"3-1-防止参数互相覆盖\"><a href=\"#3-1-防止参数互相覆盖\" class=\"headerlink\" title=\"3.1 防止参数互相覆盖\"></a>3.1 防止参数互相覆盖</h2><p>由于使用的是 Map 或线程变量，因此需要防止参数互相覆盖：  </p>\n<ol>\n<li>服务框架系统参数和业务参数的互相覆盖。</li>\n<li>业务之间的参数覆盖。</li>\n</ol>\n<p>一些系统参数往往默认会被平台占用，例如 IP、timeStamp、Host、ServiceName、Group 等常见字段。因此系统平台需要规范，对于业务来说需要有一个全局的业务传参规则。</p>\n<h2 id=\"3-2-参数声明周期管理\"><a href=\"#3-2-参数声明周期管理\" class=\"headerlink\" title=\"3.2 参数声明周期管理\"></a>3.2 参数声明周期管理</h2><p>预防内存泄漏！通常，服务框架能对参数生命周期进行自动管理，例如对于服务端，服务调用前设置参数，服务调用后清空参数。<br>但是对于消费者比较复杂，如果在将参数序列化到请求头发送之后自动清空参数，后续应答返回之后消费者可能需要继续访问之前的参数，但是有可能后续不使用该参数或者忘记删除该参数就会导致参数堆积。如果参数名每次都不同，则会发生内存泄漏。  </p>\n<p>最好的方式就是平台的提供一个删除模式参数的 API，允许用户手动删除，如果用户不指定就自动删除。</p>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>参数传递涉及到上下文、通信框架的线程切换、以及自动删除的自动管理等，而服务框架需要提供不同的参数传递模式以适应业务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>服务消费者和提供者之间进行通信时，除了接口定义的请求参数，往往还需要携带一些额外参数，例如消费提供者的 IP地址、消息调用链的跟踪 ID等；这些参数不能通过业务接口来进行传递，需要底层的分布式服务框架支持这种参数传递方式。</p>\n<h1 id=\"1-内部参数\"><a href=\"#1-内部参数\" class=\"headerlink\" title=\"1 内部参数\"></a>1 内部参数</h1><h2 id=\"1-1-业务内部参数传递\"><a href=\"#1-1-业务内部参数传递\" class=\"headerlink\" title=\"1.1 业务内部参数传递\"></a>1.1 业务内部参数传递</h2><ol>\n<li>硬编码，在业务逻辑中进行 API调用，参数通过 API接口进行引用传参。</li>\n<li>业务编排引擎对业务流程进行编排，参数往往通过抽象的编排上下文进行传递。</li>\n<li>通过专业的 BPM流程引擎进行业务逻辑编排，参数通过流程上下文进行传递。</li>\n</ol>\n<p>硬编码通常会直接通过方法参数进行参数传递，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_1.png\" alt=\"\"><br>还有一种比较常用的方法就是通过线程上下文进行参数传递。通常情况下业务逻辑处理过程很少发生线程切换，因此通过线程上下文进行隐式传参可以不与某个具体方法接口耦合，对业务解耦接口没有侵入性。例如 Spring 的资源和事务线程绑定机制，利用的就是 JDK 提供的线程上下文。使用线程上下文传参是一种隐式传参，上面的方法调用可以简化成如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_2.png\" alt=\"\"><br>最后一种方式就是 BPM流程引擎，流程引擎通过流程上下文进行参数传递，用户可以在流程编排界面声明流程级参数和全局参数，流程引擎通过流程上下文进行参数传递。</p>\n<h2 id=\"1-2-服务框架内部参数擦混地\"><a href=\"#1-2-服务框架内部参数擦混地\" class=\"headerlink\" title=\"1.2 服务框架内部参数擦混地\"></a>1.2 服务框架内部参数擦混地</h2><p>服务框架内部由多个模块组成，模块之间的调用通常会发生线程切换；另外，当服务框架通过反射调用服务接口实现类时，也需要向业务代码传递一些额外的参数，这些参数如何传递？下面我们分别对这两类场景进行分析：  </p>\n<ol>\n<li>通信框架将数据报反序列化成业务请求对象之后，需要将消息封装成 Task，丢到后面的业务线程池中执行，此时会发生线程切换，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_4.png\" alt=\"\"><br>由于发生了线程切换，如果通过线程变量的方式传递参数，需要遍历线程上下文，将线程变量复制到业务线程池的线程变量中，非常麻烦。如果后续新增系统参数，往往会忘记复制，导致参数不一致。<br>这种场景中，一般会选择通过消息上下文进行参数传递，例如在业务请求参数中定义了 Map 扩展参数，用于跨线程的参数传递。  </li>\n<li>当服务框架回调业务接口实现类时，由于是通过反射调用，业务接口的参数已经定义好了，无法传递其它参数（例如消费者的 IP地址、调用链 ID等参数）。为了解决这个问题，需要利用线程变量，因为平台调用服务实现类不会发生线程切换，所以通过线程变量传参是安全的。</li>\n</ol>\n<h1 id=\"2-外部参数\"><a href=\"#2-外部参数\" class=\"headerlink\" title=\"2 外部参数\"></a>2 外部参数</h1><p>主要用途：</p>\n<ol>\n<li>服务框架自身的参数传递，例如分布式事务中事务上下文信息传递。</li>\n<li>业务之间的参数传递，例如业务调用链 ID的传递，用于唯一表示某个完整业务流程。</li>\n</ol>\n<h2 id=\"2-1-通信协议支持\"><a href=\"#2-1-通信协议支持\" class=\"headerlink\" title=\"2.1 通信协议支持\"></a>2.1 通信协议支持</h2><p>消费者的自定义参数传递到服务端，需要有一个载体，它就是通信协议。一个设计良好的协议，往往支持用户自定义扩展消息头，在协议消息头中，可以预留一个 Map&lt;String, byte[]&gt; 类型的字段，用于服务框架或者用户自定义参数扩展。</p>\n<h2 id=\"2-2-传参接口定义\"><a href=\"#2-2-传参接口定义\" class=\"headerlink\" title=\"2.2 传参接口定义\"></a>2.2 传参接口定义</h2><p>服务框架需要提供参数设置 API接口，用于业务跨进程的参数传递。建议使用线程变量，例如平台定义一个 RPCContext 线程变量供业务传参使用。<br>服务框架在业务请求参数传递到通信框架时，需要遍历 RPCContext，将框架和业务设置的参数复制到通信线程中，由通信线程在序列化时将请求参数设置到消息头中，传递到通信对端，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_5.png\" alt=\"\"></p>\n<h1 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3 最佳实践\"></a>3 最佳实践</h1><h2 id=\"3-1-防止参数互相覆盖\"><a href=\"#3-1-防止参数互相覆盖\" class=\"headerlink\" title=\"3.1 防止参数互相覆盖\"></a>3.1 防止参数互相覆盖</h2><p>由于使用的是 Map 或线程变量，因此需要防止参数互相覆盖：  </p>\n<ol>\n<li>服务框架系统参数和业务参数的互相覆盖。</li>\n<li>业务之间的参数覆盖。</li>\n</ol>\n<p>一些系统参数往往默认会被平台占用，例如 IP、timeStamp、Host、ServiceName、Group 等常见字段。因此系统平台需要规范，对于业务来说需要有一个全局的业务传参规则。</p>\n<h2 id=\"3-2-参数声明周期管理\"><a href=\"#3-2-参数声明周期管理\" class=\"headerlink\" title=\"3.2 参数声明周期管理\"></a>3.2 参数声明周期管理</h2><p>预防内存泄漏！通常，服务框架能对参数生命周期进行自动管理，例如对于服务端，服务调用前设置参数，服务调用后清空参数。<br>但是对于消费者比较复杂，如果在将参数序列化到请求头发送之后自动清空参数，后续应答返回之后消费者可能需要继续访问之前的参数，但是有可能后续不使用该参数或者忘记删除该参数就会导致参数堆积。如果参数名每次都不同，则会发生内存泄漏。  </p>\n<p>最好的方式就是平台的提供一个删除模式参数的 API，允许用户手动删除，如果用户不指定就自动删除。</p>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>参数传递涉及到上下文、通信框架的线程切换、以及自动删除的自动管理等，而服务框架需要提供不同的参数传递模式以适应业务。</p>\n"},{"title":"十八、分布式消息跟踪","date":"2018-06-14T16:38:00.000Z","updated":"2018-06-19T17:51:00.000Z","comments":1,"_content":"\n随着业务分布式架构的发展，系统间的系统调用日趋复杂，以电商的商品购买为例，前台界面的购买操作设计到底层上百次服务调用，涉及到的中间件包括：  \n1. 分布式服务框架\n2. 消息队列\n3. 分布式缓存\n4. 分布式数据访问中间件\n5. 分布式文件存储系统\n6. 分布式日志采集\n7. 其它......\n\n如果无法有效清理后端的分布式调用和依赖关系，故障定界将会非常困难。利用分布式消息跟踪系统可以有效解决服务化之后系统面临的运维挑战，提高运维效率。\n\n# 1 业务场景分析\n\n以下为分布式调用示意图：  \n![][1]\n\n## 1.1 故障的快速定界定位\n\n传统应用软件发生故障时，往往通过接口日志手工从故障节点采集日志进行问题分析定位，分布式服务化之后，一次业务调用可能涉及到后台上百次服务调用，每个服务又是集群组网，传统人工到各个服务节点人肉搜索的方式效率很低。  \n希望能够通过调用链跟踪，将一次业务调用的完整轨迹以调用链的形式展示出来，通过图形化界面查看每次服务调用结果，以及故障信息。  \n  \n通过在业务日志中增加调用链 ID ，可以实现业务日志和调用链的动态关联。通过调用链进行快速故障定界，然后通过 ID 关联查询，可以快速定位到业务日志相关信息。\n\n## 1.2 调用路径分析\n\n通过对调用链调用路径的分析，可以识别应用的关键路径：应用被调用得最多的入口、服务是哪些，找出服务的热点、耗时瓶颈和易故障点。同时为性能优化、容量规划等提供数据支撑。  \n![][2]\n\n## 1.3 调用来源和去向分析\n\n通过调用去向分析，可以对服务的依赖关系进行梳理：  \n1. 应用直接和间接依赖了哪些服务。\n2. 各层次依赖的调用时延、QPS、成功率等性能 KPI指标。\n3. 识别不合理的强依赖，或者冗余依赖，反向要求开发进行依赖解耦和优化。  \n  \n通过对调用来源进行 TOP排序，识别当前服务的消费来源，以及获取各消费者的 QPS、平均时延、出错率等，针对特定的消费者，可以做针对性治理，例如针对某个消费者的限流降级、路由策略修改等，保障服务的 SLA。  \n![][3]\n\n# 2 分布式消息跟踪系统设计\n\n消息跟踪系统的核心就是调用链：每次业务请求都生成一个全局唯一的 TraceID,通过跟踪 ID将不同节点间的日志串接起来，形成一个完整的日志调用链，通过对调用链日志做实时采集、汇总和大数据分析，提取各种维度的价值数据，为系统运维和运营提供大数据支撑。\n\n## 2.1 系统架构\n\n分布式消息跟踪系统的整体架构如下，由四部分组成：  \n![][4]\n\n1. 调用链埋点日志生成\n2. 分布式采集和存储埋点日志\n3. 在线、离线大数据计算，对调用链数据进行分析和汇总\n4. 调用链的界面展示、排序和检索等\n\n## 2.2 埋点日志\n\n埋点就是分布式消息跟踪系统在当前节点的上下文信息，埋点可以分为两类：  \n1. 客户端埋点，客户端发送请求消息时生成的调用上下文，通常包括 TraceID、调用方 IP、调用方接口或者业务名称、调用的发起时间、被调用的服务名、方法名、IP 地址和端口等信息。\n2. 服务端埋点，服务端返回应答消息时在当前节点生成的上下文，包括 TraceID、调用方上下文信息、服务端处理的耗时、处理结果等信息。\n  \n埋点日志的实现，通常会包含如下几个功能：  \n1. 埋点规范，主要用于业务二次定制开发和第三方中间件/系统对接。\n2. 埋点日志类库，服务生成埋点上下文，打印埋点日志等。\n3. 中间件预置埋点功能，应用不需要开发任何业务代码即可直接使用，也可以通过埋点类库将应用自身的业务字段携带到调用链上下文中，例如终端类型、手机号等。  \n  \n![][5]  \n消息跟踪 ID 通常由调用首节点负责生成（各种门户 Portal），本 JVM 之内通常线程上下文传递 TraceID，跨节点传递时，往往通过分布式服务框架的显式传参传递到下游节点，实现消息跟踪上下文的跨节点传递。  \n埋点日志上下文通常需要包含如下内容：  \n1. TraceID、RPCID、调用的开始时间、调用类型、协议类型、调用方 IP 和端口、被调用方 IP 和端口、请求方接口名、被调用方服务名等信息。\n2. 调用耗时、调用结果、异常信息、处理的消息报文大小等。\n3. 可扩展字段，通常用于应用扩展埋点上下文信息。\n  \n消息跟踪ID（TraceID）是关联一次完整应用调用的唯一标识，需要在整个集群内唯一，它的取值策略有很多，例如 UUID，UUID（Universally Unique Identifier）即全局唯一标识符，是指在一台机器上生成的数字，它保证对在同一时空中所有机器都是唯一的。按照开发软件基金会（OSF）制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片 ID 码和许多可能的数字。由以下几部分组合：当前日期和时间（UUID 的第一部分与时间有关，如果你在生成一个 UUID 之后，过几秒又生成一个 UUID，则第一部分不同，其余相同），时钟序列，全局唯一的 IEEE 机器识别号（如果有网卡，从网卡获得，没有网卡以其它方式获得），UUID 的唯一缺陷在于生成的结果串会比较长。  \n  \n1. IP 地址和端口：调用发起方和被调用方 IP 地址、端口号\n2. 时间戳：埋点上下文的生成时间\n3. 顺序号：标识链路传递序列的 RpcID\n4. 进程号：应用的进程 ID\n5. 随机数：例如可以选择 8 位数的随机数  \n  \n![][6]  \n  \n原理上，埋点日志比较简单，实现起来并不复杂。但是在实际工作中，埋点日志也会面临一些技术挑战，举例如下：  \n1. 异步调用：业务服务中直接调用 MQ 客户端，或者其它中间件的客户端时，可能会发生线程切换，通常线程上下文传递的埋点信息丢失，MQ 客户端会认为自己是首节点，重新生成 TraceID，导致调用链串接不起来。\n2. 性能影响：由于 Java I/O 操作通常都是同步的，如果磁盘的 WIO 比较高，会导致写埋点日志阻塞应用线程，导致时延增大。频繁地写埋点日志，也会占用大量的 CPU、带宽等系统资源，影响正常业务的运行。  \n  \n对于线程切换问题，在切换时需求做线程上下文的备份，将埋点上下文复制到切换的线程上下文中，即可解决问题。  \n频繁写埋点日志影响性能问题，可以通过如下措施改善该问题：  \n1. 支持异步写日志，防止写埋点日志慢阻塞服务线程。具体实现上可以通过采用 log4j 的异步 Appender、独立的日志线程池甚至是 JDK1.7 之后提供的异步文件操作接口。\n2. 提供可灵活配置的埋点采样率，控制埋点日志量。\n3. 批量写日志，日志流控机制。\n\n## 2.3 采样率\n\n对于高 QPS 的应用，服务调用埋点本身的性能损耗也不容忽视，为了解决 100% 全采样的性能损耗，可以通过采样率来实现埋点低损耗的目标。  \n采样包括静态采用和动态采样两种，静态采样就是系统上线时设置一个采样率，无论负载高低，均按照采样率执行。动态采样率根据系统的负载可以自动调整，当负载比较低的时候可以实现 100% 全采样，在负载非常重时甚至可以降低到 0 采样。  \n  \n是否采样由调用链的首节点进行判断，首节点根据采样率算法，决定某个业务访问是否采样，如果需要采样，则把采样标识、TraceID 等采样上下文发送到下游服务节点，下游服务节点根据采样标识做判断，如果采样则获取调用链上下文并补充完整，反之则不埋点。\n\n## 2.4 采集和存储埋点日志\n\n开源 的 ELK，原理如下：  \n![][7]  \n需要考虑：  \n1. 采集过程中发生宕机，如何在中断点恢复采集。\n2. 采集过程中如果埋点日志发生了文件切换（例如达到单个日志文件 100MB 上限之后，自动进行文件切换），如何正确应对。\n3. 采集 Channel 发生网络故障，导致采集的日志部分发送失败，故障恢复之前，日志如何缓存，故障恢复之后，已采集尚未发送的日志如何发送。\n4. 考虑到性能，是不是单条采集、批量发送性能更优。\n\n# 3 个人总结\n\n通过对业务流程的记录和采集，进行在线和离线的大数据计算，数据清洗获取有价值的数据。同时还能根据运行情况做服务的调整。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_5.png\n[6]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_6.png\n[7]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_7.png","source":"_posts/分布式服务框架原理与实践/第十八章 分布式消息跟踪.md","raw":"---\ntitle: 十八、分布式消息跟踪\ndate: 2018-06-15 00:38:00\nupdated: 2018-06-20 01:51:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/18.html    \n---\n\n随着业务分布式架构的发展，系统间的系统调用日趋复杂，以电商的商品购买为例，前台界面的购买操作设计到底层上百次服务调用，涉及到的中间件包括：  \n1. 分布式服务框架\n2. 消息队列\n3. 分布式缓存\n4. 分布式数据访问中间件\n5. 分布式文件存储系统\n6. 分布式日志采集\n7. 其它......\n\n如果无法有效清理后端的分布式调用和依赖关系，故障定界将会非常困难。利用分布式消息跟踪系统可以有效解决服务化之后系统面临的运维挑战，提高运维效率。\n\n# 1 业务场景分析\n\n以下为分布式调用示意图：  \n![][1]\n\n## 1.1 故障的快速定界定位\n\n传统应用软件发生故障时，往往通过接口日志手工从故障节点采集日志进行问题分析定位，分布式服务化之后，一次业务调用可能涉及到后台上百次服务调用，每个服务又是集群组网，传统人工到各个服务节点人肉搜索的方式效率很低。  \n希望能够通过调用链跟踪，将一次业务调用的完整轨迹以调用链的形式展示出来，通过图形化界面查看每次服务调用结果，以及故障信息。  \n  \n通过在业务日志中增加调用链 ID ，可以实现业务日志和调用链的动态关联。通过调用链进行快速故障定界，然后通过 ID 关联查询，可以快速定位到业务日志相关信息。\n\n## 1.2 调用路径分析\n\n通过对调用链调用路径的分析，可以识别应用的关键路径：应用被调用得最多的入口、服务是哪些，找出服务的热点、耗时瓶颈和易故障点。同时为性能优化、容量规划等提供数据支撑。  \n![][2]\n\n## 1.3 调用来源和去向分析\n\n通过调用去向分析，可以对服务的依赖关系进行梳理：  \n1. 应用直接和间接依赖了哪些服务。\n2. 各层次依赖的调用时延、QPS、成功率等性能 KPI指标。\n3. 识别不合理的强依赖，或者冗余依赖，反向要求开发进行依赖解耦和优化。  \n  \n通过对调用来源进行 TOP排序，识别当前服务的消费来源，以及获取各消费者的 QPS、平均时延、出错率等，针对特定的消费者，可以做针对性治理，例如针对某个消费者的限流降级、路由策略修改等，保障服务的 SLA。  \n![][3]\n\n# 2 分布式消息跟踪系统设计\n\n消息跟踪系统的核心就是调用链：每次业务请求都生成一个全局唯一的 TraceID,通过跟踪 ID将不同节点间的日志串接起来，形成一个完整的日志调用链，通过对调用链日志做实时采集、汇总和大数据分析，提取各种维度的价值数据，为系统运维和运营提供大数据支撑。\n\n## 2.1 系统架构\n\n分布式消息跟踪系统的整体架构如下，由四部分组成：  \n![][4]\n\n1. 调用链埋点日志生成\n2. 分布式采集和存储埋点日志\n3. 在线、离线大数据计算，对调用链数据进行分析和汇总\n4. 调用链的界面展示、排序和检索等\n\n## 2.2 埋点日志\n\n埋点就是分布式消息跟踪系统在当前节点的上下文信息，埋点可以分为两类：  \n1. 客户端埋点，客户端发送请求消息时生成的调用上下文，通常包括 TraceID、调用方 IP、调用方接口或者业务名称、调用的发起时间、被调用的服务名、方法名、IP 地址和端口等信息。\n2. 服务端埋点，服务端返回应答消息时在当前节点生成的上下文，包括 TraceID、调用方上下文信息、服务端处理的耗时、处理结果等信息。\n  \n埋点日志的实现，通常会包含如下几个功能：  \n1. 埋点规范，主要用于业务二次定制开发和第三方中间件/系统对接。\n2. 埋点日志类库，服务生成埋点上下文，打印埋点日志等。\n3. 中间件预置埋点功能，应用不需要开发任何业务代码即可直接使用，也可以通过埋点类库将应用自身的业务字段携带到调用链上下文中，例如终端类型、手机号等。  \n  \n![][5]  \n消息跟踪 ID 通常由调用首节点负责生成（各种门户 Portal），本 JVM 之内通常线程上下文传递 TraceID，跨节点传递时，往往通过分布式服务框架的显式传参传递到下游节点，实现消息跟踪上下文的跨节点传递。  \n埋点日志上下文通常需要包含如下内容：  \n1. TraceID、RPCID、调用的开始时间、调用类型、协议类型、调用方 IP 和端口、被调用方 IP 和端口、请求方接口名、被调用方服务名等信息。\n2. 调用耗时、调用结果、异常信息、处理的消息报文大小等。\n3. 可扩展字段，通常用于应用扩展埋点上下文信息。\n  \n消息跟踪ID（TraceID）是关联一次完整应用调用的唯一标识，需要在整个集群内唯一，它的取值策略有很多，例如 UUID，UUID（Universally Unique Identifier）即全局唯一标识符，是指在一台机器上生成的数字，它保证对在同一时空中所有机器都是唯一的。按照开发软件基金会（OSF）制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片 ID 码和许多可能的数字。由以下几部分组合：当前日期和时间（UUID 的第一部分与时间有关，如果你在生成一个 UUID 之后，过几秒又生成一个 UUID，则第一部分不同，其余相同），时钟序列，全局唯一的 IEEE 机器识别号（如果有网卡，从网卡获得，没有网卡以其它方式获得），UUID 的唯一缺陷在于生成的结果串会比较长。  \n  \n1. IP 地址和端口：调用发起方和被调用方 IP 地址、端口号\n2. 时间戳：埋点上下文的生成时间\n3. 顺序号：标识链路传递序列的 RpcID\n4. 进程号：应用的进程 ID\n5. 随机数：例如可以选择 8 位数的随机数  \n  \n![][6]  \n  \n原理上，埋点日志比较简单，实现起来并不复杂。但是在实际工作中，埋点日志也会面临一些技术挑战，举例如下：  \n1. 异步调用：业务服务中直接调用 MQ 客户端，或者其它中间件的客户端时，可能会发生线程切换，通常线程上下文传递的埋点信息丢失，MQ 客户端会认为自己是首节点，重新生成 TraceID，导致调用链串接不起来。\n2. 性能影响：由于 Java I/O 操作通常都是同步的，如果磁盘的 WIO 比较高，会导致写埋点日志阻塞应用线程，导致时延增大。频繁地写埋点日志，也会占用大量的 CPU、带宽等系统资源，影响正常业务的运行。  \n  \n对于线程切换问题，在切换时需求做线程上下文的备份，将埋点上下文复制到切换的线程上下文中，即可解决问题。  \n频繁写埋点日志影响性能问题，可以通过如下措施改善该问题：  \n1. 支持异步写日志，防止写埋点日志慢阻塞服务线程。具体实现上可以通过采用 log4j 的异步 Appender、独立的日志线程池甚至是 JDK1.7 之后提供的异步文件操作接口。\n2. 提供可灵活配置的埋点采样率，控制埋点日志量。\n3. 批量写日志，日志流控机制。\n\n## 2.3 采样率\n\n对于高 QPS 的应用，服务调用埋点本身的性能损耗也不容忽视，为了解决 100% 全采样的性能损耗，可以通过采样率来实现埋点低损耗的目标。  \n采样包括静态采用和动态采样两种，静态采样就是系统上线时设置一个采样率，无论负载高低，均按照采样率执行。动态采样率根据系统的负载可以自动调整，当负载比较低的时候可以实现 100% 全采样，在负载非常重时甚至可以降低到 0 采样。  \n  \n是否采样由调用链的首节点进行判断，首节点根据采样率算法，决定某个业务访问是否采样，如果需要采样，则把采样标识、TraceID 等采样上下文发送到下游服务节点，下游服务节点根据采样标识做判断，如果采样则获取调用链上下文并补充完整，反之则不埋点。\n\n## 2.4 采集和存储埋点日志\n\n开源 的 ELK，原理如下：  \n![][7]  \n需要考虑：  \n1. 采集过程中发生宕机，如何在中断点恢复采集。\n2. 采集过程中如果埋点日志发生了文件切换（例如达到单个日志文件 100MB 上限之后，自动进行文件切换），如何正确应对。\n3. 采集 Channel 发生网络故障，导致采集的日志部分发送失败，故障恢复之前，日志如何缓存，故障恢复之后，已采集尚未发送的日志如何发送。\n4. 考虑到性能，是不是单条采集、批量发送性能更优。\n\n# 3 个人总结\n\n通过对业务流程的记录和采集，进行在线和离线的大数据计算，数据清洗获取有价值的数据。同时还能根据运行情况做服务的调整。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_5.png\n[6]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_6.png\n[7]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_7.png","slug":"distributed_principle_prictice/18.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavj001taxs6wv0dcxw4","content":"<p>随着业务分布式架构的发展，系统间的系统调用日趋复杂，以电商的商品购买为例，前台界面的购买操作设计到底层上百次服务调用，涉及到的中间件包括：  </p>\n<ol>\n<li>分布式服务框架</li>\n<li>消息队列</li>\n<li>分布式缓存</li>\n<li>分布式数据访问中间件</li>\n<li>分布式文件存储系统</li>\n<li>分布式日志采集</li>\n<li>其它……</li>\n</ol>\n<p>如果无法有效清理后端的分布式调用和依赖关系，故障定界将会非常困难。利用分布式消息跟踪系统可以有效解决服务化之后系统面临的运维挑战，提高运维效率。</p>\n<h1 id=\"1-业务场景分析\"><a href=\"#1-业务场景分析\" class=\"headerlink\" title=\"1 业务场景分析\"></a>1 业务场景分析</h1><p>以下为分布式调用示意图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_1.png\" alt=\"\"></p>\n<h2 id=\"1-1-故障的快速定界定位\"><a href=\"#1-1-故障的快速定界定位\" class=\"headerlink\" title=\"1.1 故障的快速定界定位\"></a>1.1 故障的快速定界定位</h2><p>传统应用软件发生故障时，往往通过接口日志手工从故障节点采集日志进行问题分析定位，分布式服务化之后，一次业务调用可能涉及到后台上百次服务调用，每个服务又是集群组网，传统人工到各个服务节点人肉搜索的方式效率很低。<br>希望能够通过调用链跟踪，将一次业务调用的完整轨迹以调用链的形式展示出来，通过图形化界面查看每次服务调用结果，以及故障信息。  </p>\n<p>通过在业务日志中增加调用链 ID ，可以实现业务日志和调用链的动态关联。通过调用链进行快速故障定界，然后通过 ID 关联查询，可以快速定位到业务日志相关信息。</p>\n<h2 id=\"1-2-调用路径分析\"><a href=\"#1-2-调用路径分析\" class=\"headerlink\" title=\"1.2 调用路径分析\"></a>1.2 调用路径分析</h2><p>通过对调用链调用路径的分析，可以识别应用的关键路径：应用被调用得最多的入口、服务是哪些，找出服务的热点、耗时瓶颈和易故障点。同时为性能优化、容量规划等提供数据支撑。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-调用来源和去向分析\"><a href=\"#1-3-调用来源和去向分析\" class=\"headerlink\" title=\"1.3 调用来源和去向分析\"></a>1.3 调用来源和去向分析</h2><p>通过调用去向分析，可以对服务的依赖关系进行梳理：  </p>\n<ol>\n<li>应用直接和间接依赖了哪些服务。</li>\n<li>各层次依赖的调用时延、QPS、成功率等性能 KPI指标。</li>\n<li>识别不合理的强依赖，或者冗余依赖，反向要求开发进行依赖解耦和优化。  </li>\n</ol>\n<p>通过对调用来源进行 TOP排序，识别当前服务的消费来源，以及获取各消费者的 QPS、平均时延、出错率等，针对特定的消费者，可以做针对性治理，例如针对某个消费者的限流降级、路由策略修改等，保障服务的 SLA。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_3.png\" alt=\"\"></p>\n<h1 id=\"2-分布式消息跟踪系统设计\"><a href=\"#2-分布式消息跟踪系统设计\" class=\"headerlink\" title=\"2 分布式消息跟踪系统设计\"></a>2 分布式消息跟踪系统设计</h1><p>消息跟踪系统的核心就是调用链：每次业务请求都生成一个全局唯一的 TraceID,通过跟踪 ID将不同节点间的日志串接起来，形成一个完整的日志调用链，通过对调用链日志做实时采集、汇总和大数据分析，提取各种维度的价值数据，为系统运维和运营提供大数据支撑。</p>\n<h2 id=\"2-1-系统架构\"><a href=\"#2-1-系统架构\" class=\"headerlink\" title=\"2.1 系统架构\"></a>2.1 系统架构</h2><p>分布式消息跟踪系统的整体架构如下，由四部分组成：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_4.png\" alt=\"\"></p>\n<ol>\n<li>调用链埋点日志生成</li>\n<li>分布式采集和存储埋点日志</li>\n<li>在线、离线大数据计算，对调用链数据进行分析和汇总</li>\n<li>调用链的界面展示、排序和检索等</li>\n</ol>\n<h2 id=\"2-2-埋点日志\"><a href=\"#2-2-埋点日志\" class=\"headerlink\" title=\"2.2 埋点日志\"></a>2.2 埋点日志</h2><p>埋点就是分布式消息跟踪系统在当前节点的上下文信息，埋点可以分为两类：  </p>\n<ol>\n<li>客户端埋点，客户端发送请求消息时生成的调用上下文，通常包括 TraceID、调用方 IP、调用方接口或者业务名称、调用的发起时间、被调用的服务名、方法名、IP 地址和端口等信息。</li>\n<li>服务端埋点，服务端返回应答消息时在当前节点生成的上下文，包括 TraceID、调用方上下文信息、服务端处理的耗时、处理结果等信息。</li>\n</ol>\n<p>埋点日志的实现，通常会包含如下几个功能：  </p>\n<ol>\n<li>埋点规范，主要用于业务二次定制开发和第三方中间件/系统对接。</li>\n<li>埋点日志类库，服务生成埋点上下文，打印埋点日志等。</li>\n<li>中间件预置埋点功能，应用不需要开发任何业务代码即可直接使用，也可以通过埋点类库将应用自身的业务字段携带到调用链上下文中，例如终端类型、手机号等。  </li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_5.png\" alt=\"\"><br>消息跟踪 ID 通常由调用首节点负责生成（各种门户 Portal），本 JVM 之内通常线程上下文传递 TraceID，跨节点传递时，往往通过分布式服务框架的显式传参传递到下游节点，实现消息跟踪上下文的跨节点传递。<br>埋点日志上下文通常需要包含如下内容：  </p>\n<ol>\n<li>TraceID、RPCID、调用的开始时间、调用类型、协议类型、调用方 IP 和端口、被调用方 IP 和端口、请求方接口名、被调用方服务名等信息。</li>\n<li>调用耗时、调用结果、异常信息、处理的消息报文大小等。</li>\n<li>可扩展字段，通常用于应用扩展埋点上下文信息。</li>\n</ol>\n<p>消息跟踪ID（TraceID）是关联一次完整应用调用的唯一标识，需要在整个集群内唯一，它的取值策略有很多，例如 UUID，UUID（Universally Unique Identifier）即全局唯一标识符，是指在一台机器上生成的数字，它保证对在同一时空中所有机器都是唯一的。按照开发软件基金会（OSF）制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片 ID 码和许多可能的数字。由以下几部分组合：当前日期和时间（UUID 的第一部分与时间有关，如果你在生成一个 UUID 之后，过几秒又生成一个 UUID，则第一部分不同，其余相同），时钟序列，全局唯一的 IEEE 机器识别号（如果有网卡，从网卡获得，没有网卡以其它方式获得），UUID 的唯一缺陷在于生成的结果串会比较长。  </p>\n<ol>\n<li>IP 地址和端口：调用发起方和被调用方 IP 地址、端口号</li>\n<li>时间戳：埋点上下文的生成时间</li>\n<li>顺序号：标识链路传递序列的 RpcID</li>\n<li>进程号：应用的进程 ID</li>\n<li>随机数：例如可以选择 8 位数的随机数  </li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_6.png\" alt=\"\">  </p>\n<p>原理上，埋点日志比较简单，实现起来并不复杂。但是在实际工作中，埋点日志也会面临一些技术挑战，举例如下：  </p>\n<ol>\n<li>异步调用：业务服务中直接调用 MQ 客户端，或者其它中间件的客户端时，可能会发生线程切换，通常线程上下文传递的埋点信息丢失，MQ 客户端会认为自己是首节点，重新生成 TraceID，导致调用链串接不起来。</li>\n<li>性能影响：由于 Java I/O 操作通常都是同步的，如果磁盘的 WIO 比较高，会导致写埋点日志阻塞应用线程，导致时延增大。频繁地写埋点日志，也会占用大量的 CPU、带宽等系统资源，影响正常业务的运行。  </li>\n</ol>\n<p>对于线程切换问题，在切换时需求做线程上下文的备份，将埋点上下文复制到切换的线程上下文中，即可解决问题。<br>频繁写埋点日志影响性能问题，可以通过如下措施改善该问题：  </p>\n<ol>\n<li>支持异步写日志，防止写埋点日志慢阻塞服务线程。具体实现上可以通过采用 log4j 的异步 Appender、独立的日志线程池甚至是 JDK1.7 之后提供的异步文件操作接口。</li>\n<li>提供可灵活配置的埋点采样率，控制埋点日志量。</li>\n<li>批量写日志，日志流控机制。</li>\n</ol>\n<h2 id=\"2-3-采样率\"><a href=\"#2-3-采样率\" class=\"headerlink\" title=\"2.3 采样率\"></a>2.3 采样率</h2><p>对于高 QPS 的应用，服务调用埋点本身的性能损耗也不容忽视，为了解决 100% 全采样的性能损耗，可以通过采样率来实现埋点低损耗的目标。<br>采样包括静态采用和动态采样两种，静态采样就是系统上线时设置一个采样率，无论负载高低，均按照采样率执行。动态采样率根据系统的负载可以自动调整，当负载比较低的时候可以实现 100% 全采样，在负载非常重时甚至可以降低到 0 采样。  </p>\n<p>是否采样由调用链的首节点进行判断，首节点根据采样率算法，决定某个业务访问是否采样，如果需要采样，则把采样标识、TraceID 等采样上下文发送到下游服务节点，下游服务节点根据采样标识做判断，如果采样则获取调用链上下文并补充完整，反之则不埋点。</p>\n<h2 id=\"2-4-采集和存储埋点日志\"><a href=\"#2-4-采集和存储埋点日志\" class=\"headerlink\" title=\"2.4 采集和存储埋点日志\"></a>2.4 采集和存储埋点日志</h2><p>开源 的 ELK，原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_7.png\" alt=\"\"><br>需要考虑：  </p>\n<ol>\n<li>采集过程中发生宕机，如何在中断点恢复采集。</li>\n<li>采集过程中如果埋点日志发生了文件切换（例如达到单个日志文件 100MB 上限之后，自动进行文件切换），如何正确应对。</li>\n<li>采集 Channel 发生网络故障，导致采集的日志部分发送失败，故障恢复之前，日志如何缓存，故障恢复之后，已采集尚未发送的日志如何发送。</li>\n<li>考虑到性能，是不是单条采集、批量发送性能更优。</li>\n</ol>\n<h1 id=\"3-个人总结\"><a href=\"#3-个人总结\" class=\"headerlink\" title=\"3 个人总结\"></a>3 个人总结</h1><p>通过对业务流程的记录和采集，进行在线和离线的大数据计算，数据清洗获取有价值的数据。同时还能根据运行情况做服务的调整。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>随着业务分布式架构的发展，系统间的系统调用日趋复杂，以电商的商品购买为例，前台界面的购买操作设计到底层上百次服务调用，涉及到的中间件包括：  </p>\n<ol>\n<li>分布式服务框架</li>\n<li>消息队列</li>\n<li>分布式缓存</li>\n<li>分布式数据访问中间件</li>\n<li>分布式文件存储系统</li>\n<li>分布式日志采集</li>\n<li>其它……</li>\n</ol>\n<p>如果无法有效清理后端的分布式调用和依赖关系，故障定界将会非常困难。利用分布式消息跟踪系统可以有效解决服务化之后系统面临的运维挑战，提高运维效率。</p>\n<h1 id=\"1-业务场景分析\"><a href=\"#1-业务场景分析\" class=\"headerlink\" title=\"1 业务场景分析\"></a>1 业务场景分析</h1><p>以下为分布式调用示意图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_1.png\" alt=\"\"></p>\n<h2 id=\"1-1-故障的快速定界定位\"><a href=\"#1-1-故障的快速定界定位\" class=\"headerlink\" title=\"1.1 故障的快速定界定位\"></a>1.1 故障的快速定界定位</h2><p>传统应用软件发生故障时，往往通过接口日志手工从故障节点采集日志进行问题分析定位，分布式服务化之后，一次业务调用可能涉及到后台上百次服务调用，每个服务又是集群组网，传统人工到各个服务节点人肉搜索的方式效率很低。<br>希望能够通过调用链跟踪，将一次业务调用的完整轨迹以调用链的形式展示出来，通过图形化界面查看每次服务调用结果，以及故障信息。  </p>\n<p>通过在业务日志中增加调用链 ID ，可以实现业务日志和调用链的动态关联。通过调用链进行快速故障定界，然后通过 ID 关联查询，可以快速定位到业务日志相关信息。</p>\n<h2 id=\"1-2-调用路径分析\"><a href=\"#1-2-调用路径分析\" class=\"headerlink\" title=\"1.2 调用路径分析\"></a>1.2 调用路径分析</h2><p>通过对调用链调用路径的分析，可以识别应用的关键路径：应用被调用得最多的入口、服务是哪些，找出服务的热点、耗时瓶颈和易故障点。同时为性能优化、容量规划等提供数据支撑。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_2.png\" alt=\"\"></p>\n<h2 id=\"1-3-调用来源和去向分析\"><a href=\"#1-3-调用来源和去向分析\" class=\"headerlink\" title=\"1.3 调用来源和去向分析\"></a>1.3 调用来源和去向分析</h2><p>通过调用去向分析，可以对服务的依赖关系进行梳理：  </p>\n<ol>\n<li>应用直接和间接依赖了哪些服务。</li>\n<li>各层次依赖的调用时延、QPS、成功率等性能 KPI指标。</li>\n<li>识别不合理的强依赖，或者冗余依赖，反向要求开发进行依赖解耦和优化。  </li>\n</ol>\n<p>通过对调用来源进行 TOP排序，识别当前服务的消费来源，以及获取各消费者的 QPS、平均时延、出错率等，针对特定的消费者，可以做针对性治理，例如针对某个消费者的限流降级、路由策略修改等，保障服务的 SLA。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_3.png\" alt=\"\"></p>\n<h1 id=\"2-分布式消息跟踪系统设计\"><a href=\"#2-分布式消息跟踪系统设计\" class=\"headerlink\" title=\"2 分布式消息跟踪系统设计\"></a>2 分布式消息跟踪系统设计</h1><p>消息跟踪系统的核心就是调用链：每次业务请求都生成一个全局唯一的 TraceID,通过跟踪 ID将不同节点间的日志串接起来，形成一个完整的日志调用链，通过对调用链日志做实时采集、汇总和大数据分析，提取各种维度的价值数据，为系统运维和运营提供大数据支撑。</p>\n<h2 id=\"2-1-系统架构\"><a href=\"#2-1-系统架构\" class=\"headerlink\" title=\"2.1 系统架构\"></a>2.1 系统架构</h2><p>分布式消息跟踪系统的整体架构如下，由四部分组成：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_4.png\" alt=\"\"></p>\n<ol>\n<li>调用链埋点日志生成</li>\n<li>分布式采集和存储埋点日志</li>\n<li>在线、离线大数据计算，对调用链数据进行分析和汇总</li>\n<li>调用链的界面展示、排序和检索等</li>\n</ol>\n<h2 id=\"2-2-埋点日志\"><a href=\"#2-2-埋点日志\" class=\"headerlink\" title=\"2.2 埋点日志\"></a>2.2 埋点日志</h2><p>埋点就是分布式消息跟踪系统在当前节点的上下文信息，埋点可以分为两类：  </p>\n<ol>\n<li>客户端埋点，客户端发送请求消息时生成的调用上下文，通常包括 TraceID、调用方 IP、调用方接口或者业务名称、调用的发起时间、被调用的服务名、方法名、IP 地址和端口等信息。</li>\n<li>服务端埋点，服务端返回应答消息时在当前节点生成的上下文，包括 TraceID、调用方上下文信息、服务端处理的耗时、处理结果等信息。</li>\n</ol>\n<p>埋点日志的实现，通常会包含如下几个功能：  </p>\n<ol>\n<li>埋点规范，主要用于业务二次定制开发和第三方中间件/系统对接。</li>\n<li>埋点日志类库，服务生成埋点上下文，打印埋点日志等。</li>\n<li>中间件预置埋点功能，应用不需要开发任何业务代码即可直接使用，也可以通过埋点类库将应用自身的业务字段携带到调用链上下文中，例如终端类型、手机号等。  </li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_5.png\" alt=\"\"><br>消息跟踪 ID 通常由调用首节点负责生成（各种门户 Portal），本 JVM 之内通常线程上下文传递 TraceID，跨节点传递时，往往通过分布式服务框架的显式传参传递到下游节点，实现消息跟踪上下文的跨节点传递。<br>埋点日志上下文通常需要包含如下内容：  </p>\n<ol>\n<li>TraceID、RPCID、调用的开始时间、调用类型、协议类型、调用方 IP 和端口、被调用方 IP 和端口、请求方接口名、被调用方服务名等信息。</li>\n<li>调用耗时、调用结果、异常信息、处理的消息报文大小等。</li>\n<li>可扩展字段，通常用于应用扩展埋点上下文信息。</li>\n</ol>\n<p>消息跟踪ID（TraceID）是关联一次完整应用调用的唯一标识，需要在整个集群内唯一，它的取值策略有很多，例如 UUID，UUID（Universally Unique Identifier）即全局唯一标识符，是指在一台机器上生成的数字，它保证对在同一时空中所有机器都是唯一的。按照开发软件基金会（OSF）制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片 ID 码和许多可能的数字。由以下几部分组合：当前日期和时间（UUID 的第一部分与时间有关，如果你在生成一个 UUID 之后，过几秒又生成一个 UUID，则第一部分不同，其余相同），时钟序列，全局唯一的 IEEE 机器识别号（如果有网卡，从网卡获得，没有网卡以其它方式获得），UUID 的唯一缺陷在于生成的结果串会比较长。  </p>\n<ol>\n<li>IP 地址和端口：调用发起方和被调用方 IP 地址、端口号</li>\n<li>时间戳：埋点上下文的生成时间</li>\n<li>顺序号：标识链路传递序列的 RpcID</li>\n<li>进程号：应用的进程 ID</li>\n<li>随机数：例如可以选择 8 位数的随机数  </li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_6.png\" alt=\"\">  </p>\n<p>原理上，埋点日志比较简单，实现起来并不复杂。但是在实际工作中，埋点日志也会面临一些技术挑战，举例如下：  </p>\n<ol>\n<li>异步调用：业务服务中直接调用 MQ 客户端，或者其它中间件的客户端时，可能会发生线程切换，通常线程上下文传递的埋点信息丢失，MQ 客户端会认为自己是首节点，重新生成 TraceID，导致调用链串接不起来。</li>\n<li>性能影响：由于 Java I/O 操作通常都是同步的，如果磁盘的 WIO 比较高，会导致写埋点日志阻塞应用线程，导致时延增大。频繁地写埋点日志，也会占用大量的 CPU、带宽等系统资源，影响正常业务的运行。  </li>\n</ol>\n<p>对于线程切换问题，在切换时需求做线程上下文的备份，将埋点上下文复制到切换的线程上下文中，即可解决问题。<br>频繁写埋点日志影响性能问题，可以通过如下措施改善该问题：  </p>\n<ol>\n<li>支持异步写日志，防止写埋点日志慢阻塞服务线程。具体实现上可以通过采用 log4j 的异步 Appender、独立的日志线程池甚至是 JDK1.7 之后提供的异步文件操作接口。</li>\n<li>提供可灵活配置的埋点采样率，控制埋点日志量。</li>\n<li>批量写日志，日志流控机制。</li>\n</ol>\n<h2 id=\"2-3-采样率\"><a href=\"#2-3-采样率\" class=\"headerlink\" title=\"2.3 采样率\"></a>2.3 采样率</h2><p>对于高 QPS 的应用，服务调用埋点本身的性能损耗也不容忽视，为了解决 100% 全采样的性能损耗，可以通过采样率来实现埋点低损耗的目标。<br>采样包括静态采用和动态采样两种，静态采样就是系统上线时设置一个采样率，无论负载高低，均按照采样率执行。动态采样率根据系统的负载可以自动调整，当负载比较低的时候可以实现 100% 全采样，在负载非常重时甚至可以降低到 0 采样。  </p>\n<p>是否采样由调用链的首节点进行判断，首节点根据采样率算法，决定某个业务访问是否采样，如果需要采样，则把采样标识、TraceID 等采样上下文发送到下游服务节点，下游服务节点根据采样标识做判断，如果采样则获取调用链上下文并补充完整，反之则不埋点。</p>\n<h2 id=\"2-4-采集和存储埋点日志\"><a href=\"#2-4-采集和存储埋点日志\" class=\"headerlink\" title=\"2.4 采集和存储埋点日志\"></a>2.4 采集和存储埋点日志</h2><p>开源 的 ELK，原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_7.png\" alt=\"\"><br>需要考虑：  </p>\n<ol>\n<li>采集过程中发生宕机，如何在中断点恢复采集。</li>\n<li>采集过程中如果埋点日志发生了文件切换（例如达到单个日志文件 100MB 上限之后，自动进行文件切换），如何正确应对。</li>\n<li>采集 Channel 发生网络故障，导致采集的日志部分发送失败，故障恢复之前，日志如何缓存，故障恢复之后，已采集尚未发送的日志如何发送。</li>\n<li>考虑到性能，是不是单条采集、批量发送性能更优。</li>\n</ol>\n<h1 id=\"3-个人总结\"><a href=\"#3-个人总结\" class=\"headerlink\" title=\"3 个人总结\"></a>3 个人总结</h1><p>通过对业务流程的记录和采集，进行在线和离线的大数据计算，数据清洗获取有价值的数据。同时还能根据运行情况做服务的调整。</p>\n"},{"title":"十六 服务优先级调度","date":"2018-06-11T14:56:00.000Z","updated":"2018-06-11T16:50:00.000Z","comments":1,"_content":"\n当系统当前资源非常有限时，为了保证高优先级的服务能够正常运行，保障服务 SLA，需要降低一些非核心服务的调度频次，释放不防资源占用，保障系统的整体运行平稳。\n\n# 1 设置服务优先级\n\n服务优先级调度有多种策略：  \n1. 基于线程调度器的优先级调度策略。\n2. 基于优先级队列的优先级调度策略。\n3. 基于加权配置的优先级调度策略。\n4. 基于服务迁入迁出的优先级调度策略。\n\n# 2 线程调度器方案\n\nThread.setPriority()。  \n线程优先级被线程调度器用来判定何时运行哪个线程，理论上，优先级高的线程比优先级低的线程获得更多的 CPU时间。而实际上，线程获得的 CPU时间通常由包括优先级在内的多个因素决定。  \n服务在发布的时候，可以根据用户的优先级配置策略，将服务优先级映射到线程优先级中，然后创建多个不同的优先级线程，分别调度对应的服务，工作原理如下：  \n![][1]  \n算法简单，开发工作量小，但是不同的操作系统上，有自己不同的策略，这对于需要某些精确控制执行比例的服务是不可接受的。  \n  \n线程优先级可以用来提高一个已经能够正常工作的服务的运行质量，但是却无法保证精确性和跨平台移植性。因此，通常不建议使用线程调度器实现服务的优先级调度。\n\n# 3 Java 优先级队列\n\nJava的 PriorityQueue是一个基于优先级堆的无界优先级队列。  \n![][2]  \n缺点在于：如果持续有优先级高的消息需要处理，会导致优先级低的消息得不到及时处理而积压。而积压到一定程度之后，低优先级的消息可能已经超时，即便后续得到执行机会，由于已经超时也需要丢弃掉，在此之前，它灰一直占用优先级队列的堆内存，同时导致客户端业务线程被挂住等待应答消息直到超时，从资源调度层面看，PriorityQueue 的算法并不太适合分布式服务框架。\n\n# 4 加权优先级队列\n\n分布式服务框架的服务优先级调度并不是只处理高优先级的消息，而是按照一定比例优先调度高优先级的服务，采用加权优先级队列可以很好地满足这个需求。  \n原理如下：它由一系列的普通队列组成，每个队列与服务优先级 1:1 对应。当服务端接收到客户端请求消息时，根据消息对应的服务优先级取值将消息投递到指定的优先级队列中。  \n工作线程按照服务优先级的加权值，按比例从各个优先级队列中获取消息，然后按照优先级的高低将消息设置到工作线程的待处理消息数组中，由于只有本工作线程会读写消息数组，因此该数组是线程安全的。  \n![][3]  \n缺点在于：如果优先级等级比较多，对应的优先级队列就会膨胀，如果优先级队列发生积压，这将导致内存占用迅速飙升。\n\n# 5 服务迁入迁出\n\n前面的几种优先级调度策略是比较传统的做法，基于服务迁入迁出的则是利用分布式服务框架的服务动态发现机制，通过调整服务运行实例数来实现优先级调度。  \n原理如下：  \n1. 当系统资源紧张时，通过服务治理 Portal的服务迁入迁出界面，将低优先级服务的部分运行实例从服务注册中心中迁出，也就是动态去注册。\n2. 消费者动态发现去注册的服务，将这部分服务实例的地址信息从路由表中删除，后续消息将不会路由到已经迁出的服务实例上。\n3. 由于只迁出了部分服务实例，被迁出的低优先级服务仍然能够正常处理，只不过由于部署实例的减少，得到调度的机会就同比降低了很多，释放的资源将被高优先级服务使用。通过资源的动态调配，实现服务的优先级调度。\n4. 当业务高峰期结束之后，通过服务治理 Portal将迁出的服务重新迁入，低优先级的消息恢复正常执行，优先级调度结束。  \n  \n缺点：自动化程度较低，对运维人员的要求较高。\n\n# 6 个人总结\n\n服务的优先级调度与动态流控不同，流控最终会拒绝消息，导致部分请求失败。优先级调度是在资源紧张时，优先执行高优先级的服务，在保障高优先级服务能够被合理调度的同时，也兼顾处理部分优先级低的消息，它们之间存在一定的比例关系。  \n  \n优先级调度本身并不拒绝消息，但是如果在运行过程中发生了流控，则由流控负责拒消息。通常对于高优先级的管理类消息，例如心跳消息、指令消息等们不能被流控掉。","source":"_posts/分布式服务框架原理与实践/第十六章 服务优先级调度.md","raw":"---\ntitle: 十六 服务优先级调度\ndate: 2018-06-11 22:56:00\nupdated: 2018-06-12 00:50:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/16.html    \n---\n\n当系统当前资源非常有限时，为了保证高优先级的服务能够正常运行，保障服务 SLA，需要降低一些非核心服务的调度频次，释放不防资源占用，保障系统的整体运行平稳。\n\n# 1 设置服务优先级\n\n服务优先级调度有多种策略：  \n1. 基于线程调度器的优先级调度策略。\n2. 基于优先级队列的优先级调度策略。\n3. 基于加权配置的优先级调度策略。\n4. 基于服务迁入迁出的优先级调度策略。\n\n# 2 线程调度器方案\n\nThread.setPriority()。  \n线程优先级被线程调度器用来判定何时运行哪个线程，理论上，优先级高的线程比优先级低的线程获得更多的 CPU时间。而实际上，线程获得的 CPU时间通常由包括优先级在内的多个因素决定。  \n服务在发布的时候，可以根据用户的优先级配置策略，将服务优先级映射到线程优先级中，然后创建多个不同的优先级线程，分别调度对应的服务，工作原理如下：  \n![][1]  \n算法简单，开发工作量小，但是不同的操作系统上，有自己不同的策略，这对于需要某些精确控制执行比例的服务是不可接受的。  \n  \n线程优先级可以用来提高一个已经能够正常工作的服务的运行质量，但是却无法保证精确性和跨平台移植性。因此，通常不建议使用线程调度器实现服务的优先级调度。\n\n# 3 Java 优先级队列\n\nJava的 PriorityQueue是一个基于优先级堆的无界优先级队列。  \n![][2]  \n缺点在于：如果持续有优先级高的消息需要处理，会导致优先级低的消息得不到及时处理而积压。而积压到一定程度之后，低优先级的消息可能已经超时，即便后续得到执行机会，由于已经超时也需要丢弃掉，在此之前，它灰一直占用优先级队列的堆内存，同时导致客户端业务线程被挂住等待应答消息直到超时，从资源调度层面看，PriorityQueue 的算法并不太适合分布式服务框架。\n\n# 4 加权优先级队列\n\n分布式服务框架的服务优先级调度并不是只处理高优先级的消息，而是按照一定比例优先调度高优先级的服务，采用加权优先级队列可以很好地满足这个需求。  \n原理如下：它由一系列的普通队列组成，每个队列与服务优先级 1:1 对应。当服务端接收到客户端请求消息时，根据消息对应的服务优先级取值将消息投递到指定的优先级队列中。  \n工作线程按照服务优先级的加权值，按比例从各个优先级队列中获取消息，然后按照优先级的高低将消息设置到工作线程的待处理消息数组中，由于只有本工作线程会读写消息数组，因此该数组是线程安全的。  \n![][3]  \n缺点在于：如果优先级等级比较多，对应的优先级队列就会膨胀，如果优先级队列发生积压，这将导致内存占用迅速飙升。\n\n# 5 服务迁入迁出\n\n前面的几种优先级调度策略是比较传统的做法，基于服务迁入迁出的则是利用分布式服务框架的服务动态发现机制，通过调整服务运行实例数来实现优先级调度。  \n原理如下：  \n1. 当系统资源紧张时，通过服务治理 Portal的服务迁入迁出界面，将低优先级服务的部分运行实例从服务注册中心中迁出，也就是动态去注册。\n2. 消费者动态发现去注册的服务，将这部分服务实例的地址信息从路由表中删除，后续消息将不会路由到已经迁出的服务实例上。\n3. 由于只迁出了部分服务实例，被迁出的低优先级服务仍然能够正常处理，只不过由于部署实例的减少，得到调度的机会就同比降低了很多，释放的资源将被高优先级服务使用。通过资源的动态调配，实现服务的优先级调度。\n4. 当业务高峰期结束之后，通过服务治理 Portal将迁出的服务重新迁入，低优先级的消息恢复正常执行，优先级调度结束。  \n  \n缺点：自动化程度较低，对运维人员的要求较高。\n\n# 6 个人总结\n\n服务的优先级调度与动态流控不同，流控最终会拒绝消息，导致部分请求失败。优先级调度是在资源紧张时，优先执行高优先级的服务，在保障高优先级服务能够被合理调度的同时，也兼顾处理部分优先级低的消息，它们之间存在一定的比例关系。  \n  \n优先级调度本身并不拒绝消息，但是如果在运行过程中发生了流控，则由流控负责拒消息。通常对于高优先级的管理类消息，例如心跳消息、指令消息等们不能被流控掉。","slug":"distributed_principle_prictice/16.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavk001waxs6ui4lyyg5","content":"<p>当系统当前资源非常有限时，为了保证高优先级的服务能够正常运行，保障服务 SLA，需要降低一些非核心服务的调度频次，释放不防资源占用，保障系统的整体运行平稳。</p>\n<h1 id=\"1-设置服务优先级\"><a href=\"#1-设置服务优先级\" class=\"headerlink\" title=\"1 设置服务优先级\"></a>1 设置服务优先级</h1><p>服务优先级调度有多种策略：  </p>\n<ol>\n<li>基于线程调度器的优先级调度策略。</li>\n<li>基于优先级队列的优先级调度策略。</li>\n<li>基于加权配置的优先级调度策略。</li>\n<li>基于服务迁入迁出的优先级调度策略。</li>\n</ol>\n<h1 id=\"2-线程调度器方案\"><a href=\"#2-线程调度器方案\" class=\"headerlink\" title=\"2 线程调度器方案\"></a>2 线程调度器方案</h1><p>Thread.setPriority()。<br>线程优先级被线程调度器用来判定何时运行哪个线程，理论上，优先级高的线程比优先级低的线程获得更多的 CPU时间。而实际上，线程获得的 CPU时间通常由包括优先级在内的多个因素决定。<br>服务在发布的时候，可以根据用户的优先级配置策略，将服务优先级映射到线程优先级中，然后创建多个不同的优先级线程，分别调度对应的服务，工作原理如下：<br>![][1]<br>算法简单，开发工作量小，但是不同的操作系统上，有自己不同的策略，这对于需要某些精确控制执行比例的服务是不可接受的。  </p>\n<p>线程优先级可以用来提高一个已经能够正常工作的服务的运行质量，但是却无法保证精确性和跨平台移植性。因此，通常不建议使用线程调度器实现服务的优先级调度。</p>\n<h1 id=\"3-Java-优先级队列\"><a href=\"#3-Java-优先级队列\" class=\"headerlink\" title=\"3 Java 优先级队列\"></a>3 Java 优先级队列</h1><p>Java的 PriorityQueue是一个基于优先级堆的无界优先级队列。<br>![][2]<br>缺点在于：如果持续有优先级高的消息需要处理，会导致优先级低的消息得不到及时处理而积压。而积压到一定程度之后，低优先级的消息可能已经超时，即便后续得到执行机会，由于已经超时也需要丢弃掉，在此之前，它灰一直占用优先级队列的堆内存，同时导致客户端业务线程被挂住等待应答消息直到超时，从资源调度层面看，PriorityQueue 的算法并不太适合分布式服务框架。</p>\n<h1 id=\"4-加权优先级队列\"><a href=\"#4-加权优先级队列\" class=\"headerlink\" title=\"4 加权优先级队列\"></a>4 加权优先级队列</h1><p>分布式服务框架的服务优先级调度并不是只处理高优先级的消息，而是按照一定比例优先调度高优先级的服务，采用加权优先级队列可以很好地满足这个需求。<br>原理如下：它由一系列的普通队列组成，每个队列与服务优先级 1:1 对应。当服务端接收到客户端请求消息时，根据消息对应的服务优先级取值将消息投递到指定的优先级队列中。<br>工作线程按照服务优先级的加权值，按比例从各个优先级队列中获取消息，然后按照优先级的高低将消息设置到工作线程的待处理消息数组中，由于只有本工作线程会读写消息数组，因此该数组是线程安全的。<br>![][3]<br>缺点在于：如果优先级等级比较多，对应的优先级队列就会膨胀，如果优先级队列发生积压，这将导致内存占用迅速飙升。</p>\n<h1 id=\"5-服务迁入迁出\"><a href=\"#5-服务迁入迁出\" class=\"headerlink\" title=\"5 服务迁入迁出\"></a>5 服务迁入迁出</h1><p>前面的几种优先级调度策略是比较传统的做法，基于服务迁入迁出的则是利用分布式服务框架的服务动态发现机制，通过调整服务运行实例数来实现优先级调度。<br>原理如下：  </p>\n<ol>\n<li>当系统资源紧张时，通过服务治理 Portal的服务迁入迁出界面，将低优先级服务的部分运行实例从服务注册中心中迁出，也就是动态去注册。</li>\n<li>消费者动态发现去注册的服务，将这部分服务实例的地址信息从路由表中删除，后续消息将不会路由到已经迁出的服务实例上。</li>\n<li>由于只迁出了部分服务实例，被迁出的低优先级服务仍然能够正常处理，只不过由于部署实例的减少，得到调度的机会就同比降低了很多，释放的资源将被高优先级服务使用。通过资源的动态调配，实现服务的优先级调度。</li>\n<li>当业务高峰期结束之后，通过服务治理 Portal将迁出的服务重新迁入，低优先级的消息恢复正常执行，优先级调度结束。  </li>\n</ol>\n<p>缺点：自动化程度较低，对运维人员的要求较高。</p>\n<h1 id=\"6-个人总结\"><a href=\"#6-个人总结\" class=\"headerlink\" title=\"6 个人总结\"></a>6 个人总结</h1><p>服务的优先级调度与动态流控不同，流控最终会拒绝消息，导致部分请求失败。优先级调度是在资源紧张时，优先执行高优先级的服务，在保障高优先级服务能够被合理调度的同时，也兼顾处理部分优先级低的消息，它们之间存在一定的比例关系。  </p>\n<p>优先级调度本身并不拒绝消息，但是如果在运行过程中发生了流控，则由流控负责拒消息。通常对于高优先级的管理类消息，例如心跳消息、指令消息等们不能被流控掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当系统当前资源非常有限时，为了保证高优先级的服务能够正常运行，保障服务 SLA，需要降低一些非核心服务的调度频次，释放不防资源占用，保障系统的整体运行平稳。</p>\n<h1 id=\"1-设置服务优先级\"><a href=\"#1-设置服务优先级\" class=\"headerlink\" title=\"1 设置服务优先级\"></a>1 设置服务优先级</h1><p>服务优先级调度有多种策略：  </p>\n<ol>\n<li>基于线程调度器的优先级调度策略。</li>\n<li>基于优先级队列的优先级调度策略。</li>\n<li>基于加权配置的优先级调度策略。</li>\n<li>基于服务迁入迁出的优先级调度策略。</li>\n</ol>\n<h1 id=\"2-线程调度器方案\"><a href=\"#2-线程调度器方案\" class=\"headerlink\" title=\"2 线程调度器方案\"></a>2 线程调度器方案</h1><p>Thread.setPriority()。<br>线程优先级被线程调度器用来判定何时运行哪个线程，理论上，优先级高的线程比优先级低的线程获得更多的 CPU时间。而实际上，线程获得的 CPU时间通常由包括优先级在内的多个因素决定。<br>服务在发布的时候，可以根据用户的优先级配置策略，将服务优先级映射到线程优先级中，然后创建多个不同的优先级线程，分别调度对应的服务，工作原理如下：<br>![][1]<br>算法简单，开发工作量小，但是不同的操作系统上，有自己不同的策略，这对于需要某些精确控制执行比例的服务是不可接受的。  </p>\n<p>线程优先级可以用来提高一个已经能够正常工作的服务的运行质量，但是却无法保证精确性和跨平台移植性。因此，通常不建议使用线程调度器实现服务的优先级调度。</p>\n<h1 id=\"3-Java-优先级队列\"><a href=\"#3-Java-优先级队列\" class=\"headerlink\" title=\"3 Java 优先级队列\"></a>3 Java 优先级队列</h1><p>Java的 PriorityQueue是一个基于优先级堆的无界优先级队列。<br>![][2]<br>缺点在于：如果持续有优先级高的消息需要处理，会导致优先级低的消息得不到及时处理而积压。而积压到一定程度之后，低优先级的消息可能已经超时，即便后续得到执行机会，由于已经超时也需要丢弃掉，在此之前，它灰一直占用优先级队列的堆内存，同时导致客户端业务线程被挂住等待应答消息直到超时，从资源调度层面看，PriorityQueue 的算法并不太适合分布式服务框架。</p>\n<h1 id=\"4-加权优先级队列\"><a href=\"#4-加权优先级队列\" class=\"headerlink\" title=\"4 加权优先级队列\"></a>4 加权优先级队列</h1><p>分布式服务框架的服务优先级调度并不是只处理高优先级的消息，而是按照一定比例优先调度高优先级的服务，采用加权优先级队列可以很好地满足这个需求。<br>原理如下：它由一系列的普通队列组成，每个队列与服务优先级 1:1 对应。当服务端接收到客户端请求消息时，根据消息对应的服务优先级取值将消息投递到指定的优先级队列中。<br>工作线程按照服务优先级的加权值，按比例从各个优先级队列中获取消息，然后按照优先级的高低将消息设置到工作线程的待处理消息数组中，由于只有本工作线程会读写消息数组，因此该数组是线程安全的。<br>![][3]<br>缺点在于：如果优先级等级比较多，对应的优先级队列就会膨胀，如果优先级队列发生积压，这将导致内存占用迅速飙升。</p>\n<h1 id=\"5-服务迁入迁出\"><a href=\"#5-服务迁入迁出\" class=\"headerlink\" title=\"5 服务迁入迁出\"></a>5 服务迁入迁出</h1><p>前面的几种优先级调度策略是比较传统的做法，基于服务迁入迁出的则是利用分布式服务框架的服务动态发现机制，通过调整服务运行实例数来实现优先级调度。<br>原理如下：  </p>\n<ol>\n<li>当系统资源紧张时，通过服务治理 Portal的服务迁入迁出界面，将低优先级服务的部分运行实例从服务注册中心中迁出，也就是动态去注册。</li>\n<li>消费者动态发现去注册的服务，将这部分服务实例的地址信息从路由表中删除，后续消息将不会路由到已经迁出的服务实例上。</li>\n<li>由于只迁出了部分服务实例，被迁出的低优先级服务仍然能够正常处理，只不过由于部署实例的减少，得到调度的机会就同比降低了很多，释放的资源将被高优先级服务使用。通过资源的动态调配，实现服务的优先级调度。</li>\n<li>当业务高峰期结束之后，通过服务治理 Portal将迁出的服务重新迁入，低优先级的消息恢复正常执行，优先级调度结束。  </li>\n</ol>\n<p>缺点：自动化程度较低，对运维人员的要求较高。</p>\n<h1 id=\"6-个人总结\"><a href=\"#6-个人总结\" class=\"headerlink\" title=\"6 个人总结\"></a>6 个人总结</h1><p>服务的优先级调度与动态流控不同，流控最终会拒绝消息，导致部分请求失败。优先级调度是在资源紧张时，优先执行高优先级的服务，在保障高优先级服务能够被合理调度的同时，也兼顾处理部分优先级低的消息，它们之间存在一定的比例关系。  </p>\n<p>优先级调度本身并不拒绝消息，但是如果在运行过程中发生了流控，则由流控负责拒消息。通常对于高优先级的管理类消息，例如心跳消息、指令消息等们不能被流控掉。</p>\n"},{"title":"十五、服务降级","date":"2018-06-10T17:30:00.000Z","updated":"2018-06-11T14:56:00.000Z","comments":1,"_content":"\n1. 业务高峰期，为了保证核心服务的 SLA，往往需要停掉一些不太重要的业务，例如商品评论、论坛或者粉丝积分等。  \n2. 某些服务因为某种原因不可用，但是流程不能直接失败，需要本地 Mock 服务端实现，做流程放通。例如图书阅读，如果用户登录余额鉴权服务不能正常工作，需要做业务放通，记录消费话单，允许用户继续阅读，而不是返回失败。  \n  \n这就是服务降级，分为容错降级和屏蔽降级两种模式。\n\n# 1 屏蔽降级\n\n在一个应用中，服务往往是合设的，尽管可以通过线程池隔离等方式保证服务之间的资源隔离，但是 100%的隔离是不现实的。特别是对缓存、网络 I/O、磁盘 I/O、数据库连接资源等公共依赖无法隔离，在业务高峰期时，服务往往存在激烈的竞争，导致订购等核心服务运行质量下降，影响系统的稳定运行和客户体验。  \n  \n此时需要对非核心服务做强制降级，不发起远程服务调用，直接返回空、异常或者执行特定的本地逻辑，减少自身对公共资源的消费，把资源释放出来供核心服务使用。  \n\n## 1.1 屏蔽降级的流程\n\n![][1]\n\n## 1.2 屏蔽降级的设计实现\n\n屏蔽降级通常用于服务运行态治理，开发时不会配置，当外界的触发条件达到某个临界值时，由运维人员/开发人员决策，通过服务治理控制台，进行人工降级操作，它的取值有如下三种：  \n1. mock = force: return null。不发起远程服务调用，直接返回空对象。\n2. mock = force: throw Exception。不发起远程服务调用，直接抛出指定异常。\n3. mock = force: execute Bean。不发起远程服务调用，直接执行本地模拟接口实现类。  \n  \n屏蔽降级操作是可逆的，当系统压力恢复正常水平或者不再需要屏蔽降级时，可以对已经屏蔽降级的服务恢复正常。恢复之后，消费者重新调用远程的服务提供者，同时服务状态被修改为正常状态。\n\n# 2 容错降级\n\n当非核心服务不可用时，可以对故障服务做业务逻辑放通，分布式服务框架的业务放通实际属于容错降级的一种。  \n容错降级不仅仅只用于业务放通，它也常用于服务提供方在客户端执行容错逻辑，容错逻辑主要包括两种：  \n1. RPC异常：通常指超时异常、消息解码异常、流控异常、系统拥塞保护异常等。\n2. Service异常：例如登录校验失败异常、数据库操作失败异常等。\n\n## 2.1 容错降级的工作原理\n\n![][2]  \n容错降级与屏蔽降级的主要差异：  \n1. 触发条件不同：容错降级时根据服务调用结果，自动匹配触发的；而屏蔽降级往往是通过人工根据系统运行情况手工操作触发的。\n2. 作用不同：容错降级时当服务提供者不可用时，让消费者执行业务放通：屏蔽降级的主要目的是将原属于降级业务的资源调配出来供核心业务使用。\n3. 调用机制不同：一个发起远程服务调用，一个只做本地调用。  \n  \n业务放通的 Mock接口实现往往放在消费者端，主要在于提供端可能为多个消费者服务，为了解耦，单独的消费者自己进行放通。\n  \n1. mock = fail: throw Exception。将异常转义。\n2. mock = fail: execute Bean。将异常屏蔽掉，直接执行本地模拟解耦实现类，返回 Mock接口的执行结果。  \n\n与屏蔽降级不同的是，通常在开发态，就需要指定容错降级的策略。  \n\n无论是屏蔽降级还是容错降级，都支持从消费者或者服务提供者两个维度去配置，从而消费端配置更灵活，实现差异化降级策略。  \n服务降级策略配置的优先级：消费者配置策略 > 服务提供者配置策略。屏蔽降级 > 容错降级。 \n\n## 2.2 运行时容错降级\n\n![][3]  \n如果开发态没有指定容错降级策略，系统上线运行后，需要临时增加容错降级策略，服务框架也需要支持在线动态增加容错降级策略，它的工作流程与屏蔽降级类似。\n  \n而在实际项目中，利用容错降级做业务放通是主要的应用场景。\n\n# 3 业务层降级\n\n实际业务开发过程中，可能会存在比较复杂的业务放通场景，例如“调用 A 服务 + 执行本地方法调用”组合成一个流程，针对这个流程的执行结果做放通，这种场景由于本地方法调用并不经过分布式服务框架，因此需要业务自己做放通处理。  \n\n服务降级并不能 100% 满足所有业务放通场景，需要业务层开发自己的降级框架。 \n\n# 4 个人总结\n\n在服务化之前，业务往往需要自己实现放通逻辑或者框架，不同的业务模块，甚至不同的开发者都自己实现了一套私有的放通流程，这对项目的开发和运维都会造成很多麻烦。  \n  \n更为严重的是由于没有统一的服务降级策略和框架，无法在服务治理 Portal 上进行统一线上降级，在应对业务高峰时，运维人员会力不从心，往往需要一大群开发在背后支撑，运维效率非常低下。  \n基于分布式服务框架的服务降级功能，有效提升线上的服务治理效率，保证服务的 SLA，尽管服务降级更多是为了提升服务线上运行质量，但是它反向对服务的设计和开发也有约束。它要求服务在设计之初就要做如下识别：  \n1. 哪些服务是核心服务、哪些是非核心服务？\n2. 哪些服务支持降级，降级策略是什么？\n3. 除了服务降级之外，是否还存在更为复杂的业务放通场景，它的策略是什么？  \n  \n系统的高效、健康运行仅仅依赖线上服务治理和运维是解决不了的，需要通过分布式服务框架的特性反向映射到设计和开发态，从设计阶段就开始考虑未来如何高效运维，才能在根本上提升服务和产品的质量，这也是矛盾对立和统一的一个具体体现。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_3.png","source":"_posts/分布式服务框架原理与实践/第十五章 服务降级.md","raw":"---\ntitle: 十五、服务降级\ndate: 2018-06-11 01:30:00\nupdated: 2018-06-11 22:56:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/15.html    \n---\n\n1. 业务高峰期，为了保证核心服务的 SLA，往往需要停掉一些不太重要的业务，例如商品评论、论坛或者粉丝积分等。  \n2. 某些服务因为某种原因不可用，但是流程不能直接失败，需要本地 Mock 服务端实现，做流程放通。例如图书阅读，如果用户登录余额鉴权服务不能正常工作，需要做业务放通，记录消费话单，允许用户继续阅读，而不是返回失败。  \n  \n这就是服务降级，分为容错降级和屏蔽降级两种模式。\n\n# 1 屏蔽降级\n\n在一个应用中，服务往往是合设的，尽管可以通过线程池隔离等方式保证服务之间的资源隔离，但是 100%的隔离是不现实的。特别是对缓存、网络 I/O、磁盘 I/O、数据库连接资源等公共依赖无法隔离，在业务高峰期时，服务往往存在激烈的竞争，导致订购等核心服务运行质量下降，影响系统的稳定运行和客户体验。  \n  \n此时需要对非核心服务做强制降级，不发起远程服务调用，直接返回空、异常或者执行特定的本地逻辑，减少自身对公共资源的消费，把资源释放出来供核心服务使用。  \n\n## 1.1 屏蔽降级的流程\n\n![][1]\n\n## 1.2 屏蔽降级的设计实现\n\n屏蔽降级通常用于服务运行态治理，开发时不会配置，当外界的触发条件达到某个临界值时，由运维人员/开发人员决策，通过服务治理控制台，进行人工降级操作，它的取值有如下三种：  \n1. mock = force: return null。不发起远程服务调用，直接返回空对象。\n2. mock = force: throw Exception。不发起远程服务调用，直接抛出指定异常。\n3. mock = force: execute Bean。不发起远程服务调用，直接执行本地模拟接口实现类。  \n  \n屏蔽降级操作是可逆的，当系统压力恢复正常水平或者不再需要屏蔽降级时，可以对已经屏蔽降级的服务恢复正常。恢复之后，消费者重新调用远程的服务提供者，同时服务状态被修改为正常状态。\n\n# 2 容错降级\n\n当非核心服务不可用时，可以对故障服务做业务逻辑放通，分布式服务框架的业务放通实际属于容错降级的一种。  \n容错降级不仅仅只用于业务放通，它也常用于服务提供方在客户端执行容错逻辑，容错逻辑主要包括两种：  \n1. RPC异常：通常指超时异常、消息解码异常、流控异常、系统拥塞保护异常等。\n2. Service异常：例如登录校验失败异常、数据库操作失败异常等。\n\n## 2.1 容错降级的工作原理\n\n![][2]  \n容错降级与屏蔽降级的主要差异：  \n1. 触发条件不同：容错降级时根据服务调用结果，自动匹配触发的；而屏蔽降级往往是通过人工根据系统运行情况手工操作触发的。\n2. 作用不同：容错降级时当服务提供者不可用时，让消费者执行业务放通：屏蔽降级的主要目的是将原属于降级业务的资源调配出来供核心业务使用。\n3. 调用机制不同：一个发起远程服务调用，一个只做本地调用。  \n  \n业务放通的 Mock接口实现往往放在消费者端，主要在于提供端可能为多个消费者服务，为了解耦，单独的消费者自己进行放通。\n  \n1. mock = fail: throw Exception。将异常转义。\n2. mock = fail: execute Bean。将异常屏蔽掉，直接执行本地模拟解耦实现类，返回 Mock接口的执行结果。  \n\n与屏蔽降级不同的是，通常在开发态，就需要指定容错降级的策略。  \n\n无论是屏蔽降级还是容错降级，都支持从消费者或者服务提供者两个维度去配置，从而消费端配置更灵活，实现差异化降级策略。  \n服务降级策略配置的优先级：消费者配置策略 > 服务提供者配置策略。屏蔽降级 > 容错降级。 \n\n## 2.2 运行时容错降级\n\n![][3]  \n如果开发态没有指定容错降级策略，系统上线运行后，需要临时增加容错降级策略，服务框架也需要支持在线动态增加容错降级策略，它的工作流程与屏蔽降级类似。\n  \n而在实际项目中，利用容错降级做业务放通是主要的应用场景。\n\n# 3 业务层降级\n\n实际业务开发过程中，可能会存在比较复杂的业务放通场景，例如“调用 A 服务 + 执行本地方法调用”组合成一个流程，针对这个流程的执行结果做放通，这种场景由于本地方法调用并不经过分布式服务框架，因此需要业务自己做放通处理。  \n\n服务降级并不能 100% 满足所有业务放通场景，需要业务层开发自己的降级框架。 \n\n# 4 个人总结\n\n在服务化之前，业务往往需要自己实现放通逻辑或者框架，不同的业务模块，甚至不同的开发者都自己实现了一套私有的放通流程，这对项目的开发和运维都会造成很多麻烦。  \n  \n更为严重的是由于没有统一的服务降级策略和框架，无法在服务治理 Portal 上进行统一线上降级，在应对业务高峰时，运维人员会力不从心，往往需要一大群开发在背后支撑，运维效率非常低下。  \n基于分布式服务框架的服务降级功能，有效提升线上的服务治理效率，保证服务的 SLA，尽管服务降级更多是为了提升服务线上运行质量，但是它反向对服务的设计和开发也有约束。它要求服务在设计之初就要做如下识别：  \n1. 哪些服务是核心服务、哪些是非核心服务？\n2. 哪些服务支持降级，降级策略是什么？\n3. 除了服务降级之外，是否还存在更为复杂的业务放通场景，它的策略是什么？  \n  \n系统的高效、健康运行仅仅依赖线上服务治理和运维是解决不了的，需要通过分布式服务框架的特性反向映射到设计和开发态，从设计阶段就开始考虑未来如何高效运维，才能在根本上提升服务和产品的质量，这也是矛盾对立和统一的一个具体体现。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_3.png","slug":"distributed_principle_prictice/15.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavl001xaxs6olsw2kpk","content":"<ol>\n<li>业务高峰期，为了保证核心服务的 SLA，往往需要停掉一些不太重要的业务，例如商品评论、论坛或者粉丝积分等。  </li>\n<li>某些服务因为某种原因不可用，但是流程不能直接失败，需要本地 Mock 服务端实现，做流程放通。例如图书阅读，如果用户登录余额鉴权服务不能正常工作，需要做业务放通，记录消费话单，允许用户继续阅读，而不是返回失败。  </li>\n</ol>\n<p>这就是服务降级，分为容错降级和屏蔽降级两种模式。</p>\n<h1 id=\"1-屏蔽降级\"><a href=\"#1-屏蔽降级\" class=\"headerlink\" title=\"1 屏蔽降级\"></a>1 屏蔽降级</h1><p>在一个应用中，服务往往是合设的，尽管可以通过线程池隔离等方式保证服务之间的资源隔离，但是 100%的隔离是不现实的。特别是对缓存、网络 I/O、磁盘 I/O、数据库连接资源等公共依赖无法隔离，在业务高峰期时，服务往往存在激烈的竞争，导致订购等核心服务运行质量下降，影响系统的稳定运行和客户体验。  </p>\n<p>此时需要对非核心服务做强制降级，不发起远程服务调用，直接返回空、异常或者执行特定的本地逻辑，减少自身对公共资源的消费，把资源释放出来供核心服务使用。  </p>\n<h2 id=\"1-1-屏蔽降级的流程\"><a href=\"#1-1-屏蔽降级的流程\" class=\"headerlink\" title=\"1.1 屏蔽降级的流程\"></a>1.1 屏蔽降级的流程</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_1.png\" alt=\"\"></p>\n<h2 id=\"1-2-屏蔽降级的设计实现\"><a href=\"#1-2-屏蔽降级的设计实现\" class=\"headerlink\" title=\"1.2 屏蔽降级的设计实现\"></a>1.2 屏蔽降级的设计实现</h2><p>屏蔽降级通常用于服务运行态治理，开发时不会配置，当外界的触发条件达到某个临界值时，由运维人员/开发人员决策，通过服务治理控制台，进行人工降级操作，它的取值有如下三种：  </p>\n<ol>\n<li>mock = force: return null。不发起远程服务调用，直接返回空对象。</li>\n<li>mock = force: throw Exception。不发起远程服务调用，直接抛出指定异常。</li>\n<li>mock = force: execute Bean。不发起远程服务调用，直接执行本地模拟接口实现类。  </li>\n</ol>\n<p>屏蔽降级操作是可逆的，当系统压力恢复正常水平或者不再需要屏蔽降级时，可以对已经屏蔽降级的服务恢复正常。恢复之后，消费者重新调用远程的服务提供者，同时服务状态被修改为正常状态。</p>\n<h1 id=\"2-容错降级\"><a href=\"#2-容错降级\" class=\"headerlink\" title=\"2 容错降级\"></a>2 容错降级</h1><p>当非核心服务不可用时，可以对故障服务做业务逻辑放通，分布式服务框架的业务放通实际属于容错降级的一种。<br>容错降级不仅仅只用于业务放通，它也常用于服务提供方在客户端执行容错逻辑，容错逻辑主要包括两种：  </p>\n<ol>\n<li>RPC异常：通常指超时异常、消息解码异常、流控异常、系统拥塞保护异常等。</li>\n<li>Service异常：例如登录校验失败异常、数据库操作失败异常等。</li>\n</ol>\n<h2 id=\"2-1-容错降级的工作原理\"><a href=\"#2-1-容错降级的工作原理\" class=\"headerlink\" title=\"2.1 容错降级的工作原理\"></a>2.1 容错降级的工作原理</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_2.png\" alt=\"\"><br>容错降级与屏蔽降级的主要差异：  </p>\n<ol>\n<li>触发条件不同：容错降级时根据服务调用结果，自动匹配触发的；而屏蔽降级往往是通过人工根据系统运行情况手工操作触发的。</li>\n<li>作用不同：容错降级时当服务提供者不可用时，让消费者执行业务放通：屏蔽降级的主要目的是将原属于降级业务的资源调配出来供核心业务使用。</li>\n<li>调用机制不同：一个发起远程服务调用，一个只做本地调用。  </li>\n</ol>\n<p>业务放通的 Mock接口实现往往放在消费者端，主要在于提供端可能为多个消费者服务，为了解耦，单独的消费者自己进行放通。</p>\n<ol>\n<li>mock = fail: throw Exception。将异常转义。</li>\n<li>mock = fail: execute Bean。将异常屏蔽掉，直接执行本地模拟解耦实现类，返回 Mock接口的执行结果。  </li>\n</ol>\n<p>与屏蔽降级不同的是，通常在开发态，就需要指定容错降级的策略。  </p>\n<p>无论是屏蔽降级还是容错降级，都支持从消费者或者服务提供者两个维度去配置，从而消费端配置更灵活，实现差异化降级策略。<br>服务降级策略配置的优先级：消费者配置策略 &gt; 服务提供者配置策略。屏蔽降级 &gt; 容错降级。 </p>\n<h2 id=\"2-2-运行时容错降级\"><a href=\"#2-2-运行时容错降级\" class=\"headerlink\" title=\"2.2 运行时容错降级\"></a>2.2 运行时容错降级</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_3.png\" alt=\"\"><br>如果开发态没有指定容错降级策略，系统上线运行后，需要临时增加容错降级策略，服务框架也需要支持在线动态增加容错降级策略，它的工作流程与屏蔽降级类似。</p>\n<p>而在实际项目中，利用容错降级做业务放通是主要的应用场景。</p>\n<h1 id=\"3-业务层降级\"><a href=\"#3-业务层降级\" class=\"headerlink\" title=\"3 业务层降级\"></a>3 业务层降级</h1><p>实际业务开发过程中，可能会存在比较复杂的业务放通场景，例如“调用 A 服务 + 执行本地方法调用”组合成一个流程，针对这个流程的执行结果做放通，这种场景由于本地方法调用并不经过分布式服务框架，因此需要业务自己做放通处理。  </p>\n<p>服务降级并不能 100% 满足所有业务放通场景，需要业务层开发自己的降级框架。 </p>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>在服务化之前，业务往往需要自己实现放通逻辑或者框架，不同的业务模块，甚至不同的开发者都自己实现了一套私有的放通流程，这对项目的开发和运维都会造成很多麻烦。  </p>\n<p>更为严重的是由于没有统一的服务降级策略和框架，无法在服务治理 Portal 上进行统一线上降级，在应对业务高峰时，运维人员会力不从心，往往需要一大群开发在背后支撑，运维效率非常低下。<br>基于分布式服务框架的服务降级功能，有效提升线上的服务治理效率，保证服务的 SLA，尽管服务降级更多是为了提升服务线上运行质量，但是它反向对服务的设计和开发也有约束。它要求服务在设计之初就要做如下识别：  </p>\n<ol>\n<li>哪些服务是核心服务、哪些是非核心服务？</li>\n<li>哪些服务支持降级，降级策略是什么？</li>\n<li>除了服务降级之外，是否还存在更为复杂的业务放通场景，它的策略是什么？  </li>\n</ol>\n<p>系统的高效、健康运行仅仅依赖线上服务治理和运维是解决不了的，需要通过分布式服务框架的特性反向映射到设计和开发态，从设计阶段就开始考虑未来如何高效运维，才能在根本上提升服务和产品的质量，这也是矛盾对立和统一的一个具体体现。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>业务高峰期，为了保证核心服务的 SLA，往往需要停掉一些不太重要的业务，例如商品评论、论坛或者粉丝积分等。  </li>\n<li>某些服务因为某种原因不可用，但是流程不能直接失败，需要本地 Mock 服务端实现，做流程放通。例如图书阅读，如果用户登录余额鉴权服务不能正常工作，需要做业务放通，记录消费话单，允许用户继续阅读，而不是返回失败。  </li>\n</ol>\n<p>这就是服务降级，分为容错降级和屏蔽降级两种模式。</p>\n<h1 id=\"1-屏蔽降级\"><a href=\"#1-屏蔽降级\" class=\"headerlink\" title=\"1 屏蔽降级\"></a>1 屏蔽降级</h1><p>在一个应用中，服务往往是合设的，尽管可以通过线程池隔离等方式保证服务之间的资源隔离，但是 100%的隔离是不现实的。特别是对缓存、网络 I/O、磁盘 I/O、数据库连接资源等公共依赖无法隔离，在业务高峰期时，服务往往存在激烈的竞争，导致订购等核心服务运行质量下降，影响系统的稳定运行和客户体验。  </p>\n<p>此时需要对非核心服务做强制降级，不发起远程服务调用，直接返回空、异常或者执行特定的本地逻辑，减少自身对公共资源的消费，把资源释放出来供核心服务使用。  </p>\n<h2 id=\"1-1-屏蔽降级的流程\"><a href=\"#1-1-屏蔽降级的流程\" class=\"headerlink\" title=\"1.1 屏蔽降级的流程\"></a>1.1 屏蔽降级的流程</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_1.png\" alt=\"\"></p>\n<h2 id=\"1-2-屏蔽降级的设计实现\"><a href=\"#1-2-屏蔽降级的设计实现\" class=\"headerlink\" title=\"1.2 屏蔽降级的设计实现\"></a>1.2 屏蔽降级的设计实现</h2><p>屏蔽降级通常用于服务运行态治理，开发时不会配置，当外界的触发条件达到某个临界值时，由运维人员/开发人员决策，通过服务治理控制台，进行人工降级操作，它的取值有如下三种：  </p>\n<ol>\n<li>mock = force: return null。不发起远程服务调用，直接返回空对象。</li>\n<li>mock = force: throw Exception。不发起远程服务调用，直接抛出指定异常。</li>\n<li>mock = force: execute Bean。不发起远程服务调用，直接执行本地模拟接口实现类。  </li>\n</ol>\n<p>屏蔽降级操作是可逆的，当系统压力恢复正常水平或者不再需要屏蔽降级时，可以对已经屏蔽降级的服务恢复正常。恢复之后，消费者重新调用远程的服务提供者，同时服务状态被修改为正常状态。</p>\n<h1 id=\"2-容错降级\"><a href=\"#2-容错降级\" class=\"headerlink\" title=\"2 容错降级\"></a>2 容错降级</h1><p>当非核心服务不可用时，可以对故障服务做业务逻辑放通，分布式服务框架的业务放通实际属于容错降级的一种。<br>容错降级不仅仅只用于业务放通，它也常用于服务提供方在客户端执行容错逻辑，容错逻辑主要包括两种：  </p>\n<ol>\n<li>RPC异常：通常指超时异常、消息解码异常、流控异常、系统拥塞保护异常等。</li>\n<li>Service异常：例如登录校验失败异常、数据库操作失败异常等。</li>\n</ol>\n<h2 id=\"2-1-容错降级的工作原理\"><a href=\"#2-1-容错降级的工作原理\" class=\"headerlink\" title=\"2.1 容错降级的工作原理\"></a>2.1 容错降级的工作原理</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_2.png\" alt=\"\"><br>容错降级与屏蔽降级的主要差异：  </p>\n<ol>\n<li>触发条件不同：容错降级时根据服务调用结果，自动匹配触发的；而屏蔽降级往往是通过人工根据系统运行情况手工操作触发的。</li>\n<li>作用不同：容错降级时当服务提供者不可用时，让消费者执行业务放通：屏蔽降级的主要目的是将原属于降级业务的资源调配出来供核心业务使用。</li>\n<li>调用机制不同：一个发起远程服务调用，一个只做本地调用。  </li>\n</ol>\n<p>业务放通的 Mock接口实现往往放在消费者端，主要在于提供端可能为多个消费者服务，为了解耦，单独的消费者自己进行放通。</p>\n<ol>\n<li>mock = fail: throw Exception。将异常转义。</li>\n<li>mock = fail: execute Bean。将异常屏蔽掉，直接执行本地模拟解耦实现类，返回 Mock接口的执行结果。  </li>\n</ol>\n<p>与屏蔽降级不同的是，通常在开发态，就需要指定容错降级的策略。  </p>\n<p>无论是屏蔽降级还是容错降级，都支持从消费者或者服务提供者两个维度去配置，从而消费端配置更灵活，实现差异化降级策略。<br>服务降级策略配置的优先级：消费者配置策略 &gt; 服务提供者配置策略。屏蔽降级 &gt; 容错降级。 </p>\n<h2 id=\"2-2-运行时容错降级\"><a href=\"#2-2-运行时容错降级\" class=\"headerlink\" title=\"2.2 运行时容错降级\"></a>2.2 运行时容错降级</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_3.png\" alt=\"\"><br>如果开发态没有指定容错降级策略，系统上线运行后，需要临时增加容错降级策略，服务框架也需要支持在线动态增加容错降级策略，它的工作流程与屏蔽降级类似。</p>\n<p>而在实际项目中，利用容错降级做业务放通是主要的应用场景。</p>\n<h1 id=\"3-业务层降级\"><a href=\"#3-业务层降级\" class=\"headerlink\" title=\"3 业务层降级\"></a>3 业务层降级</h1><p>实际业务开发过程中，可能会存在比较复杂的业务放通场景，例如“调用 A 服务 + 执行本地方法调用”组合成一个流程，针对这个流程的执行结果做放通，这种场景由于本地方法调用并不经过分布式服务框架，因此需要业务自己做放通处理。  </p>\n<p>服务降级并不能 100% 满足所有业务放通场景，需要业务层开发自己的降级框架。 </p>\n<h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>在服务化之前，业务往往需要自己实现放通逻辑或者框架，不同的业务模块，甚至不同的开发者都自己实现了一套私有的放通流程，这对项目的开发和运维都会造成很多麻烦。  </p>\n<p>更为严重的是由于没有统一的服务降级策略和框架，无法在服务治理 Portal 上进行统一线上降级，在应对业务高峰时，运维人员会力不从心，往往需要一大群开发在背后支撑，运维效率非常低下。<br>基于分布式服务框架的服务降级功能，有效提升线上的服务治理效率，保证服务的 SLA，尽管服务降级更多是为了提升服务线上运行质量，但是它反向对服务的设计和开发也有约束。它要求服务在设计之初就要做如下识别：  </p>\n<ol>\n<li>哪些服务是核心服务、哪些是非核心服务？</li>\n<li>哪些服务支持降级，降级策略是什么？</li>\n<li>除了服务降级之外，是否还存在更为复杂的业务放通场景，它的策略是什么？  </li>\n</ol>\n<p>系统的高效、健康运行仅仅依赖线上服务治理和运维是解决不了的，需要通过分布式服务框架的特性反向映射到设计和开发态，从设计阶段就开始考虑未来如何高效运维，才能在根本上提升服务和产品的质量，这也是矛盾对立和统一的一个具体体现。</p>\n"},{"title":"十四、流量控制","date":"2018-06-07T14:30:00.000Z","updated":"2018-06-10T17:30:00.000Z","comments":1,"_content":"\n当资源成为瓶颈时，服务框架需要对消费者做限流，启动流控保护机制。\n\n# 1 静态流控\n\n主要针对客户端访问速率进行控制，它通常根据服务质量等级协定（SLA）中约定的 QPS做全局流量控制，例如订单服务的静态流控阈值为 100QPS，则无论集群有多少个订单服务实例，它们总的处理速率之和不能超过 100QPS。\n\n## 1.1 传统静态流控设计方案\n\n在软件安装时，根据集群服务节点个数和静态流控阈值，计算每个服务及诶单分摊的 QPS阈值，系统运行时，各个服务节点按照自己分配的阈值进行流控，对于超出流控阈值的请求则拒绝访问。  \n![][1]  \n服务框架启动时，将本节点的静态流控阈值加载到内存中，服务框架通过 Handler拦截器咋服务调用前做拦截计数，当计数器在指定周期 T到达 QPS上限时，启动流控，拒绝信的请求消息接入。注意：  \n1. 服务实例通常由多线程执行，因此计数时需要考虑线程并发安全，可以使用 Atomic原子类进行原子操作。\n2. 达到流控阈值之后拒绝新的请求消息接入，不能拒绝后续的应答消息，否则这会导致客户端超时或者触发 FailOver，增加服务端的负载。\n\n## 1.2 传统方案的缺点\n\n1. 云端服务的弹性伸缩性使服务节点数处于动态变化过程中，预分配方案行不通。\n2. 服务节点宕机，或者有新的服务节点动态加入，导致服务节点数发生变化，静态分配的 QPS需要实时动态调整，否则会导致流控不准。\n  \n当应用和服务迁移到云上之后， PaaS 平台的一个重要功能就是支持应用和服务的弹性伸缩，在云上，资源都是动态分配和调整的，静态分配阈值方案无法适应服务迁移到云上。\n\n## 1.3 动态配额分配制\n\n原理：由服务注册中心以流控周期 T为单位，动态推送每个节点分配的流控阈值 QPS。当服务节点发生变更时，会触发服务注册中心重新计算每个节点的配额，然后进行推送，这样无论是新增还是减少服务节点数，都能够在下一个流控周期内被识别和处理。  \n![][2]  \n而在生产环境中，每台机器/VM 的配置可能不同，如果每个服务节点采用流控总阈值/服务节点数这种平均主义，可能会发生性能高、处理快的节点配额很快用完，但是性能差的节点配额有剩余的情况，这会导致总的配额没用完，但是系统却发生了静态流控的问题。  \n解决方案一：根据各个服务节点的性能 KPI数据（例如服务调用平均时延）做加权。  \n解决方案二：配额指标返还和重新申请，每个服务节点根据自身分配的指标值、处理速率做预测，如果计算结果表明指标会有剩余，则把多余的返还给服务注册中心；对于配额已经使用完的服务节点，重新主动去服务注册中心申请配额，如果连续 N次都申请不到新的配额指标，则对于新接入的请求消息做流控。  \n  \n结合负载均衡进行静态流控，才能够实现更精确的调度和控制。消费者根据各服务节点的负载情况做加权路由，性能差的节点路由到的消息更少，这样保证了系统的负载均衡和配额的合理分配。\n\n## 1.4 动态配额申请制\n\n尽管动态配额分配制可以解决节点变化引起的流控不准问题，也能改善平均主义配额分配缺点如下：\n1. 如果流控周期 T比较大，各服务节点的负载情况变化比较快，服务节点的负载反馈到注册中心，统一计算后再做配额均衡，误差会比较大。\n2. 如果流控周期 T比较小，服务注册中心需要实时获取各服务节点的性能 KPI数据并计算负载情况，经过性能数据采集、上报、汇总和计算之后会有一定的时延，这会导致流控滞后产生误差。\n3. 如果采用配额返还和重新申请方式，则会增加交互次数，同时也会存在时序误差。\n4. 扩展性差，负载的汇总、计算和配额分配、下发都由服务注册中心完成，如果服务注册中心管理的节点数非常多，则服务注册中心的计算压力就非常大，随着服务节点数的增加服务注册中心配额分配效率会急速下降、系统不具备平滑扩展能力。  \n  \n而动态配额申请制，工作原理如下：  \n1. 系统部署的时候，根据服务节点数和静态流控 QPS阈值，拿出一定比例的配额做初始分配，剩余的配额放在配额资源池中。\n2. 哪个服务节点使用完了配额，就主动向服务注册中心申请配额。配额的申请策略是，如果流控周期为 T，则将周期 T分成更小的周期 T/N（N为经验值，默认值为 10），当前的服务节点数为 M个，则申请的配额为（总 QPS配额-已经分配的 QPS）/ M * T / N。\n3. 总的配额如果被申请完，则返回 0 配额给各个申请配额的服务节点，服务节点对新接入的请求消息进行流控。\n  \n动态配额申请制的优点：\n1. 各个服务节点最清楚自己的负载情况，性能 KPI数据在本地内存中计算获得，实时性高。\n2. 由各个服务节点根据自身负载情况去申请配额，保证性能高的节点有更高的配额，性能差的自然配额就少，实现合理资源，流控的精确性。\n\n# 2 动态流控\n\n动态流控的最终目标是为了保命，并不是对流量或者访问速度做精确控制。  \n触发动态流控的因子是资源，资源又分为系统资源和应用资源两大类，根据不同的资源负载情况，动态流控又分为多个级别，每个级别流控系数都不同，也就是被拒绝掉的消息比例不同。每个级别都有相应的流控阈值，这个阈值通常支持在线动态调整。\n\n## 2.1 动态流控因子\n\n动态流控因子包括系统资源和应用资源两大类，常见的系统资源包括：\n1. 应用进程所在主机/VM 的 CPU使用率。\n2. 应用进程所在主机/VM 的 内存使用率。  \n  \n使用 java.lang.Process 执行 top、sar 等外部命令获取系统资源使用情况。  \n常用的应用资源：  \n1. JVM 堆内存使用率\n2. 消息队列积压率\n3. 会话积压率  \n  \n具体实现策略是系统启动时拉起一个管理线程，定时采集应用资源的使用率，并刷新动态流控的应用资源阈值。\n\n## 2.2 分级流控\n\n不同级别拒掉的消息比例不同，例如一级流控拒绝掉 1/8 的消息；发生二级流控时，拒绝掉 1/4 消息。  \n为了防止系统波动导致的偶发性流控，无论是进入流控状态还是从流控状态恢复，都需要连续采集 N次并计算平均值，如果连续 N次平均值大于流控阈值，则进入流控状态。  \n而在一个流控周期内，不会发生流控级别的跳变。\n\n# 3 并发控制\n\n并发控制针对线程的并发执行数进行控制，它的本质是限制对某个服务或者服务的方法过度消息，耗用过多的资源而影响其它的服务的正常运行。有两种形式：  \n1. 针对服务提供者的全局控制。\n2. 针对服务消费者的局部控制。\n\n# 4 连接控制\n\n通常分布式服务框架服务提供者和消费者之间采用长连接私有协议，为了防止因为消费者连接数过多导致服务端负载压力过大，系统需要针对连接数进行流控。  \n\n# 5 并发和连接控制算法\n\n并发连接的控制算法原理如下图：  \n![][3]\n  \n基于服务调用 Pipeline 机制，可以对请求消息接收和发送、应答消息接收和发送、异常消息等做切面拦截（类似 Spring 的 AOP 机制，但是没采用反射机制，性能更高），利用 Pipeline 拦截切面接口，对请求消息做服务调用前的拦截和计数，根据计数器做流控，服务端的算法如下：  \n1. 获取流控阈值。\n2. 从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。\n3. 如果等于或者大于流控阈值，则抛出 RPC流控异常给客户端。\n4. 服务调用执行完成之后，获取 RPC上下文中的并发执行数，做原子自减。  \n  \n客户端的算法如下：  \n1. 获取流控阈值。\n2. 从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。\n3. 如果等于或大于流控阈值，则当前线程进入 wait状态， wait超时时间为服务调用的超时时间。\n4. 如果有其它线程服务调用完成，调用计数器自减，则并发执行数小于阈值，线程被 notify，退出 wait，继续执行。\n\n# 6 个人总结\n\n流量控制是保证服务 SLA（Sevice-Level Agreement）的重要措施，也是业务高峰期故障预防和恢复的有效手段，分布式服务框架需要支持流控阈值、策略的在线调整，不需要重启应用即可生效。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_3.png","source":"_posts/分布式服务框架原理与实践/第十四章 流量控制.md","raw":"---\ntitle: 十四、流量控制\ndate: 2018-06-07 22:30:00\nupdated: 2018-06-11 01:30:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/14.html    \n---\n\n当资源成为瓶颈时，服务框架需要对消费者做限流，启动流控保护机制。\n\n# 1 静态流控\n\n主要针对客户端访问速率进行控制，它通常根据服务质量等级协定（SLA）中约定的 QPS做全局流量控制，例如订单服务的静态流控阈值为 100QPS，则无论集群有多少个订单服务实例，它们总的处理速率之和不能超过 100QPS。\n\n## 1.1 传统静态流控设计方案\n\n在软件安装时，根据集群服务节点个数和静态流控阈值，计算每个服务及诶单分摊的 QPS阈值，系统运行时，各个服务节点按照自己分配的阈值进行流控，对于超出流控阈值的请求则拒绝访问。  \n![][1]  \n服务框架启动时，将本节点的静态流控阈值加载到内存中，服务框架通过 Handler拦截器咋服务调用前做拦截计数，当计数器在指定周期 T到达 QPS上限时，启动流控，拒绝信的请求消息接入。注意：  \n1. 服务实例通常由多线程执行，因此计数时需要考虑线程并发安全，可以使用 Atomic原子类进行原子操作。\n2. 达到流控阈值之后拒绝新的请求消息接入，不能拒绝后续的应答消息，否则这会导致客户端超时或者触发 FailOver，增加服务端的负载。\n\n## 1.2 传统方案的缺点\n\n1. 云端服务的弹性伸缩性使服务节点数处于动态变化过程中，预分配方案行不通。\n2. 服务节点宕机，或者有新的服务节点动态加入，导致服务节点数发生变化，静态分配的 QPS需要实时动态调整，否则会导致流控不准。\n  \n当应用和服务迁移到云上之后， PaaS 平台的一个重要功能就是支持应用和服务的弹性伸缩，在云上，资源都是动态分配和调整的，静态分配阈值方案无法适应服务迁移到云上。\n\n## 1.3 动态配额分配制\n\n原理：由服务注册中心以流控周期 T为单位，动态推送每个节点分配的流控阈值 QPS。当服务节点发生变更时，会触发服务注册中心重新计算每个节点的配额，然后进行推送，这样无论是新增还是减少服务节点数，都能够在下一个流控周期内被识别和处理。  \n![][2]  \n而在生产环境中，每台机器/VM 的配置可能不同，如果每个服务节点采用流控总阈值/服务节点数这种平均主义，可能会发生性能高、处理快的节点配额很快用完，但是性能差的节点配额有剩余的情况，这会导致总的配额没用完，但是系统却发生了静态流控的问题。  \n解决方案一：根据各个服务节点的性能 KPI数据（例如服务调用平均时延）做加权。  \n解决方案二：配额指标返还和重新申请，每个服务节点根据自身分配的指标值、处理速率做预测，如果计算结果表明指标会有剩余，则把多余的返还给服务注册中心；对于配额已经使用完的服务节点，重新主动去服务注册中心申请配额，如果连续 N次都申请不到新的配额指标，则对于新接入的请求消息做流控。  \n  \n结合负载均衡进行静态流控，才能够实现更精确的调度和控制。消费者根据各服务节点的负载情况做加权路由，性能差的节点路由到的消息更少，这样保证了系统的负载均衡和配额的合理分配。\n\n## 1.4 动态配额申请制\n\n尽管动态配额分配制可以解决节点变化引起的流控不准问题，也能改善平均主义配额分配缺点如下：\n1. 如果流控周期 T比较大，各服务节点的负载情况变化比较快，服务节点的负载反馈到注册中心，统一计算后再做配额均衡，误差会比较大。\n2. 如果流控周期 T比较小，服务注册中心需要实时获取各服务节点的性能 KPI数据并计算负载情况，经过性能数据采集、上报、汇总和计算之后会有一定的时延，这会导致流控滞后产生误差。\n3. 如果采用配额返还和重新申请方式，则会增加交互次数，同时也会存在时序误差。\n4. 扩展性差，负载的汇总、计算和配额分配、下发都由服务注册中心完成，如果服务注册中心管理的节点数非常多，则服务注册中心的计算压力就非常大，随着服务节点数的增加服务注册中心配额分配效率会急速下降、系统不具备平滑扩展能力。  \n  \n而动态配额申请制，工作原理如下：  \n1. 系统部署的时候，根据服务节点数和静态流控 QPS阈值，拿出一定比例的配额做初始分配，剩余的配额放在配额资源池中。\n2. 哪个服务节点使用完了配额，就主动向服务注册中心申请配额。配额的申请策略是，如果流控周期为 T，则将周期 T分成更小的周期 T/N（N为经验值，默认值为 10），当前的服务节点数为 M个，则申请的配额为（总 QPS配额-已经分配的 QPS）/ M * T / N。\n3. 总的配额如果被申请完，则返回 0 配额给各个申请配额的服务节点，服务节点对新接入的请求消息进行流控。\n  \n动态配额申请制的优点：\n1. 各个服务节点最清楚自己的负载情况，性能 KPI数据在本地内存中计算获得，实时性高。\n2. 由各个服务节点根据自身负载情况去申请配额，保证性能高的节点有更高的配额，性能差的自然配额就少，实现合理资源，流控的精确性。\n\n# 2 动态流控\n\n动态流控的最终目标是为了保命，并不是对流量或者访问速度做精确控制。  \n触发动态流控的因子是资源，资源又分为系统资源和应用资源两大类，根据不同的资源负载情况，动态流控又分为多个级别，每个级别流控系数都不同，也就是被拒绝掉的消息比例不同。每个级别都有相应的流控阈值，这个阈值通常支持在线动态调整。\n\n## 2.1 动态流控因子\n\n动态流控因子包括系统资源和应用资源两大类，常见的系统资源包括：\n1. 应用进程所在主机/VM 的 CPU使用率。\n2. 应用进程所在主机/VM 的 内存使用率。  \n  \n使用 java.lang.Process 执行 top、sar 等外部命令获取系统资源使用情况。  \n常用的应用资源：  \n1. JVM 堆内存使用率\n2. 消息队列积压率\n3. 会话积压率  \n  \n具体实现策略是系统启动时拉起一个管理线程，定时采集应用资源的使用率，并刷新动态流控的应用资源阈值。\n\n## 2.2 分级流控\n\n不同级别拒掉的消息比例不同，例如一级流控拒绝掉 1/8 的消息；发生二级流控时，拒绝掉 1/4 消息。  \n为了防止系统波动导致的偶发性流控，无论是进入流控状态还是从流控状态恢复，都需要连续采集 N次并计算平均值，如果连续 N次平均值大于流控阈值，则进入流控状态。  \n而在一个流控周期内，不会发生流控级别的跳变。\n\n# 3 并发控制\n\n并发控制针对线程的并发执行数进行控制，它的本质是限制对某个服务或者服务的方法过度消息，耗用过多的资源而影响其它的服务的正常运行。有两种形式：  \n1. 针对服务提供者的全局控制。\n2. 针对服务消费者的局部控制。\n\n# 4 连接控制\n\n通常分布式服务框架服务提供者和消费者之间采用长连接私有协议，为了防止因为消费者连接数过多导致服务端负载压力过大，系统需要针对连接数进行流控。  \n\n# 5 并发和连接控制算法\n\n并发连接的控制算法原理如下图：  \n![][3]\n  \n基于服务调用 Pipeline 机制，可以对请求消息接收和发送、应答消息接收和发送、异常消息等做切面拦截（类似 Spring 的 AOP 机制，但是没采用反射机制，性能更高），利用 Pipeline 拦截切面接口，对请求消息做服务调用前的拦截和计数，根据计数器做流控，服务端的算法如下：  \n1. 获取流控阈值。\n2. 从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。\n3. 如果等于或者大于流控阈值，则抛出 RPC流控异常给客户端。\n4. 服务调用执行完成之后，获取 RPC上下文中的并发执行数，做原子自减。  \n  \n客户端的算法如下：  \n1. 获取流控阈值。\n2. 从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。\n3. 如果等于或大于流控阈值，则当前线程进入 wait状态， wait超时时间为服务调用的超时时间。\n4. 如果有其它线程服务调用完成，调用计数器自减，则并发执行数小于阈值，线程被 notify，退出 wait，继续执行。\n\n# 6 个人总结\n\n流量控制是保证服务 SLA（Sevice-Level Agreement）的重要措施，也是业务高峰期故障预防和恢复的有效手段，分布式服务框架需要支持流控阈值、策略的在线调整，不需要重启应用即可生效。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_3.png","slug":"distributed_principle_prictice/14.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavm0020axs6jdpcdcl4","content":"<p>当资源成为瓶颈时，服务框架需要对消费者做限流，启动流控保护机制。</p>\n<h1 id=\"1-静态流控\"><a href=\"#1-静态流控\" class=\"headerlink\" title=\"1 静态流控\"></a>1 静态流控</h1><p>主要针对客户端访问速率进行控制，它通常根据服务质量等级协定（SLA）中约定的 QPS做全局流量控制，例如订单服务的静态流控阈值为 100QPS，则无论集群有多少个订单服务实例，它们总的处理速率之和不能超过 100QPS。</p>\n<h2 id=\"1-1-传统静态流控设计方案\"><a href=\"#1-1-传统静态流控设计方案\" class=\"headerlink\" title=\"1.1 传统静态流控设计方案\"></a>1.1 传统静态流控设计方案</h2><p>在软件安装时，根据集群服务节点个数和静态流控阈值，计算每个服务及诶单分摊的 QPS阈值，系统运行时，各个服务节点按照自己分配的阈值进行流控，对于超出流控阈值的请求则拒绝访问。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_1.png\" alt=\"\"><br>服务框架启动时，将本节点的静态流控阈值加载到内存中，服务框架通过 Handler拦截器咋服务调用前做拦截计数，当计数器在指定周期 T到达 QPS上限时，启动流控，拒绝信的请求消息接入。注意：  </p>\n<ol>\n<li>服务实例通常由多线程执行，因此计数时需要考虑线程并发安全，可以使用 Atomic原子类进行原子操作。</li>\n<li>达到流控阈值之后拒绝新的请求消息接入，不能拒绝后续的应答消息，否则这会导致客户端超时或者触发 FailOver，增加服务端的负载。</li>\n</ol>\n<h2 id=\"1-2-传统方案的缺点\"><a href=\"#1-2-传统方案的缺点\" class=\"headerlink\" title=\"1.2 传统方案的缺点\"></a>1.2 传统方案的缺点</h2><ol>\n<li>云端服务的弹性伸缩性使服务节点数处于动态变化过程中，预分配方案行不通。</li>\n<li>服务节点宕机，或者有新的服务节点动态加入，导致服务节点数发生变化，静态分配的 QPS需要实时动态调整，否则会导致流控不准。</li>\n</ol>\n<p>当应用和服务迁移到云上之后， PaaS 平台的一个重要功能就是支持应用和服务的弹性伸缩，在云上，资源都是动态分配和调整的，静态分配阈值方案无法适应服务迁移到云上。</p>\n<h2 id=\"1-3-动态配额分配制\"><a href=\"#1-3-动态配额分配制\" class=\"headerlink\" title=\"1.3 动态配额分配制\"></a>1.3 动态配额分配制</h2><p>原理：由服务注册中心以流控周期 T为单位，动态推送每个节点分配的流控阈值 QPS。当服务节点发生变更时，会触发服务注册中心重新计算每个节点的配额，然后进行推送，这样无论是新增还是减少服务节点数，都能够在下一个流控周期内被识别和处理。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_2.png\" alt=\"\"><br>而在生产环境中，每台机器/VM 的配置可能不同，如果每个服务节点采用流控总阈值/服务节点数这种平均主义，可能会发生性能高、处理快的节点配额很快用完，但是性能差的节点配额有剩余的情况，这会导致总的配额没用完，但是系统却发生了静态流控的问题。<br>解决方案一：根据各个服务节点的性能 KPI数据（例如服务调用平均时延）做加权。<br>解决方案二：配额指标返还和重新申请，每个服务节点根据自身分配的指标值、处理速率做预测，如果计算结果表明指标会有剩余，则把多余的返还给服务注册中心；对于配额已经使用完的服务节点，重新主动去服务注册中心申请配额，如果连续 N次都申请不到新的配额指标，则对于新接入的请求消息做流控。  </p>\n<p>结合负载均衡进行静态流控，才能够实现更精确的调度和控制。消费者根据各服务节点的负载情况做加权路由，性能差的节点路由到的消息更少，这样保证了系统的负载均衡和配额的合理分配。</p>\n<h2 id=\"1-4-动态配额申请制\"><a href=\"#1-4-动态配额申请制\" class=\"headerlink\" title=\"1.4 动态配额申请制\"></a>1.4 动态配额申请制</h2><p>尽管动态配额分配制可以解决节点变化引起的流控不准问题，也能改善平均主义配额分配缺点如下：</p>\n<ol>\n<li>如果流控周期 T比较大，各服务节点的负载情况变化比较快，服务节点的负载反馈到注册中心，统一计算后再做配额均衡，误差会比较大。</li>\n<li>如果流控周期 T比较小，服务注册中心需要实时获取各服务节点的性能 KPI数据并计算负载情况，经过性能数据采集、上报、汇总和计算之后会有一定的时延，这会导致流控滞后产生误差。</li>\n<li>如果采用配额返还和重新申请方式，则会增加交互次数，同时也会存在时序误差。</li>\n<li>扩展性差，负载的汇总、计算和配额分配、下发都由服务注册中心完成，如果服务注册中心管理的节点数非常多，则服务注册中心的计算压力就非常大，随着服务节点数的增加服务注册中心配额分配效率会急速下降、系统不具备平滑扩展能力。  </li>\n</ol>\n<p>而动态配额申请制，工作原理如下：  </p>\n<ol>\n<li>系统部署的时候，根据服务节点数和静态流控 QPS阈值，拿出一定比例的配额做初始分配，剩余的配额放在配额资源池中。</li>\n<li>哪个服务节点使用完了配额，就主动向服务注册中心申请配额。配额的申请策略是，如果流控周期为 T，则将周期 T分成更小的周期 T/N（N为经验值，默认值为 10），当前的服务节点数为 M个，则申请的配额为（总 QPS配额-已经分配的 QPS）/ M * T / N。</li>\n<li>总的配额如果被申请完，则返回 0 配额给各个申请配额的服务节点，服务节点对新接入的请求消息进行流控。</li>\n</ol>\n<p>动态配额申请制的优点：</p>\n<ol>\n<li>各个服务节点最清楚自己的负载情况，性能 KPI数据在本地内存中计算获得，实时性高。</li>\n<li>由各个服务节点根据自身负载情况去申请配额，保证性能高的节点有更高的配额，性能差的自然配额就少，实现合理资源，流控的精确性。</li>\n</ol>\n<h1 id=\"2-动态流控\"><a href=\"#2-动态流控\" class=\"headerlink\" title=\"2 动态流控\"></a>2 动态流控</h1><p>动态流控的最终目标是为了保命，并不是对流量或者访问速度做精确控制。<br>触发动态流控的因子是资源，资源又分为系统资源和应用资源两大类，根据不同的资源负载情况，动态流控又分为多个级别，每个级别流控系数都不同，也就是被拒绝掉的消息比例不同。每个级别都有相应的流控阈值，这个阈值通常支持在线动态调整。</p>\n<h2 id=\"2-1-动态流控因子\"><a href=\"#2-1-动态流控因子\" class=\"headerlink\" title=\"2.1 动态流控因子\"></a>2.1 动态流控因子</h2><p>动态流控因子包括系统资源和应用资源两大类，常见的系统资源包括：</p>\n<ol>\n<li>应用进程所在主机/VM 的 CPU使用率。</li>\n<li>应用进程所在主机/VM 的 内存使用率。  </li>\n</ol>\n<p>使用 java.lang.Process 执行 top、sar 等外部命令获取系统资源使用情况。<br>常用的应用资源：  </p>\n<ol>\n<li>JVM 堆内存使用率</li>\n<li>消息队列积压率</li>\n<li>会话积压率  </li>\n</ol>\n<p>具体实现策略是系统启动时拉起一个管理线程，定时采集应用资源的使用率，并刷新动态流控的应用资源阈值。</p>\n<h2 id=\"2-2-分级流控\"><a href=\"#2-2-分级流控\" class=\"headerlink\" title=\"2.2 分级流控\"></a>2.2 分级流控</h2><p>不同级别拒掉的消息比例不同，例如一级流控拒绝掉 1/8 的消息；发生二级流控时，拒绝掉 1/4 消息。<br>为了防止系统波动导致的偶发性流控，无论是进入流控状态还是从流控状态恢复，都需要连续采集 N次并计算平均值，如果连续 N次平均值大于流控阈值，则进入流控状态。<br>而在一个流控周期内，不会发生流控级别的跳变。</p>\n<h1 id=\"3-并发控制\"><a href=\"#3-并发控制\" class=\"headerlink\" title=\"3 并发控制\"></a>3 并发控制</h1><p>并发控制针对线程的并发执行数进行控制，它的本质是限制对某个服务或者服务的方法过度消息，耗用过多的资源而影响其它的服务的正常运行。有两种形式：  </p>\n<ol>\n<li>针对服务提供者的全局控制。</li>\n<li>针对服务消费者的局部控制。</li>\n</ol>\n<h1 id=\"4-连接控制\"><a href=\"#4-连接控制\" class=\"headerlink\" title=\"4 连接控制\"></a>4 连接控制</h1><p>通常分布式服务框架服务提供者和消费者之间采用长连接私有协议，为了防止因为消费者连接数过多导致服务端负载压力过大，系统需要针对连接数进行流控。  </p>\n<h1 id=\"5-并发和连接控制算法\"><a href=\"#5-并发和连接控制算法\" class=\"headerlink\" title=\"5 并发和连接控制算法\"></a>5 并发和连接控制算法</h1><p>并发连接的控制算法原理如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_3.png\" alt=\"\"></p>\n<p>基于服务调用 Pipeline 机制，可以对请求消息接收和发送、应答消息接收和发送、异常消息等做切面拦截（类似 Spring 的 AOP 机制，但是没采用反射机制，性能更高），利用 Pipeline 拦截切面接口，对请求消息做服务调用前的拦截和计数，根据计数器做流控，服务端的算法如下：  </p>\n<ol>\n<li>获取流控阈值。</li>\n<li>从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。</li>\n<li>如果等于或者大于流控阈值，则抛出 RPC流控异常给客户端。</li>\n<li>服务调用执行完成之后，获取 RPC上下文中的并发执行数，做原子自减。  </li>\n</ol>\n<p>客户端的算法如下：  </p>\n<ol>\n<li>获取流控阈值。</li>\n<li>从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。</li>\n<li>如果等于或大于流控阈值，则当前线程进入 wait状态， wait超时时间为服务调用的超时时间。</li>\n<li>如果有其它线程服务调用完成，调用计数器自减，则并发执行数小于阈值，线程被 notify，退出 wait，继续执行。</li>\n</ol>\n<h1 id=\"6-个人总结\"><a href=\"#6-个人总结\" class=\"headerlink\" title=\"6 个人总结\"></a>6 个人总结</h1><p>流量控制是保证服务 SLA（Sevice-Level Agreement）的重要措施，也是业务高峰期故障预防和恢复的有效手段，分布式服务框架需要支持流控阈值、策略的在线调整，不需要重启应用即可生效。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当资源成为瓶颈时，服务框架需要对消费者做限流，启动流控保护机制。</p>\n<h1 id=\"1-静态流控\"><a href=\"#1-静态流控\" class=\"headerlink\" title=\"1 静态流控\"></a>1 静态流控</h1><p>主要针对客户端访问速率进行控制，它通常根据服务质量等级协定（SLA）中约定的 QPS做全局流量控制，例如订单服务的静态流控阈值为 100QPS，则无论集群有多少个订单服务实例，它们总的处理速率之和不能超过 100QPS。</p>\n<h2 id=\"1-1-传统静态流控设计方案\"><a href=\"#1-1-传统静态流控设计方案\" class=\"headerlink\" title=\"1.1 传统静态流控设计方案\"></a>1.1 传统静态流控设计方案</h2><p>在软件安装时，根据集群服务节点个数和静态流控阈值，计算每个服务及诶单分摊的 QPS阈值，系统运行时，各个服务节点按照自己分配的阈值进行流控，对于超出流控阈值的请求则拒绝访问。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_1.png\" alt=\"\"><br>服务框架启动时，将本节点的静态流控阈值加载到内存中，服务框架通过 Handler拦截器咋服务调用前做拦截计数，当计数器在指定周期 T到达 QPS上限时，启动流控，拒绝信的请求消息接入。注意：  </p>\n<ol>\n<li>服务实例通常由多线程执行，因此计数时需要考虑线程并发安全，可以使用 Atomic原子类进行原子操作。</li>\n<li>达到流控阈值之后拒绝新的请求消息接入，不能拒绝后续的应答消息，否则这会导致客户端超时或者触发 FailOver，增加服务端的负载。</li>\n</ol>\n<h2 id=\"1-2-传统方案的缺点\"><a href=\"#1-2-传统方案的缺点\" class=\"headerlink\" title=\"1.2 传统方案的缺点\"></a>1.2 传统方案的缺点</h2><ol>\n<li>云端服务的弹性伸缩性使服务节点数处于动态变化过程中，预分配方案行不通。</li>\n<li>服务节点宕机，或者有新的服务节点动态加入，导致服务节点数发生变化，静态分配的 QPS需要实时动态调整，否则会导致流控不准。</li>\n</ol>\n<p>当应用和服务迁移到云上之后， PaaS 平台的一个重要功能就是支持应用和服务的弹性伸缩，在云上，资源都是动态分配和调整的，静态分配阈值方案无法适应服务迁移到云上。</p>\n<h2 id=\"1-3-动态配额分配制\"><a href=\"#1-3-动态配额分配制\" class=\"headerlink\" title=\"1.3 动态配额分配制\"></a>1.3 动态配额分配制</h2><p>原理：由服务注册中心以流控周期 T为单位，动态推送每个节点分配的流控阈值 QPS。当服务节点发生变更时，会触发服务注册中心重新计算每个节点的配额，然后进行推送，这样无论是新增还是减少服务节点数，都能够在下一个流控周期内被识别和处理。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_2.png\" alt=\"\"><br>而在生产环境中，每台机器/VM 的配置可能不同，如果每个服务节点采用流控总阈值/服务节点数这种平均主义，可能会发生性能高、处理快的节点配额很快用完，但是性能差的节点配额有剩余的情况，这会导致总的配额没用完，但是系统却发生了静态流控的问题。<br>解决方案一：根据各个服务节点的性能 KPI数据（例如服务调用平均时延）做加权。<br>解决方案二：配额指标返还和重新申请，每个服务节点根据自身分配的指标值、处理速率做预测，如果计算结果表明指标会有剩余，则把多余的返还给服务注册中心；对于配额已经使用完的服务节点，重新主动去服务注册中心申请配额，如果连续 N次都申请不到新的配额指标，则对于新接入的请求消息做流控。  </p>\n<p>结合负载均衡进行静态流控，才能够实现更精确的调度和控制。消费者根据各服务节点的负载情况做加权路由，性能差的节点路由到的消息更少，这样保证了系统的负载均衡和配额的合理分配。</p>\n<h2 id=\"1-4-动态配额申请制\"><a href=\"#1-4-动态配额申请制\" class=\"headerlink\" title=\"1.4 动态配额申请制\"></a>1.4 动态配额申请制</h2><p>尽管动态配额分配制可以解决节点变化引起的流控不准问题，也能改善平均主义配额分配缺点如下：</p>\n<ol>\n<li>如果流控周期 T比较大，各服务节点的负载情况变化比较快，服务节点的负载反馈到注册中心，统一计算后再做配额均衡，误差会比较大。</li>\n<li>如果流控周期 T比较小，服务注册中心需要实时获取各服务节点的性能 KPI数据并计算负载情况，经过性能数据采集、上报、汇总和计算之后会有一定的时延，这会导致流控滞后产生误差。</li>\n<li>如果采用配额返还和重新申请方式，则会增加交互次数，同时也会存在时序误差。</li>\n<li>扩展性差，负载的汇总、计算和配额分配、下发都由服务注册中心完成，如果服务注册中心管理的节点数非常多，则服务注册中心的计算压力就非常大，随着服务节点数的增加服务注册中心配额分配效率会急速下降、系统不具备平滑扩展能力。  </li>\n</ol>\n<p>而动态配额申请制，工作原理如下：  </p>\n<ol>\n<li>系统部署的时候，根据服务节点数和静态流控 QPS阈值，拿出一定比例的配额做初始分配，剩余的配额放在配额资源池中。</li>\n<li>哪个服务节点使用完了配额，就主动向服务注册中心申请配额。配额的申请策略是，如果流控周期为 T，则将周期 T分成更小的周期 T/N（N为经验值，默认值为 10），当前的服务节点数为 M个，则申请的配额为（总 QPS配额-已经分配的 QPS）/ M * T / N。</li>\n<li>总的配额如果被申请完，则返回 0 配额给各个申请配额的服务节点，服务节点对新接入的请求消息进行流控。</li>\n</ol>\n<p>动态配额申请制的优点：</p>\n<ol>\n<li>各个服务节点最清楚自己的负载情况，性能 KPI数据在本地内存中计算获得，实时性高。</li>\n<li>由各个服务节点根据自身负载情况去申请配额，保证性能高的节点有更高的配额，性能差的自然配额就少，实现合理资源，流控的精确性。</li>\n</ol>\n<h1 id=\"2-动态流控\"><a href=\"#2-动态流控\" class=\"headerlink\" title=\"2 动态流控\"></a>2 动态流控</h1><p>动态流控的最终目标是为了保命，并不是对流量或者访问速度做精确控制。<br>触发动态流控的因子是资源，资源又分为系统资源和应用资源两大类，根据不同的资源负载情况，动态流控又分为多个级别，每个级别流控系数都不同，也就是被拒绝掉的消息比例不同。每个级别都有相应的流控阈值，这个阈值通常支持在线动态调整。</p>\n<h2 id=\"2-1-动态流控因子\"><a href=\"#2-1-动态流控因子\" class=\"headerlink\" title=\"2.1 动态流控因子\"></a>2.1 动态流控因子</h2><p>动态流控因子包括系统资源和应用资源两大类，常见的系统资源包括：</p>\n<ol>\n<li>应用进程所在主机/VM 的 CPU使用率。</li>\n<li>应用进程所在主机/VM 的 内存使用率。  </li>\n</ol>\n<p>使用 java.lang.Process 执行 top、sar 等外部命令获取系统资源使用情况。<br>常用的应用资源：  </p>\n<ol>\n<li>JVM 堆内存使用率</li>\n<li>消息队列积压率</li>\n<li>会话积压率  </li>\n</ol>\n<p>具体实现策略是系统启动时拉起一个管理线程，定时采集应用资源的使用率，并刷新动态流控的应用资源阈值。</p>\n<h2 id=\"2-2-分级流控\"><a href=\"#2-2-分级流控\" class=\"headerlink\" title=\"2.2 分级流控\"></a>2.2 分级流控</h2><p>不同级别拒掉的消息比例不同，例如一级流控拒绝掉 1/8 的消息；发生二级流控时，拒绝掉 1/4 消息。<br>为了防止系统波动导致的偶发性流控，无论是进入流控状态还是从流控状态恢复，都需要连续采集 N次并计算平均值，如果连续 N次平均值大于流控阈值，则进入流控状态。<br>而在一个流控周期内，不会发生流控级别的跳变。</p>\n<h1 id=\"3-并发控制\"><a href=\"#3-并发控制\" class=\"headerlink\" title=\"3 并发控制\"></a>3 并发控制</h1><p>并发控制针对线程的并发执行数进行控制，它的本质是限制对某个服务或者服务的方法过度消息，耗用过多的资源而影响其它的服务的正常运行。有两种形式：  </p>\n<ol>\n<li>针对服务提供者的全局控制。</li>\n<li>针对服务消费者的局部控制。</li>\n</ol>\n<h1 id=\"4-连接控制\"><a href=\"#4-连接控制\" class=\"headerlink\" title=\"4 连接控制\"></a>4 连接控制</h1><p>通常分布式服务框架服务提供者和消费者之间采用长连接私有协议，为了防止因为消费者连接数过多导致服务端负载压力过大，系统需要针对连接数进行流控。  </p>\n<h1 id=\"5-并发和连接控制算法\"><a href=\"#5-并发和连接控制算法\" class=\"headerlink\" title=\"5 并发和连接控制算法\"></a>5 并发和连接控制算法</h1><p>并发连接的控制算法原理如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_3.png\" alt=\"\"></p>\n<p>基于服务调用 Pipeline 机制，可以对请求消息接收和发送、应答消息接收和发送、异常消息等做切面拦截（类似 Spring 的 AOP 机制，但是没采用反射机制，性能更高），利用 Pipeline 拦截切面接口，对请求消息做服务调用前的拦截和计数，根据计数器做流控，服务端的算法如下：  </p>\n<ol>\n<li>获取流控阈值。</li>\n<li>从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。</li>\n<li>如果等于或者大于流控阈值，则抛出 RPC流控异常给客户端。</li>\n<li>服务调用执行完成之后，获取 RPC上下文中的并发执行数，做原子自减。  </li>\n</ol>\n<p>客户端的算法如下：  </p>\n<ol>\n<li>获取流控阈值。</li>\n<li>从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。</li>\n<li>如果等于或大于流控阈值，则当前线程进入 wait状态， wait超时时间为服务调用的超时时间。</li>\n<li>如果有其它线程服务调用完成，调用计数器自减，则并发执行数小于阈值，线程被 notify，退出 wait，继续执行。</li>\n</ol>\n<h1 id=\"6-个人总结\"><a href=\"#6-个人总结\" class=\"headerlink\" title=\"6 个人总结\"></a>6 个人总结</h1><p>流量控制是保证服务 SLA（Sevice-Level Agreement）的重要措施，也是业务高峰期故障预防和恢复的有效手段，分布式服务框架需要支持流控阈值、策略的在线调整，不需要重启应用即可生效。</p>\n"},{"title":"十、服务发布和引用","date":"2018-06-03T15:55:00.000Z","updated":"2018-06-04T15:51:00.000Z","comments":1,"_content":"\n服务提供者需要支持通过配置、注解、API调用等方式，把本地接口发布成远程服务；对于消费者，可以通过对等的方式引用远程服务提供者，实现服务的发布和引用。\n\n# 1 服务发布设计\n\n服务发布流程：  \n![][1]\n\n## 1.1 服务发布的几种方式\n\n1. XML配置化方式：业务代码零侵入\n2. 注解方式：业务代码低侵入\n3. API调用方式：业务代码侵入较强\n\n## 1.2 本地实现类封装成代理\n\n对于服务提供者，将本地实现类封装成代理对象不是必需的：也可以利用一系列工具类解析服务提供者信息，然后将服务提供者的地址信息注册到服务注册中心。采用动态代理的好处如下：  \n1. 不管是什么服务，它们的发布流程都是相似的，通过抽象代理层，可以对服务发布行为本身进行封装和抽象。\n2. 通过动态代理对象，可以对服务发布进行动态拦截，方便平台和业务对服务发布进行个性化定制。\n3. 便于扩展和替换。\n\n## 1.3 服务发布成指定协议\n\n同一个服务，允许发布成多种协议，例如 HTTP、Thrift 等。\n\n## 1.4 服务提供者信息注册\n\n服务按指定协议发布之后，需要将服务发布信息注册到注册中心，用于服务路由和服务治理。  \n  \n服务注册的结构有多种方式，例如按照主机地址、按照服务名或者 URL。  \n![][2]\n\n# 2 服务引用设计\n\n消费者导入服务提供者的接口 API定义，配置服务引用信息，即可在代码中直接调用远程服务：  \n![][3]  \n\n## 2.1 本地接口调用转换成远程服务调用\n\n原理在于根据导入的服务提供者接口 API和服务引用信息，生成远程服务的本地动态代理对象；它负责将本地的 API调用转换成远程服务调用，然后将结果返回给调用者。\n\n## 2.2 服务地址的本地缓存\n\n服务消费者和提供者的启动顺序无法控制，因此消费者需要检测指定服务目录，监听新的服务提供者注册和已发布服务的下线，工作原理如下：  \n![][4]\n\n## 2.3 远程服务调用\n\n消费者从本地缓存的服务列表中按照指定策略路由，将请求消息封装成协议消息：调用相关协议的客户端将请求发送给服务提供者，业务线程按照服务调用方式选择同步等待或者注册监听器回调。  \n![][5]\n\n# 3 最佳实践\n\n## 3.1 对等设计原则\n\n例如，通过 XML的 Method 元素可以配置方法级参数，那么 API或者注解也应该支持方法级设置，以防止能力不对等。\n\n## 3.2 启动顺序问题\n\n服务注册中心如果后启动，需要服务提供者和消费者能够自动重连。\n\n## 3.3 同步还是异步发布服务\n\n通常情况下，服务全部准备就绪的时间比较短，而且系统启动之后也并不意味着所有服务都会被立即消费，因此，采用异步的方式发布服务也是可行的。  \n当然还有另外一些办法可减少系统启动时间。例如对于不经常访问的服务采用延迟发布的策略；还有就是服务的懒加载，只发布服务但是不初始化，等到消费者真正调用的时候才进行初始化服务。\n\n## 3.4 警惕网络风暴\n\n在大规模集群系统中，服务注册中心可能管理数十万条的服务注册信息以及上万个服务提供者和消费者节点。如果服务注册中心管理了大量经常变更的信息，就会发生频繁的变更通知：而这种海量的变更通知可能会挤占服务注册中心的网络带宽，严重时还会导致网络风暴。  \n因此，在设计时需要考虑如下几个要素：  \n1. 哪些信息需要注册到服务注册中心，需要甄别。\n2. 服务注册中心能够管理的服务上限。\n3. 服务注册中心的网络带宽规划。\n4. 服务注册中心的磁盘空间规划。\n5. 服务注册中心的性能。\n\n\n## 3.5 配置扩展\n\n# 4 个人总结\n\n好的分布服务框架对业务代码的侵入要足够低（使用 XML配置方式），将普通的 Java 接口发布成远程服务。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_5.png","source":"_posts/分布式服务框架原理与实践/第十章 服务发布和引用.md","raw":"---\ntitle: 十、服务发布和引用\ndate: 2018-06-03 23:55:00\nupdated: 2018-06-04 23:51:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/10.html    \n---\n\n服务提供者需要支持通过配置、注解、API调用等方式，把本地接口发布成远程服务；对于消费者，可以通过对等的方式引用远程服务提供者，实现服务的发布和引用。\n\n# 1 服务发布设计\n\n服务发布流程：  \n![][1]\n\n## 1.1 服务发布的几种方式\n\n1. XML配置化方式：业务代码零侵入\n2. 注解方式：业务代码低侵入\n3. API调用方式：业务代码侵入较强\n\n## 1.2 本地实现类封装成代理\n\n对于服务提供者，将本地实现类封装成代理对象不是必需的：也可以利用一系列工具类解析服务提供者信息，然后将服务提供者的地址信息注册到服务注册中心。采用动态代理的好处如下：  \n1. 不管是什么服务，它们的发布流程都是相似的，通过抽象代理层，可以对服务发布行为本身进行封装和抽象。\n2. 通过动态代理对象，可以对服务发布进行动态拦截，方便平台和业务对服务发布进行个性化定制。\n3. 便于扩展和替换。\n\n## 1.3 服务发布成指定协议\n\n同一个服务，允许发布成多种协议，例如 HTTP、Thrift 等。\n\n## 1.4 服务提供者信息注册\n\n服务按指定协议发布之后，需要将服务发布信息注册到注册中心，用于服务路由和服务治理。  \n  \n服务注册的结构有多种方式，例如按照主机地址、按照服务名或者 URL。  \n![][2]\n\n# 2 服务引用设计\n\n消费者导入服务提供者的接口 API定义，配置服务引用信息，即可在代码中直接调用远程服务：  \n![][3]  \n\n## 2.1 本地接口调用转换成远程服务调用\n\n原理在于根据导入的服务提供者接口 API和服务引用信息，生成远程服务的本地动态代理对象；它负责将本地的 API调用转换成远程服务调用，然后将结果返回给调用者。\n\n## 2.2 服务地址的本地缓存\n\n服务消费者和提供者的启动顺序无法控制，因此消费者需要检测指定服务目录，监听新的服务提供者注册和已发布服务的下线，工作原理如下：  \n![][4]\n\n## 2.3 远程服务调用\n\n消费者从本地缓存的服务列表中按照指定策略路由，将请求消息封装成协议消息：调用相关协议的客户端将请求发送给服务提供者，业务线程按照服务调用方式选择同步等待或者注册监听器回调。  \n![][5]\n\n# 3 最佳实践\n\n## 3.1 对等设计原则\n\n例如，通过 XML的 Method 元素可以配置方法级参数，那么 API或者注解也应该支持方法级设置，以防止能力不对等。\n\n## 3.2 启动顺序问题\n\n服务注册中心如果后启动，需要服务提供者和消费者能够自动重连。\n\n## 3.3 同步还是异步发布服务\n\n通常情况下，服务全部准备就绪的时间比较短，而且系统启动之后也并不意味着所有服务都会被立即消费，因此，采用异步的方式发布服务也是可行的。  \n当然还有另外一些办法可减少系统启动时间。例如对于不经常访问的服务采用延迟发布的策略；还有就是服务的懒加载，只发布服务但是不初始化，等到消费者真正调用的时候才进行初始化服务。\n\n## 3.4 警惕网络风暴\n\n在大规模集群系统中，服务注册中心可能管理数十万条的服务注册信息以及上万个服务提供者和消费者节点。如果服务注册中心管理了大量经常变更的信息，就会发生频繁的变更通知：而这种海量的变更通知可能会挤占服务注册中心的网络带宽，严重时还会导致网络风暴。  \n因此，在设计时需要考虑如下几个要素：  \n1. 哪些信息需要注册到服务注册中心，需要甄别。\n2. 服务注册中心能够管理的服务上限。\n3. 服务注册中心的网络带宽规划。\n4. 服务注册中心的磁盘空间规划。\n5. 服务注册中心的性能。\n\n\n## 3.5 配置扩展\n\n# 4 个人总结\n\n好的分布服务框架对业务代码的侵入要足够低（使用 XML配置方式），将普通的 Java 接口发布成远程服务。\n\n[1]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_1.png\n[2]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_2.png\n[3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_3.png\n[4]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_4.png\n[5]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_5.png","slug":"distributed_principle_prictice/10.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavn0022axs6s1hmfk49","content":"<p>服务提供者需要支持通过配置、注解、API调用等方式，把本地接口发布成远程服务；对于消费者，可以通过对等的方式引用远程服务提供者，实现服务的发布和引用。</p>\n<h1 id=\"1-服务发布设计\"><a href=\"#1-服务发布设计\" class=\"headerlink\" title=\"1 服务发布设计\"></a>1 服务发布设计</h1><p>服务发布流程：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_1.png\" alt=\"\"></p>\n<h2 id=\"1-1-服务发布的几种方式\"><a href=\"#1-1-服务发布的几种方式\" class=\"headerlink\" title=\"1.1 服务发布的几种方式\"></a>1.1 服务发布的几种方式</h2><ol>\n<li>XML配置化方式：业务代码零侵入</li>\n<li>注解方式：业务代码低侵入</li>\n<li>API调用方式：业务代码侵入较强</li>\n</ol>\n<h2 id=\"1-2-本地实现类封装成代理\"><a href=\"#1-2-本地实现类封装成代理\" class=\"headerlink\" title=\"1.2 本地实现类封装成代理\"></a>1.2 本地实现类封装成代理</h2><p>对于服务提供者，将本地实现类封装成代理对象不是必需的：也可以利用一系列工具类解析服务提供者信息，然后将服务提供者的地址信息注册到服务注册中心。采用动态代理的好处如下：  </p>\n<ol>\n<li>不管是什么服务，它们的发布流程都是相似的，通过抽象代理层，可以对服务发布行为本身进行封装和抽象。</li>\n<li>通过动态代理对象，可以对服务发布进行动态拦截，方便平台和业务对服务发布进行个性化定制。</li>\n<li>便于扩展和替换。</li>\n</ol>\n<h2 id=\"1-3-服务发布成指定协议\"><a href=\"#1-3-服务发布成指定协议\" class=\"headerlink\" title=\"1.3 服务发布成指定协议\"></a>1.3 服务发布成指定协议</h2><p>同一个服务，允许发布成多种协议，例如 HTTP、Thrift 等。</p>\n<h2 id=\"1-4-服务提供者信息注册\"><a href=\"#1-4-服务提供者信息注册\" class=\"headerlink\" title=\"1.4 服务提供者信息注册\"></a>1.4 服务提供者信息注册</h2><p>服务按指定协议发布之后，需要将服务发布信息注册到注册中心，用于服务路由和服务治理。  </p>\n<p>服务注册的结构有多种方式，例如按照主机地址、按照服务名或者 URL。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_2.png\" alt=\"\"></p>\n<h1 id=\"2-服务引用设计\"><a href=\"#2-服务引用设计\" class=\"headerlink\" title=\"2 服务引用设计\"></a>2 服务引用设计</h1><p>消费者导入服务提供者的接口 API定义，配置服务引用信息，即可在代码中直接调用远程服务：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_3.png\" alt=\"\">  </p>\n<h2 id=\"2-1-本地接口调用转换成远程服务调用\"><a href=\"#2-1-本地接口调用转换成远程服务调用\" class=\"headerlink\" title=\"2.1 本地接口调用转换成远程服务调用\"></a>2.1 本地接口调用转换成远程服务调用</h2><p>原理在于根据导入的服务提供者接口 API和服务引用信息，生成远程服务的本地动态代理对象；它负责将本地的 API调用转换成远程服务调用，然后将结果返回给调用者。</p>\n<h2 id=\"2-2-服务地址的本地缓存\"><a href=\"#2-2-服务地址的本地缓存\" class=\"headerlink\" title=\"2.2 服务地址的本地缓存\"></a>2.2 服务地址的本地缓存</h2><p>服务消费者和提供者的启动顺序无法控制，因此消费者需要检测指定服务目录，监听新的服务提供者注册和已发布服务的下线，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_4.png\" alt=\"\"></p>\n<h2 id=\"2-3-远程服务调用\"><a href=\"#2-3-远程服务调用\" class=\"headerlink\" title=\"2.3 远程服务调用\"></a>2.3 远程服务调用</h2><p>消费者从本地缓存的服务列表中按照指定策略路由，将请求消息封装成协议消息：调用相关协议的客户端将请求发送给服务提供者，业务线程按照服务调用方式选择同步等待或者注册监听器回调。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_5.png\" alt=\"\"></p>\n<h1 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3 最佳实践\"></a>3 最佳实践</h1><h2 id=\"3-1-对等设计原则\"><a href=\"#3-1-对等设计原则\" class=\"headerlink\" title=\"3.1 对等设计原则\"></a>3.1 对等设计原则</h2><p>例如，通过 XML的 Method 元素可以配置方法级参数，那么 API或者注解也应该支持方法级设置，以防止能力不对等。</p>\n<h2 id=\"3-2-启动顺序问题\"><a href=\"#3-2-启动顺序问题\" class=\"headerlink\" title=\"3.2 启动顺序问题\"></a>3.2 启动顺序问题</h2><p>服务注册中心如果后启动，需要服务提供者和消费者能够自动重连。</p>\n<h2 id=\"3-3-同步还是异步发布服务\"><a href=\"#3-3-同步还是异步发布服务\" class=\"headerlink\" title=\"3.3 同步还是异步发布服务\"></a>3.3 同步还是异步发布服务</h2><p>通常情况下，服务全部准备就绪的时间比较短，而且系统启动之后也并不意味着所有服务都会被立即消费，因此，采用异步的方式发布服务也是可行的。<br>当然还有另外一些办法可减少系统启动时间。例如对于不经常访问的服务采用延迟发布的策略；还有就是服务的懒加载，只发布服务但是不初始化，等到消费者真正调用的时候才进行初始化服务。</p>\n<h2 id=\"3-4-警惕网络风暴\"><a href=\"#3-4-警惕网络风暴\" class=\"headerlink\" title=\"3.4 警惕网络风暴\"></a>3.4 警惕网络风暴</h2><p>在大规模集群系统中，服务注册中心可能管理数十万条的服务注册信息以及上万个服务提供者和消费者节点。如果服务注册中心管理了大量经常变更的信息，就会发生频繁的变更通知：而这种海量的变更通知可能会挤占服务注册中心的网络带宽，严重时还会导致网络风暴。<br>因此，在设计时需要考虑如下几个要素：  </p>\n<ol>\n<li>哪些信息需要注册到服务注册中心，需要甄别。</li>\n<li>服务注册中心能够管理的服务上限。</li>\n<li>服务注册中心的网络带宽规划。</li>\n<li>服务注册中心的磁盘空间规划。</li>\n<li>服务注册中心的性能。</li>\n</ol>\n<h2 id=\"3-5-配置扩展\"><a href=\"#3-5-配置扩展\" class=\"headerlink\" title=\"3.5 配置扩展\"></a>3.5 配置扩展</h2><h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>好的分布服务框架对业务代码的侵入要足够低（使用 XML配置方式），将普通的 Java 接口发布成远程服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>服务提供者需要支持通过配置、注解、API调用等方式，把本地接口发布成远程服务；对于消费者，可以通过对等的方式引用远程服务提供者，实现服务的发布和引用。</p>\n<h1 id=\"1-服务发布设计\"><a href=\"#1-服务发布设计\" class=\"headerlink\" title=\"1 服务发布设计\"></a>1 服务发布设计</h1><p>服务发布流程：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_1.png\" alt=\"\"></p>\n<h2 id=\"1-1-服务发布的几种方式\"><a href=\"#1-1-服务发布的几种方式\" class=\"headerlink\" title=\"1.1 服务发布的几种方式\"></a>1.1 服务发布的几种方式</h2><ol>\n<li>XML配置化方式：业务代码零侵入</li>\n<li>注解方式：业务代码低侵入</li>\n<li>API调用方式：业务代码侵入较强</li>\n</ol>\n<h2 id=\"1-2-本地实现类封装成代理\"><a href=\"#1-2-本地实现类封装成代理\" class=\"headerlink\" title=\"1.2 本地实现类封装成代理\"></a>1.2 本地实现类封装成代理</h2><p>对于服务提供者，将本地实现类封装成代理对象不是必需的：也可以利用一系列工具类解析服务提供者信息，然后将服务提供者的地址信息注册到服务注册中心。采用动态代理的好处如下：  </p>\n<ol>\n<li>不管是什么服务，它们的发布流程都是相似的，通过抽象代理层，可以对服务发布行为本身进行封装和抽象。</li>\n<li>通过动态代理对象，可以对服务发布进行动态拦截，方便平台和业务对服务发布进行个性化定制。</li>\n<li>便于扩展和替换。</li>\n</ol>\n<h2 id=\"1-3-服务发布成指定协议\"><a href=\"#1-3-服务发布成指定协议\" class=\"headerlink\" title=\"1.3 服务发布成指定协议\"></a>1.3 服务发布成指定协议</h2><p>同一个服务，允许发布成多种协议，例如 HTTP、Thrift 等。</p>\n<h2 id=\"1-4-服务提供者信息注册\"><a href=\"#1-4-服务提供者信息注册\" class=\"headerlink\" title=\"1.4 服务提供者信息注册\"></a>1.4 服务提供者信息注册</h2><p>服务按指定协议发布之后，需要将服务发布信息注册到注册中心，用于服务路由和服务治理。  </p>\n<p>服务注册的结构有多种方式，例如按照主机地址、按照服务名或者 URL。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_2.png\" alt=\"\"></p>\n<h1 id=\"2-服务引用设计\"><a href=\"#2-服务引用设计\" class=\"headerlink\" title=\"2 服务引用设计\"></a>2 服务引用设计</h1><p>消费者导入服务提供者的接口 API定义，配置服务引用信息，即可在代码中直接调用远程服务：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_3.png\" alt=\"\">  </p>\n<h2 id=\"2-1-本地接口调用转换成远程服务调用\"><a href=\"#2-1-本地接口调用转换成远程服务调用\" class=\"headerlink\" title=\"2.1 本地接口调用转换成远程服务调用\"></a>2.1 本地接口调用转换成远程服务调用</h2><p>原理在于根据导入的服务提供者接口 API和服务引用信息，生成远程服务的本地动态代理对象；它负责将本地的 API调用转换成远程服务调用，然后将结果返回给调用者。</p>\n<h2 id=\"2-2-服务地址的本地缓存\"><a href=\"#2-2-服务地址的本地缓存\" class=\"headerlink\" title=\"2.2 服务地址的本地缓存\"></a>2.2 服务地址的本地缓存</h2><p>服务消费者和提供者的启动顺序无法控制，因此消费者需要检测指定服务目录，监听新的服务提供者注册和已发布服务的下线，工作原理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_4.png\" alt=\"\"></p>\n<h2 id=\"2-3-远程服务调用\"><a href=\"#2-3-远程服务调用\" class=\"headerlink\" title=\"2.3 远程服务调用\"></a>2.3 远程服务调用</h2><p>消费者从本地缓存的服务列表中按照指定策略路由，将请求消息封装成协议消息：调用相关协议的客户端将请求发送给服务提供者，业务线程按照服务调用方式选择同步等待或者注册监听器回调。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_5.png\" alt=\"\"></p>\n<h1 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3 最佳实践\"></a>3 最佳实践</h1><h2 id=\"3-1-对等设计原则\"><a href=\"#3-1-对等设计原则\" class=\"headerlink\" title=\"3.1 对等设计原则\"></a>3.1 对等设计原则</h2><p>例如，通过 XML的 Method 元素可以配置方法级参数，那么 API或者注解也应该支持方法级设置，以防止能力不对等。</p>\n<h2 id=\"3-2-启动顺序问题\"><a href=\"#3-2-启动顺序问题\" class=\"headerlink\" title=\"3.2 启动顺序问题\"></a>3.2 启动顺序问题</h2><p>服务注册中心如果后启动，需要服务提供者和消费者能够自动重连。</p>\n<h2 id=\"3-3-同步还是异步发布服务\"><a href=\"#3-3-同步还是异步发布服务\" class=\"headerlink\" title=\"3.3 同步还是异步发布服务\"></a>3.3 同步还是异步发布服务</h2><p>通常情况下，服务全部准备就绪的时间比较短，而且系统启动之后也并不意味着所有服务都会被立即消费，因此，采用异步的方式发布服务也是可行的。<br>当然还有另外一些办法可减少系统启动时间。例如对于不经常访问的服务采用延迟发布的策略；还有就是服务的懒加载，只发布服务但是不初始化，等到消费者真正调用的时候才进行初始化服务。</p>\n<h2 id=\"3-4-警惕网络风暴\"><a href=\"#3-4-警惕网络风暴\" class=\"headerlink\" title=\"3.4 警惕网络风暴\"></a>3.4 警惕网络风暴</h2><p>在大规模集群系统中，服务注册中心可能管理数十万条的服务注册信息以及上万个服务提供者和消费者节点。如果服务注册中心管理了大量经常变更的信息，就会发生频繁的变更通知：而这种海量的变更通知可能会挤占服务注册中心的网络带宽，严重时还会导致网络风暴。<br>因此，在设计时需要考虑如下几个要素：  </p>\n<ol>\n<li>哪些信息需要注册到服务注册中心，需要甄别。</li>\n<li>服务注册中心能够管理的服务上限。</li>\n<li>服务注册中心的网络带宽规划。</li>\n<li>服务注册中心的磁盘空间规划。</li>\n<li>服务注册中心的性能。</li>\n</ol>\n<h2 id=\"3-5-配置扩展\"><a href=\"#3-5-配置扩展\" class=\"headerlink\" title=\"3.5 配置扩展\"></a>3.5 配置扩展</h2><h1 id=\"4-个人总结\"><a href=\"#4-个人总结\" class=\"headerlink\" title=\"4 个人总结\"></a>4 个人总结</h1><p>好的分布服务框架对业务代码的侵入要足够低（使用 XML配置方式），将普通的 Java 接口发布成远程服务。</p>\n"},{"title":"如何阅读一本书之分布式服务框架原理与实践","date":"2018-06-11T14:56:00.000Z","updated":"2018-06-11T16:50:00.000Z","comments":1,"_content":"\n# 1 这本书在谈些什么\n\n# 2 作者的主要想法和主要观点是什么\n\n# 3 这本书说的有道理吗，还是只有部分有道理\n\n# 4 这本书跟我有什么关系","source":"_posts/分布式服务框架原理与实践/阅读总结.md","raw":"---\ntitle: 如何阅读一本书之分布式服务框架原理与实践\ndate: 2018-06-11 22:56:00\nupdated: 2018-06-12 00:50:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\n- 如何阅读一本书\npermalink: distributed_principle_prictice/0.html    \n---\n\n# 1 这本书在谈些什么\n\n# 2 作者的主要想法和主要观点是什么\n\n# 3 这本书说的有道理吗，还是只有部分有道理\n\n# 4 这本书跟我有什么关系","slug":"distributed_principle_prictice/0.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavo0025axs63pw9knkh","content":"<h1 id=\"1-这本书在谈些什么\"><a href=\"#1-这本书在谈些什么\" class=\"headerlink\" title=\"1 这本书在谈些什么\"></a>1 这本书在谈些什么</h1><h1 id=\"2-作者的主要想法和主要观点是什么\"><a href=\"#2-作者的主要想法和主要观点是什么\" class=\"headerlink\" title=\"2 作者的主要想法和主要观点是什么\"></a>2 作者的主要想法和主要观点是什么</h1><h1 id=\"3-这本书说的有道理吗，还是只有部分有道理\"><a href=\"#3-这本书说的有道理吗，还是只有部分有道理\" class=\"headerlink\" title=\"3 这本书说的有道理吗，还是只有部分有道理\"></a>3 这本书说的有道理吗，还是只有部分有道理</h1><h1 id=\"4-这本书跟我有什么关系\"><a href=\"#4-这本书跟我有什么关系\" class=\"headerlink\" title=\"4 这本书跟我有什么关系\"></a>4 这本书跟我有什么关系</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-这本书在谈些什么\"><a href=\"#1-这本书在谈些什么\" class=\"headerlink\" title=\"1 这本书在谈些什么\"></a>1 这本书在谈些什么</h1><h1 id=\"2-作者的主要想法和主要观点是什么\"><a href=\"#2-作者的主要想法和主要观点是什么\" class=\"headerlink\" title=\"2 作者的主要想法和主要观点是什么\"></a>2 作者的主要想法和主要观点是什么</h1><h1 id=\"3-这本书说的有道理吗，还是只有部分有道理\"><a href=\"#3-这本书说的有道理吗，还是只有部分有道理\" class=\"headerlink\" title=\"3 这本书说的有道理吗，还是只有部分有道理\"></a>3 这本书说的有道理吗，还是只有部分有道理</h1><h1 id=\"4-这本书跟我有什么关系\"><a href=\"#4-这本书跟我有什么关系\" class=\"headerlink\" title=\"4 这本书跟我有什么关系\"></a>4 这本书跟我有什么关系</h1>"},{"title":"四、序列化和反序列化","date":"2018-05-22T14:41:00.000Z","updated":"2018-05-26T15:36:00.000Z","comments":1,"_content":"\n# 1 几个关键概念澄清\n\n通常我们习惯将序列化（Serialization）称为编码（Encode）,它将对象序列化为字节数组，用于网络传输、数据持久化或其它用途。  \n反之，反序列化（Deserialization）/解码（Decode）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的副本）。\n\n## 1.1 序列化与通信框架的关系\n\n序列化与通信框架不是强耦合的关系，通信框架提供的编解码框架可以非常方便地支持用户通过扩展实现自定义的序列化格式。通信框架的编解码接口作为可选插件，并不强制用户一定要在通信框架内部实现消息的序列化和反序列化。\n\n## 1.2 序列化与通信协议的关系\n\n序列化与通信协议是解耦的，同一种通信协议可能由多种序列化方式承载，同一种序列化方式也可以用在不同协议里。  \n  \n以 HTTP 协议为例，承载消息体的可以是 XML、JSON 等文本类的协议，也可以是图片附件等二进制流媒体协议。  \n在设计分布式服务框架时，序列化和反序列化是一个独立的接口和插件，它可以被多种协议重用、替换和扩展，以实现服务框架序列化方式的多样性。\n\n## 1.3 是否需要支持多种序列化方式\n\n整体而言，序列化可以分为文本类和二进制类两种，不同的业务场景需求也不同，分布式服务框架面向的领域是多样化的，因此它的序列化/反序列化框架需要具备如下特性：  \n1. 默认支持多种常用的序列化/反序列化方式，文本类例如 XML/JSON 等，二进制的如 PB（Protocol Buffer）/Thrift 等。\n2. 序列化框架可扩展，用户可以非常灵活、方便地扩展其它序列化方式。\n\n# 2 功能设计\n\n从功能、跨语言支持、兼容性、性能等多个角度进行综合考量。  \n1. 功能丰富。\n2. 跨语言支持。\n3. 兼容性\n4. 性能。\n\n# 3 扩展性设计\n\n利用 Netty 提供的编解码框架，可以非常快速的实现序列化/反序列化框架的扩展。\n\n## 3.1 内置的序列化/反序列化功能类\n\n为了降低用户的开发难度，Netty 对常用的功能和 API 做了装饰，以屏蔽底层的实现细节。Netty 内置的编解码功能包括 base64、Protobuf、JBoss Marshalling、spdy 等。\n\n## 3.2 反序列化扩展\n\n1. 业务发布服务的时候，可以指定协议类型和承载数据的序列化方式，例如将购买商品服务发布成 HTTP 服务，序列化格式采用 XML；同时允许用户指定新增的序列化格式发布服务。\n2. 序列化类库能够以插件的格式插入到通信调用链中，实现序列化格式的扩展。在这个过程中，需要考虑 TCP 的黏包和拆包等底层相关的技术细节。\n  \n我们看半包的处理，如果不处理半包，Netty 调用 decode 方法传递的 ByteBuf 对象可能就是个半包，我们拿半包做反序列化就会失败，因此在反序列化之前，我们需要保证调用解码方法时传递的是个完整的数据包。  \n  \n了解 TCP 通信机制的渎职应该都知道 TCP 底层的黏包和拆包，当我们在接收消息的时候，不能认为读取到的报文就是个整包消息，特别是对于采用非阻塞 I/O 和长连接通信的程序。  \n如何区分一个整包消息，通常有如下四种做法：  \n1. 固定长度，例如每 120 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定长消息的时候比较简单，每次读到指定长度的字节后进行解码。\n2. 通过回车换行符区分消息，例如 HTTP 协议。这类区分消息的方式多用于文本协议。\n3. 通过特定的分隔符区分整包消息。\n4. 通过在协议头/消息头中设置长度字段来标识整包消息。\n\n# 4 最佳实践\n\n## 4.1 接口的前向兼容性规范\n\n1. 制定”分布式服务框架接口兼容性规范“，在规范中要明确服务框架支持哪些兼容性，例如新增字段、删除字段还是修改字段。\n2. 引导客户。\n\n## 4.2 高并发下的稳定性\n\n需要模拟现网高并发场景对序列化框架做压测和稳定性测试，如果序列化框架存在全局锁较激烈的线程竞争等问题，多线程、高并发压力测试就会出现问题。究其原因是因为一些序列化框架为了实现线程安全，使用了全局锁等，这从实用角度看确实简单，但是在高并发场景下就会出现性能下降、耗时不稳定等问题。  \n  \n解决此类问题的方案很多，例如每个线程聚合一个序列化/反序列化类库，避免多线程竞争。\n\n# 5 个人总结\n\n序列化/反序列化是 RPC 框架的基础组成部分，从性能、业务考虑，而 Netty 非常适合去做扩展。当然，还是清楚其中的经典黏包、拆包。\n","source":"_posts/分布式服务框架原理与实践/第四章 序列化和反序列化.md","raw":"---\ntitle: 四、序列化和反序列化\ndate: 2018-05-22 22:41:00\nupdated: 2018-05-26 23:36:00\ncomments: true\ncategories: \n- 读书笔记\n- 分布式服务框架原理与实践\npermalink: distributed_principle_prictice/4.html    \n---\n\n# 1 几个关键概念澄清\n\n通常我们习惯将序列化（Serialization）称为编码（Encode）,它将对象序列化为字节数组，用于网络传输、数据持久化或其它用途。  \n反之，反序列化（Deserialization）/解码（Decode）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的副本）。\n\n## 1.1 序列化与通信框架的关系\n\n序列化与通信框架不是强耦合的关系，通信框架提供的编解码框架可以非常方便地支持用户通过扩展实现自定义的序列化格式。通信框架的编解码接口作为可选插件，并不强制用户一定要在通信框架内部实现消息的序列化和反序列化。\n\n## 1.2 序列化与通信协议的关系\n\n序列化与通信协议是解耦的，同一种通信协议可能由多种序列化方式承载，同一种序列化方式也可以用在不同协议里。  \n  \n以 HTTP 协议为例，承载消息体的可以是 XML、JSON 等文本类的协议，也可以是图片附件等二进制流媒体协议。  \n在设计分布式服务框架时，序列化和反序列化是一个独立的接口和插件，它可以被多种协议重用、替换和扩展，以实现服务框架序列化方式的多样性。\n\n## 1.3 是否需要支持多种序列化方式\n\n整体而言，序列化可以分为文本类和二进制类两种，不同的业务场景需求也不同，分布式服务框架面向的领域是多样化的，因此它的序列化/反序列化框架需要具备如下特性：  \n1. 默认支持多种常用的序列化/反序列化方式，文本类例如 XML/JSON 等，二进制的如 PB（Protocol Buffer）/Thrift 等。\n2. 序列化框架可扩展，用户可以非常灵活、方便地扩展其它序列化方式。\n\n# 2 功能设计\n\n从功能、跨语言支持、兼容性、性能等多个角度进行综合考量。  \n1. 功能丰富。\n2. 跨语言支持。\n3. 兼容性\n4. 性能。\n\n# 3 扩展性设计\n\n利用 Netty 提供的编解码框架，可以非常快速的实现序列化/反序列化框架的扩展。\n\n## 3.1 内置的序列化/反序列化功能类\n\n为了降低用户的开发难度，Netty 对常用的功能和 API 做了装饰，以屏蔽底层的实现细节。Netty 内置的编解码功能包括 base64、Protobuf、JBoss Marshalling、spdy 等。\n\n## 3.2 反序列化扩展\n\n1. 业务发布服务的时候，可以指定协议类型和承载数据的序列化方式，例如将购买商品服务发布成 HTTP 服务，序列化格式采用 XML；同时允许用户指定新增的序列化格式发布服务。\n2. 序列化类库能够以插件的格式插入到通信调用链中，实现序列化格式的扩展。在这个过程中，需要考虑 TCP 的黏包和拆包等底层相关的技术细节。\n  \n我们看半包的处理，如果不处理半包，Netty 调用 decode 方法传递的 ByteBuf 对象可能就是个半包，我们拿半包做反序列化就会失败，因此在反序列化之前，我们需要保证调用解码方法时传递的是个完整的数据包。  \n  \n了解 TCP 通信机制的渎职应该都知道 TCP 底层的黏包和拆包，当我们在接收消息的时候，不能认为读取到的报文就是个整包消息，特别是对于采用非阻塞 I/O 和长连接通信的程序。  \n如何区分一个整包消息，通常有如下四种做法：  \n1. 固定长度，例如每 120 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定长消息的时候比较简单，每次读到指定长度的字节后进行解码。\n2. 通过回车换行符区分消息，例如 HTTP 协议。这类区分消息的方式多用于文本协议。\n3. 通过特定的分隔符区分整包消息。\n4. 通过在协议头/消息头中设置长度字段来标识整包消息。\n\n# 4 最佳实践\n\n## 4.1 接口的前向兼容性规范\n\n1. 制定”分布式服务框架接口兼容性规范“，在规范中要明确服务框架支持哪些兼容性，例如新增字段、删除字段还是修改字段。\n2. 引导客户。\n\n## 4.2 高并发下的稳定性\n\n需要模拟现网高并发场景对序列化框架做压测和稳定性测试，如果序列化框架存在全局锁较激烈的线程竞争等问题，多线程、高并发压力测试就会出现问题。究其原因是因为一些序列化框架为了实现线程安全，使用了全局锁等，这从实用角度看确实简单，但是在高并发场景下就会出现性能下降、耗时不稳定等问题。  \n  \n解决此类问题的方案很多，例如每个线程聚合一个序列化/反序列化类库，避免多线程竞争。\n\n# 5 个人总结\n\n序列化/反序列化是 RPC 框架的基础组成部分，从性能、业务考虑，而 Netty 非常适合去做扩展。当然，还是清楚其中的经典黏包、拆包。\n","slug":"distributed_principle_prictice/4.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavo0026axs6qy84v768","content":"<h1 id=\"1-几个关键概念澄清\"><a href=\"#1-几个关键概念澄清\" class=\"headerlink\" title=\"1 几个关键概念澄清\"></a>1 几个关键概念澄清</h1><p>通常我们习惯将序列化（Serialization）称为编码（Encode）,它将对象序列化为字节数组，用于网络传输、数据持久化或其它用途。<br>反之，反序列化（Deserialization）/解码（Decode）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的副本）。</p>\n<h2 id=\"1-1-序列化与通信框架的关系\"><a href=\"#1-1-序列化与通信框架的关系\" class=\"headerlink\" title=\"1.1 序列化与通信框架的关系\"></a>1.1 序列化与通信框架的关系</h2><p>序列化与通信框架不是强耦合的关系，通信框架提供的编解码框架可以非常方便地支持用户通过扩展实现自定义的序列化格式。通信框架的编解码接口作为可选插件，并不强制用户一定要在通信框架内部实现消息的序列化和反序列化。</p>\n<h2 id=\"1-2-序列化与通信协议的关系\"><a href=\"#1-2-序列化与通信协议的关系\" class=\"headerlink\" title=\"1.2 序列化与通信协议的关系\"></a>1.2 序列化与通信协议的关系</h2><p>序列化与通信协议是解耦的，同一种通信协议可能由多种序列化方式承载，同一种序列化方式也可以用在不同协议里。  </p>\n<p>以 HTTP 协议为例，承载消息体的可以是 XML、JSON 等文本类的协议，也可以是图片附件等二进制流媒体协议。<br>在设计分布式服务框架时，序列化和反序列化是一个独立的接口和插件，它可以被多种协议重用、替换和扩展，以实现服务框架序列化方式的多样性。</p>\n<h2 id=\"1-3-是否需要支持多种序列化方式\"><a href=\"#1-3-是否需要支持多种序列化方式\" class=\"headerlink\" title=\"1.3 是否需要支持多种序列化方式\"></a>1.3 是否需要支持多种序列化方式</h2><p>整体而言，序列化可以分为文本类和二进制类两种，不同的业务场景需求也不同，分布式服务框架面向的领域是多样化的，因此它的序列化/反序列化框架需要具备如下特性：  </p>\n<ol>\n<li>默认支持多种常用的序列化/反序列化方式，文本类例如 XML/JSON 等，二进制的如 PB（Protocol Buffer）/Thrift 等。</li>\n<li>序列化框架可扩展，用户可以非常灵活、方便地扩展其它序列化方式。</li>\n</ol>\n<h1 id=\"2-功能设计\"><a href=\"#2-功能设计\" class=\"headerlink\" title=\"2 功能设计\"></a>2 功能设计</h1><p>从功能、跨语言支持、兼容性、性能等多个角度进行综合考量。  </p>\n<ol>\n<li>功能丰富。</li>\n<li>跨语言支持。</li>\n<li>兼容性</li>\n<li>性能。</li>\n</ol>\n<h1 id=\"3-扩展性设计\"><a href=\"#3-扩展性设计\" class=\"headerlink\" title=\"3 扩展性设计\"></a>3 扩展性设计</h1><p>利用 Netty 提供的编解码框架，可以非常快速的实现序列化/反序列化框架的扩展。</p>\n<h2 id=\"3-1-内置的序列化-反序列化功能类\"><a href=\"#3-1-内置的序列化-反序列化功能类\" class=\"headerlink\" title=\"3.1 内置的序列化/反序列化功能类\"></a>3.1 内置的序列化/反序列化功能类</h2><p>为了降低用户的开发难度，Netty 对常用的功能和 API 做了装饰，以屏蔽底层的实现细节。Netty 内置的编解码功能包括 base64、Protobuf、JBoss Marshalling、spdy 等。</p>\n<h2 id=\"3-2-反序列化扩展\"><a href=\"#3-2-反序列化扩展\" class=\"headerlink\" title=\"3.2 反序列化扩展\"></a>3.2 反序列化扩展</h2><ol>\n<li>业务发布服务的时候，可以指定协议类型和承载数据的序列化方式，例如将购买商品服务发布成 HTTP 服务，序列化格式采用 XML；同时允许用户指定新增的序列化格式发布服务。</li>\n<li>序列化类库能够以插件的格式插入到通信调用链中，实现序列化格式的扩展。在这个过程中，需要考虑 TCP 的黏包和拆包等底层相关的技术细节。</li>\n</ol>\n<p>我们看半包的处理，如果不处理半包，Netty 调用 decode 方法传递的 ByteBuf 对象可能就是个半包，我们拿半包做反序列化就会失败，因此在反序列化之前，我们需要保证调用解码方法时传递的是个完整的数据包。  </p>\n<p>了解 TCP 通信机制的渎职应该都知道 TCP 底层的黏包和拆包，当我们在接收消息的时候，不能认为读取到的报文就是个整包消息，特别是对于采用非阻塞 I/O 和长连接通信的程序。<br>如何区分一个整包消息，通常有如下四种做法：  </p>\n<ol>\n<li>固定长度，例如每 120 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定长消息的时候比较简单，每次读到指定长度的字节后进行解码。</li>\n<li>通过回车换行符区分消息，例如 HTTP 协议。这类区分消息的方式多用于文本协议。</li>\n<li>通过特定的分隔符区分整包消息。</li>\n<li>通过在协议头/消息头中设置长度字段来标识整包消息。</li>\n</ol>\n<h1 id=\"4-最佳实践\"><a href=\"#4-最佳实践\" class=\"headerlink\" title=\"4 最佳实践\"></a>4 最佳实践</h1><h2 id=\"4-1-接口的前向兼容性规范\"><a href=\"#4-1-接口的前向兼容性规范\" class=\"headerlink\" title=\"4.1 接口的前向兼容性规范\"></a>4.1 接口的前向兼容性规范</h2><ol>\n<li>制定”分布式服务框架接口兼容性规范“，在规范中要明确服务框架支持哪些兼容性，例如新增字段、删除字段还是修改字段。</li>\n<li>引导客户。</li>\n</ol>\n<h2 id=\"4-2-高并发下的稳定性\"><a href=\"#4-2-高并发下的稳定性\" class=\"headerlink\" title=\"4.2 高并发下的稳定性\"></a>4.2 高并发下的稳定性</h2><p>需要模拟现网高并发场景对序列化框架做压测和稳定性测试，如果序列化框架存在全局锁较激烈的线程竞争等问题，多线程、高并发压力测试就会出现问题。究其原因是因为一些序列化框架为了实现线程安全，使用了全局锁等，这从实用角度看确实简单，但是在高并发场景下就会出现性能下降、耗时不稳定等问题。  </p>\n<p>解决此类问题的方案很多，例如每个线程聚合一个序列化/反序列化类库，避免多线程竞争。</p>\n<h1 id=\"5-个人总结\"><a href=\"#5-个人总结\" class=\"headerlink\" title=\"5 个人总结\"></a>5 个人总结</h1><p>序列化/反序列化是 RPC 框架的基础组成部分，从性能、业务考虑，而 Netty 非常适合去做扩展。当然，还是清楚其中的经典黏包、拆包。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-几个关键概念澄清\"><a href=\"#1-几个关键概念澄清\" class=\"headerlink\" title=\"1 几个关键概念澄清\"></a>1 几个关键概念澄清</h1><p>通常我们习惯将序列化（Serialization）称为编码（Encode）,它将对象序列化为字节数组，用于网络传输、数据持久化或其它用途。<br>反之，反序列化（Deserialization）/解码（Decode）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的副本）。</p>\n<h2 id=\"1-1-序列化与通信框架的关系\"><a href=\"#1-1-序列化与通信框架的关系\" class=\"headerlink\" title=\"1.1 序列化与通信框架的关系\"></a>1.1 序列化与通信框架的关系</h2><p>序列化与通信框架不是强耦合的关系，通信框架提供的编解码框架可以非常方便地支持用户通过扩展实现自定义的序列化格式。通信框架的编解码接口作为可选插件，并不强制用户一定要在通信框架内部实现消息的序列化和反序列化。</p>\n<h2 id=\"1-2-序列化与通信协议的关系\"><a href=\"#1-2-序列化与通信协议的关系\" class=\"headerlink\" title=\"1.2 序列化与通信协议的关系\"></a>1.2 序列化与通信协议的关系</h2><p>序列化与通信协议是解耦的，同一种通信协议可能由多种序列化方式承载，同一种序列化方式也可以用在不同协议里。  </p>\n<p>以 HTTP 协议为例，承载消息体的可以是 XML、JSON 等文本类的协议，也可以是图片附件等二进制流媒体协议。<br>在设计分布式服务框架时，序列化和反序列化是一个独立的接口和插件，它可以被多种协议重用、替换和扩展，以实现服务框架序列化方式的多样性。</p>\n<h2 id=\"1-3-是否需要支持多种序列化方式\"><a href=\"#1-3-是否需要支持多种序列化方式\" class=\"headerlink\" title=\"1.3 是否需要支持多种序列化方式\"></a>1.3 是否需要支持多种序列化方式</h2><p>整体而言，序列化可以分为文本类和二进制类两种，不同的业务场景需求也不同，分布式服务框架面向的领域是多样化的，因此它的序列化/反序列化框架需要具备如下特性：  </p>\n<ol>\n<li>默认支持多种常用的序列化/反序列化方式，文本类例如 XML/JSON 等，二进制的如 PB（Protocol Buffer）/Thrift 等。</li>\n<li>序列化框架可扩展，用户可以非常灵活、方便地扩展其它序列化方式。</li>\n</ol>\n<h1 id=\"2-功能设计\"><a href=\"#2-功能设计\" class=\"headerlink\" title=\"2 功能设计\"></a>2 功能设计</h1><p>从功能、跨语言支持、兼容性、性能等多个角度进行综合考量。  </p>\n<ol>\n<li>功能丰富。</li>\n<li>跨语言支持。</li>\n<li>兼容性</li>\n<li>性能。</li>\n</ol>\n<h1 id=\"3-扩展性设计\"><a href=\"#3-扩展性设计\" class=\"headerlink\" title=\"3 扩展性设计\"></a>3 扩展性设计</h1><p>利用 Netty 提供的编解码框架，可以非常快速的实现序列化/反序列化框架的扩展。</p>\n<h2 id=\"3-1-内置的序列化-反序列化功能类\"><a href=\"#3-1-内置的序列化-反序列化功能类\" class=\"headerlink\" title=\"3.1 内置的序列化/反序列化功能类\"></a>3.1 内置的序列化/反序列化功能类</h2><p>为了降低用户的开发难度，Netty 对常用的功能和 API 做了装饰，以屏蔽底层的实现细节。Netty 内置的编解码功能包括 base64、Protobuf、JBoss Marshalling、spdy 等。</p>\n<h2 id=\"3-2-反序列化扩展\"><a href=\"#3-2-反序列化扩展\" class=\"headerlink\" title=\"3.2 反序列化扩展\"></a>3.2 反序列化扩展</h2><ol>\n<li>业务发布服务的时候，可以指定协议类型和承载数据的序列化方式，例如将购买商品服务发布成 HTTP 服务，序列化格式采用 XML；同时允许用户指定新增的序列化格式发布服务。</li>\n<li>序列化类库能够以插件的格式插入到通信调用链中，实现序列化格式的扩展。在这个过程中，需要考虑 TCP 的黏包和拆包等底层相关的技术细节。</li>\n</ol>\n<p>我们看半包的处理，如果不处理半包，Netty 调用 decode 方法传递的 ByteBuf 对象可能就是个半包，我们拿半包做反序列化就会失败，因此在反序列化之前，我们需要保证调用解码方法时传递的是个完整的数据包。  </p>\n<p>了解 TCP 通信机制的渎职应该都知道 TCP 底层的黏包和拆包，当我们在接收消息的时候，不能认为读取到的报文就是个整包消息，特别是对于采用非阻塞 I/O 和长连接通信的程序。<br>如何区分一个整包消息，通常有如下四种做法：  </p>\n<ol>\n<li>固定长度，例如每 120 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定长消息的时候比较简单，每次读到指定长度的字节后进行解码。</li>\n<li>通过回车换行符区分消息，例如 HTTP 协议。这类区分消息的方式多用于文本协议。</li>\n<li>通过特定的分隔符区分整包消息。</li>\n<li>通过在协议头/消息头中设置长度字段来标识整包消息。</li>\n</ol>\n<h1 id=\"4-最佳实践\"><a href=\"#4-最佳实践\" class=\"headerlink\" title=\"4 最佳实践\"></a>4 最佳实践</h1><h2 id=\"4-1-接口的前向兼容性规范\"><a href=\"#4-1-接口的前向兼容性规范\" class=\"headerlink\" title=\"4.1 接口的前向兼容性规范\"></a>4.1 接口的前向兼容性规范</h2><ol>\n<li>制定”分布式服务框架接口兼容性规范“，在规范中要明确服务框架支持哪些兼容性，例如新增字段、删除字段还是修改字段。</li>\n<li>引导客户。</li>\n</ol>\n<h2 id=\"4-2-高并发下的稳定性\"><a href=\"#4-2-高并发下的稳定性\" class=\"headerlink\" title=\"4.2 高并发下的稳定性\"></a>4.2 高并发下的稳定性</h2><p>需要模拟现网高并发场景对序列化框架做压测和稳定性测试，如果序列化框架存在全局锁较激烈的线程竞争等问题，多线程、高并发压力测试就会出现问题。究其原因是因为一些序列化框架为了实现线程安全，使用了全局锁等，这从实用角度看确实简单，但是在高并发场景下就会出现性能下降、耗时不稳定等问题。  </p>\n<p>解决此类问题的方案很多，例如每个线程聚合一个序列化/反序列化类库，避免多线程竞争。</p>\n<h1 id=\"5-个人总结\"><a href=\"#5-个人总结\" class=\"headerlink\" title=\"5 个人总结\"></a>5 个人总结</h1><p>序列化/反序列化是 RPC 框架的基础组成部分，从性能、业务考虑，而 Netty 非常适合去做扩展。当然，还是清楚其中的经典黏包、拆包。</p>\n"},{"title":"一、环游密码世界","date":"2017-11-10T11:47:00.000Z","updated":"2017-11-11T08:30:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n从整体上了解密码世界的模样。\n\n# 2 密码\n\n## 2.1 Alice 与 Bob\n\n要讲解密码，需要给参与信息交互的人和计算机起几个名字，如下表：\n\n| 名称 | 说明 |\n|:----:|:----:|\n| Alice| 一般角色 |\n| Bob | 一般角色 |\n| Eve | 窃听者，可窃听通信内容 |\n| Mallory | 主动攻击者，可妨碍正常通信、伪造消息等 |\n| Trent | 可信的第三方 | \n| Victor | 验证者 | \n\n## 2.2 发送者、接受者和窃听者\n\nAlice 向 Bob 发送消息，Alice 作为 Sender，Bob 作为 Receiver，消息作为 Message。在互联网中，消息会经过许多台计算机和通信设备做中转，\n在这个过程中，就存在被恶意窃听者（eavesdropper）偷看的可能。作为监听者，我们给它起名为Eve，它可能是人类也有可能是某些程序软件。\n\n## 2.3 加密与解密\n\nAlice 不想让别人看到她传递消息的内容，因为它决定将消息加密（encrypt） 后再发送出去，加密之前的是明文（plaintext），加密之后的消息称为\n密文（ciphertext）。  \n  \nBob 收到了 Alice 的加密消息后，他需要进行解密（decrypt）之后再查阅，即将密文恢复成明文的过程。这样，窃听者在网络上得到的只是密文。\n\n## 2.4 破译\n\nEve 得到了密文，试图将密文还原为明文，被称为密码破译（cryptanalysis），简称破译，或者密码分析。\n\n# 3 对称密码与公钥密码\n\n## 3.1 密码算法\n\n用于解决复杂问题的步骤，通常称为算法（algorithm），明文生成密文的步骤，被称为“加密算法”；而解密的步骤被称为“解密算法”，它们两统称为密码算法。\n\n## 3.2 密钥\n\n密码算法中需要密钥（key）。如下：\n![][1]  \n无论是在加密还是解密时，都需要知道密钥。\n\n## 3.3 对称密钥与公钥密码\n\n根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。\n1. 对称密码（symmetric cryptography）是指在加密和解密时使用同一密钥的方式。\n2. 公钥密码（public-key cryptography）则是在加密和解密时使用不同密钥的方式，也称非对称密码（asymmetric cryptography）。\n![][2]\n\n## 3.4 混合密码系统\n\n将对称密码和公钥密码结合起来的密码方式。\n\n# 4 其它密码技术\n\n## 4.1 单向散列函数\n\n为了防止下载的软件被篡改，有安全意思的软件发布者会步的散列值。散列值就是用单向散列函数（one-way hash function）计算出来的数值。  \n  \n单向散列函数所保证的并不是机密性，而是完整性（integrity），即“数据是正牌的而不是伪造的”。第七章，详细讲解。\n\n## 4.2 消息认证码\n\n为了确认消息是否来自所期望的通信对象，可以使用消息认证码（message authentication code）技术，不仅能保证完整性还能提供认证（authentication）机制。\n\n## 4.3 数字签名\n\n验证消息是否被篡改，能够确保完整性、提供认证并防止否认的密码机制。将第九章详解。\n\n## 4.4 伪随机数生成器\n\n伪随机数生成器（Pseudo Random Number Generator，PRNG）是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这么说可能会感到意外，\n但实际上随机数确实承担着密钥生成的重要职责。例如在 Web 中进行 SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥\n就是基于伪随机数生成的。将在第十二章详解。\n\n# 5 密码学家的工具箱\n\n在以上内容中，已经出现了很多种类的密码技术，其中以下六种发挥尤其重要的作用：\n1. 对称密码\n2. 公钥密码（非对称密码）\n3. 单向散列函数\n4. 消息认证码\n5. 数字签名\n6. 伪随机数生成器\n\n在本书中，将上述六种技术统称为密码学家的工具箱。  \n![][3]\n\n# 6 隐写术与数字水印\n\n上面讲过，密码是一种能够让消息内容变得无法解读的技术，即 cryptography。除此之外，还有另外一种技术，它不是让消息内容变得无法解读，而是能够\n隐藏消息本身，这种技术称为隐写术（steganography）。例如：  \n**我**们先准备一段话，  \n**很**容易看懂的就可以，  \n**喜**闻乐见的当然更好，  \n**欢**迎你尝试将另一句话嵌在这段话中，  \n**你**会发现这其实就是一种隐写术。  \n  \n这样，就发现这段话还隐藏着另一句话“我很喜欢你”。  \n隐写术在计算机中，用于数字水印技术，它是一种将著作权拥有者及购买者的信息嵌入文本中的技术。但是仅凭数字水印技术时无法对信息进行加密的，因此需要\n和其它技术配合使用。  \n  \n例如，将密码技术和隐写术相结合的方法就很常见。首先，我们将要嵌入的文章进行加密并生成密文，然后再通过隐写术将密文隐藏到图片中。这样一来，\n即便有人发现了密文的存在，也无法读取出所嵌入的文章的内容。  \n密码隐藏的是内容，隐写术隐藏的是消息本身。\n  \n# 7 密码与信息安全常识\n\n## 7.1 不要使用保密的密码算法\n\n我们不应该制作或使用任何保密的密码算法，而是应该使用那些已经公开的、被公认为强度较高的密码算法，原因如下：\n1. 密码算法的秘密早晚会公诸于世。\n2. 开发高强度的密码算法是非常困难的。而试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（security by obscurity），这是危险且愚蠢的行为。\n\n## 7.2 使用低强度的密码比不进行任何加密更危险\n\n对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，这通常会导致用户在处理一些机密信息的时候麻痹大意。\n\n## 7.3 任何密码总会有一天都会被破解\n\n无论使用任何密码算法锁生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的\n价值之间的权衡就显得非常重要。严格来说，绝对不会被破解的密码其实是存在的，这种算法称为一次性密码本（one-time pad），将在3.4节详解。  \n此外，还有另一种技术被认为有可能早就完美的密码技术，那就是量子密码，将在15.3.1节详解。\n\n## 7.4 密码只是信息安全的一部分\n\n社会工程学（social engineering）。最脆弱的环节并不是密码，而是人类自己。\n\n# 8 本章小结\n\n主要浏览了密码世界中的一些主要技术。\n\n# 9 小测验\n\n下面说法是否正确？  \n1. 将明文转换为密文的过程称为加密。\n2. 明文是供人类读取的数据，而密文则是供计算机读取的数据。\n3. 只要检查邮件发送者（From:）一栏的内容，就能够正确判断邮件是谁发出的。\n4. 在对称密码中，加密用的密钥和解密用的密钥是相同的。\n5. 公开的密码算法容易遭到坏人的攻击，因此使用自己公司开发的保密的密码算法更加安全。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_3.png","source":"_posts/图解密码技术/第一章 环游密码世界.md","raw":"---\ntitle: 一、环游密码世界\ndate: 2017-11-10 19:47:00\nupdated: 2017-11-11 16:30:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/1.html    \n---\n\n# 1 本章概要\n\n从整体上了解密码世界的模样。\n\n# 2 密码\n\n## 2.1 Alice 与 Bob\n\n要讲解密码，需要给参与信息交互的人和计算机起几个名字，如下表：\n\n| 名称 | 说明 |\n|:----:|:----:|\n| Alice| 一般角色 |\n| Bob | 一般角色 |\n| Eve | 窃听者，可窃听通信内容 |\n| Mallory | 主动攻击者，可妨碍正常通信、伪造消息等 |\n| Trent | 可信的第三方 | \n| Victor | 验证者 | \n\n## 2.2 发送者、接受者和窃听者\n\nAlice 向 Bob 发送消息，Alice 作为 Sender，Bob 作为 Receiver，消息作为 Message。在互联网中，消息会经过许多台计算机和通信设备做中转，\n在这个过程中，就存在被恶意窃听者（eavesdropper）偷看的可能。作为监听者，我们给它起名为Eve，它可能是人类也有可能是某些程序软件。\n\n## 2.3 加密与解密\n\nAlice 不想让别人看到她传递消息的内容，因为它决定将消息加密（encrypt） 后再发送出去，加密之前的是明文（plaintext），加密之后的消息称为\n密文（ciphertext）。  \n  \nBob 收到了 Alice 的加密消息后，他需要进行解密（decrypt）之后再查阅，即将密文恢复成明文的过程。这样，窃听者在网络上得到的只是密文。\n\n## 2.4 破译\n\nEve 得到了密文，试图将密文还原为明文，被称为密码破译（cryptanalysis），简称破译，或者密码分析。\n\n# 3 对称密码与公钥密码\n\n## 3.1 密码算法\n\n用于解决复杂问题的步骤，通常称为算法（algorithm），明文生成密文的步骤，被称为“加密算法”；而解密的步骤被称为“解密算法”，它们两统称为密码算法。\n\n## 3.2 密钥\n\n密码算法中需要密钥（key）。如下：\n![][1]  \n无论是在加密还是解密时，都需要知道密钥。\n\n## 3.3 对称密钥与公钥密码\n\n根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。\n1. 对称密码（symmetric cryptography）是指在加密和解密时使用同一密钥的方式。\n2. 公钥密码（public-key cryptography）则是在加密和解密时使用不同密钥的方式，也称非对称密码（asymmetric cryptography）。\n![][2]\n\n## 3.4 混合密码系统\n\n将对称密码和公钥密码结合起来的密码方式。\n\n# 4 其它密码技术\n\n## 4.1 单向散列函数\n\n为了防止下载的软件被篡改，有安全意思的软件发布者会步的散列值。散列值就是用单向散列函数（one-way hash function）计算出来的数值。  \n  \n单向散列函数所保证的并不是机密性，而是完整性（integrity），即“数据是正牌的而不是伪造的”。第七章，详细讲解。\n\n## 4.2 消息认证码\n\n为了确认消息是否来自所期望的通信对象，可以使用消息认证码（message authentication code）技术，不仅能保证完整性还能提供认证（authentication）机制。\n\n## 4.3 数字签名\n\n验证消息是否被篡改，能够确保完整性、提供认证并防止否认的密码机制。将第九章详解。\n\n## 4.4 伪随机数生成器\n\n伪随机数生成器（Pseudo Random Number Generator，PRNG）是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这么说可能会感到意外，\n但实际上随机数确实承担着密钥生成的重要职责。例如在 Web 中进行 SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥\n就是基于伪随机数生成的。将在第十二章详解。\n\n# 5 密码学家的工具箱\n\n在以上内容中，已经出现了很多种类的密码技术，其中以下六种发挥尤其重要的作用：\n1. 对称密码\n2. 公钥密码（非对称密码）\n3. 单向散列函数\n4. 消息认证码\n5. 数字签名\n6. 伪随机数生成器\n\n在本书中，将上述六种技术统称为密码学家的工具箱。  \n![][3]\n\n# 6 隐写术与数字水印\n\n上面讲过，密码是一种能够让消息内容变得无法解读的技术，即 cryptography。除此之外，还有另外一种技术，它不是让消息内容变得无法解读，而是能够\n隐藏消息本身，这种技术称为隐写术（steganography）。例如：  \n**我**们先准备一段话，  \n**很**容易看懂的就可以，  \n**喜**闻乐见的当然更好，  \n**欢**迎你尝试将另一句话嵌在这段话中，  \n**你**会发现这其实就是一种隐写术。  \n  \n这样，就发现这段话还隐藏着另一句话“我很喜欢你”。  \n隐写术在计算机中，用于数字水印技术，它是一种将著作权拥有者及购买者的信息嵌入文本中的技术。但是仅凭数字水印技术时无法对信息进行加密的，因此需要\n和其它技术配合使用。  \n  \n例如，将密码技术和隐写术相结合的方法就很常见。首先，我们将要嵌入的文章进行加密并生成密文，然后再通过隐写术将密文隐藏到图片中。这样一来，\n即便有人发现了密文的存在，也无法读取出所嵌入的文章的内容。  \n密码隐藏的是内容，隐写术隐藏的是消息本身。\n  \n# 7 密码与信息安全常识\n\n## 7.1 不要使用保密的密码算法\n\n我们不应该制作或使用任何保密的密码算法，而是应该使用那些已经公开的、被公认为强度较高的密码算法，原因如下：\n1. 密码算法的秘密早晚会公诸于世。\n2. 开发高强度的密码算法是非常困难的。而试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（security by obscurity），这是危险且愚蠢的行为。\n\n## 7.2 使用低强度的密码比不进行任何加密更危险\n\n对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，这通常会导致用户在处理一些机密信息的时候麻痹大意。\n\n## 7.3 任何密码总会有一天都会被破解\n\n无论使用任何密码算法锁生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的\n价值之间的权衡就显得非常重要。严格来说，绝对不会被破解的密码其实是存在的，这种算法称为一次性密码本（one-time pad），将在3.4节详解。  \n此外，还有另一种技术被认为有可能早就完美的密码技术，那就是量子密码，将在15.3.1节详解。\n\n## 7.4 密码只是信息安全的一部分\n\n社会工程学（social engineering）。最脆弱的环节并不是密码，而是人类自己。\n\n# 8 本章小结\n\n主要浏览了密码世界中的一些主要技术。\n\n# 9 小测验\n\n下面说法是否正确？  \n1. 将明文转换为密文的过程称为加密。\n2. 明文是供人类读取的数据，而密文则是供计算机读取的数据。\n3. 只要检查邮件发送者（From:）一栏的内容，就能够正确判断邮件是谁发出的。\n4. 在对称密码中，加密用的密钥和解密用的密钥是相同的。\n5. 公开的密码算法容易遭到坏人的攻击，因此使用自己公司开发的保密的密码算法更加安全。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_3.png","slug":"graphic2cryptography/1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavp0029axs65x4ep2ln","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>从整体上了解密码世界的模样。</p>\n<h1 id=\"2-密码\"><a href=\"#2-密码\" class=\"headerlink\" title=\"2 密码\"></a>2 密码</h1><h2 id=\"2-1-Alice-与-Bob\"><a href=\"#2-1-Alice-与-Bob\" class=\"headerlink\" title=\"2.1 Alice 与 Bob\"></a>2.1 Alice 与 Bob</h2><p>要讲解密码，需要给参与信息交互的人和计算机起几个名字，如下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Alice</td>\n<td style=\"text-align:center\">一般角色</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bob</td>\n<td style=\"text-align:center\">一般角色</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Eve</td>\n<td style=\"text-align:center\">窃听者，可窃听通信内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Mallory</td>\n<td style=\"text-align:center\">主动攻击者，可妨碍正常通信、伪造消息等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Trent</td>\n<td style=\"text-align:center\">可信的第三方</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Victor</td>\n<td style=\"text-align:center\">验证者</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-2-发送者、接受者和窃听者\"><a href=\"#2-2-发送者、接受者和窃听者\" class=\"headerlink\" title=\"2.2 发送者、接受者和窃听者\"></a>2.2 发送者、接受者和窃听者</h2><p>Alice 向 Bob 发送消息，Alice 作为 Sender，Bob 作为 Receiver，消息作为 Message。在互联网中，消息会经过许多台计算机和通信设备做中转，<br>在这个过程中，就存在被恶意窃听者（eavesdropper）偷看的可能。作为监听者，我们给它起名为Eve，它可能是人类也有可能是某些程序软件。</p>\n<h2 id=\"2-3-加密与解密\"><a href=\"#2-3-加密与解密\" class=\"headerlink\" title=\"2.3 加密与解密\"></a>2.3 加密与解密</h2><p>Alice 不想让别人看到她传递消息的内容，因为它决定将消息加密（encrypt） 后再发送出去，加密之前的是明文（plaintext），加密之后的消息称为<br>密文（ciphertext）。  </p>\n<p>Bob 收到了 Alice 的加密消息后，他需要进行解密（decrypt）之后再查阅，即将密文恢复成明文的过程。这样，窃听者在网络上得到的只是密文。</p>\n<h2 id=\"2-4-破译\"><a href=\"#2-4-破译\" class=\"headerlink\" title=\"2.4 破译\"></a>2.4 破译</h2><p>Eve 得到了密文，试图将密文还原为明文，被称为密码破译（cryptanalysis），简称破译，或者密码分析。</p>\n<h1 id=\"3-对称密码与公钥密码\"><a href=\"#3-对称密码与公钥密码\" class=\"headerlink\" title=\"3 对称密码与公钥密码\"></a>3 对称密码与公钥密码</h1><h2 id=\"3-1-密码算法\"><a href=\"#3-1-密码算法\" class=\"headerlink\" title=\"3.1 密码算法\"></a>3.1 密码算法</h2><p>用于解决复杂问题的步骤，通常称为算法（algorithm），明文生成密文的步骤，被称为“加密算法”；而解密的步骤被称为“解密算法”，它们两统称为密码算法。</p>\n<h2 id=\"3-2-密钥\"><a href=\"#3-2-密钥\" class=\"headerlink\" title=\"3.2 密钥\"></a>3.2 密钥</h2><p>密码算法中需要密钥（key）。如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_1.png\" alt=\"\"><br>无论是在加密还是解密时，都需要知道密钥。</p>\n<h2 id=\"3-3-对称密钥与公钥密码\"><a href=\"#3-3-对称密钥与公钥密码\" class=\"headerlink\" title=\"3.3 对称密钥与公钥密码\"></a>3.3 对称密钥与公钥密码</h2><p>根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。</p>\n<ol>\n<li>对称密码（symmetric cryptography）是指在加密和解密时使用同一密钥的方式。</li>\n<li>公钥密码（public-key cryptography）则是在加密和解密时使用不同密钥的方式，也称非对称密码（asymmetric cryptography）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_2.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"3-4-混合密码系统\"><a href=\"#3-4-混合密码系统\" class=\"headerlink\" title=\"3.4 混合密码系统\"></a>3.4 混合密码系统</h2><p>将对称密码和公钥密码结合起来的密码方式。</p>\n<h1 id=\"4-其它密码技术\"><a href=\"#4-其它密码技术\" class=\"headerlink\" title=\"4 其它密码技术\"></a>4 其它密码技术</h1><h2 id=\"4-1-单向散列函数\"><a href=\"#4-1-单向散列函数\" class=\"headerlink\" title=\"4.1 单向散列函数\"></a>4.1 单向散列函数</h2><p>为了防止下载的软件被篡改，有安全意思的软件发布者会步的散列值。散列值就是用单向散列函数（one-way hash function）计算出来的数值。  </p>\n<p>单向散列函数所保证的并不是机密性，而是完整性（integrity），即“数据是正牌的而不是伪造的”。第七章，详细讲解。</p>\n<h2 id=\"4-2-消息认证码\"><a href=\"#4-2-消息认证码\" class=\"headerlink\" title=\"4.2 消息认证码\"></a>4.2 消息认证码</h2><p>为了确认消息是否来自所期望的通信对象，可以使用消息认证码（message authentication code）技术，不仅能保证完整性还能提供认证（authentication）机制。</p>\n<h2 id=\"4-3-数字签名\"><a href=\"#4-3-数字签名\" class=\"headerlink\" title=\"4.3 数字签名\"></a>4.3 数字签名</h2><p>验证消息是否被篡改，能够确保完整性、提供认证并防止否认的密码机制。将第九章详解。</p>\n<h2 id=\"4-4-伪随机数生成器\"><a href=\"#4-4-伪随机数生成器\" class=\"headerlink\" title=\"4.4 伪随机数生成器\"></a>4.4 伪随机数生成器</h2><p>伪随机数生成器（Pseudo Random Number Generator，PRNG）是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这么说可能会感到意外，<br>但实际上随机数确实承担着密钥生成的重要职责。例如在 Web 中进行 SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥<br>就是基于伪随机数生成的。将在第十二章详解。</p>\n<h1 id=\"5-密码学家的工具箱\"><a href=\"#5-密码学家的工具箱\" class=\"headerlink\" title=\"5 密码学家的工具箱\"></a>5 密码学家的工具箱</h1><p>在以上内容中，已经出现了很多种类的密码技术，其中以下六种发挥尤其重要的作用：</p>\n<ol>\n<li>对称密码</li>\n<li>公钥密码（非对称密码）</li>\n<li>单向散列函数</li>\n<li>消息认证码</li>\n<li>数字签名</li>\n<li>伪随机数生成器</li>\n</ol>\n<p>在本书中，将上述六种技术统称为密码学家的工具箱。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_3.png\" alt=\"\"></p>\n<h1 id=\"6-隐写术与数字水印\"><a href=\"#6-隐写术与数字水印\" class=\"headerlink\" title=\"6 隐写术与数字水印\"></a>6 隐写术与数字水印</h1><p>上面讲过，密码是一种能够让消息内容变得无法解读的技术，即 cryptography。除此之外，还有另外一种技术，它不是让消息内容变得无法解读，而是能够<br>隐藏消息本身，这种技术称为隐写术（steganography）。例如：<br><strong>我</strong>们先准备一段话，<br><strong>很</strong>容易看懂的就可以，<br><strong>喜</strong>闻乐见的当然更好，<br><strong>欢</strong>迎你尝试将另一句话嵌在这段话中，<br><strong>你</strong>会发现这其实就是一种隐写术。  </p>\n<p>这样，就发现这段话还隐藏着另一句话“我很喜欢你”。<br>隐写术在计算机中，用于数字水印技术，它是一种将著作权拥有者及购买者的信息嵌入文本中的技术。但是仅凭数字水印技术时无法对信息进行加密的，因此需要<br>和其它技术配合使用。  </p>\n<p>例如，将密码技术和隐写术相结合的方法就很常见。首先，我们将要嵌入的文章进行加密并生成密文，然后再通过隐写术将密文隐藏到图片中。这样一来，<br>即便有人发现了密文的存在，也无法读取出所嵌入的文章的内容。<br>密码隐藏的是内容，隐写术隐藏的是消息本身。</p>\n<h1 id=\"7-密码与信息安全常识\"><a href=\"#7-密码与信息安全常识\" class=\"headerlink\" title=\"7 密码与信息安全常识\"></a>7 密码与信息安全常识</h1><h2 id=\"7-1-不要使用保密的密码算法\"><a href=\"#7-1-不要使用保密的密码算法\" class=\"headerlink\" title=\"7.1 不要使用保密的密码算法\"></a>7.1 不要使用保密的密码算法</h2><p>我们不应该制作或使用任何保密的密码算法，而是应该使用那些已经公开的、被公认为强度较高的密码算法，原因如下：</p>\n<ol>\n<li>密码算法的秘密早晚会公诸于世。</li>\n<li>开发高强度的密码算法是非常困难的。而试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（security by obscurity），这是危险且愚蠢的行为。</li>\n</ol>\n<h2 id=\"7-2-使用低强度的密码比不进行任何加密更危险\"><a href=\"#7-2-使用低强度的密码比不进行任何加密更危险\" class=\"headerlink\" title=\"7.2 使用低强度的密码比不进行任何加密更危险\"></a>7.2 使用低强度的密码比不进行任何加密更危险</h2><p>对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，这通常会导致用户在处理一些机密信息的时候麻痹大意。</p>\n<h2 id=\"7-3-任何密码总会有一天都会被破解\"><a href=\"#7-3-任何密码总会有一天都会被破解\" class=\"headerlink\" title=\"7.3 任何密码总会有一天都会被破解\"></a>7.3 任何密码总会有一天都会被破解</h2><p>无论使用任何密码算法锁生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的<br>价值之间的权衡就显得非常重要。严格来说，绝对不会被破解的密码其实是存在的，这种算法称为一次性密码本（one-time pad），将在3.4节详解。<br>此外，还有另一种技术被认为有可能早就完美的密码技术，那就是量子密码，将在15.3.1节详解。</p>\n<h2 id=\"7-4-密码只是信息安全的一部分\"><a href=\"#7-4-密码只是信息安全的一部分\" class=\"headerlink\" title=\"7.4 密码只是信息安全的一部分\"></a>7.4 密码只是信息安全的一部分</h2><p>社会工程学（social engineering）。最脆弱的环节并不是密码，而是人类自己。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>主要浏览了密码世界中的一些主要技术。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><p>下面说法是否正确？  </p>\n<ol>\n<li>将明文转换为密文的过程称为加密。</li>\n<li>明文是供人类读取的数据，而密文则是供计算机读取的数据。</li>\n<li>只要检查邮件发送者（From:）一栏的内容，就能够正确判断邮件是谁发出的。</li>\n<li>在对称密码中，加密用的密钥和解密用的密钥是相同的。</li>\n<li>公开的密码算法容易遭到坏人的攻击，因此使用自己公司开发的保密的密码算法更加安全。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>从整体上了解密码世界的模样。</p>\n<h1 id=\"2-密码\"><a href=\"#2-密码\" class=\"headerlink\" title=\"2 密码\"></a>2 密码</h1><h2 id=\"2-1-Alice-与-Bob\"><a href=\"#2-1-Alice-与-Bob\" class=\"headerlink\" title=\"2.1 Alice 与 Bob\"></a>2.1 Alice 与 Bob</h2><p>要讲解密码，需要给参与信息交互的人和计算机起几个名字，如下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Alice</td>\n<td style=\"text-align:center\">一般角色</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bob</td>\n<td style=\"text-align:center\">一般角色</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Eve</td>\n<td style=\"text-align:center\">窃听者，可窃听通信内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Mallory</td>\n<td style=\"text-align:center\">主动攻击者，可妨碍正常通信、伪造消息等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Trent</td>\n<td style=\"text-align:center\">可信的第三方</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Victor</td>\n<td style=\"text-align:center\">验证者</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-2-发送者、接受者和窃听者\"><a href=\"#2-2-发送者、接受者和窃听者\" class=\"headerlink\" title=\"2.2 发送者、接受者和窃听者\"></a>2.2 发送者、接受者和窃听者</h2><p>Alice 向 Bob 发送消息，Alice 作为 Sender，Bob 作为 Receiver，消息作为 Message。在互联网中，消息会经过许多台计算机和通信设备做中转，<br>在这个过程中，就存在被恶意窃听者（eavesdropper）偷看的可能。作为监听者，我们给它起名为Eve，它可能是人类也有可能是某些程序软件。</p>\n<h2 id=\"2-3-加密与解密\"><a href=\"#2-3-加密与解密\" class=\"headerlink\" title=\"2.3 加密与解密\"></a>2.3 加密与解密</h2><p>Alice 不想让别人看到她传递消息的内容，因为它决定将消息加密（encrypt） 后再发送出去，加密之前的是明文（plaintext），加密之后的消息称为<br>密文（ciphertext）。  </p>\n<p>Bob 收到了 Alice 的加密消息后，他需要进行解密（decrypt）之后再查阅，即将密文恢复成明文的过程。这样，窃听者在网络上得到的只是密文。</p>\n<h2 id=\"2-4-破译\"><a href=\"#2-4-破译\" class=\"headerlink\" title=\"2.4 破译\"></a>2.4 破译</h2><p>Eve 得到了密文，试图将密文还原为明文，被称为密码破译（cryptanalysis），简称破译，或者密码分析。</p>\n<h1 id=\"3-对称密码与公钥密码\"><a href=\"#3-对称密码与公钥密码\" class=\"headerlink\" title=\"3 对称密码与公钥密码\"></a>3 对称密码与公钥密码</h1><h2 id=\"3-1-密码算法\"><a href=\"#3-1-密码算法\" class=\"headerlink\" title=\"3.1 密码算法\"></a>3.1 密码算法</h2><p>用于解决复杂问题的步骤，通常称为算法（algorithm），明文生成密文的步骤，被称为“加密算法”；而解密的步骤被称为“解密算法”，它们两统称为密码算法。</p>\n<h2 id=\"3-2-密钥\"><a href=\"#3-2-密钥\" class=\"headerlink\" title=\"3.2 密钥\"></a>3.2 密钥</h2><p>密码算法中需要密钥（key）。如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_1.png\" alt=\"\"><br>无论是在加密还是解密时，都需要知道密钥。</p>\n<h2 id=\"3-3-对称密钥与公钥密码\"><a href=\"#3-3-对称密钥与公钥密码\" class=\"headerlink\" title=\"3.3 对称密钥与公钥密码\"></a>3.3 对称密钥与公钥密码</h2><p>根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。</p>\n<ol>\n<li>对称密码（symmetric cryptography）是指在加密和解密时使用同一密钥的方式。</li>\n<li>公钥密码（public-key cryptography）则是在加密和解密时使用不同密钥的方式，也称非对称密码（asymmetric cryptography）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_2.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"3-4-混合密码系统\"><a href=\"#3-4-混合密码系统\" class=\"headerlink\" title=\"3.4 混合密码系统\"></a>3.4 混合密码系统</h2><p>将对称密码和公钥密码结合起来的密码方式。</p>\n<h1 id=\"4-其它密码技术\"><a href=\"#4-其它密码技术\" class=\"headerlink\" title=\"4 其它密码技术\"></a>4 其它密码技术</h1><h2 id=\"4-1-单向散列函数\"><a href=\"#4-1-单向散列函数\" class=\"headerlink\" title=\"4.1 单向散列函数\"></a>4.1 单向散列函数</h2><p>为了防止下载的软件被篡改，有安全意思的软件发布者会步的散列值。散列值就是用单向散列函数（one-way hash function）计算出来的数值。  </p>\n<p>单向散列函数所保证的并不是机密性，而是完整性（integrity），即“数据是正牌的而不是伪造的”。第七章，详细讲解。</p>\n<h2 id=\"4-2-消息认证码\"><a href=\"#4-2-消息认证码\" class=\"headerlink\" title=\"4.2 消息认证码\"></a>4.2 消息认证码</h2><p>为了确认消息是否来自所期望的通信对象，可以使用消息认证码（message authentication code）技术，不仅能保证完整性还能提供认证（authentication）机制。</p>\n<h2 id=\"4-3-数字签名\"><a href=\"#4-3-数字签名\" class=\"headerlink\" title=\"4.3 数字签名\"></a>4.3 数字签名</h2><p>验证消息是否被篡改，能够确保完整性、提供认证并防止否认的密码机制。将第九章详解。</p>\n<h2 id=\"4-4-伪随机数生成器\"><a href=\"#4-4-伪随机数生成器\" class=\"headerlink\" title=\"4.4 伪随机数生成器\"></a>4.4 伪随机数生成器</h2><p>伪随机数生成器（Pseudo Random Number Generator，PRNG）是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这么说可能会感到意外，<br>但实际上随机数确实承担着密钥生成的重要职责。例如在 Web 中进行 SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥<br>就是基于伪随机数生成的。将在第十二章详解。</p>\n<h1 id=\"5-密码学家的工具箱\"><a href=\"#5-密码学家的工具箱\" class=\"headerlink\" title=\"5 密码学家的工具箱\"></a>5 密码学家的工具箱</h1><p>在以上内容中，已经出现了很多种类的密码技术，其中以下六种发挥尤其重要的作用：</p>\n<ol>\n<li>对称密码</li>\n<li>公钥密码（非对称密码）</li>\n<li>单向散列函数</li>\n<li>消息认证码</li>\n<li>数字签名</li>\n<li>伪随机数生成器</li>\n</ol>\n<p>在本书中，将上述六种技术统称为密码学家的工具箱。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_3.png\" alt=\"\"></p>\n<h1 id=\"6-隐写术与数字水印\"><a href=\"#6-隐写术与数字水印\" class=\"headerlink\" title=\"6 隐写术与数字水印\"></a>6 隐写术与数字水印</h1><p>上面讲过，密码是一种能够让消息内容变得无法解读的技术，即 cryptography。除此之外，还有另外一种技术，它不是让消息内容变得无法解读，而是能够<br>隐藏消息本身，这种技术称为隐写术（steganography）。例如：<br><strong>我</strong>们先准备一段话，<br><strong>很</strong>容易看懂的就可以，<br><strong>喜</strong>闻乐见的当然更好，<br><strong>欢</strong>迎你尝试将另一句话嵌在这段话中，<br><strong>你</strong>会发现这其实就是一种隐写术。  </p>\n<p>这样，就发现这段话还隐藏着另一句话“我很喜欢你”。<br>隐写术在计算机中，用于数字水印技术，它是一种将著作权拥有者及购买者的信息嵌入文本中的技术。但是仅凭数字水印技术时无法对信息进行加密的，因此需要<br>和其它技术配合使用。  </p>\n<p>例如，将密码技术和隐写术相结合的方法就很常见。首先，我们将要嵌入的文章进行加密并生成密文，然后再通过隐写术将密文隐藏到图片中。这样一来，<br>即便有人发现了密文的存在，也无法读取出所嵌入的文章的内容。<br>密码隐藏的是内容，隐写术隐藏的是消息本身。</p>\n<h1 id=\"7-密码与信息安全常识\"><a href=\"#7-密码与信息安全常识\" class=\"headerlink\" title=\"7 密码与信息安全常识\"></a>7 密码与信息安全常识</h1><h2 id=\"7-1-不要使用保密的密码算法\"><a href=\"#7-1-不要使用保密的密码算法\" class=\"headerlink\" title=\"7.1 不要使用保密的密码算法\"></a>7.1 不要使用保密的密码算法</h2><p>我们不应该制作或使用任何保密的密码算法，而是应该使用那些已经公开的、被公认为强度较高的密码算法，原因如下：</p>\n<ol>\n<li>密码算法的秘密早晚会公诸于世。</li>\n<li>开发高强度的密码算法是非常困难的。而试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（security by obscurity），这是危险且愚蠢的行为。</li>\n</ol>\n<h2 id=\"7-2-使用低强度的密码比不进行任何加密更危险\"><a href=\"#7-2-使用低强度的密码比不进行任何加密更危险\" class=\"headerlink\" title=\"7.2 使用低强度的密码比不进行任何加密更危险\"></a>7.2 使用低强度的密码比不进行任何加密更危险</h2><p>对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，这通常会导致用户在处理一些机密信息的时候麻痹大意。</p>\n<h2 id=\"7-3-任何密码总会有一天都会被破解\"><a href=\"#7-3-任何密码总会有一天都会被破解\" class=\"headerlink\" title=\"7.3 任何密码总会有一天都会被破解\"></a>7.3 任何密码总会有一天都会被破解</h2><p>无论使用任何密码算法锁生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的<br>价值之间的权衡就显得非常重要。严格来说，绝对不会被破解的密码其实是存在的，这种算法称为一次性密码本（one-time pad），将在3.4节详解。<br>此外，还有另一种技术被认为有可能早就完美的密码技术，那就是量子密码，将在15.3.1节详解。</p>\n<h2 id=\"7-4-密码只是信息安全的一部分\"><a href=\"#7-4-密码只是信息安全的一部分\" class=\"headerlink\" title=\"7.4 密码只是信息安全的一部分\"></a>7.4 密码只是信息安全的一部分</h2><p>社会工程学（social engineering）。最脆弱的环节并不是密码，而是人类自己。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>主要浏览了密码世界中的一些主要技术。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><p>下面说法是否正确？  </p>\n<ol>\n<li>将明文转换为密文的过程称为加密。</li>\n<li>明文是供人类读取的数据，而密文则是供计算机读取的数据。</li>\n<li>只要检查邮件发送者（From:）一栏的内容，就能够正确判断邮件是谁发出的。</li>\n<li>在对称密码中，加密用的密钥和解密用的密钥是相同的。</li>\n<li>公开的密码算法容易遭到坏人的攻击，因此使用自己公司开发的保密的密码算法更加安全。</li>\n</ol>\n"},{"title":"七、单向散列函数（获取消息的“指纹”）","date":"2017-11-19T07:16:00.000Z","updated":"2017-11-19T15:09:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。  \n本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。  \n我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。\n\n# 2 什么是单向散列函数\n\n## 2.1 这个文件是不是真的呢\n\nAlice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。  \n第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：  \n“这个文件和我昨天晚上生成的文件是一样的吗？”  \nAlice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改......在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。  \n  \n也就是说，Alice 需要确定自己的文件的完整性（integrity）。  \n![][1]  \n稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。  \n不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？  \n![][2]  \n这里还存在一个效率问题。如果需\b需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。  \n我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：  \n![][3]  \n本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。\n\n## 2.2 什么是单向散列函数\n\n单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。  \n![][4]  \n这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。  \n散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。  \n![][5]  \n由于散列值很短，因此很容易处理和使用。  \n  \n回家之前，Alice 用单向散列函数计算文件的散列值：  \n35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5  \n单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~  \n第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。\n\n## 2.3 单向散列函数的性质\n\n### 1. 根据任意长度的消息计算出固定长度的散列值\n\n### 2.能够快速计算出散列值\n\n### 3.消息不同散列值也不同\n如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为**碰撞（collision）**。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。  \n难以发现碰撞的性质称为**抗碰撞性（collision resistance）**。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。  \n我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。  \nAlice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。  \n![][6]  \n由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。  \n  \n这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保**要找到和该条消息具有相同散列值的另外一条消息是非常困难的**。这一性质称为**弱抗碰撞性**。单向散列函数都必须具备弱抗碰撞性。  \n  \n和弱抗碰撞性相对的，还有**强抗碰撞性**。所谓强抗碰撞性，是指**要找到散列值相同的两条不同的消息是非常困难的**这一性质。在这里，散列值可以是任意值。  \n  \n密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。\n\n### 4. 具备单向性\n\n## 2.4 关于术语\n\n**单向散列函数**也称为**消息摘要函数（message digest function）**、**哈希函数**或者**杂凑函数**。  \n输入单向散列函数的消息也称为**原像（pre-image）**。  \n单向散列函数输出的**散列值**也称为**消息摘要（message digest）**或者指纹（fingerprint）**。  \n完整性也称为一致性。  \n“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。\n\n# 3 单向散列函数的实际应用\n\n## 3.1 检测软件是否被篡改\n\n![][7]\n\n## 3.2 基于口令的加密\n\n单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。  \nPBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。\n\n## 3.3 消息认证码\n\n使用单向散列函数可以构造消息认证码。  \n消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。  \n消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。\n\n## 3.4 数字签名\n\n数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。\n\n## 3.5 伪随机数生成器\n\n使用单向散列函数可以构造伪随机数生成器。  \n密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。\n\n## 3.6 一次性口令\n\n一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。\n\n# 4 单向散列函数的具体例子\n\n## 4.1 MD4、MD5\n\nMD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。  \nMD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。  \nMD 是消息摘要（Message Digest）的缩写。\n\n## 4.2 SHA-1、SHA-256、SHA-384、SHA-512\n\nSHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。  \nSHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。  \n它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。\n\n## 4.3 RIPEMD-160\n\nRIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。\n\n## 4.4 AHS（Advanced Hash Standard）与 SHA-3\n\n在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。\n\n# 5 单向散列函数 SHA-1\n\n此章主要讲解其具体算法，有感兴趣者请看原书。\n\n# 6 对单向散列函数的攻击\n\n## 6.1 暴力破解（攻击故事 1 ）\n\nAlice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的：\n>Alice 要支付的金额为 100 万元。\n\n改成：\n>Alice 要支付的金额为 1 亿元。\n\n不过，不仅要修改合同内容，还要不能改变散列值。  \nMallory 可以从文档文件所具有的**冗余性**入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。  \n举个例子，下面的这些句子基本上说的都是一个意思：  \nAlice 要支付的金额为 1 亿元。  \nAlice 要支付的金额为壹亿元。  \nAlice 要支付的金额为 100000000 元。  \nAlice 应支付 1 亿元。  \n作为报酬， Alice 需要支付 1 亿元。  \n\b  \n除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。  \n  \n于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“\b100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。  \n在这里，Mallory 所进行的攻击就是**暴力攻击**。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种**试图破解单向散列函数的“弱抗碰撞性”的攻击**。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次）\n\n## 6.2 生日攻击（攻击故事 2 ）\n\n编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100\b 万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。  \n这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为**生日攻击（birthday attack）**，这是一种**试图破解单向散列函数的“强抗碰撞性”的攻击。**  \n这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。\n\n# 7 单向散列函数无法解决的问题\n\n假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，**单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。**  \n因此我们还需要进行**认证**，用于认证的技术包括**消息认证码**和**数字签名**。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。  \n认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。\n\n# 8 本章小结\n\n本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。  \n以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。  \n但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。\n\n# 9 小测验\n\n1. MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。\n2. 要找出和某条消息具备相同散列值的另一条消息是非常困难的。\n3. 要找出具有相同散列值但互不相同的两条消息是非常困难的。\n4. SHA-1 的散列值长度为 20字节。\n5. 如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。\n\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_7.png\n","source":"_posts/图解密码技术/第七章 单向散列函数.md","raw":"---\ntitle: 七、单向散列函数（获取消息的“指纹”）\ndate: 2017-11-19 15:16:00\nupdated: 2017-11-19 23:09:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/7.html    \n---\n\n# 1 本章概要\n\n针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。  \n本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。  \n我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。\n\n# 2 什么是单向散列函数\n\n## 2.1 这个文件是不是真的呢\n\nAlice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。  \n第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：  \n“这个文件和我昨天晚上生成的文件是一样的吗？”  \nAlice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改......在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。  \n  \n也就是说，Alice 需要确定自己的文件的完整性（integrity）。  \n![][1]  \n稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。  \n不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？  \n![][2]  \n这里还存在一个效率问题。如果需\b需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。  \n我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：  \n![][3]  \n本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。\n\n## 2.2 什么是单向散列函数\n\n单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。  \n![][4]  \n这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。  \n散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。  \n![][5]  \n由于散列值很短，因此很容易处理和使用。  \n  \n回家之前，Alice 用单向散列函数计算文件的散列值：  \n35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5  \n单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~  \n第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。\n\n## 2.3 单向散列函数的性质\n\n### 1. 根据任意长度的消息计算出固定长度的散列值\n\n### 2.能够快速计算出散列值\n\n### 3.消息不同散列值也不同\n如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为**碰撞（collision）**。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。  \n难以发现碰撞的性质称为**抗碰撞性（collision resistance）**。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。  \n我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。  \nAlice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。  \n![][6]  \n由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。  \n  \n这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保**要找到和该条消息具有相同散列值的另外一条消息是非常困难的**。这一性质称为**弱抗碰撞性**。单向散列函数都必须具备弱抗碰撞性。  \n  \n和弱抗碰撞性相对的，还有**强抗碰撞性**。所谓强抗碰撞性，是指**要找到散列值相同的两条不同的消息是非常困难的**这一性质。在这里，散列值可以是任意值。  \n  \n密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。\n\n### 4. 具备单向性\n\n## 2.4 关于术语\n\n**单向散列函数**也称为**消息摘要函数（message digest function）**、**哈希函数**或者**杂凑函数**。  \n输入单向散列函数的消息也称为**原像（pre-image）**。  \n单向散列函数输出的**散列值**也称为**消息摘要（message digest）**或者指纹（fingerprint）**。  \n完整性也称为一致性。  \n“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。\n\n# 3 单向散列函数的实际应用\n\n## 3.1 检测软件是否被篡改\n\n![][7]\n\n## 3.2 基于口令的加密\n\n单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。  \nPBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。\n\n## 3.3 消息认证码\n\n使用单向散列函数可以构造消息认证码。  \n消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。  \n消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。\n\n## 3.4 数字签名\n\n数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。\n\n## 3.5 伪随机数生成器\n\n使用单向散列函数可以构造伪随机数生成器。  \n密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。\n\n## 3.6 一次性口令\n\n一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。\n\n# 4 单向散列函数的具体例子\n\n## 4.1 MD4、MD5\n\nMD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。  \nMD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。  \nMD 是消息摘要（Message Digest）的缩写。\n\n## 4.2 SHA-1、SHA-256、SHA-384、SHA-512\n\nSHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。  \nSHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。  \n它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。\n\n## 4.3 RIPEMD-160\n\nRIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。\n\n## 4.4 AHS（Advanced Hash Standard）与 SHA-3\n\n在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。\n\n# 5 单向散列函数 SHA-1\n\n此章主要讲解其具体算法，有感兴趣者请看原书。\n\n# 6 对单向散列函数的攻击\n\n## 6.1 暴力破解（攻击故事 1 ）\n\nAlice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的：\n>Alice 要支付的金额为 100 万元。\n\n改成：\n>Alice 要支付的金额为 1 亿元。\n\n不过，不仅要修改合同内容，还要不能改变散列值。  \nMallory 可以从文档文件所具有的**冗余性**入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。  \n举个例子，下面的这些句子基本上说的都是一个意思：  \nAlice 要支付的金额为 1 亿元。  \nAlice 要支付的金额为壹亿元。  \nAlice 要支付的金额为 100000000 元。  \nAlice 应支付 1 亿元。  \n作为报酬， Alice 需要支付 1 亿元。  \n\b  \n除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。  \n  \n于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“\b100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。  \n在这里，Mallory 所进行的攻击就是**暴力攻击**。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种**试图破解单向散列函数的“弱抗碰撞性”的攻击**。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次）\n\n## 6.2 生日攻击（攻击故事 2 ）\n\n编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100\b 万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。  \n这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为**生日攻击（birthday attack）**，这是一种**试图破解单向散列函数的“强抗碰撞性”的攻击。**  \n这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。\n\n# 7 单向散列函数无法解决的问题\n\n假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，**单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。**  \n因此我们还需要进行**认证**，用于认证的技术包括**消息认证码**和**数字签名**。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。  \n认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。\n\n# 8 本章小结\n\n本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。  \n以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。  \n但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。\n\n# 9 小测验\n\n1. MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。\n2. 要找出和某条消息具备相同散列值的另一条消息是非常困难的。\n3. 要找出具有相同散列值但互不相同的两条消息是非常困难的。\n4. SHA-1 的散列值长度为 20字节。\n5. 如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。\n\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_7.png\n","slug":"graphic2cryptography/7.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavq002aaxs61wnsggvg","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。<br>本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。<br>我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。</p>\n<h1 id=\"2-什么是单向散列函数\"><a href=\"#2-什么是单向散列函数\" class=\"headerlink\" title=\"2 什么是单向散列函数\"></a>2 什么是单向散列函数</h1><h2 id=\"2-1-这个文件是不是真的呢\"><a href=\"#2-1-这个文件是不是真的呢\" class=\"headerlink\" title=\"2.1 这个文件是不是真的呢\"></a>2.1 这个文件是不是真的呢</h2><p>Alice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。<br>第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：<br>“这个文件和我昨天晚上生成的文件是一样的吗？”<br>Alice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改……在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。  </p>\n<p>也就是说，Alice 需要确定自己的文件的完整性（integrity）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_1.png\" alt=\"\"><br>稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。<br>不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_2.png\" alt=\"\"><br>这里还存在一个效率问题。如果需\b需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。<br>我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_3.png\" alt=\"\"><br>本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。</p>\n<h2 id=\"2-2-什么是单向散列函数\"><a href=\"#2-2-什么是单向散列函数\" class=\"headerlink\" title=\"2.2 什么是单向散列函数\"></a>2.2 什么是单向散列函数</h2><p>单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_4.png\" alt=\"\"><br>这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。<br>散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_5.png\" alt=\"\"><br>由于散列值很短，因此很容易处理和使用。  </p>\n<p>回家之前，Alice 用单向散列函数计算文件的散列值：<br>35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5<br>单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~<br>第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。</p>\n<h2 id=\"2-3-单向散列函数的性质\"><a href=\"#2-3-单向散列函数的性质\" class=\"headerlink\" title=\"2.3 单向散列函数的性质\"></a>2.3 单向散列函数的性质</h2><h3 id=\"1-根据任意长度的消息计算出固定长度的散列值\"><a href=\"#1-根据任意长度的消息计算出固定长度的散列值\" class=\"headerlink\" title=\"1. 根据任意长度的消息计算出固定长度的散列值\"></a>1. 根据任意长度的消息计算出固定长度的散列值</h3><h3 id=\"2-能够快速计算出散列值\"><a href=\"#2-能够快速计算出散列值\" class=\"headerlink\" title=\"2.能够快速计算出散列值\"></a>2.能够快速计算出散列值</h3><h3 id=\"3-消息不同散列值也不同\"><a href=\"#3-消息不同散列值也不同\" class=\"headerlink\" title=\"3.消息不同散列值也不同\"></a>3.消息不同散列值也不同</h3><p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为<strong>碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。<br>难以发现碰撞的性质称为<strong>抗碰撞性（collision resistance）</strong>。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。<br>我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。<br>Alice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_6.png\" alt=\"\"><br>由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。  </p>\n<p>这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保<strong>要找到和该条消息具有相同散列值的另外一条消息是非常困难的</strong>。这一性质称为<strong>弱抗碰撞性</strong>。单向散列函数都必须具备弱抗碰撞性。  </p>\n<p>和弱抗碰撞性相对的，还有<strong>强抗碰撞性</strong>。所谓强抗碰撞性，是指<strong>要找到散列值相同的两条不同的消息是非常困难的</strong>这一性质。在这里，散列值可以是任意值。  </p>\n<p>密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p>\n<h3 id=\"4-具备单向性\"><a href=\"#4-具备单向性\" class=\"headerlink\" title=\"4. 具备单向性\"></a>4. 具备单向性</h3><h2 id=\"2-4-关于术语\"><a href=\"#2-4-关于术语\" class=\"headerlink\" title=\"2.4 关于术语\"></a>2.4 关于术语</h2><p><strong>单向散列函数</strong>也称为<strong>消息摘要函数（message digest function）</strong>、<strong>哈希函数</strong>或者<strong>杂凑函数</strong>。<br>输入单向散列函数的消息也称为<strong>原像（pre-image）</strong>。<br>单向散列函数输出的<strong>散列值</strong>也称为<strong>消息摘要（message digest）</strong>或者指纹（fingerprint）**。<br>完整性也称为一致性。<br>“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。</p>\n<h1 id=\"3-单向散列函数的实际应用\"><a href=\"#3-单向散列函数的实际应用\" class=\"headerlink\" title=\"3 单向散列函数的实际应用\"></a>3 单向散列函数的实际应用</h1><h2 id=\"3-1-检测软件是否被篡改\"><a href=\"#3-1-检测软件是否被篡改\" class=\"headerlink\" title=\"3.1 检测软件是否被篡改\"></a>3.1 检测软件是否被篡改</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_7.png\" alt=\"\"></p>\n<h2 id=\"3-2-基于口令的加密\"><a href=\"#3-2-基于口令的加密\" class=\"headerlink\" title=\"3.2 基于口令的加密\"></a>3.2 基于口令的加密</h2><p>单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。<br>PBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。</p>\n<h2 id=\"3-3-消息认证码\"><a href=\"#3-3-消息认证码\" class=\"headerlink\" title=\"3.3 消息认证码\"></a>3.3 消息认证码</h2><p>使用单向散列函数可以构造消息认证码。<br>消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。<br>消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。</p>\n<h2 id=\"3-4-数字签名\"><a href=\"#3-4-数字签名\" class=\"headerlink\" title=\"3.4 数字签名\"></a>3.4 数字签名</h2><p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。</p>\n<h2 id=\"3-5-伪随机数生成器\"><a href=\"#3-5-伪随机数生成器\" class=\"headerlink\" title=\"3.5 伪随机数生成器\"></a>3.5 伪随机数生成器</h2><p>使用单向散列函数可以构造伪随机数生成器。<br>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。</p>\n<h2 id=\"3-6-一次性口令\"><a href=\"#3-6-一次性口令\" class=\"headerlink\" title=\"3.6 一次性口令\"></a>3.6 一次性口令</h2><p>一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p>\n<h1 id=\"4-单向散列函数的具体例子\"><a href=\"#4-单向散列函数的具体例子\" class=\"headerlink\" title=\"4 单向散列函数的具体例子\"></a>4 单向散列函数的具体例子</h1><h2 id=\"4-1-MD4、MD5\"><a href=\"#4-1-MD4、MD5\" class=\"headerlink\" title=\"4.1 MD4、MD5\"></a>4.1 MD4、MD5</h2><p>MD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。<br>MD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。<br>MD 是消息摘要（Message Digest）的缩写。</p>\n<h2 id=\"4-2-SHA-1、SHA-256、SHA-384、SHA-512\"><a href=\"#4-2-SHA-1、SHA-256、SHA-384、SHA-512\" class=\"headerlink\" title=\"4.2 SHA-1、SHA-256、SHA-384、SHA-512\"></a>4.2 SHA-1、SHA-256、SHA-384、SHA-512</h2><p>SHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。<br>SHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。<br>它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。</p>\n<h2 id=\"4-3-RIPEMD-160\"><a href=\"#4-3-RIPEMD-160\" class=\"headerlink\" title=\"4.3 RIPEMD-160\"></a>4.3 RIPEMD-160</h2><p>RIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。</p>\n<h2 id=\"4-4-AHS（Advanced-Hash-Standard）与-SHA-3\"><a href=\"#4-4-AHS（Advanced-Hash-Standard）与-SHA-3\" class=\"headerlink\" title=\"4.4 AHS（Advanced Hash Standard）与 SHA-3\"></a>4.4 AHS（Advanced Hash Standard）与 SHA-3</h2><p>在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。</p>\n<h1 id=\"5-单向散列函数-SHA-1\"><a href=\"#5-单向散列函数-SHA-1\" class=\"headerlink\" title=\"5 单向散列函数 SHA-1\"></a>5 单向散列函数 SHA-1</h1><p>此章主要讲解其具体算法，有感兴趣者请看原书。</p>\n<h1 id=\"6-对单向散列函数的攻击\"><a href=\"#6-对单向散列函数的攻击\" class=\"headerlink\" title=\"6 对单向散列函数的攻击\"></a>6 对单向散列函数的攻击</h1><h2 id=\"6-1-暴力破解（攻击故事-1-）\"><a href=\"#6-1-暴力破解（攻击故事-1-）\" class=\"headerlink\" title=\"6.1 暴力破解（攻击故事 1 ）\"></a>6.1 暴力破解（攻击故事 1 ）</h2><p>Alice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的：</p>\n<blockquote>\n<p>Alice 要支付的金额为 100 万元。</p>\n</blockquote>\n<p>改成：</p>\n<blockquote>\n<p>Alice 要支付的金额为 1 亿元。</p>\n</blockquote>\n<p>不过，不仅要修改合同内容，还要不能改变散列值。<br>Mallory 可以从文档文件所具有的<strong>冗余性</strong>入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。<br>举个例子，下面的这些句子基本上说的都是一个意思：<br>Alice 要支付的金额为 1 亿元。<br>Alice 要支付的金额为壹亿元。<br>Alice 要支付的金额为 100000000 元。<br>Alice 应支付 1 亿元。<br>作为报酬， Alice 需要支付 1 亿元。<br>\b<br>除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。  </p>\n<p>于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“\b100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。<br>在这里，Mallory 所进行的攻击就是<strong>暴力攻击</strong>。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种<strong>试图破解单向散列函数的“弱抗碰撞性”的攻击</strong>。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次）</p>\n<h2 id=\"6-2-生日攻击（攻击故事-2-）\"><a href=\"#6-2-生日攻击（攻击故事-2-）\" class=\"headerlink\" title=\"6.2 生日攻击（攻击故事 2 ）\"></a>6.2 生日攻击（攻击故事 2 ）</h2><p>编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100\b 万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。<br>这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为<strong>生日攻击（birthday attack）</strong>，这是一种<strong>试图破解单向散列函数的“强抗碰撞性”的攻击。</strong><br>这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。</p>\n<h1 id=\"7-单向散列函数无法解决的问题\"><a href=\"#7-单向散列函数无法解决的问题\" class=\"headerlink\" title=\"7 单向散列函数无法解决的问题\"></a>7 单向散列函数无法解决的问题</h1><p>假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，<strong>单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。</strong><br>因此我们还需要进行<strong>认证</strong>，用于认证的技术包括<strong>消息认证码</strong>和<strong>数字签名</strong>。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。<br>认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。<br>以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。<br>但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><ol>\n<li>MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。</li>\n<li>要找出和某条消息具备相同散列值的另一条消息是非常困难的。</li>\n<li>要找出具有相同散列值但互不相同的两条消息是非常困难的。</li>\n<li>SHA-1 的散列值长度为 20字节。</li>\n<li>如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。<br>本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。<br>我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。</p>\n<h1 id=\"2-什么是单向散列函数\"><a href=\"#2-什么是单向散列函数\" class=\"headerlink\" title=\"2 什么是单向散列函数\"></a>2 什么是单向散列函数</h1><h2 id=\"2-1-这个文件是不是真的呢\"><a href=\"#2-1-这个文件是不是真的呢\" class=\"headerlink\" title=\"2.1 这个文件是不是真的呢\"></a>2.1 这个文件是不是真的呢</h2><p>Alice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。<br>第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：<br>“这个文件和我昨天晚上生成的文件是一样的吗？”<br>Alice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改……在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。  </p>\n<p>也就是说，Alice 需要确定自己的文件的完整性（integrity）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_1.png\" alt=\"\"><br>稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。<br>不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_2.png\" alt=\"\"><br>这里还存在一个效率问题。如果需\b需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。<br>我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_3.png\" alt=\"\"><br>本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。</p>\n<h2 id=\"2-2-什么是单向散列函数\"><a href=\"#2-2-什么是单向散列函数\" class=\"headerlink\" title=\"2.2 什么是单向散列函数\"></a>2.2 什么是单向散列函数</h2><p>单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_4.png\" alt=\"\"><br>这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。<br>散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_5.png\" alt=\"\"><br>由于散列值很短，因此很容易处理和使用。  </p>\n<p>回家之前，Alice 用单向散列函数计算文件的散列值：<br>35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5<br>单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~<br>第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。</p>\n<h2 id=\"2-3-单向散列函数的性质\"><a href=\"#2-3-单向散列函数的性质\" class=\"headerlink\" title=\"2.3 单向散列函数的性质\"></a>2.3 单向散列函数的性质</h2><h3 id=\"1-根据任意长度的消息计算出固定长度的散列值\"><a href=\"#1-根据任意长度的消息计算出固定长度的散列值\" class=\"headerlink\" title=\"1. 根据任意长度的消息计算出固定长度的散列值\"></a>1. 根据任意长度的消息计算出固定长度的散列值</h3><h3 id=\"2-能够快速计算出散列值\"><a href=\"#2-能够快速计算出散列值\" class=\"headerlink\" title=\"2.能够快速计算出散列值\"></a>2.能够快速计算出散列值</h3><h3 id=\"3-消息不同散列值也不同\"><a href=\"#3-消息不同散列值也不同\" class=\"headerlink\" title=\"3.消息不同散列值也不同\"></a>3.消息不同散列值也不同</h3><p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为<strong>碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。<br>难以发现碰撞的性质称为<strong>抗碰撞性（collision resistance）</strong>。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。<br>我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。<br>Alice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_6.png\" alt=\"\"><br>由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。  </p>\n<p>这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保<strong>要找到和该条消息具有相同散列值的另外一条消息是非常困难的</strong>。这一性质称为<strong>弱抗碰撞性</strong>。单向散列函数都必须具备弱抗碰撞性。  </p>\n<p>和弱抗碰撞性相对的，还有<strong>强抗碰撞性</strong>。所谓强抗碰撞性，是指<strong>要找到散列值相同的两条不同的消息是非常困难的</strong>这一性质。在这里，散列值可以是任意值。  </p>\n<p>密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p>\n<h3 id=\"4-具备单向性\"><a href=\"#4-具备单向性\" class=\"headerlink\" title=\"4. 具备单向性\"></a>4. 具备单向性</h3><h2 id=\"2-4-关于术语\"><a href=\"#2-4-关于术语\" class=\"headerlink\" title=\"2.4 关于术语\"></a>2.4 关于术语</h2><p><strong>单向散列函数</strong>也称为<strong>消息摘要函数（message digest function）</strong>、<strong>哈希函数</strong>或者<strong>杂凑函数</strong>。<br>输入单向散列函数的消息也称为<strong>原像（pre-image）</strong>。<br>单向散列函数输出的<strong>散列值</strong>也称为<strong>消息摘要（message digest）</strong>或者指纹（fingerprint）**。<br>完整性也称为一致性。<br>“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。</p>\n<h1 id=\"3-单向散列函数的实际应用\"><a href=\"#3-单向散列函数的实际应用\" class=\"headerlink\" title=\"3 单向散列函数的实际应用\"></a>3 单向散列函数的实际应用</h1><h2 id=\"3-1-检测软件是否被篡改\"><a href=\"#3-1-检测软件是否被篡改\" class=\"headerlink\" title=\"3.1 检测软件是否被篡改\"></a>3.1 检测软件是否被篡改</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_7.png\" alt=\"\"></p>\n<h2 id=\"3-2-基于口令的加密\"><a href=\"#3-2-基于口令的加密\" class=\"headerlink\" title=\"3.2 基于口令的加密\"></a>3.2 基于口令的加密</h2><p>单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。<br>PBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。</p>\n<h2 id=\"3-3-消息认证码\"><a href=\"#3-3-消息认证码\" class=\"headerlink\" title=\"3.3 消息认证码\"></a>3.3 消息认证码</h2><p>使用单向散列函数可以构造消息认证码。<br>消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。<br>消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。</p>\n<h2 id=\"3-4-数字签名\"><a href=\"#3-4-数字签名\" class=\"headerlink\" title=\"3.4 数字签名\"></a>3.4 数字签名</h2><p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。</p>\n<h2 id=\"3-5-伪随机数生成器\"><a href=\"#3-5-伪随机数生成器\" class=\"headerlink\" title=\"3.5 伪随机数生成器\"></a>3.5 伪随机数生成器</h2><p>使用单向散列函数可以构造伪随机数生成器。<br>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。</p>\n<h2 id=\"3-6-一次性口令\"><a href=\"#3-6-一次性口令\" class=\"headerlink\" title=\"3.6 一次性口令\"></a>3.6 一次性口令</h2><p>一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p>\n<h1 id=\"4-单向散列函数的具体例子\"><a href=\"#4-单向散列函数的具体例子\" class=\"headerlink\" title=\"4 单向散列函数的具体例子\"></a>4 单向散列函数的具体例子</h1><h2 id=\"4-1-MD4、MD5\"><a href=\"#4-1-MD4、MD5\" class=\"headerlink\" title=\"4.1 MD4、MD5\"></a>4.1 MD4、MD5</h2><p>MD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。<br>MD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。<br>MD 是消息摘要（Message Digest）的缩写。</p>\n<h2 id=\"4-2-SHA-1、SHA-256、SHA-384、SHA-512\"><a href=\"#4-2-SHA-1、SHA-256、SHA-384、SHA-512\" class=\"headerlink\" title=\"4.2 SHA-1、SHA-256、SHA-384、SHA-512\"></a>4.2 SHA-1、SHA-256、SHA-384、SHA-512</h2><p>SHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。<br>SHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。<br>它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。</p>\n<h2 id=\"4-3-RIPEMD-160\"><a href=\"#4-3-RIPEMD-160\" class=\"headerlink\" title=\"4.3 RIPEMD-160\"></a>4.3 RIPEMD-160</h2><p>RIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。</p>\n<h2 id=\"4-4-AHS（Advanced-Hash-Standard）与-SHA-3\"><a href=\"#4-4-AHS（Advanced-Hash-Standard）与-SHA-3\" class=\"headerlink\" title=\"4.4 AHS（Advanced Hash Standard）与 SHA-3\"></a>4.4 AHS（Advanced Hash Standard）与 SHA-3</h2><p>在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。</p>\n<h1 id=\"5-单向散列函数-SHA-1\"><a href=\"#5-单向散列函数-SHA-1\" class=\"headerlink\" title=\"5 单向散列函数 SHA-1\"></a>5 单向散列函数 SHA-1</h1><p>此章主要讲解其具体算法，有感兴趣者请看原书。</p>\n<h1 id=\"6-对单向散列函数的攻击\"><a href=\"#6-对单向散列函数的攻击\" class=\"headerlink\" title=\"6 对单向散列函数的攻击\"></a>6 对单向散列函数的攻击</h1><h2 id=\"6-1-暴力破解（攻击故事-1-）\"><a href=\"#6-1-暴力破解（攻击故事-1-）\" class=\"headerlink\" title=\"6.1 暴力破解（攻击故事 1 ）\"></a>6.1 暴力破解（攻击故事 1 ）</h2><p>Alice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的：</p>\n<blockquote>\n<p>Alice 要支付的金额为 100 万元。</p>\n</blockquote>\n<p>改成：</p>\n<blockquote>\n<p>Alice 要支付的金额为 1 亿元。</p>\n</blockquote>\n<p>不过，不仅要修改合同内容，还要不能改变散列值。<br>Mallory 可以从文档文件所具有的<strong>冗余性</strong>入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。<br>举个例子，下面的这些句子基本上说的都是一个意思：<br>Alice 要支付的金额为 1 亿元。<br>Alice 要支付的金额为壹亿元。<br>Alice 要支付的金额为 100000000 元。<br>Alice 应支付 1 亿元。<br>作为报酬， Alice 需要支付 1 亿元。<br>\b<br>除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。  </p>\n<p>于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“\b100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。<br>在这里，Mallory 所进行的攻击就是<strong>暴力攻击</strong>。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种<strong>试图破解单向散列函数的“弱抗碰撞性”的攻击</strong>。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次）</p>\n<h2 id=\"6-2-生日攻击（攻击故事-2-）\"><a href=\"#6-2-生日攻击（攻击故事-2-）\" class=\"headerlink\" title=\"6.2 生日攻击（攻击故事 2 ）\"></a>6.2 生日攻击（攻击故事 2 ）</h2><p>编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100\b 万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。<br>这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为<strong>生日攻击（birthday attack）</strong>，这是一种<strong>试图破解单向散列函数的“强抗碰撞性”的攻击。</strong><br>这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。</p>\n<h1 id=\"7-单向散列函数无法解决的问题\"><a href=\"#7-单向散列函数无法解决的问题\" class=\"headerlink\" title=\"7 单向散列函数无法解决的问题\"></a>7 单向散列函数无法解决的问题</h1><p>假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，<strong>单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。</strong><br>因此我们还需要进行<strong>认证</strong>，用于认证的技术包括<strong>消息认证码</strong>和<strong>数字签名</strong>。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。<br>认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。<br>以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。<br>但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><ol>\n<li>MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。</li>\n<li>要找出和某条消息具备相同散列值的另一条消息是非常困难的。</li>\n<li>要找出具有相同散列值但互不相同的两条消息是非常困难的。</li>\n<li>SHA-1 的散列值长度为 20字节。</li>\n<li>如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。</li>\n</ol>\n"},{"title":"九、数字签名——消息到底是谁写的","date":"2017-11-20T17:07:00.000Z","updated":"2017-11-22T13:48:00.000Z","comments":1,"_content":"\n# 1 羊妈妈的认证\n\n大灰狼把黑色的爪子伸进门缝，说道：  \n“我是你们的妈妈，快快开门吧！”  \n七只小羊回答道：  \n“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”  \n听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。  \n这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。  \n如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。\n\n# 2 本章概要\n\n数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。\n\n# 3 数字签名\n\n## 3.1 Alice 的借条\n\n假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：  \n“Bob，我向你借款 100 万元。”————Alice。  \n显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。\n\n## 3.2 从消息认证码到数字签名\n\n### 1. 消息认证码的局限性\n第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。\n\n### 2. 通过数字签名解决问题\n假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。  \n实际上，这种看似神奇的技术，早就已经问世了，这就是**数字签名**（digital signature）。\n\n## 3.3 签名的生成和验证\n\n在数字签名技术中，出现了下面两种行为：  \n* 生成消息签名的行为\n* 验证消息签名的行为\n\n生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。  \n验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。  \n  \nAlice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。**数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。**这一点非常重要。此外，**签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。**  \n这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，**数字签名**就是通过将公钥密码“反过来用”而实现的。  \n![][1]\n\n## 3.4 公钥密码与数字签名\n\n![][2]  \n![][3]\n\n# 4 数字签名的方法\n\n我们来介绍两种生成和验证数字签名的方法：  \n1. 直接对消息签名的方法\n2. 对消息的散列值签名的方法\n\n后者虽然复杂，但实际中我们一般都使用这种方法。\n\n## 4.1 直接对消息签名的方法\n\n发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。  \nAlice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名\b签名的 Bob 则需要得到 Alice 公钥。过程如下：  \n![][4]  \n1. Alice 用自己的私钥对消息进行加密。\n2. Alice 将消息和签名发送给 Bob。\n3. Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。\n4. Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。\n\n## 4.2 对消息的散列值签名的方法\n\n\b与对消息签名的不同是，\b这里的消息变成了消息的散列值。流程参考上图。\n\n# 5 对数字签名的疑问\n\n## 5.1 密文为什么能作为签名使用\n\n疑问：为什么密文能够具备签名的意义呢？  \n解答：数字签名是\b利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表**只有持有该秘钥的人才能够生成的信息**。  \n这样的信息一般称为**认证符号**（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。\n\n## 5.2 数字签名不能保证机密性吗\n\n疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？  \n解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。\n\n## 5.3 这种签名可以随意复制吗\n\n疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？  \n解答：签名重要的是，**特定的签名者与特定的消息绑定在了一起**这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。\n\n## 5.4 消息内容会不不会任意修改\n\n疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？  \n解答：数字签名所要实现的并不是**防止修改**，而是**识别修改**。修改没问题，但验证签名会失败。\n\n## 5.5 删除签名也无法“作废合同”吗\n\n疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？  \n解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。\n\n## 5.6 如何防止否认\n\n\b严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。\n\n## 5.7 数字签名真的能够代替签名吗\n\n不能代替，而是共存。\n\n# 6 数字签名的应用实例\n\n## 6.1 安全信息公告\n\n\b一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥\b可以排除有人恶意伪装成该组织来发布假消息的风险。\n\n## 6.2 软件下载\n\n\b保证网络下载的软件是否被篡改过。\n\n## 6.3 公钥证书\n\n在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是**公钥证书**，将在第十章详解。\n\n## 6.4 SSL/TLS\n\nSSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。\n\n# 7 通过 RSA 实现数字签名\n\n## 7.1 用 RSA 生成签名\n\n## 签名 = 消息 ^ D mod N\n这里所使用的 D 和 N 就是签名者的私钥。\n\n## 7.2 用 RSA 验证签名\n\n## 由签名求得的消息 = 签名 ^ E mod N\n这里所使用的 E 和 N 就是签名者的公钥。\n\n## 7.3 具体实践\n\n假设密钥对：  \n公钥：E = 5; N = 323;\n私钥：D = 29; N = 323;\n\n### 1.生成签名\n消息^D mod N = 123^29 mod 323 = 157  \n得到签名是 157，向接收者发送的内容为：(123，157)。\n\n### 2.验证签名\n签名^E mod N = 157^5 mod 323 = 123  \n得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。\n\n# 8 其它的数字签名\n\n1. EIGamal 方式：利用了在 mod N 中求离散对数的困难度。\n2. DSA。\n3. Rabin 方式：利用了在 mod N 中其平方根的困难度。\n\n# 9 对数字签名的攻击\n\n## 9.1 中间人攻击\n\n## 9.2 对单向散列函数的攻击\n\n数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。\n\n## 9.3 利用数字签名攻击公钥密码\n\n将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴）  \n![][5]\n\n# 10 各种密码技术的对比\n\n## 10.1 消息认证码与数字签名\n\n|| 对称密码 | 公钥密码 |\n|:-:|:-----:|:-------|\n|发送者|用共享秘钥加密|用公钥加密|\n|接收者|用共享秘钥解密|用私钥解密|\n|秘钥配送问题|存在|不存在，但公钥需要另外认证|\n|机密性|✔️|✔️|\n\n||消息认证码|数字签名|\n|:-:|:-----:|:-------|\n|发送者|用共享秘钥计算 MAC 值|用私钥生成签名|\n|接收者|用共享秘钥计算 MAC 值|用公钥验证签名|\n|秘钥配送问题|存在|不存在，但公钥需要另外认证|\n|完整性|✔️|✔️|\n|认证|✔️（仅限通信对象双方）|✔️（可适用于任何第三方）|\n|防止否认|✘|✔️|\n\n## 10.2 混合密码系统与散列值签名\n\n在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。  \n另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。  \n即：**对称密码的秘钥是机密性的精华**，**单向散列函数的散列值是完整性的精华**。\n\n# 11 数字签名无法解决的问题\n\n用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。  \n然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的**公钥必须属于真正的发送者**。  \n现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。  \n为了能够确认自己得到的公钥是否合法，我们需要使用**证书**。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。   \n  \n但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即**公钥基础设施（Public Key Intrastructure）**，简称 PKI，关于证书和 PKI 将在第十章详解。\n\n# 12 本章小结\n\n本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。  \n通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。\n\n# 13 小测验\n\n1. 要验证数字签名，需要使用签名者的私钥。\n2. RSA 可以用作数字签名算法。\n3. 使用数字签名可以保护消息的机密性，不用担心被窃听。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_5.png","source":"_posts/图解密码技术/第九章 数字签名.md","raw":"---\ntitle: 九、数字签名——消息到底是谁写的\ndate: 2017-11-21 01:07:00\nupdated: 2017-11-22 21:48:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/9.html    \n---\n\n# 1 羊妈妈的认证\n\n大灰狼把黑色的爪子伸进门缝，说道：  \n“我是你们的妈妈，快快开门吧！”  \n七只小羊回答道：  \n“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”  \n听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。  \n这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。  \n如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。\n\n# 2 本章概要\n\n数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。\n\n# 3 数字签名\n\n## 3.1 Alice 的借条\n\n假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：  \n“Bob，我向你借款 100 万元。”————Alice。  \n显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。\n\n## 3.2 从消息认证码到数字签名\n\n### 1. 消息认证码的局限性\n第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。\n\n### 2. 通过数字签名解决问题\n假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。  \n实际上，这种看似神奇的技术，早就已经问世了，这就是**数字签名**（digital signature）。\n\n## 3.3 签名的生成和验证\n\n在数字签名技术中，出现了下面两种行为：  \n* 生成消息签名的行为\n* 验证消息签名的行为\n\n生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。  \n验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。  \n  \nAlice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。**数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。**这一点非常重要。此外，**签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。**  \n这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，**数字签名**就是通过将公钥密码“反过来用”而实现的。  \n![][1]\n\n## 3.4 公钥密码与数字签名\n\n![][2]  \n![][3]\n\n# 4 数字签名的方法\n\n我们来介绍两种生成和验证数字签名的方法：  \n1. 直接对消息签名的方法\n2. 对消息的散列值签名的方法\n\n后者虽然复杂，但实际中我们一般都使用这种方法。\n\n## 4.1 直接对消息签名的方法\n\n发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。  \nAlice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名\b签名的 Bob 则需要得到 Alice 公钥。过程如下：  \n![][4]  \n1. Alice 用自己的私钥对消息进行加密。\n2. Alice 将消息和签名发送给 Bob。\n3. Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。\n4. Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。\n\n## 4.2 对消息的散列值签名的方法\n\n\b与对消息签名的不同是，\b这里的消息变成了消息的散列值。流程参考上图。\n\n# 5 对数字签名的疑问\n\n## 5.1 密文为什么能作为签名使用\n\n疑问：为什么密文能够具备签名的意义呢？  \n解答：数字签名是\b利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表**只有持有该秘钥的人才能够生成的信息**。  \n这样的信息一般称为**认证符号**（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。\n\n## 5.2 数字签名不能保证机密性吗\n\n疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？  \n解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。\n\n## 5.3 这种签名可以随意复制吗\n\n疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？  \n解答：签名重要的是，**特定的签名者与特定的消息绑定在了一起**这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。\n\n## 5.4 消息内容会不不会任意修改\n\n疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？  \n解答：数字签名所要实现的并不是**防止修改**，而是**识别修改**。修改没问题，但验证签名会失败。\n\n## 5.5 删除签名也无法“作废合同”吗\n\n疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？  \n解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。\n\n## 5.6 如何防止否认\n\n\b严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。\n\n## 5.7 数字签名真的能够代替签名吗\n\n不能代替，而是共存。\n\n# 6 数字签名的应用实例\n\n## 6.1 安全信息公告\n\n\b一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥\b可以排除有人恶意伪装成该组织来发布假消息的风险。\n\n## 6.2 软件下载\n\n\b保证网络下载的软件是否被篡改过。\n\n## 6.3 公钥证书\n\n在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是**公钥证书**，将在第十章详解。\n\n## 6.4 SSL/TLS\n\nSSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。\n\n# 7 通过 RSA 实现数字签名\n\n## 7.1 用 RSA 生成签名\n\n## 签名 = 消息 ^ D mod N\n这里所使用的 D 和 N 就是签名者的私钥。\n\n## 7.2 用 RSA 验证签名\n\n## 由签名求得的消息 = 签名 ^ E mod N\n这里所使用的 E 和 N 就是签名者的公钥。\n\n## 7.3 具体实践\n\n假设密钥对：  \n公钥：E = 5; N = 323;\n私钥：D = 29; N = 323;\n\n### 1.生成签名\n消息^D mod N = 123^29 mod 323 = 157  \n得到签名是 157，向接收者发送的内容为：(123，157)。\n\n### 2.验证签名\n签名^E mod N = 157^5 mod 323 = 123  \n得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。\n\n# 8 其它的数字签名\n\n1. EIGamal 方式：利用了在 mod N 中求离散对数的困难度。\n2. DSA。\n3. Rabin 方式：利用了在 mod N 中其平方根的困难度。\n\n# 9 对数字签名的攻击\n\n## 9.1 中间人攻击\n\n## 9.2 对单向散列函数的攻击\n\n数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。\n\n## 9.3 利用数字签名攻击公钥密码\n\n将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴）  \n![][5]\n\n# 10 各种密码技术的对比\n\n## 10.1 消息认证码与数字签名\n\n|| 对称密码 | 公钥密码 |\n|:-:|:-----:|:-------|\n|发送者|用共享秘钥加密|用公钥加密|\n|接收者|用共享秘钥解密|用私钥解密|\n|秘钥配送问题|存在|不存在，但公钥需要另外认证|\n|机密性|✔️|✔️|\n\n||消息认证码|数字签名|\n|:-:|:-----:|:-------|\n|发送者|用共享秘钥计算 MAC 值|用私钥生成签名|\n|接收者|用共享秘钥计算 MAC 值|用公钥验证签名|\n|秘钥配送问题|存在|不存在，但公钥需要另外认证|\n|完整性|✔️|✔️|\n|认证|✔️（仅限通信对象双方）|✔️（可适用于任何第三方）|\n|防止否认|✘|✔️|\n\n## 10.2 混合密码系统与散列值签名\n\n在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。  \n另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。  \n即：**对称密码的秘钥是机密性的精华**，**单向散列函数的散列值是完整性的精华**。\n\n# 11 数字签名无法解决的问题\n\n用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。  \n然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的**公钥必须属于真正的发送者**。  \n现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。  \n为了能够确认自己得到的公钥是否合法，我们需要使用**证书**。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。   \n  \n但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即**公钥基础设施（Public Key Intrastructure）**，简称 PKI，关于证书和 PKI 将在第十章详解。\n\n# 12 本章小结\n\n本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。  \n通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。\n\n# 13 小测验\n\n1. 要验证数字签名，需要使用签名者的私钥。\n2. RSA 可以用作数字签名算法。\n3. 使用数字签名可以保护消息的机密性，不用担心被窃听。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_5.png","slug":"graphic2cryptography/9.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavr002daxs6u7ggnjz4","content":"<h1 id=\"1-羊妈妈的认证\"><a href=\"#1-羊妈妈的认证\" class=\"headerlink\" title=\"1 羊妈妈的认证\"></a>1 羊妈妈的认证</h1><p>大灰狼把黑色的爪子伸进门缝，说道：<br>“我是你们的妈妈，快快开门吧！”<br>七只小羊回答道：<br>“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”<br>听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。<br>这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。<br>如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。</p>\n<h1 id=\"3-数字签名\"><a href=\"#3-数字签名\" class=\"headerlink\" title=\"3 数字签名\"></a>3 数字签名</h1><h2 id=\"3-1-Alice-的借条\"><a href=\"#3-1-Alice-的借条\" class=\"headerlink\" title=\"3.1 Alice 的借条\"></a>3.1 Alice 的借条</h2><p>假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：<br>“Bob，我向你借款 100 万元。”————Alice。<br>显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。</p>\n<h2 id=\"3-2-从消息认证码到数字签名\"><a href=\"#3-2-从消息认证码到数字签名\" class=\"headerlink\" title=\"3.2 从消息认证码到数字签名\"></a>3.2 从消息认证码到数字签名</h2><h3 id=\"1-消息认证码的局限性\"><a href=\"#1-消息认证码的局限性\" class=\"headerlink\" title=\"1. 消息认证码的局限性\"></a>1. 消息认证码的局限性</h3><p>第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。</p>\n<h3 id=\"2-通过数字签名解决问题\"><a href=\"#2-通过数字签名解决问题\" class=\"headerlink\" title=\"2. 通过数字签名解决问题\"></a>2. 通过数字签名解决问题</h3><p>假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。<br>实际上，这种看似神奇的技术，早就已经问世了，这就是<strong>数字签名</strong>（digital signature）。</p>\n<h2 id=\"3-3-签名的生成和验证\"><a href=\"#3-3-签名的生成和验证\" class=\"headerlink\" title=\"3.3 签名的生成和验证\"></a>3.3 签名的生成和验证</h2><p>在数字签名技术中，出现了下面两种行为：  </p>\n<ul>\n<li>生成消息签名的行为</li>\n<li>验证消息签名的行为</li>\n</ul>\n<p>生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。<br>验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。  </p>\n<p>Alice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。<strong>数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。</strong>这一点非常重要。此外，<strong>签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。</strong><br>这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，<strong>数字签名</strong>就是通过将公钥密码“反过来用”而实现的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_1.png\" alt=\"\"></p>\n<h2 id=\"3-4-公钥密码与数字签名\"><a href=\"#3-4-公钥密码与数字签名\" class=\"headerlink\" title=\"3.4 公钥密码与数字签名\"></a>3.4 公钥密码与数字签名</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_2.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_3.png\" alt=\"\"></p>\n<h1 id=\"4-数字签名的方法\"><a href=\"#4-数字签名的方法\" class=\"headerlink\" title=\"4 数字签名的方法\"></a>4 数字签名的方法</h1><p>我们来介绍两种生成和验证数字签名的方法：  </p>\n<ol>\n<li>直接对消息签名的方法</li>\n<li>对消息的散列值签名的方法</li>\n</ol>\n<p>后者虽然复杂，但实际中我们一般都使用这种方法。</p>\n<h2 id=\"4-1-直接对消息签名的方法\"><a href=\"#4-1-直接对消息签名的方法\" class=\"headerlink\" title=\"4.1 直接对消息签名的方法\"></a>4.1 直接对消息签名的方法</h2><p>发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。<br>Alice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名\b签名的 Bob 则需要得到 Alice 公钥。过程如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_4.png\" alt=\"\">  </p>\n<ol>\n<li>Alice 用自己的私钥对消息进行加密。</li>\n<li>Alice 将消息和签名发送给 Bob。</li>\n<li>Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。</li>\n<li>Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。</li>\n</ol>\n<h2 id=\"4-2-对消息的散列值签名的方法\"><a href=\"#4-2-对消息的散列值签名的方法\" class=\"headerlink\" title=\"4.2 对消息的散列值签名的方法\"></a>4.2 对消息的散列值签名的方法</h2><p>\b与对消息签名的不同是，\b这里的消息变成了消息的散列值。流程参考上图。</p>\n<h1 id=\"5-对数字签名的疑问\"><a href=\"#5-对数字签名的疑问\" class=\"headerlink\" title=\"5 对数字签名的疑问\"></a>5 对数字签名的疑问</h1><h2 id=\"5-1-密文为什么能作为签名使用\"><a href=\"#5-1-密文为什么能作为签名使用\" class=\"headerlink\" title=\"5.1 密文为什么能作为签名使用\"></a>5.1 密文为什么能作为签名使用</h2><p>疑问：为什么密文能够具备签名的意义呢？<br>解答：数字签名是\b利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表<strong>只有持有该秘钥的人才能够生成的信息</strong>。<br>这样的信息一般称为<strong>认证符号</strong>（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。</p>\n<h2 id=\"5-2-数字签名不能保证机密性吗\"><a href=\"#5-2-数字签名不能保证机密性吗\" class=\"headerlink\" title=\"5.2 数字签名不能保证机密性吗\"></a>5.2 数字签名不能保证机密性吗</h2><p>疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？<br>解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。</p>\n<h2 id=\"5-3-这种签名可以随意复制吗\"><a href=\"#5-3-这种签名可以随意复制吗\" class=\"headerlink\" title=\"5.3 这种签名可以随意复制吗\"></a>5.3 这种签名可以随意复制吗</h2><p>疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？<br>解答：签名重要的是，<strong>特定的签名者与特定的消息绑定在了一起</strong>这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。</p>\n<h2 id=\"5-4-消息内容会不不会任意修改\"><a href=\"#5-4-消息内容会不不会任意修改\" class=\"headerlink\" title=\"5.4 消息内容会不不会任意修改\"></a>5.4 消息内容会不不会任意修改</h2><p>疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？<br>解答：数字签名所要实现的并不是<strong>防止修改</strong>，而是<strong>识别修改</strong>。修改没问题，但验证签名会失败。</p>\n<h2 id=\"5-5-删除签名也无法“作废合同”吗\"><a href=\"#5-5-删除签名也无法“作废合同”吗\" class=\"headerlink\" title=\"5.5 删除签名也无法“作废合同”吗\"></a>5.5 删除签名也无法“作废合同”吗</h2><p>疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？<br>解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。</p>\n<h2 id=\"5-6-如何防止否认\"><a href=\"#5-6-如何防止否认\" class=\"headerlink\" title=\"5.6 如何防止否认\"></a>5.6 如何防止否认</h2><p>\b严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。</p>\n<h2 id=\"5-7-数字签名真的能够代替签名吗\"><a href=\"#5-7-数字签名真的能够代替签名吗\" class=\"headerlink\" title=\"5.7 数字签名真的能够代替签名吗\"></a>5.7 数字签名真的能够代替签名吗</h2><p>不能代替，而是共存。</p>\n<h1 id=\"6-数字签名的应用实例\"><a href=\"#6-数字签名的应用实例\" class=\"headerlink\" title=\"6 数字签名的应用实例\"></a>6 数字签名的应用实例</h1><h2 id=\"6-1-安全信息公告\"><a href=\"#6-1-安全信息公告\" class=\"headerlink\" title=\"6.1 安全信息公告\"></a>6.1 安全信息公告</h2><p>\b一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥\b可以排除有人恶意伪装成该组织来发布假消息的风险。</p>\n<h2 id=\"6-2-软件下载\"><a href=\"#6-2-软件下载\" class=\"headerlink\" title=\"6.2 软件下载\"></a>6.2 软件下载</h2><p>\b保证网络下载的软件是否被篡改过。</p>\n<h2 id=\"6-3-公钥证书\"><a href=\"#6-3-公钥证书\" class=\"headerlink\" title=\"6.3 公钥证书\"></a>6.3 公钥证书</h2><p>在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是<strong>公钥证书</strong>，将在第十章详解。</p>\n<h2 id=\"6-4-SSL-TLS\"><a href=\"#6-4-SSL-TLS\" class=\"headerlink\" title=\"6.4 SSL/TLS\"></a>6.4 SSL/TLS</h2><p>SSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。</p>\n<h1 id=\"7-通过-RSA-实现数字签名\"><a href=\"#7-通过-RSA-实现数字签名\" class=\"headerlink\" title=\"7 通过 RSA 实现数字签名\"></a>7 通过 RSA 实现数字签名</h1><h2 id=\"7-1-用-RSA-生成签名\"><a href=\"#7-1-用-RSA-生成签名\" class=\"headerlink\" title=\"7.1 用 RSA 生成签名\"></a>7.1 用 RSA 生成签名</h2><h2 id=\"签名-消息-D-mod-N\"><a href=\"#签名-消息-D-mod-N\" class=\"headerlink\" title=\"签名 = 消息 ^ D mod N\"></a>签名 = 消息 ^ D mod N</h2><p>这里所使用的 D 和 N 就是签名者的私钥。</p>\n<h2 id=\"7-2-用-RSA-验证签名\"><a href=\"#7-2-用-RSA-验证签名\" class=\"headerlink\" title=\"7.2 用 RSA 验证签名\"></a>7.2 用 RSA 验证签名</h2><h2 id=\"由签名求得的消息-签名-E-mod-N\"><a href=\"#由签名求得的消息-签名-E-mod-N\" class=\"headerlink\" title=\"由签名求得的消息 = 签名 ^ E mod N\"></a>由签名求得的消息 = 签名 ^ E mod N</h2><p>这里所使用的 E 和 N 就是签名者的公钥。</p>\n<h2 id=\"7-3-具体实践\"><a href=\"#7-3-具体实践\" class=\"headerlink\" title=\"7.3 具体实践\"></a>7.3 具体实践</h2><p>假设密钥对：<br>公钥：E = 5; N = 323;<br>私钥：D = 29; N = 323;</p>\n<h3 id=\"1-生成签名\"><a href=\"#1-生成签名\" class=\"headerlink\" title=\"1.生成签名\"></a>1.生成签名</h3><p>消息^D mod N = 123^29 mod 323 = 157<br>得到签名是 157，向接收者发送的内容为：(123，157)。</p>\n<h3 id=\"2-验证签名\"><a href=\"#2-验证签名\" class=\"headerlink\" title=\"2.验证签名\"></a>2.验证签名</h3><p>签名^E mod N = 157^5 mod 323 = 123<br>得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。</p>\n<h1 id=\"8-其它的数字签名\"><a href=\"#8-其它的数字签名\" class=\"headerlink\" title=\"8 其它的数字签名\"></a>8 其它的数字签名</h1><ol>\n<li>EIGamal 方式：利用了在 mod N 中求离散对数的困难度。</li>\n<li>DSA。</li>\n<li>Rabin 方式：利用了在 mod N 中其平方根的困难度。</li>\n</ol>\n<h1 id=\"9-对数字签名的攻击\"><a href=\"#9-对数字签名的攻击\" class=\"headerlink\" title=\"9 对数字签名的攻击\"></a>9 对数字签名的攻击</h1><h2 id=\"9-1-中间人攻击\"><a href=\"#9-1-中间人攻击\" class=\"headerlink\" title=\"9.1 中间人攻击\"></a>9.1 中间人攻击</h2><h2 id=\"9-2-对单向散列函数的攻击\"><a href=\"#9-2-对单向散列函数的攻击\" class=\"headerlink\" title=\"9.2 对单向散列函数的攻击\"></a>9.2 对单向散列函数的攻击</h2><p>数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。</p>\n<h2 id=\"9-3-利用数字签名攻击公钥密码\"><a href=\"#9-3-利用数字签名攻击公钥密码\" class=\"headerlink\" title=\"9.3 利用数字签名攻击公钥密码\"></a>9.3 利用数字签名攻击公钥密码</h2><p>将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴）<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_5.png\" alt=\"\"></p>\n<h1 id=\"10-各种密码技术的对比\"><a href=\"#10-各种密码技术的对比\" class=\"headerlink\" title=\"10 各种密码技术的对比\"></a>10 各种密码技术的对比</h1><h2 id=\"10-1-消息认证码与数字签名\"><a href=\"#10-1-消息认证码与数字签名\" class=\"headerlink\" title=\"10.1 消息认证码与数字签名\"></a>10.1 消息认证码与数字签名</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">对称密码</th>\n<th style=\"text-align:left\">公钥密码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">发送者</td>\n<td style=\"text-align:center\">用共享秘钥加密</td>\n<td style=\"text-align:left\">用公钥加密</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">接收者</td>\n<td style=\"text-align:center\">用共享秘钥解密</td>\n<td style=\"text-align:left\">用私钥解密</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">秘钥配送问题</td>\n<td style=\"text-align:center\">存在</td>\n<td style=\"text-align:left\">不存在，但公钥需要另外认证</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">机密性</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:left\">✔️</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">消息认证码</th>\n<th style=\"text-align:left\">数字签名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">发送者</td>\n<td style=\"text-align:center\">用共享秘钥计算 MAC 值</td>\n<td style=\"text-align:left\">用私钥生成签名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">接收者</td>\n<td style=\"text-align:center\">用共享秘钥计算 MAC 值</td>\n<td style=\"text-align:left\">用公钥验证签名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">秘钥配送问题</td>\n<td style=\"text-align:center\">存在</td>\n<td style=\"text-align:left\">不存在，但公钥需要另外认证</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">完整性</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:left\">✔️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">认证</td>\n<td style=\"text-align:center\">✔️（仅限通信对象双方）</td>\n<td style=\"text-align:left\">✔️（可适用于任何第三方）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">防止否认</td>\n<td style=\"text-align:center\">✘</td>\n<td style=\"text-align:left\">✔️</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"10-2-混合密码系统与散列值签名\"><a href=\"#10-2-混合密码系统与散列值签名\" class=\"headerlink\" title=\"10.2 混合密码系统与散列值签名\"></a>10.2 混合密码系统与散列值签名</h2><p>在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。<br>另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。<br>即：<strong>对称密码的秘钥是机密性的精华</strong>，<strong>单向散列函数的散列值是完整性的精华</strong>。</p>\n<h1 id=\"11-数字签名无法解决的问题\"><a href=\"#11-数字签名无法解决的问题\" class=\"headerlink\" title=\"11 数字签名无法解决的问题\"></a>11 数字签名无法解决的问题</h1><p>用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。<br>然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的<strong>公钥必须属于真正的发送者</strong>。<br>现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。<br>为了能够确认自己得到的公钥是否合法，我们需要使用<strong>证书</strong>。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。   </p>\n<p>但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即<strong>公钥基础设施（Public Key Intrastructure）</strong>，简称 PKI，关于证书和 PKI 将在第十章详解。</p>\n<h1 id=\"12-本章小结\"><a href=\"#12-本章小结\" class=\"headerlink\" title=\"12 本章小结\"></a>12 本章小结</h1><p>本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。<br>通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。</p>\n<h1 id=\"13-小测验\"><a href=\"#13-小测验\" class=\"headerlink\" title=\"13 小测验\"></a>13 小测验</h1><ol>\n<li>要验证数字签名，需要使用签名者的私钥。</li>\n<li>RSA 可以用作数字签名算法。</li>\n<li>使用数字签名可以保护消息的机密性，不用担心被窃听。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-羊妈妈的认证\"><a href=\"#1-羊妈妈的认证\" class=\"headerlink\" title=\"1 羊妈妈的认证\"></a>1 羊妈妈的认证</h1><p>大灰狼把黑色的爪子伸进门缝，说道：<br>“我是你们的妈妈，快快开门吧！”<br>七只小羊回答道：<br>“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”<br>听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。<br>这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。<br>如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。</p>\n<h1 id=\"3-数字签名\"><a href=\"#3-数字签名\" class=\"headerlink\" title=\"3 数字签名\"></a>3 数字签名</h1><h2 id=\"3-1-Alice-的借条\"><a href=\"#3-1-Alice-的借条\" class=\"headerlink\" title=\"3.1 Alice 的借条\"></a>3.1 Alice 的借条</h2><p>假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：<br>“Bob，我向你借款 100 万元。”————Alice。<br>显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。</p>\n<h2 id=\"3-2-从消息认证码到数字签名\"><a href=\"#3-2-从消息认证码到数字签名\" class=\"headerlink\" title=\"3.2 从消息认证码到数字签名\"></a>3.2 从消息认证码到数字签名</h2><h3 id=\"1-消息认证码的局限性\"><a href=\"#1-消息认证码的局限性\" class=\"headerlink\" title=\"1. 消息认证码的局限性\"></a>1. 消息认证码的局限性</h3><p>第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。</p>\n<h3 id=\"2-通过数字签名解决问题\"><a href=\"#2-通过数字签名解决问题\" class=\"headerlink\" title=\"2. 通过数字签名解决问题\"></a>2. 通过数字签名解决问题</h3><p>假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。<br>实际上，这种看似神奇的技术，早就已经问世了，这就是<strong>数字签名</strong>（digital signature）。</p>\n<h2 id=\"3-3-签名的生成和验证\"><a href=\"#3-3-签名的生成和验证\" class=\"headerlink\" title=\"3.3 签名的生成和验证\"></a>3.3 签名的生成和验证</h2><p>在数字签名技术中，出现了下面两种行为：  </p>\n<ul>\n<li>生成消息签名的行为</li>\n<li>验证消息签名的行为</li>\n</ul>\n<p>生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。<br>验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。  </p>\n<p>Alice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。<strong>数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。</strong>这一点非常重要。此外，<strong>签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。</strong><br>这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，<strong>数字签名</strong>就是通过将公钥密码“反过来用”而实现的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_1.png\" alt=\"\"></p>\n<h2 id=\"3-4-公钥密码与数字签名\"><a href=\"#3-4-公钥密码与数字签名\" class=\"headerlink\" title=\"3.4 公钥密码与数字签名\"></a>3.4 公钥密码与数字签名</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_2.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_3.png\" alt=\"\"></p>\n<h1 id=\"4-数字签名的方法\"><a href=\"#4-数字签名的方法\" class=\"headerlink\" title=\"4 数字签名的方法\"></a>4 数字签名的方法</h1><p>我们来介绍两种生成和验证数字签名的方法：  </p>\n<ol>\n<li>直接对消息签名的方法</li>\n<li>对消息的散列值签名的方法</li>\n</ol>\n<p>后者虽然复杂，但实际中我们一般都使用这种方法。</p>\n<h2 id=\"4-1-直接对消息签名的方法\"><a href=\"#4-1-直接对消息签名的方法\" class=\"headerlink\" title=\"4.1 直接对消息签名的方法\"></a>4.1 直接对消息签名的方法</h2><p>发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。<br>Alice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名\b签名的 Bob 则需要得到 Alice 公钥。过程如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_4.png\" alt=\"\">  </p>\n<ol>\n<li>Alice 用自己的私钥对消息进行加密。</li>\n<li>Alice 将消息和签名发送给 Bob。</li>\n<li>Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。</li>\n<li>Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。</li>\n</ol>\n<h2 id=\"4-2-对消息的散列值签名的方法\"><a href=\"#4-2-对消息的散列值签名的方法\" class=\"headerlink\" title=\"4.2 对消息的散列值签名的方法\"></a>4.2 对消息的散列值签名的方法</h2><p>\b与对消息签名的不同是，\b这里的消息变成了消息的散列值。流程参考上图。</p>\n<h1 id=\"5-对数字签名的疑问\"><a href=\"#5-对数字签名的疑问\" class=\"headerlink\" title=\"5 对数字签名的疑问\"></a>5 对数字签名的疑问</h1><h2 id=\"5-1-密文为什么能作为签名使用\"><a href=\"#5-1-密文为什么能作为签名使用\" class=\"headerlink\" title=\"5.1 密文为什么能作为签名使用\"></a>5.1 密文为什么能作为签名使用</h2><p>疑问：为什么密文能够具备签名的意义呢？<br>解答：数字签名是\b利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表<strong>只有持有该秘钥的人才能够生成的信息</strong>。<br>这样的信息一般称为<strong>认证符号</strong>（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。</p>\n<h2 id=\"5-2-数字签名不能保证机密性吗\"><a href=\"#5-2-数字签名不能保证机密性吗\" class=\"headerlink\" title=\"5.2 数字签名不能保证机密性吗\"></a>5.2 数字签名不能保证机密性吗</h2><p>疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？<br>解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。</p>\n<h2 id=\"5-3-这种签名可以随意复制吗\"><a href=\"#5-3-这种签名可以随意复制吗\" class=\"headerlink\" title=\"5.3 这种签名可以随意复制吗\"></a>5.3 这种签名可以随意复制吗</h2><p>疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？<br>解答：签名重要的是，<strong>特定的签名者与特定的消息绑定在了一起</strong>这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。</p>\n<h2 id=\"5-4-消息内容会不不会任意修改\"><a href=\"#5-4-消息内容会不不会任意修改\" class=\"headerlink\" title=\"5.4 消息内容会不不会任意修改\"></a>5.4 消息内容会不不会任意修改</h2><p>疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？<br>解答：数字签名所要实现的并不是<strong>防止修改</strong>，而是<strong>识别修改</strong>。修改没问题，但验证签名会失败。</p>\n<h2 id=\"5-5-删除签名也无法“作废合同”吗\"><a href=\"#5-5-删除签名也无法“作废合同”吗\" class=\"headerlink\" title=\"5.5 删除签名也无法“作废合同”吗\"></a>5.5 删除签名也无法“作废合同”吗</h2><p>疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？<br>解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。</p>\n<h2 id=\"5-6-如何防止否认\"><a href=\"#5-6-如何防止否认\" class=\"headerlink\" title=\"5.6 如何防止否认\"></a>5.6 如何防止否认</h2><p>\b严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。</p>\n<h2 id=\"5-7-数字签名真的能够代替签名吗\"><a href=\"#5-7-数字签名真的能够代替签名吗\" class=\"headerlink\" title=\"5.7 数字签名真的能够代替签名吗\"></a>5.7 数字签名真的能够代替签名吗</h2><p>不能代替，而是共存。</p>\n<h1 id=\"6-数字签名的应用实例\"><a href=\"#6-数字签名的应用实例\" class=\"headerlink\" title=\"6 数字签名的应用实例\"></a>6 数字签名的应用实例</h1><h2 id=\"6-1-安全信息公告\"><a href=\"#6-1-安全信息公告\" class=\"headerlink\" title=\"6.1 安全信息公告\"></a>6.1 安全信息公告</h2><p>\b一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥\b可以排除有人恶意伪装成该组织来发布假消息的风险。</p>\n<h2 id=\"6-2-软件下载\"><a href=\"#6-2-软件下载\" class=\"headerlink\" title=\"6.2 软件下载\"></a>6.2 软件下载</h2><p>\b保证网络下载的软件是否被篡改过。</p>\n<h2 id=\"6-3-公钥证书\"><a href=\"#6-3-公钥证书\" class=\"headerlink\" title=\"6.3 公钥证书\"></a>6.3 公钥证书</h2><p>在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是<strong>公钥证书</strong>，将在第十章详解。</p>\n<h2 id=\"6-4-SSL-TLS\"><a href=\"#6-4-SSL-TLS\" class=\"headerlink\" title=\"6.4 SSL/TLS\"></a>6.4 SSL/TLS</h2><p>SSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。</p>\n<h1 id=\"7-通过-RSA-实现数字签名\"><a href=\"#7-通过-RSA-实现数字签名\" class=\"headerlink\" title=\"7 通过 RSA 实现数字签名\"></a>7 通过 RSA 实现数字签名</h1><h2 id=\"7-1-用-RSA-生成签名\"><a href=\"#7-1-用-RSA-生成签名\" class=\"headerlink\" title=\"7.1 用 RSA 生成签名\"></a>7.1 用 RSA 生成签名</h2><h2 id=\"签名-消息-D-mod-N\"><a href=\"#签名-消息-D-mod-N\" class=\"headerlink\" title=\"签名 = 消息 ^ D mod N\"></a>签名 = 消息 ^ D mod N</h2><p>这里所使用的 D 和 N 就是签名者的私钥。</p>\n<h2 id=\"7-2-用-RSA-验证签名\"><a href=\"#7-2-用-RSA-验证签名\" class=\"headerlink\" title=\"7.2 用 RSA 验证签名\"></a>7.2 用 RSA 验证签名</h2><h2 id=\"由签名求得的消息-签名-E-mod-N\"><a href=\"#由签名求得的消息-签名-E-mod-N\" class=\"headerlink\" title=\"由签名求得的消息 = 签名 ^ E mod N\"></a>由签名求得的消息 = 签名 ^ E mod N</h2><p>这里所使用的 E 和 N 就是签名者的公钥。</p>\n<h2 id=\"7-3-具体实践\"><a href=\"#7-3-具体实践\" class=\"headerlink\" title=\"7.3 具体实践\"></a>7.3 具体实践</h2><p>假设密钥对：<br>公钥：E = 5; N = 323;<br>私钥：D = 29; N = 323;</p>\n<h3 id=\"1-生成签名\"><a href=\"#1-生成签名\" class=\"headerlink\" title=\"1.生成签名\"></a>1.生成签名</h3><p>消息^D mod N = 123^29 mod 323 = 157<br>得到签名是 157，向接收者发送的内容为：(123，157)。</p>\n<h3 id=\"2-验证签名\"><a href=\"#2-验证签名\" class=\"headerlink\" title=\"2.验证签名\"></a>2.验证签名</h3><p>签名^E mod N = 157^5 mod 323 = 123<br>得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。</p>\n<h1 id=\"8-其它的数字签名\"><a href=\"#8-其它的数字签名\" class=\"headerlink\" title=\"8 其它的数字签名\"></a>8 其它的数字签名</h1><ol>\n<li>EIGamal 方式：利用了在 mod N 中求离散对数的困难度。</li>\n<li>DSA。</li>\n<li>Rabin 方式：利用了在 mod N 中其平方根的困难度。</li>\n</ol>\n<h1 id=\"9-对数字签名的攻击\"><a href=\"#9-对数字签名的攻击\" class=\"headerlink\" title=\"9 对数字签名的攻击\"></a>9 对数字签名的攻击</h1><h2 id=\"9-1-中间人攻击\"><a href=\"#9-1-中间人攻击\" class=\"headerlink\" title=\"9.1 中间人攻击\"></a>9.1 中间人攻击</h2><h2 id=\"9-2-对单向散列函数的攻击\"><a href=\"#9-2-对单向散列函数的攻击\" class=\"headerlink\" title=\"9.2 对单向散列函数的攻击\"></a>9.2 对单向散列函数的攻击</h2><p>数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。</p>\n<h2 id=\"9-3-利用数字签名攻击公钥密码\"><a href=\"#9-3-利用数字签名攻击公钥密码\" class=\"headerlink\" title=\"9.3 利用数字签名攻击公钥密码\"></a>9.3 利用数字签名攻击公钥密码</h2><p>将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴）<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_5.png\" alt=\"\"></p>\n<h1 id=\"10-各种密码技术的对比\"><a href=\"#10-各种密码技术的对比\" class=\"headerlink\" title=\"10 各种密码技术的对比\"></a>10 各种密码技术的对比</h1><h2 id=\"10-1-消息认证码与数字签名\"><a href=\"#10-1-消息认证码与数字签名\" class=\"headerlink\" title=\"10.1 消息认证码与数字签名\"></a>10.1 消息认证码与数字签名</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">对称密码</th>\n<th style=\"text-align:left\">公钥密码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">发送者</td>\n<td style=\"text-align:center\">用共享秘钥加密</td>\n<td style=\"text-align:left\">用公钥加密</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">接收者</td>\n<td style=\"text-align:center\">用共享秘钥解密</td>\n<td style=\"text-align:left\">用私钥解密</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">秘钥配送问题</td>\n<td style=\"text-align:center\">存在</td>\n<td style=\"text-align:left\">不存在，但公钥需要另外认证</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">机密性</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:left\">✔️</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">消息认证码</th>\n<th style=\"text-align:left\">数字签名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">发送者</td>\n<td style=\"text-align:center\">用共享秘钥计算 MAC 值</td>\n<td style=\"text-align:left\">用私钥生成签名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">接收者</td>\n<td style=\"text-align:center\">用共享秘钥计算 MAC 值</td>\n<td style=\"text-align:left\">用公钥验证签名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">秘钥配送问题</td>\n<td style=\"text-align:center\">存在</td>\n<td style=\"text-align:left\">不存在，但公钥需要另外认证</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">完整性</td>\n<td style=\"text-align:center\">✔️</td>\n<td style=\"text-align:left\">✔️</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">认证</td>\n<td style=\"text-align:center\">✔️（仅限通信对象双方）</td>\n<td style=\"text-align:left\">✔️（可适用于任何第三方）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">防止否认</td>\n<td style=\"text-align:center\">✘</td>\n<td style=\"text-align:left\">✔️</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"10-2-混合密码系统与散列值签名\"><a href=\"#10-2-混合密码系统与散列值签名\" class=\"headerlink\" title=\"10.2 混合密码系统与散列值签名\"></a>10.2 混合密码系统与散列值签名</h2><p>在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。<br>另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。<br>即：<strong>对称密码的秘钥是机密性的精华</strong>，<strong>单向散列函数的散列值是完整性的精华</strong>。</p>\n<h1 id=\"11-数字签名无法解决的问题\"><a href=\"#11-数字签名无法解决的问题\" class=\"headerlink\" title=\"11 数字签名无法解决的问题\"></a>11 数字签名无法解决的问题</h1><p>用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。<br>然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的<strong>公钥必须属于真正的发送者</strong>。<br>现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。<br>为了能够确认自己得到的公钥是否合法，我们需要使用<strong>证书</strong>。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。   </p>\n<p>但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即<strong>公钥基础设施（Public Key Intrastructure）</strong>，简称 PKI，关于证书和 PKI 将在第十章详解。</p>\n<h1 id=\"12-本章小结\"><a href=\"#12-本章小结\" class=\"headerlink\" title=\"12 本章小结\"></a>12 本章小结</h1><p>本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。<br>通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。</p>\n<h1 id=\"13-小测验\"><a href=\"#13-小测验\" class=\"headerlink\" title=\"13 小测验\"></a>13 小测验</h1><ol>\n<li>要验证数字签名，需要使用签名者的私钥。</li>\n<li>RSA 可以用作数字签名算法。</li>\n<li>使用数字签名可以保护消息的机密性，不用担心被窃听。</li>\n</ol>\n"},{"title":"三、对称密码","date":"2017-11-12T08:14:00.000Z","updated":"2017-11-14T19:06:00.000Z","comments":1,"_content":"\n# 1 炒鸡蛋与对称密码\n\n鸡蛋炒好之后就完全分不清原来的蛋黄和蛋白了，使用对称密码进行加密，和炒鸡蛋有着异曲同工之妙。炒鸡蛋搅拌的是鸡蛋，而密文打乱的则是比特序列。\n然后，它们最大的不同是，炒鸡蛋无法还原成原来的鸡蛋，但密文却必须能够让接收者正确解密才行。\n因此，如果只是随意地搅拌和混合，则不能称之为加密，而必须仔细设计出一种能够还原的混合方式。\n\n# 2 本章概要\n\n学习比特序列运算和 XOR 运算。以及介绍一种称为一次性密码本的密码系统。  \n具体介绍几种对称密码算法，包括 DES、三重DES、AES以及其它一些密码算法。  \n需要注意的是，密码算法有时候会设计开发者的专利和授权等问题，记得先调查一下该算法的专利和授权信息。\n\n# 3 从文字密码到比特序列密码\n\n## 3.1 编码\n\n计算机操作对象并不是文字，而是由 0 和 1 排列而成的**比特序列**。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。\n\n## 3.2 XOR\n\nXOR 的全称是 exclusive or ，中文叫作**异或**。\n\n### 1. 一个比特的 XOR\n0 XOR 0 = 0  \n0 XOR 1 = 1  \n1 XOR 0 = 1  \n1 XOR 1 = 0  \n可以理解为硬币翻转：  \n不翻转 + 不翻转 = 不翻转\n不翻转 + 翻转   = 翻转\n翻转   + 不翻转 = 翻转\n翻转   + 翻转   = 不翻转\n\n### 2. 比特序列的 XOR\nA  XOR B = AB  \nAB XOR B = A  \n这是因为两个相同的数进行 XOR 运算的结果一定为 0 ，因此 A XOR B XOR B = A。这不就和加密、界面的步骤非常相似么，如下：  \n* 将明文 A 用密钥 B 进行加密，得到密文 AB。  \n* 将密文 AB 用密钥 B 进行解密，得到明文 A。  \n  \n实际上，只要选择一个合适的 B，仅仅使用 XOR 就可以实现一个高强度的密码。  \n对同一个比特序列进行两次 XOR 之后就会回到最初的状态。我们不妨来看看一副由很多点组成的图像。如果将白色的点作为 0 ，黑色的点作为 1 ，\n那么一副黑白图像就可以表示为 0 和 1 的比特序列。我们转呗两幅图像，一幅画是英文字母 D，另一幅是用 0 和 1 交替排列形成的图像（蒙版），\n并进行如下操作：  \n![][1]  \n如果所使用的蒙版是完全随机的比特序列，则使用 XOR 就可以将原来的图像掩盖起来。但如果蒙版中的比特序列是可以被推测出来的，那么实质上图像就\n没有被真正的掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特\n序列就称为**随机数**。将在第十二章详解。\n\n# 4 一次性密码本——绝对不会被破译的密码\n\n## 4.1 什么是一次性密码本\n\n只要通过暴力破解对密钥空间进行遍历，无论任何密文总有一天都能够被破译。然后，本节中将要介绍的一次性密码本（one-time pad）却是一个例外。\n即便用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。\n\n## 4.2 一次性密码本的加密\n\n它的原理是“将明文与一串随机的比特序列进行 XOR 运算”。如果将硬币的正面设为 0 ，反面设为 1 ，则通过不断掷硬币就能够产生这样一串随机的比特序列。  \n下面我们将明文 midnight 这个字符串通过 ASCII 进行编码并产生一串比特序列。  \n![][2]  \n  \n接着，我们掷 64 次硬币产生 64 比特的随机比特序列：  \n![][3]  \n  \n下面我们将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结构也就是一次性密码本的密文。  \n![][4]  \n  \n这样产生的比特序列如果硬要显示在计算上，那么显示结果看上去就像是乱码一样（其实是加密），因此密文通常不会被还原为字符，而是被作为二进制数据来处理。\n\n## 4.3 一次性密码本的解密\n\n用密文和密钥进行 XOR 运算，就可以得到明文：  \n![][5]  \n这样显示在计算上就会是正常的文本： midnight。\n\n## 4.4 一次性密码本是无法破译的\n\n为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是，\n即便我们能够解密出 midnight 这个字符串，我们也**无法判断它是否是正确的明文**。  \n  \n因为在解密过程中，所有的 64 比特的排列组合都会出现，包括像 aaaaaaaa、bbbbbbbb、ZZZZZZZZ 这样的规则字符串，也会包含 midnight、onenight、\nmistress 等英文单词，还会包含乱码看不懂的组合。由于明文中又有的可能排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个\n密钥才能够正确解密）。  \n  \n所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文，\n因此一次性密码本是无法破译的。  \n  \n一次性密码本无法破译的这一特性是由香农于 1949 年通过数学方法加以证明的。**一次性密码本是无条件安全（unconditionally secure）的，\n在理论上是无法破译的（theoretically unbreakable）**。\n\n## 4.5 一次性密码本为什么没有被使用\n\n### 1. 秘钥的配送\n最大的问题在于秘钥的配送。  \n接受者 Bob 收到了 Alice 发来的密文。 Bob 要想进行解密，就必须使用和 Alice 进行加密时相同的秘钥，因此 Alice 必须将秘钥也发送给 Bob ，\n且该秘钥的长度和密文是相等的。但这样就产生了一个矛盾——如果能够有一种方法将秘钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？\n\n### 2. 秘钥的保存\n既然能保存和明文一样长度的秘钥，那么不也就有办法安全保存明文本身了吗？也就是说，从一开始我们根本就不需要密码。也就是说，我们只是将“保护明文”\n这一命题替换成了“保护和明文一样的秘钥”而已，问题并没有得到实质性的解决。\n\n### 3. 秘钥的重用\n此外，在一次性密码本中是绝对不能重用过去用过的随机比特序列的，一次性密码本中的“一次性”也正是由此而来。这是因为作为秘钥的比特序列一旦泄露，\n过去所有的机密通信内容将全部被解密（假设窃听者 Eve 保存了过去所有的通信内容）。\n\n### 4. 秘钥的同步\n如果明文是一个大小为 100MB 的文件，则秘钥的大小也一定是 100MB 。而且在通信过程中，发送者和接受者的秘钥的比特序列不允许有任何错位，否则错位\n后的比特的所有信息都将无法解密。\n\n### 5. 秘钥的生成\n在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。因此，能够使用一次性密码本的，只有那些机密性重过一切，且可以\n话费大量财力和人力来生成并配送秘钥的场合。  \n  \n综上所述，一次性密码本是一种几乎没有实用性的密码。但是，一次性密码本的思路却孕育出了流密码（stream cipher）。流密码使用的不是真正的随机比特序列，\n而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。\n\n# 5 DES\n\n## 5.1 什么是 DES\n\nDES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。由于其在 1999 年只用了 22 小时就可破译，\n因此除了用它来解密以前的密文以外，现在我们不应该再使用 DES 了。\n\n## 5.2 加密和解密\n\nDES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于\n每隔 7 比特 会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。  \n  \nDES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的算法密码称为分组密码\n（block cipher），DES 就是分组密码的一种。  \n  \nDES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为模式（mode），关于模式会在第四章详解。  \n![][6]\n\n## 5.3 DES 的结构（Feistel网络）\n\n在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。如下是 Feistel 网络中一轮的计算流程。而 DES 是\n一种 16 轮循环的 Feistel 网络。  \n![][7]  \n\n### 1. Feistel 网络的加密\n输入的数据被分为左右两半分别进行处理，中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。\n由于子密钥只在一轮中使用，它只是一个局部密钥，因此才成为**子密钥**。  \n**轮函数**的作用是根据“右侧”和子密钥一起生成中间密钥，这个中间密钥对“左侧”进行加密，轮函数是该密码系统的核心。一轮的步骤总结如下：  \n1. 将输入的数据等分位左右两部分\n2. 将输入的右侧直接发送到输入的右侧\n3. 将输入的右侧发送到轮函数\n4. 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列\n5. 将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧  \n  \n这样一来，“右侧”根本就没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调\n\n### 2. Feistel 网路的解密\n我们尝试一次下将一轮加密的输出结果用相同的子密钥重新运行一次，结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文\n正确地还原为明文。关于这一点，可以从 XOR 的性质（两个相同的数进行 XOR 的结果一定为 0 ）进行思考。  \n  \n有多个轮的情况下也是一样的。也就是说， Feistel 网络的解密操作只要按照相反的熟悉怒来使用子密钥就可以完成了。下图是三轮加密图：  \n![][8]  \n下图是解密示意图：  \n![][9]\n\n### 3. Feistel 网络的性质\nFeistel 网络的轮数可以任意增加。无论运行多少轮的加密计算，都不会发生无法解密的情况。以及加密时无论使用任何函数作为轮函数都可以正确解密。\n最后是加密和解密可以用完全相同的结构来实现。在 Feistel 网络的一轮中，右半部分实际上没有任何处理，这在加密算法中看起来是一种浪费，\n但却保证了可解密性。 \n\n# 6 三重 DES\n\n现在 DES 已经可以在限时的时间内被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。\n\n## 6.1 什么是三重 DES \n\n三重 DES（triple-DES）是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。\n\n## 6.2 三重 DES 的加密\n![][10]  \n经过三次 DES 处理CIA能变成最后的密文，由于 DES 秘钥的长度实质上是 56 比特，因此三重 DES 的秘钥长度就是 56 * 3 = 168 比特。  \n从上图中，我们发现，三重 DES 并不是进行三次 DES 加密，而是加密-解密-加密的过程，实际上这是 IBM 公司设计出来的，目的是为了让三重 DES \n能够兼容普通的 DES。当三重 DES 所有秘钥都相同的时候就相当于普通的 DES 了。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES\n来进行解密。也就是说三重 DES 对 DES 具备向下兼容性。  \n![][11]\n\n## 6.3 三重 DES 的解密\n\n解密过程与加密过程顺序相反。\n\n## 6.4 三重 DES 的现状\n\n其处理速度不高，而且在安全性方面也逐渐显现了一些问题，但还被银行等机构使用。\n\n# 7 AES 的选定过程\n\n## 7.1 什么是 AES\n\nAES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码。全世界的企业和密码学家提交了多个对称密码算法\n作为 AES 的候选，最终在 2000 年选出了一种名为 Rijndael 的对称密码算法，并将其确定为了 AES。\n\n## 7.2 AES 的选定过程\n\n组织 AES 公开竞选活动的，是美国的一个标准化机构——NIST，参加 AES 竞选的条件是：被选为 AES 的密码算法必须无条件地免费供全世界使用。  \n此外，参与者还必须提交密码算法的详细规格书、以 ANSIC 和 Java 编写的实现代码以及抗密码破译强度的评估等材料。因此，在提交了详细设计和程序代码\n完全公开的情况下，就杜绝了隐蔽式安全性（security by obscurity）。  \n  \n评审者也是参与者，通过发现别人的弱点，实现竞争，最终实现标准化，正是密码算法选定的正确方式。只有由世界最高水平的密码学家共同尝试破译，依然未能\n找到弱点，这样才能够证明一种密码算法的强度。\n\n## 7.3 AES 最终候选算法的确定与 AES 的最终确定\n![][12]\n\n# 8 Rijndael\n\n## 8.1 什么是 Rijndael\n\n由比利时密码学家 Joan Daemon 和 Vincent Rijmen 设计的分组密码算法。\n\n## 8.2 Rijndael 的加密和解密\n\n和 DES 一样， Rijndael 算法也是由多个轮所构成，但是 Rijndael 使用了 SPN 结构，Rijndael 的输入分组为 128 比特，也就是 16字节。\n首先，需要逐个字节地对 16 字节地输入数据进行 SubBytes 处理，即将一个 1 字节地值替换成另一个 1 字节地值，可以想象成简单替换密码。  \nSubBytes 之后进行 ShiftRows处理，即将 SubBytes 的输出以字节单位进行打乱处理，这种打乱是有规律的。然后进行 MixColumns 处理，即对\n一个 4 字节地值进行比特运算，将其变成另一个 4 字节值，最后与轮秘钥进行 XOR ，进行 AddRoundkey处理。这就是一轮。  \n实际上，在 Rijndael 需要重复进行 10 ~ 14 次计算。  \n![][14]  \n它在一轮使用了 SubBytes、ShiftRows、MixColumns 分别存在反向运算 InvSubBytes、InvShiftRows、InvMixColumns，分别按字节、行、列进行并行计算。\n\n## 8.3 Rijndael 的破译\n\n对 Rijndael 来说，可能会出现以前并不存在的新的攻击方法。它的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公司来表达。  \n  \n这只是一种假设而已，到现在为止，还没有出现针对 Rijndael 的有效攻击。\n\n## 8.4 应该使用哪种对称密码呢\n\n介绍了 DES、三重 DES、和 AES 等对称密码。那么我们到底用哪种呢？  \n一般来说不应该使用任何**任何自制的密码算法**，而是应该使用 AES。\n\n# 9 本章小结\n\n本章介绍了对称密码，以及 DES、三重 DES、AES密码算法。  \n  \n使用一种秘钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的秘钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他\n类型的攻击。  \n  \n然后用对称密码进行通信时，还会出现秘钥的配送问题。为了解决秘钥配送问题，我们需要公钥密码技术，将在第五章详解。  \n本章所介绍的几乎所有的密码算法，都只能讲一个固定长度的分组进行加密。当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。下一章将\n探讨对分组密码进行迭代的方法。\n\n# 10 小测验\n\n1. 一次性密码本的秘钥可以进行压缩变短。\n2. 对称密码中，加密的秘钥和解密的秘钥是相等的。\n3. 如果秘钥长度为 56 比特，那么用暴力破解找到正确秘钥需要平均尝试约 2^28 次。\n4. 三重 DES 的秘钥空间是 DES 秘钥空间的三倍大。\n5. 现在 DES 可以在限时的时间内被破译。\n6. AES 标准选定的密码算法叫 Rijndael。  \n  \n>注：秘钥长度为 56 比特，则秘钥空间（秘钥总数）是 2^56，平均时间除以 2 ，为 2^55。  \n压缩算法在于：重复。  \n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_8.png\n[9]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_9.png\n[10]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_10.png\n[11]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_11.png\n[12]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_12.png\n[13]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_13.png","source":"_posts/图解密码技术/第三章 对称密码.md","raw":"---\ntitle: 三、对称密码\ndate: 2017-11-12 16:14:00\nupdated: 2017-11-15 03:06:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/3.html    \n---\n\n# 1 炒鸡蛋与对称密码\n\n鸡蛋炒好之后就完全分不清原来的蛋黄和蛋白了，使用对称密码进行加密，和炒鸡蛋有着异曲同工之妙。炒鸡蛋搅拌的是鸡蛋，而密文打乱的则是比特序列。\n然后，它们最大的不同是，炒鸡蛋无法还原成原来的鸡蛋，但密文却必须能够让接收者正确解密才行。\n因此，如果只是随意地搅拌和混合，则不能称之为加密，而必须仔细设计出一种能够还原的混合方式。\n\n# 2 本章概要\n\n学习比特序列运算和 XOR 运算。以及介绍一种称为一次性密码本的密码系统。  \n具体介绍几种对称密码算法，包括 DES、三重DES、AES以及其它一些密码算法。  \n需要注意的是，密码算法有时候会设计开发者的专利和授权等问题，记得先调查一下该算法的专利和授权信息。\n\n# 3 从文字密码到比特序列密码\n\n## 3.1 编码\n\n计算机操作对象并不是文字，而是由 0 和 1 排列而成的**比特序列**。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。\n\n## 3.2 XOR\n\nXOR 的全称是 exclusive or ，中文叫作**异或**。\n\n### 1. 一个比特的 XOR\n0 XOR 0 = 0  \n0 XOR 1 = 1  \n1 XOR 0 = 1  \n1 XOR 1 = 0  \n可以理解为硬币翻转：  \n不翻转 + 不翻转 = 不翻转\n不翻转 + 翻转   = 翻转\n翻转   + 不翻转 = 翻转\n翻转   + 翻转   = 不翻转\n\n### 2. 比特序列的 XOR\nA  XOR B = AB  \nAB XOR B = A  \n这是因为两个相同的数进行 XOR 运算的结果一定为 0 ，因此 A XOR B XOR B = A。这不就和加密、界面的步骤非常相似么，如下：  \n* 将明文 A 用密钥 B 进行加密，得到密文 AB。  \n* 将密文 AB 用密钥 B 进行解密，得到明文 A。  \n  \n实际上，只要选择一个合适的 B，仅仅使用 XOR 就可以实现一个高强度的密码。  \n对同一个比特序列进行两次 XOR 之后就会回到最初的状态。我们不妨来看看一副由很多点组成的图像。如果将白色的点作为 0 ，黑色的点作为 1 ，\n那么一副黑白图像就可以表示为 0 和 1 的比特序列。我们转呗两幅图像，一幅画是英文字母 D，另一幅是用 0 和 1 交替排列形成的图像（蒙版），\n并进行如下操作：  \n![][1]  \n如果所使用的蒙版是完全随机的比特序列，则使用 XOR 就可以将原来的图像掩盖起来。但如果蒙版中的比特序列是可以被推测出来的，那么实质上图像就\n没有被真正的掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特\n序列就称为**随机数**。将在第十二章详解。\n\n# 4 一次性密码本——绝对不会被破译的密码\n\n## 4.1 什么是一次性密码本\n\n只要通过暴力破解对密钥空间进行遍历，无论任何密文总有一天都能够被破译。然后，本节中将要介绍的一次性密码本（one-time pad）却是一个例外。\n即便用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。\n\n## 4.2 一次性密码本的加密\n\n它的原理是“将明文与一串随机的比特序列进行 XOR 运算”。如果将硬币的正面设为 0 ，反面设为 1 ，则通过不断掷硬币就能够产生这样一串随机的比特序列。  \n下面我们将明文 midnight 这个字符串通过 ASCII 进行编码并产生一串比特序列。  \n![][2]  \n  \n接着，我们掷 64 次硬币产生 64 比特的随机比特序列：  \n![][3]  \n  \n下面我们将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结构也就是一次性密码本的密文。  \n![][4]  \n  \n这样产生的比特序列如果硬要显示在计算上，那么显示结果看上去就像是乱码一样（其实是加密），因此密文通常不会被还原为字符，而是被作为二进制数据来处理。\n\n## 4.3 一次性密码本的解密\n\n用密文和密钥进行 XOR 运算，就可以得到明文：  \n![][5]  \n这样显示在计算上就会是正常的文本： midnight。\n\n## 4.4 一次性密码本是无法破译的\n\n为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是，\n即便我们能够解密出 midnight 这个字符串，我们也**无法判断它是否是正确的明文**。  \n  \n因为在解密过程中，所有的 64 比特的排列组合都会出现，包括像 aaaaaaaa、bbbbbbbb、ZZZZZZZZ 这样的规则字符串，也会包含 midnight、onenight、\nmistress 等英文单词，还会包含乱码看不懂的组合。由于明文中又有的可能排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个\n密钥才能够正确解密）。  \n  \n所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文，\n因此一次性密码本是无法破译的。  \n  \n一次性密码本无法破译的这一特性是由香农于 1949 年通过数学方法加以证明的。**一次性密码本是无条件安全（unconditionally secure）的，\n在理论上是无法破译的（theoretically unbreakable）**。\n\n## 4.5 一次性密码本为什么没有被使用\n\n### 1. 秘钥的配送\n最大的问题在于秘钥的配送。  \n接受者 Bob 收到了 Alice 发来的密文。 Bob 要想进行解密，就必须使用和 Alice 进行加密时相同的秘钥，因此 Alice 必须将秘钥也发送给 Bob ，\n且该秘钥的长度和密文是相等的。但这样就产生了一个矛盾——如果能够有一种方法将秘钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？\n\n### 2. 秘钥的保存\n既然能保存和明文一样长度的秘钥，那么不也就有办法安全保存明文本身了吗？也就是说，从一开始我们根本就不需要密码。也就是说，我们只是将“保护明文”\n这一命题替换成了“保护和明文一样的秘钥”而已，问题并没有得到实质性的解决。\n\n### 3. 秘钥的重用\n此外，在一次性密码本中是绝对不能重用过去用过的随机比特序列的，一次性密码本中的“一次性”也正是由此而来。这是因为作为秘钥的比特序列一旦泄露，\n过去所有的机密通信内容将全部被解密（假设窃听者 Eve 保存了过去所有的通信内容）。\n\n### 4. 秘钥的同步\n如果明文是一个大小为 100MB 的文件，则秘钥的大小也一定是 100MB 。而且在通信过程中，发送者和接受者的秘钥的比特序列不允许有任何错位，否则错位\n后的比特的所有信息都将无法解密。\n\n### 5. 秘钥的生成\n在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。因此，能够使用一次性密码本的，只有那些机密性重过一切，且可以\n话费大量财力和人力来生成并配送秘钥的场合。  \n  \n综上所述，一次性密码本是一种几乎没有实用性的密码。但是，一次性密码本的思路却孕育出了流密码（stream cipher）。流密码使用的不是真正的随机比特序列，\n而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。\n\n# 5 DES\n\n## 5.1 什么是 DES\n\nDES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。由于其在 1999 年只用了 22 小时就可破译，\n因此除了用它来解密以前的密文以外，现在我们不应该再使用 DES 了。\n\n## 5.2 加密和解密\n\nDES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于\n每隔 7 比特 会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。  \n  \nDES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的算法密码称为分组密码\n（block cipher），DES 就是分组密码的一种。  \n  \nDES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为模式（mode），关于模式会在第四章详解。  \n![][6]\n\n## 5.3 DES 的结构（Feistel网络）\n\n在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。如下是 Feistel 网络中一轮的计算流程。而 DES 是\n一种 16 轮循环的 Feistel 网络。  \n![][7]  \n\n### 1. Feistel 网络的加密\n输入的数据被分为左右两半分别进行处理，中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。\n由于子密钥只在一轮中使用，它只是一个局部密钥，因此才成为**子密钥**。  \n**轮函数**的作用是根据“右侧”和子密钥一起生成中间密钥，这个中间密钥对“左侧”进行加密，轮函数是该密码系统的核心。一轮的步骤总结如下：  \n1. 将输入的数据等分位左右两部分\n2. 将输入的右侧直接发送到输入的右侧\n3. 将输入的右侧发送到轮函数\n4. 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列\n5. 将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧  \n  \n这样一来，“右侧”根本就没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调\n\n### 2. Feistel 网路的解密\n我们尝试一次下将一轮加密的输出结果用相同的子密钥重新运行一次，结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文\n正确地还原为明文。关于这一点，可以从 XOR 的性质（两个相同的数进行 XOR 的结果一定为 0 ）进行思考。  \n  \n有多个轮的情况下也是一样的。也就是说， Feistel 网络的解密操作只要按照相反的熟悉怒来使用子密钥就可以完成了。下图是三轮加密图：  \n![][8]  \n下图是解密示意图：  \n![][9]\n\n### 3. Feistel 网络的性质\nFeistel 网络的轮数可以任意增加。无论运行多少轮的加密计算，都不会发生无法解密的情况。以及加密时无论使用任何函数作为轮函数都可以正确解密。\n最后是加密和解密可以用完全相同的结构来实现。在 Feistel 网络的一轮中，右半部分实际上没有任何处理，这在加密算法中看起来是一种浪费，\n但却保证了可解密性。 \n\n# 6 三重 DES\n\n现在 DES 已经可以在限时的时间内被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。\n\n## 6.1 什么是三重 DES \n\n三重 DES（triple-DES）是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。\n\n## 6.2 三重 DES 的加密\n![][10]  \n经过三次 DES 处理CIA能变成最后的密文，由于 DES 秘钥的长度实质上是 56 比特，因此三重 DES 的秘钥长度就是 56 * 3 = 168 比特。  \n从上图中，我们发现，三重 DES 并不是进行三次 DES 加密，而是加密-解密-加密的过程，实际上这是 IBM 公司设计出来的，目的是为了让三重 DES \n能够兼容普通的 DES。当三重 DES 所有秘钥都相同的时候就相当于普通的 DES 了。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES\n来进行解密。也就是说三重 DES 对 DES 具备向下兼容性。  \n![][11]\n\n## 6.3 三重 DES 的解密\n\n解密过程与加密过程顺序相反。\n\n## 6.4 三重 DES 的现状\n\n其处理速度不高，而且在安全性方面也逐渐显现了一些问题，但还被银行等机构使用。\n\n# 7 AES 的选定过程\n\n## 7.1 什么是 AES\n\nAES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码。全世界的企业和密码学家提交了多个对称密码算法\n作为 AES 的候选，最终在 2000 年选出了一种名为 Rijndael 的对称密码算法，并将其确定为了 AES。\n\n## 7.2 AES 的选定过程\n\n组织 AES 公开竞选活动的，是美国的一个标准化机构——NIST，参加 AES 竞选的条件是：被选为 AES 的密码算法必须无条件地免费供全世界使用。  \n此外，参与者还必须提交密码算法的详细规格书、以 ANSIC 和 Java 编写的实现代码以及抗密码破译强度的评估等材料。因此，在提交了详细设计和程序代码\n完全公开的情况下，就杜绝了隐蔽式安全性（security by obscurity）。  \n  \n评审者也是参与者，通过发现别人的弱点，实现竞争，最终实现标准化，正是密码算法选定的正确方式。只有由世界最高水平的密码学家共同尝试破译，依然未能\n找到弱点，这样才能够证明一种密码算法的强度。\n\n## 7.3 AES 最终候选算法的确定与 AES 的最终确定\n![][12]\n\n# 8 Rijndael\n\n## 8.1 什么是 Rijndael\n\n由比利时密码学家 Joan Daemon 和 Vincent Rijmen 设计的分组密码算法。\n\n## 8.2 Rijndael 的加密和解密\n\n和 DES 一样， Rijndael 算法也是由多个轮所构成，但是 Rijndael 使用了 SPN 结构，Rijndael 的输入分组为 128 比特，也就是 16字节。\n首先，需要逐个字节地对 16 字节地输入数据进行 SubBytes 处理，即将一个 1 字节地值替换成另一个 1 字节地值，可以想象成简单替换密码。  \nSubBytes 之后进行 ShiftRows处理，即将 SubBytes 的输出以字节单位进行打乱处理，这种打乱是有规律的。然后进行 MixColumns 处理，即对\n一个 4 字节地值进行比特运算，将其变成另一个 4 字节值，最后与轮秘钥进行 XOR ，进行 AddRoundkey处理。这就是一轮。  \n实际上，在 Rijndael 需要重复进行 10 ~ 14 次计算。  \n![][14]  \n它在一轮使用了 SubBytes、ShiftRows、MixColumns 分别存在反向运算 InvSubBytes、InvShiftRows、InvMixColumns，分别按字节、行、列进行并行计算。\n\n## 8.3 Rijndael 的破译\n\n对 Rijndael 来说，可能会出现以前并不存在的新的攻击方法。它的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公司来表达。  \n  \n这只是一种假设而已，到现在为止，还没有出现针对 Rijndael 的有效攻击。\n\n## 8.4 应该使用哪种对称密码呢\n\n介绍了 DES、三重 DES、和 AES 等对称密码。那么我们到底用哪种呢？  \n一般来说不应该使用任何**任何自制的密码算法**，而是应该使用 AES。\n\n# 9 本章小结\n\n本章介绍了对称密码，以及 DES、三重 DES、AES密码算法。  \n  \n使用一种秘钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的秘钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他\n类型的攻击。  \n  \n然后用对称密码进行通信时，还会出现秘钥的配送问题。为了解决秘钥配送问题，我们需要公钥密码技术，将在第五章详解。  \n本章所介绍的几乎所有的密码算法，都只能讲一个固定长度的分组进行加密。当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。下一章将\n探讨对分组密码进行迭代的方法。\n\n# 10 小测验\n\n1. 一次性密码本的秘钥可以进行压缩变短。\n2. 对称密码中，加密的秘钥和解密的秘钥是相等的。\n3. 如果秘钥长度为 56 比特，那么用暴力破解找到正确秘钥需要平均尝试约 2^28 次。\n4. 三重 DES 的秘钥空间是 DES 秘钥空间的三倍大。\n5. 现在 DES 可以在限时的时间内被破译。\n6. AES 标准选定的密码算法叫 Rijndael。  \n  \n>注：秘钥长度为 56 比特，则秘钥空间（秘钥总数）是 2^56，平均时间除以 2 ，为 2^55。  \n压缩算法在于：重复。  \n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_8.png\n[9]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_9.png\n[10]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_10.png\n[11]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_11.png\n[12]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_12.png\n[13]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_13.png","slug":"graphic2cryptography/3.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavs002faxs6w8nbot14","content":"<h1 id=\"1-炒鸡蛋与对称密码\"><a href=\"#1-炒鸡蛋与对称密码\" class=\"headerlink\" title=\"1 炒鸡蛋与对称密码\"></a>1 炒鸡蛋与对称密码</h1><p>鸡蛋炒好之后就完全分不清原来的蛋黄和蛋白了，使用对称密码进行加密，和炒鸡蛋有着异曲同工之妙。炒鸡蛋搅拌的是鸡蛋，而密文打乱的则是比特序列。<br>然后，它们最大的不同是，炒鸡蛋无法还原成原来的鸡蛋，但密文却必须能够让接收者正确解密才行。<br>因此，如果只是随意地搅拌和混合，则不能称之为加密，而必须仔细设计出一种能够还原的混合方式。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>学习比特序列运算和 XOR 运算。以及介绍一种称为一次性密码本的密码系统。<br>具体介绍几种对称密码算法，包括 DES、三重DES、AES以及其它一些密码算法。<br>需要注意的是，密码算法有时候会设计开发者的专利和授权等问题，记得先调查一下该算法的专利和授权信息。</p>\n<h1 id=\"3-从文字密码到比特序列密码\"><a href=\"#3-从文字密码到比特序列密码\" class=\"headerlink\" title=\"3 从文字密码到比特序列密码\"></a>3 从文字密码到比特序列密码</h1><h2 id=\"3-1-编码\"><a href=\"#3-1-编码\" class=\"headerlink\" title=\"3.1 编码\"></a>3.1 编码</h2><p>计算机操作对象并不是文字，而是由 0 和 1 排列而成的<strong>比特序列</strong>。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p>\n<h2 id=\"3-2-XOR\"><a href=\"#3-2-XOR\" class=\"headerlink\" title=\"3.2 XOR\"></a>3.2 XOR</h2><p>XOR 的全称是 exclusive or ，中文叫作<strong>异或</strong>。</p>\n<h3 id=\"1-一个比特的-XOR\"><a href=\"#1-一个比特的-XOR\" class=\"headerlink\" title=\"1. 一个比特的 XOR\"></a>1. 一个比特的 XOR</h3><p>0 XOR 0 = 0<br>0 XOR 1 = 1<br>1 XOR 0 = 1<br>1 XOR 1 = 0<br>可以理解为硬币翻转：<br>不翻转 + 不翻转 = 不翻转<br>不翻转 + 翻转   = 翻转<br>翻转   + 不翻转 = 翻转<br>翻转   + 翻转   = 不翻转</p>\n<h3 id=\"2-比特序列的-XOR\"><a href=\"#2-比特序列的-XOR\" class=\"headerlink\" title=\"2. 比特序列的 XOR\"></a>2. 比特序列的 XOR</h3><p>A  XOR B = AB<br>AB XOR B = A<br>这是因为两个相同的数进行 XOR 运算的结果一定为 0 ，因此 A XOR B XOR B = A。这不就和加密、界面的步骤非常相似么，如下：  </p>\n<ul>\n<li>将明文 A 用密钥 B 进行加密，得到密文 AB。  </li>\n<li>将密文 AB 用密钥 B 进行解密，得到明文 A。  </li>\n</ul>\n<p>实际上，只要选择一个合适的 B，仅仅使用 XOR 就可以实现一个高强度的密码。<br>对同一个比特序列进行两次 XOR 之后就会回到最初的状态。我们不妨来看看一副由很多点组成的图像。如果将白色的点作为 0 ，黑色的点作为 1 ，<br>那么一副黑白图像就可以表示为 0 和 1 的比特序列。我们转呗两幅图像，一幅画是英文字母 D，另一幅是用 0 和 1 交替排列形成的图像（蒙版），<br>并进行如下操作：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_1.png\" alt=\"\"><br>如果所使用的蒙版是完全随机的比特序列，则使用 XOR 就可以将原来的图像掩盖起来。但如果蒙版中的比特序列是可以被推测出来的，那么实质上图像就<br>没有被真正的掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特<br>序列就称为<strong>随机数</strong>。将在第十二章详解。</p>\n<h1 id=\"4-一次性密码本——绝对不会被破译的密码\"><a href=\"#4-一次性密码本——绝对不会被破译的密码\" class=\"headerlink\" title=\"4 一次性密码本——绝对不会被破译的密码\"></a>4 一次性密码本——绝对不会被破译的密码</h1><h2 id=\"4-1-什么是一次性密码本\"><a href=\"#4-1-什么是一次性密码本\" class=\"headerlink\" title=\"4.1 什么是一次性密码本\"></a>4.1 什么是一次性密码本</h2><p>只要通过暴力破解对密钥空间进行遍历，无论任何密文总有一天都能够被破译。然后，本节中将要介绍的一次性密码本（one-time pad）却是一个例外。<br>即便用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。</p>\n<h2 id=\"4-2-一次性密码本的加密\"><a href=\"#4-2-一次性密码本的加密\" class=\"headerlink\" title=\"4.2 一次性密码本的加密\"></a>4.2 一次性密码本的加密</h2><p>它的原理是“将明文与一串随机的比特序列进行 XOR 运算”。如果将硬币的正面设为 0 ，反面设为 1 ，则通过不断掷硬币就能够产生这样一串随机的比特序列。<br>下面我们将明文 midnight 这个字符串通过 ASCII 进行编码并产生一串比特序列。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_2.png\" alt=\"\">  </p>\n<p>接着，我们掷 64 次硬币产生 64 比特的随机比特序列：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_3.png\" alt=\"\">  </p>\n<p>下面我们将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结构也就是一次性密码本的密文。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_4.png\" alt=\"\">  </p>\n<p>这样产生的比特序列如果硬要显示在计算上，那么显示结果看上去就像是乱码一样（其实是加密），因此密文通常不会被还原为字符，而是被作为二进制数据来处理。</p>\n<h2 id=\"4-3-一次性密码本的解密\"><a href=\"#4-3-一次性密码本的解密\" class=\"headerlink\" title=\"4.3 一次性密码本的解密\"></a>4.3 一次性密码本的解密</h2><p>用密文和密钥进行 XOR 运算，就可以得到明文：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_5.png\" alt=\"\"><br>这样显示在计算上就会是正常的文本： midnight。</p>\n<h2 id=\"4-4-一次性密码本是无法破译的\"><a href=\"#4-4-一次性密码本是无法破译的\" class=\"headerlink\" title=\"4.4 一次性密码本是无法破译的\"></a>4.4 一次性密码本是无法破译的</h2><p>为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是，<br>即便我们能够解密出 midnight 这个字符串，我们也<strong>无法判断它是否是正确的明文</strong>。  </p>\n<p>因为在解密过程中，所有的 64 比特的排列组合都会出现，包括像 aaaaaaaa、bbbbbbbb、ZZZZZZZZ 这样的规则字符串，也会包含 midnight、onenight、<br>mistress 等英文单词，还会包含乱码看不懂的组合。由于明文中又有的可能排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个<br>密钥才能够正确解密）。  </p>\n<p>所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文，<br>因此一次性密码本是无法破译的。  </p>\n<p>一次性密码本无法破译的这一特性是由香农于 1949 年通过数学方法加以证明的。<strong>一次性密码本是无条件安全（unconditionally secure）的，<br>在理论上是无法破译的（theoretically unbreakable）</strong>。</p>\n<h2 id=\"4-5-一次性密码本为什么没有被使用\"><a href=\"#4-5-一次性密码本为什么没有被使用\" class=\"headerlink\" title=\"4.5 一次性密码本为什么没有被使用\"></a>4.5 一次性密码本为什么没有被使用</h2><h3 id=\"1-秘钥的配送\"><a href=\"#1-秘钥的配送\" class=\"headerlink\" title=\"1. 秘钥的配送\"></a>1. 秘钥的配送</h3><p>最大的问题在于秘钥的配送。<br>接受者 Bob 收到了 Alice 发来的密文。 Bob 要想进行解密，就必须使用和 Alice 进行加密时相同的秘钥，因此 Alice 必须将秘钥也发送给 Bob ，<br>且该秘钥的长度和密文是相等的。但这样就产生了一个矛盾——如果能够有一种方法将秘钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？</p>\n<h3 id=\"2-秘钥的保存\"><a href=\"#2-秘钥的保存\" class=\"headerlink\" title=\"2. 秘钥的保存\"></a>2. 秘钥的保存</h3><p>既然能保存和明文一样长度的秘钥，那么不也就有办法安全保存明文本身了吗？也就是说，从一开始我们根本就不需要密码。也就是说，我们只是将“保护明文”<br>这一命题替换成了“保护和明文一样的秘钥”而已，问题并没有得到实质性的解决。</p>\n<h3 id=\"3-秘钥的重用\"><a href=\"#3-秘钥的重用\" class=\"headerlink\" title=\"3. 秘钥的重用\"></a>3. 秘钥的重用</h3><p>此外，在一次性密码本中是绝对不能重用过去用过的随机比特序列的，一次性密码本中的“一次性”也正是由此而来。这是因为作为秘钥的比特序列一旦泄露，<br>过去所有的机密通信内容将全部被解密（假设窃听者 Eve 保存了过去所有的通信内容）。</p>\n<h3 id=\"4-秘钥的同步\"><a href=\"#4-秘钥的同步\" class=\"headerlink\" title=\"4. 秘钥的同步\"></a>4. 秘钥的同步</h3><p>如果明文是一个大小为 100MB 的文件，则秘钥的大小也一定是 100MB 。而且在通信过程中，发送者和接受者的秘钥的比特序列不允许有任何错位，否则错位<br>后的比特的所有信息都将无法解密。</p>\n<h3 id=\"5-秘钥的生成\"><a href=\"#5-秘钥的生成\" class=\"headerlink\" title=\"5. 秘钥的生成\"></a>5. 秘钥的生成</h3><p>在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。因此，能够使用一次性密码本的，只有那些机密性重过一切，且可以<br>话费大量财力和人力来生成并配送秘钥的场合。  </p>\n<p>综上所述，一次性密码本是一种几乎没有实用性的密码。但是，一次性密码本的思路却孕育出了流密码（stream cipher）。流密码使用的不是真正的随机比特序列，<br>而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。</p>\n<h1 id=\"5-DES\"><a href=\"#5-DES\" class=\"headerlink\" title=\"5 DES\"></a>5 DES</h1><h2 id=\"5-1-什么是-DES\"><a href=\"#5-1-什么是-DES\" class=\"headerlink\" title=\"5.1 什么是 DES\"></a>5.1 什么是 DES</h2><p>DES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。由于其在 1999 年只用了 22 小时就可破译，<br>因此除了用它来解密以前的密文以外，现在我们不应该再使用 DES 了。</p>\n<h2 id=\"5-2-加密和解密\"><a href=\"#5-2-加密和解密\" class=\"headerlink\" title=\"5.2 加密和解密\"></a>5.2 加密和解密</h2><p>DES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于<br>每隔 7 比特 会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。  </p>\n<p>DES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的算法密码称为分组密码<br>（block cipher），DES 就是分组密码的一种。  </p>\n<p>DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为模式（mode），关于模式会在第四章详解。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_6.png\" alt=\"\"></p>\n<h2 id=\"5-3-DES-的结构（Feistel网络）\"><a href=\"#5-3-DES-的结构（Feistel网络）\" class=\"headerlink\" title=\"5.3 DES 的结构（Feistel网络）\"></a>5.3 DES 的结构（Feistel网络）</h2><p>在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。如下是 Feistel 网络中一轮的计算流程。而 DES 是<br>一种 16 轮循环的 Feistel 网络。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_7.png\" alt=\"\">  </p>\n<h3 id=\"1-Feistel-网络的加密\"><a href=\"#1-Feistel-网络的加密\" class=\"headerlink\" title=\"1. Feistel 网络的加密\"></a>1. Feistel 网络的加密</h3><p>输入的数据被分为左右两半分别进行处理，中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。<br>由于子密钥只在一轮中使用，它只是一个局部密钥，因此才成为<strong>子密钥</strong>。<br><strong>轮函数</strong>的作用是根据“右侧”和子密钥一起生成中间密钥，这个中间密钥对“左侧”进行加密，轮函数是该密码系统的核心。一轮的步骤总结如下：  </p>\n<ol>\n<li>将输入的数据等分位左右两部分</li>\n<li>将输入的右侧直接发送到输入的右侧</li>\n<li>将输入的右侧发送到轮函数</li>\n<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列</li>\n<li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧  </li>\n</ol>\n<p>这样一来，“右侧”根本就没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调</p>\n<h3 id=\"2-Feistel-网路的解密\"><a href=\"#2-Feistel-网路的解密\" class=\"headerlink\" title=\"2. Feistel 网路的解密\"></a>2. Feistel 网路的解密</h3><p>我们尝试一次下将一轮加密的输出结果用相同的子密钥重新运行一次，结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文<br>正确地还原为明文。关于这一点，可以从 XOR 的性质（两个相同的数进行 XOR 的结果一定为 0 ）进行思考。  </p>\n<p>有多个轮的情况下也是一样的。也就是说， Feistel 网络的解密操作只要按照相反的熟悉怒来使用子密钥就可以完成了。下图是三轮加密图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_8.png\" alt=\"\"><br>下图是解密示意图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_9.png\" alt=\"\"></p>\n<h3 id=\"3-Feistel-网络的性质\"><a href=\"#3-Feistel-网络的性质\" class=\"headerlink\" title=\"3. Feistel 网络的性质\"></a>3. Feistel 网络的性质</h3><p>Feistel 网络的轮数可以任意增加。无论运行多少轮的加密计算，都不会发生无法解密的情况。以及加密时无论使用任何函数作为轮函数都可以正确解密。<br>最后是加密和解密可以用完全相同的结构来实现。在 Feistel 网络的一轮中，右半部分实际上没有任何处理，这在加密算法中看起来是一种浪费，<br>但却保证了可解密性。 </p>\n<h1 id=\"6-三重-DES\"><a href=\"#6-三重-DES\" class=\"headerlink\" title=\"6 三重 DES\"></a>6 三重 DES</h1><p>现在 DES 已经可以在限时的时间内被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。</p>\n<h2 id=\"6-1-什么是三重-DES\"><a href=\"#6-1-什么是三重-DES\" class=\"headerlink\" title=\"6.1 什么是三重 DES\"></a>6.1 什么是三重 DES</h2><p>三重 DES（triple-DES）是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。</p>\n<h2 id=\"6-2-三重-DES-的加密\"><a href=\"#6-2-三重-DES-的加密\" class=\"headerlink\" title=\"6.2 三重 DES 的加密\"></a>6.2 三重 DES 的加密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_10.png\" alt=\"\"><br>经过三次 DES 处理CIA能变成最后的密文，由于 DES 秘钥的长度实质上是 56 比特，因此三重 DES 的秘钥长度就是 56 * 3 = 168 比特。<br>从上图中，我们发现，三重 DES 并不是进行三次 DES 加密，而是加密-解密-加密的过程，实际上这是 IBM 公司设计出来的，目的是为了让三重 DES<br>能够兼容普通的 DES。当三重 DES 所有秘钥都相同的时候就相当于普通的 DES 了。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES<br>来进行解密。也就是说三重 DES 对 DES 具备向下兼容性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_11.png\" alt=\"\"></p>\n<h2 id=\"6-3-三重-DES-的解密\"><a href=\"#6-3-三重-DES-的解密\" class=\"headerlink\" title=\"6.3 三重 DES 的解密\"></a>6.3 三重 DES 的解密</h2><p>解密过程与加密过程顺序相反。</p>\n<h2 id=\"6-4-三重-DES-的现状\"><a href=\"#6-4-三重-DES-的现状\" class=\"headerlink\" title=\"6.4 三重 DES 的现状\"></a>6.4 三重 DES 的现状</h2><p>其处理速度不高，而且在安全性方面也逐渐显现了一些问题，但还被银行等机构使用。</p>\n<h1 id=\"7-AES-的选定过程\"><a href=\"#7-AES-的选定过程\" class=\"headerlink\" title=\"7 AES 的选定过程\"></a>7 AES 的选定过程</h1><h2 id=\"7-1-什么是-AES\"><a href=\"#7-1-什么是-AES\" class=\"headerlink\" title=\"7.1 什么是 AES\"></a>7.1 什么是 AES</h2><p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码。全世界的企业和密码学家提交了多个对称密码算法<br>作为 AES 的候选，最终在 2000 年选出了一种名为 Rijndael 的对称密码算法，并将其确定为了 AES。</p>\n<h2 id=\"7-2-AES-的选定过程\"><a href=\"#7-2-AES-的选定过程\" class=\"headerlink\" title=\"7.2 AES 的选定过程\"></a>7.2 AES 的选定过程</h2><p>组织 AES 公开竞选活动的，是美国的一个标准化机构——NIST，参加 AES 竞选的条件是：被选为 AES 的密码算法必须无条件地免费供全世界使用。<br>此外，参与者还必须提交密码算法的详细规格书、以 ANSIC 和 Java 编写的实现代码以及抗密码破译强度的评估等材料。因此，在提交了详细设计和程序代码<br>完全公开的情况下，就杜绝了隐蔽式安全性（security by obscurity）。  </p>\n<p>评审者也是参与者，通过发现别人的弱点，实现竞争，最终实现标准化，正是密码算法选定的正确方式。只有由世界最高水平的密码学家共同尝试破译，依然未能<br>找到弱点，这样才能够证明一种密码算法的强度。</p>\n<h2 id=\"7-3-AES-最终候选算法的确定与-AES-的最终确定\"><a href=\"#7-3-AES-最终候选算法的确定与-AES-的最终确定\" class=\"headerlink\" title=\"7.3 AES 最终候选算法的确定与 AES 的最终确定\"></a>7.3 AES 最终候选算法的确定与 AES 的最终确定</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_12.png\" alt=\"\"></p>\n<h1 id=\"8-Rijndael\"><a href=\"#8-Rijndael\" class=\"headerlink\" title=\"8 Rijndael\"></a>8 Rijndael</h1><h2 id=\"8-1-什么是-Rijndael\"><a href=\"#8-1-什么是-Rijndael\" class=\"headerlink\" title=\"8.1 什么是 Rijndael\"></a>8.1 什么是 Rijndael</h2><p>由比利时密码学家 Joan Daemon 和 Vincent Rijmen 设计的分组密码算法。</p>\n<h2 id=\"8-2-Rijndael-的加密和解密\"><a href=\"#8-2-Rijndael-的加密和解密\" class=\"headerlink\" title=\"8.2 Rijndael 的加密和解密\"></a>8.2 Rijndael 的加密和解密</h2><p>和 DES 一样， Rijndael 算法也是由多个轮所构成，但是 Rijndael 使用了 SPN 结构，Rijndael 的输入分组为 128 比特，也就是 16字节。<br>首先，需要逐个字节地对 16 字节地输入数据进行 SubBytes 处理，即将一个 1 字节地值替换成另一个 1 字节地值，可以想象成简单替换密码。<br>SubBytes 之后进行 ShiftRows处理，即将 SubBytes 的输出以字节单位进行打乱处理，这种打乱是有规律的。然后进行 MixColumns 处理，即对<br>一个 4 字节地值进行比特运算，将其变成另一个 4 字节值，最后与轮秘钥进行 XOR ，进行 AddRoundkey处理。这就是一轮。<br>实际上，在 Rijndael 需要重复进行 10 ~ 14 次计算。<br>![][14]<br>它在一轮使用了 SubBytes、ShiftRows、MixColumns 分别存在反向运算 InvSubBytes、InvShiftRows、InvMixColumns，分别按字节、行、列进行并行计算。</p>\n<h2 id=\"8-3-Rijndael-的破译\"><a href=\"#8-3-Rijndael-的破译\" class=\"headerlink\" title=\"8.3 Rijndael 的破译\"></a>8.3 Rijndael 的破译</h2><p>对 Rijndael 来说，可能会出现以前并不存在的新的攻击方法。它的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公司来表达。  </p>\n<p>这只是一种假设而已，到现在为止，还没有出现针对 Rijndael 的有效攻击。</p>\n<h2 id=\"8-4-应该使用哪种对称密码呢\"><a href=\"#8-4-应该使用哪种对称密码呢\" class=\"headerlink\" title=\"8.4 应该使用哪种对称密码呢\"></a>8.4 应该使用哪种对称密码呢</h2><p>介绍了 DES、三重 DES、和 AES 等对称密码。那么我们到底用哪种呢？<br>一般来说不应该使用任何<strong>任何自制的密码算法</strong>，而是应该使用 AES。</p>\n<h1 id=\"9-本章小结\"><a href=\"#9-本章小结\" class=\"headerlink\" title=\"9 本章小结\"></a>9 本章小结</h1><p>本章介绍了对称密码，以及 DES、三重 DES、AES密码算法。  </p>\n<p>使用一种秘钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的秘钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他<br>类型的攻击。  </p>\n<p>然后用对称密码进行通信时，还会出现秘钥的配送问题。为了解决秘钥配送问题，我们需要公钥密码技术，将在第五章详解。<br>本章所介绍的几乎所有的密码算法，都只能讲一个固定长度的分组进行加密。当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。下一章将<br>探讨对分组密码进行迭代的方法。</p>\n<h1 id=\"10-小测验\"><a href=\"#10-小测验\" class=\"headerlink\" title=\"10 小测验\"></a>10 小测验</h1><ol>\n<li>一次性密码本的秘钥可以进行压缩变短。</li>\n<li>对称密码中，加密的秘钥和解密的秘钥是相等的。</li>\n<li>如果秘钥长度为 56 比特，那么用暴力破解找到正确秘钥需要平均尝试约 2^28 次。</li>\n<li>三重 DES 的秘钥空间是 DES 秘钥空间的三倍大。</li>\n<li>现在 DES 可以在限时的时间内被破译。</li>\n<li>AES 标准选定的密码算法叫 Rijndael。  </li>\n</ol>\n<blockquote>\n<p>注：秘钥长度为 56 比特，则秘钥空间（秘钥总数）是 2^56，平均时间除以 2 ，为 2^55。<br>压缩算法在于：重复。  </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-炒鸡蛋与对称密码\"><a href=\"#1-炒鸡蛋与对称密码\" class=\"headerlink\" title=\"1 炒鸡蛋与对称密码\"></a>1 炒鸡蛋与对称密码</h1><p>鸡蛋炒好之后就完全分不清原来的蛋黄和蛋白了，使用对称密码进行加密，和炒鸡蛋有着异曲同工之妙。炒鸡蛋搅拌的是鸡蛋，而密文打乱的则是比特序列。<br>然后，它们最大的不同是，炒鸡蛋无法还原成原来的鸡蛋，但密文却必须能够让接收者正确解密才行。<br>因此，如果只是随意地搅拌和混合，则不能称之为加密，而必须仔细设计出一种能够还原的混合方式。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>学习比特序列运算和 XOR 运算。以及介绍一种称为一次性密码本的密码系统。<br>具体介绍几种对称密码算法，包括 DES、三重DES、AES以及其它一些密码算法。<br>需要注意的是，密码算法有时候会设计开发者的专利和授权等问题，记得先调查一下该算法的专利和授权信息。</p>\n<h1 id=\"3-从文字密码到比特序列密码\"><a href=\"#3-从文字密码到比特序列密码\" class=\"headerlink\" title=\"3 从文字密码到比特序列密码\"></a>3 从文字密码到比特序列密码</h1><h2 id=\"3-1-编码\"><a href=\"#3-1-编码\" class=\"headerlink\" title=\"3.1 编码\"></a>3.1 编码</h2><p>计算机操作对象并不是文字，而是由 0 和 1 排列而成的<strong>比特序列</strong>。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p>\n<h2 id=\"3-2-XOR\"><a href=\"#3-2-XOR\" class=\"headerlink\" title=\"3.2 XOR\"></a>3.2 XOR</h2><p>XOR 的全称是 exclusive or ，中文叫作<strong>异或</strong>。</p>\n<h3 id=\"1-一个比特的-XOR\"><a href=\"#1-一个比特的-XOR\" class=\"headerlink\" title=\"1. 一个比特的 XOR\"></a>1. 一个比特的 XOR</h3><p>0 XOR 0 = 0<br>0 XOR 1 = 1<br>1 XOR 0 = 1<br>1 XOR 1 = 0<br>可以理解为硬币翻转：<br>不翻转 + 不翻转 = 不翻转<br>不翻转 + 翻转   = 翻转<br>翻转   + 不翻转 = 翻转<br>翻转   + 翻转   = 不翻转</p>\n<h3 id=\"2-比特序列的-XOR\"><a href=\"#2-比特序列的-XOR\" class=\"headerlink\" title=\"2. 比特序列的 XOR\"></a>2. 比特序列的 XOR</h3><p>A  XOR B = AB<br>AB XOR B = A<br>这是因为两个相同的数进行 XOR 运算的结果一定为 0 ，因此 A XOR B XOR B = A。这不就和加密、界面的步骤非常相似么，如下：  </p>\n<ul>\n<li>将明文 A 用密钥 B 进行加密，得到密文 AB。  </li>\n<li>将密文 AB 用密钥 B 进行解密，得到明文 A。  </li>\n</ul>\n<p>实际上，只要选择一个合适的 B，仅仅使用 XOR 就可以实现一个高强度的密码。<br>对同一个比特序列进行两次 XOR 之后就会回到最初的状态。我们不妨来看看一副由很多点组成的图像。如果将白色的点作为 0 ，黑色的点作为 1 ，<br>那么一副黑白图像就可以表示为 0 和 1 的比特序列。我们转呗两幅图像，一幅画是英文字母 D，另一幅是用 0 和 1 交替排列形成的图像（蒙版），<br>并进行如下操作：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_1.png\" alt=\"\"><br>如果所使用的蒙版是完全随机的比特序列，则使用 XOR 就可以将原来的图像掩盖起来。但如果蒙版中的比特序列是可以被推测出来的，那么实质上图像就<br>没有被真正的掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特<br>序列就称为<strong>随机数</strong>。将在第十二章详解。</p>\n<h1 id=\"4-一次性密码本——绝对不会被破译的密码\"><a href=\"#4-一次性密码本——绝对不会被破译的密码\" class=\"headerlink\" title=\"4 一次性密码本——绝对不会被破译的密码\"></a>4 一次性密码本——绝对不会被破译的密码</h1><h2 id=\"4-1-什么是一次性密码本\"><a href=\"#4-1-什么是一次性密码本\" class=\"headerlink\" title=\"4.1 什么是一次性密码本\"></a>4.1 什么是一次性密码本</h2><p>只要通过暴力破解对密钥空间进行遍历，无论任何密文总有一天都能够被破译。然后，本节中将要介绍的一次性密码本（one-time pad）却是一个例外。<br>即便用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。</p>\n<h2 id=\"4-2-一次性密码本的加密\"><a href=\"#4-2-一次性密码本的加密\" class=\"headerlink\" title=\"4.2 一次性密码本的加密\"></a>4.2 一次性密码本的加密</h2><p>它的原理是“将明文与一串随机的比特序列进行 XOR 运算”。如果将硬币的正面设为 0 ，反面设为 1 ，则通过不断掷硬币就能够产生这样一串随机的比特序列。<br>下面我们将明文 midnight 这个字符串通过 ASCII 进行编码并产生一串比特序列。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_2.png\" alt=\"\">  </p>\n<p>接着，我们掷 64 次硬币产生 64 比特的随机比特序列：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_3.png\" alt=\"\">  </p>\n<p>下面我们将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结构也就是一次性密码本的密文。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_4.png\" alt=\"\">  </p>\n<p>这样产生的比特序列如果硬要显示在计算上，那么显示结果看上去就像是乱码一样（其实是加密），因此密文通常不会被还原为字符，而是被作为二进制数据来处理。</p>\n<h2 id=\"4-3-一次性密码本的解密\"><a href=\"#4-3-一次性密码本的解密\" class=\"headerlink\" title=\"4.3 一次性密码本的解密\"></a>4.3 一次性密码本的解密</h2><p>用密文和密钥进行 XOR 运算，就可以得到明文：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_5.png\" alt=\"\"><br>这样显示在计算上就会是正常的文本： midnight。</p>\n<h2 id=\"4-4-一次性密码本是无法破译的\"><a href=\"#4-4-一次性密码本是无法破译的\" class=\"headerlink\" title=\"4.4 一次性密码本是无法破译的\"></a>4.4 一次性密码本是无法破译的</h2><p>为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是，<br>即便我们能够解密出 midnight 这个字符串，我们也<strong>无法判断它是否是正确的明文</strong>。  </p>\n<p>因为在解密过程中，所有的 64 比特的排列组合都会出现，包括像 aaaaaaaa、bbbbbbbb、ZZZZZZZZ 这样的规则字符串，也会包含 midnight、onenight、<br>mistress 等英文单词，还会包含乱码看不懂的组合。由于明文中又有的可能排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个<br>密钥才能够正确解密）。  </p>\n<p>所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文，<br>因此一次性密码本是无法破译的。  </p>\n<p>一次性密码本无法破译的这一特性是由香农于 1949 年通过数学方法加以证明的。<strong>一次性密码本是无条件安全（unconditionally secure）的，<br>在理论上是无法破译的（theoretically unbreakable）</strong>。</p>\n<h2 id=\"4-5-一次性密码本为什么没有被使用\"><a href=\"#4-5-一次性密码本为什么没有被使用\" class=\"headerlink\" title=\"4.5 一次性密码本为什么没有被使用\"></a>4.5 一次性密码本为什么没有被使用</h2><h3 id=\"1-秘钥的配送\"><a href=\"#1-秘钥的配送\" class=\"headerlink\" title=\"1. 秘钥的配送\"></a>1. 秘钥的配送</h3><p>最大的问题在于秘钥的配送。<br>接受者 Bob 收到了 Alice 发来的密文。 Bob 要想进行解密，就必须使用和 Alice 进行加密时相同的秘钥，因此 Alice 必须将秘钥也发送给 Bob ，<br>且该秘钥的长度和密文是相等的。但这样就产生了一个矛盾——如果能够有一种方法将秘钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？</p>\n<h3 id=\"2-秘钥的保存\"><a href=\"#2-秘钥的保存\" class=\"headerlink\" title=\"2. 秘钥的保存\"></a>2. 秘钥的保存</h3><p>既然能保存和明文一样长度的秘钥，那么不也就有办法安全保存明文本身了吗？也就是说，从一开始我们根本就不需要密码。也就是说，我们只是将“保护明文”<br>这一命题替换成了“保护和明文一样的秘钥”而已，问题并没有得到实质性的解决。</p>\n<h3 id=\"3-秘钥的重用\"><a href=\"#3-秘钥的重用\" class=\"headerlink\" title=\"3. 秘钥的重用\"></a>3. 秘钥的重用</h3><p>此外，在一次性密码本中是绝对不能重用过去用过的随机比特序列的，一次性密码本中的“一次性”也正是由此而来。这是因为作为秘钥的比特序列一旦泄露，<br>过去所有的机密通信内容将全部被解密（假设窃听者 Eve 保存了过去所有的通信内容）。</p>\n<h3 id=\"4-秘钥的同步\"><a href=\"#4-秘钥的同步\" class=\"headerlink\" title=\"4. 秘钥的同步\"></a>4. 秘钥的同步</h3><p>如果明文是一个大小为 100MB 的文件，则秘钥的大小也一定是 100MB 。而且在通信过程中，发送者和接受者的秘钥的比特序列不允许有任何错位，否则错位<br>后的比特的所有信息都将无法解密。</p>\n<h3 id=\"5-秘钥的生成\"><a href=\"#5-秘钥的生成\" class=\"headerlink\" title=\"5. 秘钥的生成\"></a>5. 秘钥的生成</h3><p>在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。因此，能够使用一次性密码本的，只有那些机密性重过一切，且可以<br>话费大量财力和人力来生成并配送秘钥的场合。  </p>\n<p>综上所述，一次性密码本是一种几乎没有实用性的密码。但是，一次性密码本的思路却孕育出了流密码（stream cipher）。流密码使用的不是真正的随机比特序列，<br>而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。</p>\n<h1 id=\"5-DES\"><a href=\"#5-DES\" class=\"headerlink\" title=\"5 DES\"></a>5 DES</h1><h2 id=\"5-1-什么是-DES\"><a href=\"#5-1-什么是-DES\" class=\"headerlink\" title=\"5.1 什么是 DES\"></a>5.1 什么是 DES</h2><p>DES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。由于其在 1999 年只用了 22 小时就可破译，<br>因此除了用它来解密以前的密文以外，现在我们不应该再使用 DES 了。</p>\n<h2 id=\"5-2-加密和解密\"><a href=\"#5-2-加密和解密\" class=\"headerlink\" title=\"5.2 加密和解密\"></a>5.2 加密和解密</h2><p>DES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于<br>每隔 7 比特 会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。  </p>\n<p>DES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的算法密码称为分组密码<br>（block cipher），DES 就是分组密码的一种。  </p>\n<p>DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为模式（mode），关于模式会在第四章详解。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_6.png\" alt=\"\"></p>\n<h2 id=\"5-3-DES-的结构（Feistel网络）\"><a href=\"#5-3-DES-的结构（Feistel网络）\" class=\"headerlink\" title=\"5.3 DES 的结构（Feistel网络）\"></a>5.3 DES 的结构（Feistel网络）</h2><p>在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。如下是 Feistel 网络中一轮的计算流程。而 DES 是<br>一种 16 轮循环的 Feistel 网络。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_7.png\" alt=\"\">  </p>\n<h3 id=\"1-Feistel-网络的加密\"><a href=\"#1-Feistel-网络的加密\" class=\"headerlink\" title=\"1. Feistel 网络的加密\"></a>1. Feistel 网络的加密</h3><p>输入的数据被分为左右两半分别进行处理，中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。<br>由于子密钥只在一轮中使用，它只是一个局部密钥，因此才成为<strong>子密钥</strong>。<br><strong>轮函数</strong>的作用是根据“右侧”和子密钥一起生成中间密钥，这个中间密钥对“左侧”进行加密，轮函数是该密码系统的核心。一轮的步骤总结如下：  </p>\n<ol>\n<li>将输入的数据等分位左右两部分</li>\n<li>将输入的右侧直接发送到输入的右侧</li>\n<li>将输入的右侧发送到轮函数</li>\n<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列</li>\n<li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧  </li>\n</ol>\n<p>这样一来，“右侧”根本就没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调</p>\n<h3 id=\"2-Feistel-网路的解密\"><a href=\"#2-Feistel-网路的解密\" class=\"headerlink\" title=\"2. Feistel 网路的解密\"></a>2. Feistel 网路的解密</h3><p>我们尝试一次下将一轮加密的输出结果用相同的子密钥重新运行一次，结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文<br>正确地还原为明文。关于这一点，可以从 XOR 的性质（两个相同的数进行 XOR 的结果一定为 0 ）进行思考。  </p>\n<p>有多个轮的情况下也是一样的。也就是说， Feistel 网络的解密操作只要按照相反的熟悉怒来使用子密钥就可以完成了。下图是三轮加密图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_8.png\" alt=\"\"><br>下图是解密示意图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_9.png\" alt=\"\"></p>\n<h3 id=\"3-Feistel-网络的性质\"><a href=\"#3-Feistel-网络的性质\" class=\"headerlink\" title=\"3. Feistel 网络的性质\"></a>3. Feistel 网络的性质</h3><p>Feistel 网络的轮数可以任意增加。无论运行多少轮的加密计算，都不会发生无法解密的情况。以及加密时无论使用任何函数作为轮函数都可以正确解密。<br>最后是加密和解密可以用完全相同的结构来实现。在 Feistel 网络的一轮中，右半部分实际上没有任何处理，这在加密算法中看起来是一种浪费，<br>但却保证了可解密性。 </p>\n<h1 id=\"6-三重-DES\"><a href=\"#6-三重-DES\" class=\"headerlink\" title=\"6 三重 DES\"></a>6 三重 DES</h1><p>现在 DES 已经可以在限时的时间内被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。</p>\n<h2 id=\"6-1-什么是三重-DES\"><a href=\"#6-1-什么是三重-DES\" class=\"headerlink\" title=\"6.1 什么是三重 DES\"></a>6.1 什么是三重 DES</h2><p>三重 DES（triple-DES）是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。</p>\n<h2 id=\"6-2-三重-DES-的加密\"><a href=\"#6-2-三重-DES-的加密\" class=\"headerlink\" title=\"6.2 三重 DES 的加密\"></a>6.2 三重 DES 的加密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_10.png\" alt=\"\"><br>经过三次 DES 处理CIA能变成最后的密文，由于 DES 秘钥的长度实质上是 56 比特，因此三重 DES 的秘钥长度就是 56 * 3 = 168 比特。<br>从上图中，我们发现，三重 DES 并不是进行三次 DES 加密，而是加密-解密-加密的过程，实际上这是 IBM 公司设计出来的，目的是为了让三重 DES<br>能够兼容普通的 DES。当三重 DES 所有秘钥都相同的时候就相当于普通的 DES 了。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES<br>来进行解密。也就是说三重 DES 对 DES 具备向下兼容性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_11.png\" alt=\"\"></p>\n<h2 id=\"6-3-三重-DES-的解密\"><a href=\"#6-3-三重-DES-的解密\" class=\"headerlink\" title=\"6.3 三重 DES 的解密\"></a>6.3 三重 DES 的解密</h2><p>解密过程与加密过程顺序相反。</p>\n<h2 id=\"6-4-三重-DES-的现状\"><a href=\"#6-4-三重-DES-的现状\" class=\"headerlink\" title=\"6.4 三重 DES 的现状\"></a>6.4 三重 DES 的现状</h2><p>其处理速度不高，而且在安全性方面也逐渐显现了一些问题，但还被银行等机构使用。</p>\n<h1 id=\"7-AES-的选定过程\"><a href=\"#7-AES-的选定过程\" class=\"headerlink\" title=\"7 AES 的选定过程\"></a>7 AES 的选定过程</h1><h2 id=\"7-1-什么是-AES\"><a href=\"#7-1-什么是-AES\" class=\"headerlink\" title=\"7.1 什么是 AES\"></a>7.1 什么是 AES</h2><p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码。全世界的企业和密码学家提交了多个对称密码算法<br>作为 AES 的候选，最终在 2000 年选出了一种名为 Rijndael 的对称密码算法，并将其确定为了 AES。</p>\n<h2 id=\"7-2-AES-的选定过程\"><a href=\"#7-2-AES-的选定过程\" class=\"headerlink\" title=\"7.2 AES 的选定过程\"></a>7.2 AES 的选定过程</h2><p>组织 AES 公开竞选活动的，是美国的一个标准化机构——NIST，参加 AES 竞选的条件是：被选为 AES 的密码算法必须无条件地免费供全世界使用。<br>此外，参与者还必须提交密码算法的详细规格书、以 ANSIC 和 Java 编写的实现代码以及抗密码破译强度的评估等材料。因此，在提交了详细设计和程序代码<br>完全公开的情况下，就杜绝了隐蔽式安全性（security by obscurity）。  </p>\n<p>评审者也是参与者，通过发现别人的弱点，实现竞争，最终实现标准化，正是密码算法选定的正确方式。只有由世界最高水平的密码学家共同尝试破译，依然未能<br>找到弱点，这样才能够证明一种密码算法的强度。</p>\n<h2 id=\"7-3-AES-最终候选算法的确定与-AES-的最终确定\"><a href=\"#7-3-AES-最终候选算法的确定与-AES-的最终确定\" class=\"headerlink\" title=\"7.3 AES 最终候选算法的确定与 AES 的最终确定\"></a>7.3 AES 最终候选算法的确定与 AES 的最终确定</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_12.png\" alt=\"\"></p>\n<h1 id=\"8-Rijndael\"><a href=\"#8-Rijndael\" class=\"headerlink\" title=\"8 Rijndael\"></a>8 Rijndael</h1><h2 id=\"8-1-什么是-Rijndael\"><a href=\"#8-1-什么是-Rijndael\" class=\"headerlink\" title=\"8.1 什么是 Rijndael\"></a>8.1 什么是 Rijndael</h2><p>由比利时密码学家 Joan Daemon 和 Vincent Rijmen 设计的分组密码算法。</p>\n<h2 id=\"8-2-Rijndael-的加密和解密\"><a href=\"#8-2-Rijndael-的加密和解密\" class=\"headerlink\" title=\"8.2 Rijndael 的加密和解密\"></a>8.2 Rijndael 的加密和解密</h2><p>和 DES 一样， Rijndael 算法也是由多个轮所构成，但是 Rijndael 使用了 SPN 结构，Rijndael 的输入分组为 128 比特，也就是 16字节。<br>首先，需要逐个字节地对 16 字节地输入数据进行 SubBytes 处理，即将一个 1 字节地值替换成另一个 1 字节地值，可以想象成简单替换密码。<br>SubBytes 之后进行 ShiftRows处理，即将 SubBytes 的输出以字节单位进行打乱处理，这种打乱是有规律的。然后进行 MixColumns 处理，即对<br>一个 4 字节地值进行比特运算，将其变成另一个 4 字节值，最后与轮秘钥进行 XOR ，进行 AddRoundkey处理。这就是一轮。<br>实际上，在 Rijndael 需要重复进行 10 ~ 14 次计算。<br>![][14]<br>它在一轮使用了 SubBytes、ShiftRows、MixColumns 分别存在反向运算 InvSubBytes、InvShiftRows、InvMixColumns，分别按字节、行、列进行并行计算。</p>\n<h2 id=\"8-3-Rijndael-的破译\"><a href=\"#8-3-Rijndael-的破译\" class=\"headerlink\" title=\"8.3 Rijndael 的破译\"></a>8.3 Rijndael 的破译</h2><p>对 Rijndael 来说，可能会出现以前并不存在的新的攻击方法。它的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公司来表达。  </p>\n<p>这只是一种假设而已，到现在为止，还没有出现针对 Rijndael 的有效攻击。</p>\n<h2 id=\"8-4-应该使用哪种对称密码呢\"><a href=\"#8-4-应该使用哪种对称密码呢\" class=\"headerlink\" title=\"8.4 应该使用哪种对称密码呢\"></a>8.4 应该使用哪种对称密码呢</h2><p>介绍了 DES、三重 DES、和 AES 等对称密码。那么我们到底用哪种呢？<br>一般来说不应该使用任何<strong>任何自制的密码算法</strong>，而是应该使用 AES。</p>\n<h1 id=\"9-本章小结\"><a href=\"#9-本章小结\" class=\"headerlink\" title=\"9 本章小结\"></a>9 本章小结</h1><p>本章介绍了对称密码，以及 DES、三重 DES、AES密码算法。  </p>\n<p>使用一种秘钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的秘钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他<br>类型的攻击。  </p>\n<p>然后用对称密码进行通信时，还会出现秘钥的配送问题。为了解决秘钥配送问题，我们需要公钥密码技术，将在第五章详解。<br>本章所介绍的几乎所有的密码算法，都只能讲一个固定长度的分组进行加密。当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。下一章将<br>探讨对分组密码进行迭代的方法。</p>\n<h1 id=\"10-小测验\"><a href=\"#10-小测验\" class=\"headerlink\" title=\"10 小测验\"></a>10 小测验</h1><ol>\n<li>一次性密码本的秘钥可以进行压缩变短。</li>\n<li>对称密码中，加密的秘钥和解密的秘钥是相等的。</li>\n<li>如果秘钥长度为 56 比特，那么用暴力破解找到正确秘钥需要平均尝试约 2^28 次。</li>\n<li>三重 DES 的秘钥空间是 DES 秘钥空间的三倍大。</li>\n<li>现在 DES 可以在限时的时间内被破译。</li>\n<li>AES 标准选定的密码算法叫 Rijndael。  </li>\n</ol>\n<blockquote>\n<p>注：秘钥长度为 56 比特，则秘钥空间（秘钥总数）是 2^56，平均时间除以 2 ，为 2^55。<br>压缩算法在于：重复。  </p>\n</blockquote>\n"},{"title":"二、历史上的密码，写一篇别人看不懂的文章","date":"2017-11-11T09:40:00.000Z","updated":"2017-11-12T08:14:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n本章将介绍历史上几种著名的密码：\n1. 凯撒密码\n2. 简单替换密码\n3. Enigma  \n  \n此外，还介绍两种破译密码的方法：\n1. 暴力攻击\n2. 频率分析  \n  \n最后，我们还将思考密码算法与密钥之间的关系。  \n本章所介绍的密码在现在都已经不再适用了，但在寻找密码弱点的方法、破译密码的思路以及密码算法与密钥的关系等方面，这些密码与现在密码技术依然是相通的。\n\n# 2 凯撒密码\n\n## 2.1 什么是凯撒密码\n\n凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的。  \n![][1]\n\n## 2.2 凯撒密码的加密\n\n例如，将 yoshiko 这个女性的名字，加密：\ny -> B  \no -> R  \ns -> V  \nh -> K  \ni -> L  \nk -> N  \no -> R  \n这样，明文 yoshiko 就被加密为了密文BRVKLNR。凯撒密码中，将字母表中的字母平移这个操作就是密码的算法，而平移的字母数量则相当于密钥。\n在本例中，密钥为3：  \n![][2]\n\n## 2.3 凯撒密码的解密\n\n我们只需要反向平移3个字母就可以解密了：  \nB -> y  \nR -> o  \nV -> s  \nK -> h  \nL -> i  \nN -> k  \nR -> o  \n这样就得到了明文 yoshiko，但是密钥 3 必须由发送者和接受者事先约定好。  \n![][3]  \n\n## 2.4 用暴力破解来破译密码\n\n通过上面的讲解，我们知道对于发送者用凯撒密码加密过的密文，接受者是能够进行解密的，但是接受者以为的人在看到密文 BRVKLNR ，是否能够进行破译\n得到明文呢？在凯撒密码中，密钥就是字母表平移的字数。因此可以按顺序将这 26 种密钥都尝试一遍：  \nBRVKLNR -> 用密钥 0 解密 -> brvklnr  \nBRVKLNR -> 用密钥 1 解密 -> aqujkmq  \nBRVKLNR -> 用密钥 2 解密 -> zptijlp  \nBRVKLNR -> 用密钥 3 解密 -> yoshiko  \n......  \nBRVKLNR -> 用密钥 25 解密 -> cswlmos  \n尝试一遍都，发现当密钥为 3 时，可以解密出有意义的字符串 yoshiko 。这就意味着我们仅仅根据密文就推测除了密钥和明文，这样的密码有什么用呢？\n凯撒密码实在是太脆弱了，无法保护重要的密码。  \n  \n上面介绍的这种密码破译方法，就是讲所有可能的密钥全部尝试一遍，这种方法称为暴力破解（brute-force attack）。由于这种方法的本质是从所有的密钥\n中找出正确的密钥，因此又称为穷举搜索（exhausive search）。  \n\n# 3 简单替换密码\n\n## 3.1 什么是简单替换密码\n\n将明文中所使用的字母表替换为另一套字母表的密码，如下图就是一个简单替换密码的对应表：  \n![][4]\n\n## 3.2 简单替换密码的加密\n\n按照上图的替换表，对明文 yoshiko　进行加密：  \ny -> K  \no -> B  \ns -> L  \nh -> T  \ni -> J  \nk -> S  \no -> B  \n就得到密文：KBLTJSB。\n\n## 3.3 简单替换密码的解密\n\n需要根据使用的替换表进行解密。\n\n## 3.4 简单替换密码的密钥空间\n\nyoshiko 用凯撒密码（密钥为 3 ）加密后的密文是 BRVKLNR ，二用简单替换密码（密钥为上图）加密后的密文则是 KBLTJSB。单从密文上来看，我们无法\n判断出凯撒密码和简单替换密码到底哪一种更难破解。  \n  \n**凯撒密码可以通过暴力破解来破译，但简单替换密码很难通过暴力破解来破译**。这是因为简单替换密码中可以使用的密钥数量，比凯撒密码要多得多。  \n  \n为了确定这一点，我们计算一下简单替换密码中可以使用的密钥总数。一种密码能够使用的“所有密钥的集合”称为密钥空间（keyspace），所有可用密钥的总数就是密钥空间的\n大小。密钥空间越大，暴力破解就越困难。  \n  \n简单替换密码中，明文字母表中的 a 可以对应A，B，C，...，Z 这 26 个字母中的任意一个，b 可以对应除了 a 所对应的字母以为的剩余 25 个字母中的任意一个。\n以此类推，我们可以计算出简单替换密码的密钥总数为：  \n26 \\* 25 \\* 24 \\* 23 \\* ... \\* 1 = 403291461126605635584000000  \n即使美妙能够遍历 10 亿个密钥，也要花费 120 亿年的时间。\n\n## 3.5 用频率分析来破译密码\n\n频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。例如：  \n![][5]  \n  \n首先，我们统一一下这段密文中**每个字母出现的频率**：  \n![][6]  \n  \n为了找到破译的线索，我们再来看一下英语文章中所使用的字母的频率，一般的英语文章中出现频率最高的字母是 e 。而上图中出现频率最高的两个字母是 I 和 Y，\n我们假设它们中的其中一个是 e 。然后将密文中的 Y 全部替换成 e ，替换后的密文如下：  \n![][7]  \n英语中出现最多的单词是 the ，因此我们可以寻找一下以 e 结尾的 3 个字母的组合，结果我们发现 MEe 这3个字母的组合是最常出现的，而且 MEe 出现在\n密文的开头，因此 MEe 很可能就是 the 。于是，我们再假设 M -> t，E -> h。得到如下图的表：  \n![][8]  \n让我们动员自己所有的英文词汇，在上面的文字中继续寻找可能的组合。我们发现中间有一个词 thPee 比较可以，这个词不会就是 three 吧（P -> r）？\n除了高频字母以外，密文中的低频字母 Q 也可以找到一些相关的组合。直到得到最后通顺的明文，有以下结论：\n* 除了高频字母以外，低频字母也能够成为线索。\n* 搞清开头和结尾能够称为线索，搞清单词之间的分隔也能够成为线索。\n* 密文越长越容易破译。\n* 同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）。\n* 破译的速度会越来越快。\n\n# 4 Enigma\n\n## 4.1 什么是 Enigma\n\nEnigma 是由德国人于 20 世纪初发明的一种能够进行加密与解密操作的机器。Enigma 这个名字在德语里是“谜”的意思。\n\n## 4.2 用 Enigma 进行加密通信\n\nEnigma 是一种由键盘、齿轮、电池和灯泡所组成的机器，通过这一台机器就可以完成加密和解密两种操作。  \n  \n发送者和接收者各自拥有一台 Enigma。发送者用 Enigma 将明文加密，将生成的密文通过无线电发送给接收者。接收者将接收到的密文用自己的 Enigma 解密。  \n  \n由于发送者和接收者必须使用相同的密钥才能完成密码通信，因此发送者和接收者会事先收到一份叫**国防军密码本**的册子。发送者和接收者按照册子指示来设置 Enigma。  \n![][9]\n\n## 4.3 Enigma 的构造\n\nEnigma 的构造如下图。它能对字母表中的 26 个字母进行加密和解密操作，这里将字母的数量简化为 4 个：  \n![][10] \n每当按下 Enigma 上的一个键，就会点亮一个灯泡。而接线板和轮子在每次输入的时候都会变化，这样的组合让 Enigma 看起来像是一个能够动态变化的操作。\n\n## 4.4 Enigma 的加密\n![][11]  \n在进行通信之前，发送者金和接收者双方都需要持有国防军密码本，国防军密码本中记载了发送者和接收者需要使用的每日密码。\n\n### 1.设置 Enigma\n发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。具体来说，就是接线板和转子排列。\n\n### 2. 加密通信密码\n接下来，发送者需要想出 3 个字母，并将其加密。这 3 个字母称为通信密码。  \n通信密码的加密也是通过 Enigma 完成的。假设发送者选择的通信密码为 psv，则发送者需要在 Enigma 的键盘上输入两次该通信密码，也就是说需要输入 \npsvpsv 这 6 个字母。  \n  \n发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输入全部 6 个字母之后，发送者就记下了它们所对应的密文，\n假设密文是 ATCDVT（密文用大写字母来表示）。\n\n### 3. 重新设置 Enigma\n接下来，发送者根据通信密码重新设置 Enigma。通信密码中的 3 个字母实际上代表了三个转子的初始位置。每一个转子的上面都印有字母，可以根据字母\n来设置转子的初始位置。通信密码 psv 就表示需要将转子 1、2、3 分别转到 p、s、v 所对应的位置。\n\n### 4. 加密消息\n接下来，发送者对消息进行加密。发送者将明文逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。例如输入 nacht ，记录下对应的 KXNWP 。\n\n### 5. 拼接\n接下来，发送者将“加密后的通信密码” ATCDVT 与 “加密后的消息” KXNWP 进行拼接，将 ATCDVTKXNWP 作为电文通过无线电发出。  \n  \n上面就是用 Enigma 进行加密的操作步骤，看来还真是挺麻烦的。\n\n## 4.5 每日密码与通信密码\n\n每日密码在这里不是用来加密消息的，而是用来加密通信密码的。也就是说，每日密码是一种用来加密密钥的密钥，这种密钥，一般称为密钥加密密钥（Key Encrypting Key，KEY）。\n\n## 4.6 避免通信错误\n\n在通信密码的加密中，我们需要将通信密码 psv 连续输入两次，即 psvpsv。这是因为接收者可以对通信密码进行校验，避免错误。\n\n## 4.7 Enigma 的解密\n\n![][12]  \n\n### 1.分解\n接收者将接受到的电文分解为两部分，即开头的 6 个字母 ATCDVT 和剩下的字母 KXNWP。\n\n### 2. 设置 Enigma\n接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，这一步和发送者进行的操作是相同的。\n\n### 3. 解密通信密码\n接下来，接收者将加密后的通信密码 ATCDVT 进行解密。接收者在 Enigma 的键盘上输入 ATCDVT 这 6 个字母，然后将亮起的灯泡对应的字母 psvpsv 记下来。\n因为是 psv 重复两次的形式，所以接收者可以判断在通信过程中没有发生错误。\n\n### 4. 重新设置 Enigma\n接下来，接收者根据通信密码 psv 重新设置 Enigma。\n\n### 5. 解密消息\n接下里，接收者将电文中的剩余部分 KXNWP 逐一输入，将灯泡的结果记下来，得到了 nacht。\n\n## 4.8 Enigma 的弱点\n\n### 1. 将通信密码连续输入两次并加密\n这样密码破译者知道密文开头的 6 个字母被解密后的明文一定是 3 个字母重复两次的形式\n\n### 2. 通信密码是人为选定的\n有可能使用 aaa、bbb 或者生日，女朋友的名字当做密码。密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。\n\n### 3. 必须派发国防军密码本\n如果落到敌人手里，就会带来大麻烦。如果现在所使用的国防军密码本被敌人得到，哪怕只泄漏了一本，也必须重新制作新的密码本并发到全军。\n必须配送密钥这个问题，将在第五章详解。\n\n## 4.9 Enigma 的破译\n\n即使得到了 Enigma 的构造，但是由于 Enigma 的设计并不依赖于“隐蔽式安全性”，只要不知道 Enigma的设置（密钥），就无法破译密码。但是，\n每日密码在一天之内不会变，即一天内截获的所有通信，都是用同一个密码进行加密的；以及通信密码都会重复两次。以 ATCDVT 为例，即知道第一个字母和\n第四个字母，都是由相同的明文加密得到的；另外，由于一个轮子只有26个可能。最终经过了许多密码专家的破译，包括现代计算机之父阿兰图灵，最终破译了这个密码。\n\n# 5 思考\n\n## 5.1 为什么吗要将密码算法和密钥分开呢\n\n我们来列举一下本章介绍过的密码系统的“密码算法”和“密钥”。\n\n|密码系统|密码算法|密钥|\n|:------|:------|:---|\n|凯撒密码|将明文中的各个字母按照指定的字母数平移|平移的字母数量|\n|简单替换密码|按照替换表对字母表进行替换|替换表|\n|Enigma（通信密码的加密）|使用Enigma密码机，通过接线板的接线方式、三个转子的顺序、每个转子的旋转位置对字母进行替换|接线板的接线方式、转子的顺序、转子的旋转位置|\n|Enigma（通信电文的加密）|使用接线板的接线方式和三个转子的顺序固定的Enigma密码机，按照每个转子的旋转位置对字母进行替换|每个转子的旋转位置|\n\n仔细研究一下每一对密码算法和密钥的组合就会发现，在密码算法中必然存在可变部分，而这些可变部分就相当于密钥。当密码算法和密钥都确定时，加密的方法也就确定了。  \n如果每次加密都必须产生一个新的密码算法，那真是太诡异了。对于已经开发出的一种密码算法，我们总是希望能够重复使用。  \n  \n将密码算法和密钥分开的意义正在于此。密码算法是需要重复使用的，但在重复使用同一种算法的过程中，该算法被破译的可能性也在逐渐增大。因此，\n我们就在密码算法中准备了一些可变部分，并在每次通信时都对这部分进行改变，而这一可变部分就是密钥。  \n  \n将密码算法和密钥分开考虑，就解决了**希望重复使用，但重复使用会增加风险**这个难题。  \n  \n密钥才是秘密的精华。因此，在密码技术中，如何管理密钥是一个重要的课题。这将在第十一章详解。  \n>每个人都可以拥有相同品牌的锁，但每个人都有不同的钥匙。锁的设计师公开的——锁匠都带有详细图的书，而且绝大多数好的设计方案都在公开专利\n中进行了描述——但是钥匙是秘密的。\n\n# 6 本章小结\n\n密码系统：凯撒密码、简单替换密码以及 Enigma。  \n密码破译：暴力破解、字母频率分析。\n\n# 7 小测验\n\n1. 凯撒密码中，如果存在如 c -> C， q -> Q这样，明文中的字母被替换成了相同字母的密文的情况。于是Alice就想：如果替换表中不出现这种被替换\n为相同字母的情况，那么密文应该会更难被破译吧？请问 Alice 的想法正确吗？ \n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_8.png\n[9]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_9.png\n[10]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_10.png\n[11]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_11.png\n[12]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_12.png","source":"_posts/图解密码技术/第二章 历史上的密码，写一篇别人看不懂的文章.md","raw":"---\ntitle: 二、历史上的密码，写一篇别人看不懂的文章\ndate: 2017-11-11 17:40:00\nupdated: 2017-11-12 16:14:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/2.html    \n---\n\n# 1 本章概要\n\n本章将介绍历史上几种著名的密码：\n1. 凯撒密码\n2. 简单替换密码\n3. Enigma  \n  \n此外，还介绍两种破译密码的方法：\n1. 暴力攻击\n2. 频率分析  \n  \n最后，我们还将思考密码算法与密钥之间的关系。  \n本章所介绍的密码在现在都已经不再适用了，但在寻找密码弱点的方法、破译密码的思路以及密码算法与密钥的关系等方面，这些密码与现在密码技术依然是相通的。\n\n# 2 凯撒密码\n\n## 2.1 什么是凯撒密码\n\n凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的。  \n![][1]\n\n## 2.2 凯撒密码的加密\n\n例如，将 yoshiko 这个女性的名字，加密：\ny -> B  \no -> R  \ns -> V  \nh -> K  \ni -> L  \nk -> N  \no -> R  \n这样，明文 yoshiko 就被加密为了密文BRVKLNR。凯撒密码中，将字母表中的字母平移这个操作就是密码的算法，而平移的字母数量则相当于密钥。\n在本例中，密钥为3：  \n![][2]\n\n## 2.3 凯撒密码的解密\n\n我们只需要反向平移3个字母就可以解密了：  \nB -> y  \nR -> o  \nV -> s  \nK -> h  \nL -> i  \nN -> k  \nR -> o  \n这样就得到了明文 yoshiko，但是密钥 3 必须由发送者和接受者事先约定好。  \n![][3]  \n\n## 2.4 用暴力破解来破译密码\n\n通过上面的讲解，我们知道对于发送者用凯撒密码加密过的密文，接受者是能够进行解密的，但是接受者以为的人在看到密文 BRVKLNR ，是否能够进行破译\n得到明文呢？在凯撒密码中，密钥就是字母表平移的字数。因此可以按顺序将这 26 种密钥都尝试一遍：  \nBRVKLNR -> 用密钥 0 解密 -> brvklnr  \nBRVKLNR -> 用密钥 1 解密 -> aqujkmq  \nBRVKLNR -> 用密钥 2 解密 -> zptijlp  \nBRVKLNR -> 用密钥 3 解密 -> yoshiko  \n......  \nBRVKLNR -> 用密钥 25 解密 -> cswlmos  \n尝试一遍都，发现当密钥为 3 时，可以解密出有意义的字符串 yoshiko 。这就意味着我们仅仅根据密文就推测除了密钥和明文，这样的密码有什么用呢？\n凯撒密码实在是太脆弱了，无法保护重要的密码。  \n  \n上面介绍的这种密码破译方法，就是讲所有可能的密钥全部尝试一遍，这种方法称为暴力破解（brute-force attack）。由于这种方法的本质是从所有的密钥\n中找出正确的密钥，因此又称为穷举搜索（exhausive search）。  \n\n# 3 简单替换密码\n\n## 3.1 什么是简单替换密码\n\n将明文中所使用的字母表替换为另一套字母表的密码，如下图就是一个简单替换密码的对应表：  \n![][4]\n\n## 3.2 简单替换密码的加密\n\n按照上图的替换表，对明文 yoshiko　进行加密：  \ny -> K  \no -> B  \ns -> L  \nh -> T  \ni -> J  \nk -> S  \no -> B  \n就得到密文：KBLTJSB。\n\n## 3.3 简单替换密码的解密\n\n需要根据使用的替换表进行解密。\n\n## 3.4 简单替换密码的密钥空间\n\nyoshiko 用凯撒密码（密钥为 3 ）加密后的密文是 BRVKLNR ，二用简单替换密码（密钥为上图）加密后的密文则是 KBLTJSB。单从密文上来看，我们无法\n判断出凯撒密码和简单替换密码到底哪一种更难破解。  \n  \n**凯撒密码可以通过暴力破解来破译，但简单替换密码很难通过暴力破解来破译**。这是因为简单替换密码中可以使用的密钥数量，比凯撒密码要多得多。  \n  \n为了确定这一点，我们计算一下简单替换密码中可以使用的密钥总数。一种密码能够使用的“所有密钥的集合”称为密钥空间（keyspace），所有可用密钥的总数就是密钥空间的\n大小。密钥空间越大，暴力破解就越困难。  \n  \n简单替换密码中，明文字母表中的 a 可以对应A，B，C，...，Z 这 26 个字母中的任意一个，b 可以对应除了 a 所对应的字母以为的剩余 25 个字母中的任意一个。\n以此类推，我们可以计算出简单替换密码的密钥总数为：  \n26 \\* 25 \\* 24 \\* 23 \\* ... \\* 1 = 403291461126605635584000000  \n即使美妙能够遍历 10 亿个密钥，也要花费 120 亿年的时间。\n\n## 3.5 用频率分析来破译密码\n\n频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。例如：  \n![][5]  \n  \n首先，我们统一一下这段密文中**每个字母出现的频率**：  \n![][6]  \n  \n为了找到破译的线索，我们再来看一下英语文章中所使用的字母的频率，一般的英语文章中出现频率最高的字母是 e 。而上图中出现频率最高的两个字母是 I 和 Y，\n我们假设它们中的其中一个是 e 。然后将密文中的 Y 全部替换成 e ，替换后的密文如下：  \n![][7]  \n英语中出现最多的单词是 the ，因此我们可以寻找一下以 e 结尾的 3 个字母的组合，结果我们发现 MEe 这3个字母的组合是最常出现的，而且 MEe 出现在\n密文的开头，因此 MEe 很可能就是 the 。于是，我们再假设 M -> t，E -> h。得到如下图的表：  \n![][8]  \n让我们动员自己所有的英文词汇，在上面的文字中继续寻找可能的组合。我们发现中间有一个词 thPee 比较可以，这个词不会就是 three 吧（P -> r）？\n除了高频字母以外，密文中的低频字母 Q 也可以找到一些相关的组合。直到得到最后通顺的明文，有以下结论：\n* 除了高频字母以外，低频字母也能够成为线索。\n* 搞清开头和结尾能够称为线索，搞清单词之间的分隔也能够成为线索。\n* 密文越长越容易破译。\n* 同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）。\n* 破译的速度会越来越快。\n\n# 4 Enigma\n\n## 4.1 什么是 Enigma\n\nEnigma 是由德国人于 20 世纪初发明的一种能够进行加密与解密操作的机器。Enigma 这个名字在德语里是“谜”的意思。\n\n## 4.2 用 Enigma 进行加密通信\n\nEnigma 是一种由键盘、齿轮、电池和灯泡所组成的机器，通过这一台机器就可以完成加密和解密两种操作。  \n  \n发送者和接收者各自拥有一台 Enigma。发送者用 Enigma 将明文加密，将生成的密文通过无线电发送给接收者。接收者将接收到的密文用自己的 Enigma 解密。  \n  \n由于发送者和接收者必须使用相同的密钥才能完成密码通信，因此发送者和接收者会事先收到一份叫**国防军密码本**的册子。发送者和接收者按照册子指示来设置 Enigma。  \n![][9]\n\n## 4.3 Enigma 的构造\n\nEnigma 的构造如下图。它能对字母表中的 26 个字母进行加密和解密操作，这里将字母的数量简化为 4 个：  \n![][10] \n每当按下 Enigma 上的一个键，就会点亮一个灯泡。而接线板和轮子在每次输入的时候都会变化，这样的组合让 Enigma 看起来像是一个能够动态变化的操作。\n\n## 4.4 Enigma 的加密\n![][11]  \n在进行通信之前，发送者金和接收者双方都需要持有国防军密码本，国防军密码本中记载了发送者和接收者需要使用的每日密码。\n\n### 1.设置 Enigma\n发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。具体来说，就是接线板和转子排列。\n\n### 2. 加密通信密码\n接下来，发送者需要想出 3 个字母，并将其加密。这 3 个字母称为通信密码。  \n通信密码的加密也是通过 Enigma 完成的。假设发送者选择的通信密码为 psv，则发送者需要在 Enigma 的键盘上输入两次该通信密码，也就是说需要输入 \npsvpsv 这 6 个字母。  \n  \n发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输入全部 6 个字母之后，发送者就记下了它们所对应的密文，\n假设密文是 ATCDVT（密文用大写字母来表示）。\n\n### 3. 重新设置 Enigma\n接下来，发送者根据通信密码重新设置 Enigma。通信密码中的 3 个字母实际上代表了三个转子的初始位置。每一个转子的上面都印有字母，可以根据字母\n来设置转子的初始位置。通信密码 psv 就表示需要将转子 1、2、3 分别转到 p、s、v 所对应的位置。\n\n### 4. 加密消息\n接下来，发送者对消息进行加密。发送者将明文逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。例如输入 nacht ，记录下对应的 KXNWP 。\n\n### 5. 拼接\n接下来，发送者将“加密后的通信密码” ATCDVT 与 “加密后的消息” KXNWP 进行拼接，将 ATCDVTKXNWP 作为电文通过无线电发出。  \n  \n上面就是用 Enigma 进行加密的操作步骤，看来还真是挺麻烦的。\n\n## 4.5 每日密码与通信密码\n\n每日密码在这里不是用来加密消息的，而是用来加密通信密码的。也就是说，每日密码是一种用来加密密钥的密钥，这种密钥，一般称为密钥加密密钥（Key Encrypting Key，KEY）。\n\n## 4.6 避免通信错误\n\n在通信密码的加密中，我们需要将通信密码 psv 连续输入两次，即 psvpsv。这是因为接收者可以对通信密码进行校验，避免错误。\n\n## 4.7 Enigma 的解密\n\n![][12]  \n\n### 1.分解\n接收者将接受到的电文分解为两部分，即开头的 6 个字母 ATCDVT 和剩下的字母 KXNWP。\n\n### 2. 设置 Enigma\n接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，这一步和发送者进行的操作是相同的。\n\n### 3. 解密通信密码\n接下来，接收者将加密后的通信密码 ATCDVT 进行解密。接收者在 Enigma 的键盘上输入 ATCDVT 这 6 个字母，然后将亮起的灯泡对应的字母 psvpsv 记下来。\n因为是 psv 重复两次的形式，所以接收者可以判断在通信过程中没有发生错误。\n\n### 4. 重新设置 Enigma\n接下来，接收者根据通信密码 psv 重新设置 Enigma。\n\n### 5. 解密消息\n接下里，接收者将电文中的剩余部分 KXNWP 逐一输入，将灯泡的结果记下来，得到了 nacht。\n\n## 4.8 Enigma 的弱点\n\n### 1. 将通信密码连续输入两次并加密\n这样密码破译者知道密文开头的 6 个字母被解密后的明文一定是 3 个字母重复两次的形式\n\n### 2. 通信密码是人为选定的\n有可能使用 aaa、bbb 或者生日，女朋友的名字当做密码。密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。\n\n### 3. 必须派发国防军密码本\n如果落到敌人手里，就会带来大麻烦。如果现在所使用的国防军密码本被敌人得到，哪怕只泄漏了一本，也必须重新制作新的密码本并发到全军。\n必须配送密钥这个问题，将在第五章详解。\n\n## 4.9 Enigma 的破译\n\n即使得到了 Enigma 的构造，但是由于 Enigma 的设计并不依赖于“隐蔽式安全性”，只要不知道 Enigma的设置（密钥），就无法破译密码。但是，\n每日密码在一天之内不会变，即一天内截获的所有通信，都是用同一个密码进行加密的；以及通信密码都会重复两次。以 ATCDVT 为例，即知道第一个字母和\n第四个字母，都是由相同的明文加密得到的；另外，由于一个轮子只有26个可能。最终经过了许多密码专家的破译，包括现代计算机之父阿兰图灵，最终破译了这个密码。\n\n# 5 思考\n\n## 5.1 为什么吗要将密码算法和密钥分开呢\n\n我们来列举一下本章介绍过的密码系统的“密码算法”和“密钥”。\n\n|密码系统|密码算法|密钥|\n|:------|:------|:---|\n|凯撒密码|将明文中的各个字母按照指定的字母数平移|平移的字母数量|\n|简单替换密码|按照替换表对字母表进行替换|替换表|\n|Enigma（通信密码的加密）|使用Enigma密码机，通过接线板的接线方式、三个转子的顺序、每个转子的旋转位置对字母进行替换|接线板的接线方式、转子的顺序、转子的旋转位置|\n|Enigma（通信电文的加密）|使用接线板的接线方式和三个转子的顺序固定的Enigma密码机，按照每个转子的旋转位置对字母进行替换|每个转子的旋转位置|\n\n仔细研究一下每一对密码算法和密钥的组合就会发现，在密码算法中必然存在可变部分，而这些可变部分就相当于密钥。当密码算法和密钥都确定时，加密的方法也就确定了。  \n如果每次加密都必须产生一个新的密码算法，那真是太诡异了。对于已经开发出的一种密码算法，我们总是希望能够重复使用。  \n  \n将密码算法和密钥分开的意义正在于此。密码算法是需要重复使用的，但在重复使用同一种算法的过程中，该算法被破译的可能性也在逐渐增大。因此，\n我们就在密码算法中准备了一些可变部分，并在每次通信时都对这部分进行改变，而这一可变部分就是密钥。  \n  \n将密码算法和密钥分开考虑，就解决了**希望重复使用，但重复使用会增加风险**这个难题。  \n  \n密钥才是秘密的精华。因此，在密码技术中，如何管理密钥是一个重要的课题。这将在第十一章详解。  \n>每个人都可以拥有相同品牌的锁，但每个人都有不同的钥匙。锁的设计师公开的——锁匠都带有详细图的书，而且绝大多数好的设计方案都在公开专利\n中进行了描述——但是钥匙是秘密的。\n\n# 6 本章小结\n\n密码系统：凯撒密码、简单替换密码以及 Enigma。  \n密码破译：暴力破解、字母频率分析。\n\n# 7 小测验\n\n1. 凯撒密码中，如果存在如 c -> C， q -> Q这样，明文中的字母被替换成了相同字母的密文的情况。于是Alice就想：如果替换表中不出现这种被替换\n为相同字母的情况，那么密文应该会更难被破译吧？请问 Alice 的想法正确吗？ \n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_8.png\n[9]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_9.png\n[10]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_10.png\n[11]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_11.png\n[12]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_12.png","slug":"graphic2cryptography/2.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavt002iaxs6sik9zyy8","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>本章将介绍历史上几种著名的密码：</p>\n<ol>\n<li>凯撒密码</li>\n<li>简单替换密码</li>\n<li>Enigma  </li>\n</ol>\n<p>此外，还介绍两种破译密码的方法：</p>\n<ol>\n<li>暴力攻击</li>\n<li>频率分析  </li>\n</ol>\n<p>最后，我们还将思考密码算法与密钥之间的关系。<br>本章所介绍的密码在现在都已经不再适用了，但在寻找密码弱点的方法、破译密码的思路以及密码算法与密钥的关系等方面，这些密码与现在密码技术依然是相通的。</p>\n<h1 id=\"2-凯撒密码\"><a href=\"#2-凯撒密码\" class=\"headerlink\" title=\"2 凯撒密码\"></a>2 凯撒密码</h1><h2 id=\"2-1-什么是凯撒密码\"><a href=\"#2-1-什么是凯撒密码\" class=\"headerlink\" title=\"2.1 什么是凯撒密码\"></a>2.1 什么是凯撒密码</h2><p>凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_1.png\" alt=\"\"></p>\n<h2 id=\"2-2-凯撒密码的加密\"><a href=\"#2-2-凯撒密码的加密\" class=\"headerlink\" title=\"2.2 凯撒密码的加密\"></a>2.2 凯撒密码的加密</h2><p>例如，将 yoshiko 这个女性的名字，加密：<br>y -&gt; B<br>o -&gt; R<br>s -&gt; V<br>h -&gt; K<br>i -&gt; L<br>k -&gt; N<br>o -&gt; R<br>这样，明文 yoshiko 就被加密为了密文BRVKLNR。凯撒密码中，将字母表中的字母平移这个操作就是密码的算法，而平移的字母数量则相当于密钥。<br>在本例中，密钥为3：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_2.png\" alt=\"\"></p>\n<h2 id=\"2-3-凯撒密码的解密\"><a href=\"#2-3-凯撒密码的解密\" class=\"headerlink\" title=\"2.3 凯撒密码的解密\"></a>2.3 凯撒密码的解密</h2><p>我们只需要反向平移3个字母就可以解密了：<br>B -&gt; y<br>R -&gt; o<br>V -&gt; s<br>K -&gt; h<br>L -&gt; i<br>N -&gt; k<br>R -&gt; o<br>这样就得到了明文 yoshiko，但是密钥 3 必须由发送者和接受者事先约定好。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_3.png\" alt=\"\">  </p>\n<h2 id=\"2-4-用暴力破解来破译密码\"><a href=\"#2-4-用暴力破解来破译密码\" class=\"headerlink\" title=\"2.4 用暴力破解来破译密码\"></a>2.4 用暴力破解来破译密码</h2><p>通过上面的讲解，我们知道对于发送者用凯撒密码加密过的密文，接受者是能够进行解密的，但是接受者以为的人在看到密文 BRVKLNR ，是否能够进行破译<br>得到明文呢？在凯撒密码中，密钥就是字母表平移的字数。因此可以按顺序将这 26 种密钥都尝试一遍：<br>BRVKLNR -&gt; 用密钥 0 解密 -&gt; brvklnr<br>BRVKLNR -&gt; 用密钥 1 解密 -&gt; aqujkmq<br>BRVKLNR -&gt; 用密钥 2 解密 -&gt; zptijlp<br>BRVKLNR -&gt; 用密钥 3 解密 -&gt; yoshiko<br>……<br>BRVKLNR -&gt; 用密钥 25 解密 -&gt; cswlmos<br>尝试一遍都，发现当密钥为 3 时，可以解密出有意义的字符串 yoshiko 。这就意味着我们仅仅根据密文就推测除了密钥和明文，这样的密码有什么用呢？<br>凯撒密码实在是太脆弱了，无法保护重要的密码。  </p>\n<p>上面介绍的这种密码破译方法，就是讲所有可能的密钥全部尝试一遍，这种方法称为暴力破解（brute-force attack）。由于这种方法的本质是从所有的密钥<br>中找出正确的密钥，因此又称为穷举搜索（exhausive search）。  </p>\n<h1 id=\"3-简单替换密码\"><a href=\"#3-简单替换密码\" class=\"headerlink\" title=\"3 简单替换密码\"></a>3 简单替换密码</h1><h2 id=\"3-1-什么是简单替换密码\"><a href=\"#3-1-什么是简单替换密码\" class=\"headerlink\" title=\"3.1 什么是简单替换密码\"></a>3.1 什么是简单替换密码</h2><p>将明文中所使用的字母表替换为另一套字母表的密码，如下图就是一个简单替换密码的对应表：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_4.png\" alt=\"\"></p>\n<h2 id=\"3-2-简单替换密码的加密\"><a href=\"#3-2-简单替换密码的加密\" class=\"headerlink\" title=\"3.2 简单替换密码的加密\"></a>3.2 简单替换密码的加密</h2><p>按照上图的替换表，对明文 yoshiko　进行加密：<br>y -&gt; K<br>o -&gt; B<br>s -&gt; L<br>h -&gt; T<br>i -&gt; J<br>k -&gt; S<br>o -&gt; B<br>就得到密文：KBLTJSB。</p>\n<h2 id=\"3-3-简单替换密码的解密\"><a href=\"#3-3-简单替换密码的解密\" class=\"headerlink\" title=\"3.3 简单替换密码的解密\"></a>3.3 简单替换密码的解密</h2><p>需要根据使用的替换表进行解密。</p>\n<h2 id=\"3-4-简单替换密码的密钥空间\"><a href=\"#3-4-简单替换密码的密钥空间\" class=\"headerlink\" title=\"3.4 简单替换密码的密钥空间\"></a>3.4 简单替换密码的密钥空间</h2><p>yoshiko 用凯撒密码（密钥为 3 ）加密后的密文是 BRVKLNR ，二用简单替换密码（密钥为上图）加密后的密文则是 KBLTJSB。单从密文上来看，我们无法<br>判断出凯撒密码和简单替换密码到底哪一种更难破解。  </p>\n<p><strong>凯撒密码可以通过暴力破解来破译，但简单替换密码很难通过暴力破解来破译</strong>。这是因为简单替换密码中可以使用的密钥数量，比凯撒密码要多得多。  </p>\n<p>为了确定这一点，我们计算一下简单替换密码中可以使用的密钥总数。一种密码能够使用的“所有密钥的集合”称为密钥空间（keyspace），所有可用密钥的总数就是密钥空间的<br>大小。密钥空间越大，暴力破解就越困难。  </p>\n<p>简单替换密码中，明文字母表中的 a 可以对应A，B，C，…，Z 这 26 个字母中的任意一个，b 可以对应除了 a 所对应的字母以为的剩余 25 个字母中的任意一个。<br>以此类推，我们可以计算出简单替换密码的密钥总数为：<br>26 * 25 * 24 * 23 * … * 1 = 403291461126605635584000000<br>即使美妙能够遍历 10 亿个密钥，也要花费 120 亿年的时间。</p>\n<h2 id=\"3-5-用频率分析来破译密码\"><a href=\"#3-5-用频率分析来破译密码\" class=\"headerlink\" title=\"3.5 用频率分析来破译密码\"></a>3.5 用频率分析来破译密码</h2><p>频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。例如：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_5.png\" alt=\"\">  </p>\n<p>首先，我们统一一下这段密文中<strong>每个字母出现的频率</strong>：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_6.png\" alt=\"\">  </p>\n<p>为了找到破译的线索，我们再来看一下英语文章中所使用的字母的频率，一般的英语文章中出现频率最高的字母是 e 。而上图中出现频率最高的两个字母是 I 和 Y，<br>我们假设它们中的其中一个是 e 。然后将密文中的 Y 全部替换成 e ，替换后的密文如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_7.png\" alt=\"\"><br>英语中出现最多的单词是 the ，因此我们可以寻找一下以 e 结尾的 3 个字母的组合，结果我们发现 MEe 这3个字母的组合是最常出现的，而且 MEe 出现在<br>密文的开头，因此 MEe 很可能就是 the 。于是，我们再假设 M -&gt; t，E -&gt; h。得到如下图的表：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_8.png\" alt=\"\"><br>让我们动员自己所有的英文词汇，在上面的文字中继续寻找可能的组合。我们发现中间有一个词 thPee 比较可以，这个词不会就是 three 吧（P -&gt; r）？<br>除了高频字母以外，密文中的低频字母 Q 也可以找到一些相关的组合。直到得到最后通顺的明文，有以下结论：</p>\n<ul>\n<li>除了高频字母以外，低频字母也能够成为线索。</li>\n<li>搞清开头和结尾能够称为线索，搞清单词之间的分隔也能够成为线索。</li>\n<li>密文越长越容易破译。</li>\n<li>同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）。</li>\n<li>破译的速度会越来越快。</li>\n</ul>\n<h1 id=\"4-Enigma\"><a href=\"#4-Enigma\" class=\"headerlink\" title=\"4 Enigma\"></a>4 Enigma</h1><h2 id=\"4-1-什么是-Enigma\"><a href=\"#4-1-什么是-Enigma\" class=\"headerlink\" title=\"4.1 什么是 Enigma\"></a>4.1 什么是 Enigma</h2><p>Enigma 是由德国人于 20 世纪初发明的一种能够进行加密与解密操作的机器。Enigma 这个名字在德语里是“谜”的意思。</p>\n<h2 id=\"4-2-用-Enigma-进行加密通信\"><a href=\"#4-2-用-Enigma-进行加密通信\" class=\"headerlink\" title=\"4.2 用 Enigma 进行加密通信\"></a>4.2 用 Enigma 进行加密通信</h2><p>Enigma 是一种由键盘、齿轮、电池和灯泡所组成的机器，通过这一台机器就可以完成加密和解密两种操作。  </p>\n<p>发送者和接收者各自拥有一台 Enigma。发送者用 Enigma 将明文加密，将生成的密文通过无线电发送给接收者。接收者将接收到的密文用自己的 Enigma 解密。  </p>\n<p>由于发送者和接收者必须使用相同的密钥才能完成密码通信，因此发送者和接收者会事先收到一份叫<strong>国防军密码本</strong>的册子。发送者和接收者按照册子指示来设置 Enigma。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_9.png\" alt=\"\"></p>\n<h2 id=\"4-3-Enigma-的构造\"><a href=\"#4-3-Enigma-的构造\" class=\"headerlink\" title=\"4.3 Enigma 的构造\"></a>4.3 Enigma 的构造</h2><p>Enigma 的构造如下图。它能对字母表中的 26 个字母进行加密和解密操作，这里将字母的数量简化为 4 个：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_10.png\" alt=\"\"><br>每当按下 Enigma 上的一个键，就会点亮一个灯泡。而接线板和轮子在每次输入的时候都会变化，这样的组合让 Enigma 看起来像是一个能够动态变化的操作。</p>\n<h2 id=\"4-4-Enigma-的加密\"><a href=\"#4-4-Enigma-的加密\" class=\"headerlink\" title=\"4.4 Enigma 的加密\"></a>4.4 Enigma 的加密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_11.png\" alt=\"\"><br>在进行通信之前，发送者金和接收者双方都需要持有国防军密码本，国防军密码本中记载了发送者和接收者需要使用的每日密码。</p>\n<h3 id=\"1-设置-Enigma\"><a href=\"#1-设置-Enigma\" class=\"headerlink\" title=\"1.设置 Enigma\"></a>1.设置 Enigma</h3><p>发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。具体来说，就是接线板和转子排列。</p>\n<h3 id=\"2-加密通信密码\"><a href=\"#2-加密通信密码\" class=\"headerlink\" title=\"2. 加密通信密码\"></a>2. 加密通信密码</h3><p>接下来，发送者需要想出 3 个字母，并将其加密。这 3 个字母称为通信密码。<br>通信密码的加密也是通过 Enigma 完成的。假设发送者选择的通信密码为 psv，则发送者需要在 Enigma 的键盘上输入两次该通信密码，也就是说需要输入<br>psvpsv 这 6 个字母。  </p>\n<p>发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输入全部 6 个字母之后，发送者就记下了它们所对应的密文，<br>假设密文是 ATCDVT（密文用大写字母来表示）。</p>\n<h3 id=\"3-重新设置-Enigma\"><a href=\"#3-重新设置-Enigma\" class=\"headerlink\" title=\"3. 重新设置 Enigma\"></a>3. 重新设置 Enigma</h3><p>接下来，发送者根据通信密码重新设置 Enigma。通信密码中的 3 个字母实际上代表了三个转子的初始位置。每一个转子的上面都印有字母，可以根据字母<br>来设置转子的初始位置。通信密码 psv 就表示需要将转子 1、2、3 分别转到 p、s、v 所对应的位置。</p>\n<h3 id=\"4-加密消息\"><a href=\"#4-加密消息\" class=\"headerlink\" title=\"4. 加密消息\"></a>4. 加密消息</h3><p>接下来，发送者对消息进行加密。发送者将明文逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。例如输入 nacht ，记录下对应的 KXNWP 。</p>\n<h3 id=\"5-拼接\"><a href=\"#5-拼接\" class=\"headerlink\" title=\"5. 拼接\"></a>5. 拼接</h3><p>接下来，发送者将“加密后的通信密码” ATCDVT 与 “加密后的消息” KXNWP 进行拼接，将 ATCDVTKXNWP 作为电文通过无线电发出。  </p>\n<p>上面就是用 Enigma 进行加密的操作步骤，看来还真是挺麻烦的。</p>\n<h2 id=\"4-5-每日密码与通信密码\"><a href=\"#4-5-每日密码与通信密码\" class=\"headerlink\" title=\"4.5 每日密码与通信密码\"></a>4.5 每日密码与通信密码</h2><p>每日密码在这里不是用来加密消息的，而是用来加密通信密码的。也就是说，每日密码是一种用来加密密钥的密钥，这种密钥，一般称为密钥加密密钥（Key Encrypting Key，KEY）。</p>\n<h2 id=\"4-6-避免通信错误\"><a href=\"#4-6-避免通信错误\" class=\"headerlink\" title=\"4.6 避免通信错误\"></a>4.6 避免通信错误</h2><p>在通信密码的加密中，我们需要将通信密码 psv 连续输入两次，即 psvpsv。这是因为接收者可以对通信密码进行校验，避免错误。</p>\n<h2 id=\"4-7-Enigma-的解密\"><a href=\"#4-7-Enigma-的解密\" class=\"headerlink\" title=\"4.7 Enigma 的解密\"></a>4.7 Enigma 的解密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_12.png\" alt=\"\">  </p>\n<h3 id=\"1-分解\"><a href=\"#1-分解\" class=\"headerlink\" title=\"1.分解\"></a>1.分解</h3><p>接收者将接受到的电文分解为两部分，即开头的 6 个字母 ATCDVT 和剩下的字母 KXNWP。</p>\n<h3 id=\"2-设置-Enigma\"><a href=\"#2-设置-Enigma\" class=\"headerlink\" title=\"2. 设置 Enigma\"></a>2. 设置 Enigma</h3><p>接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，这一步和发送者进行的操作是相同的。</p>\n<h3 id=\"3-解密通信密码\"><a href=\"#3-解密通信密码\" class=\"headerlink\" title=\"3. 解密通信密码\"></a>3. 解密通信密码</h3><p>接下来，接收者将加密后的通信密码 ATCDVT 进行解密。接收者在 Enigma 的键盘上输入 ATCDVT 这 6 个字母，然后将亮起的灯泡对应的字母 psvpsv 记下来。<br>因为是 psv 重复两次的形式，所以接收者可以判断在通信过程中没有发生错误。</p>\n<h3 id=\"4-重新设置-Enigma\"><a href=\"#4-重新设置-Enigma\" class=\"headerlink\" title=\"4. 重新设置 Enigma\"></a>4. 重新设置 Enigma</h3><p>接下来，接收者根据通信密码 psv 重新设置 Enigma。</p>\n<h3 id=\"5-解密消息\"><a href=\"#5-解密消息\" class=\"headerlink\" title=\"5. 解密消息\"></a>5. 解密消息</h3><p>接下里，接收者将电文中的剩余部分 KXNWP 逐一输入，将灯泡的结果记下来，得到了 nacht。</p>\n<h2 id=\"4-8-Enigma-的弱点\"><a href=\"#4-8-Enigma-的弱点\" class=\"headerlink\" title=\"4.8 Enigma 的弱点\"></a>4.8 Enigma 的弱点</h2><h3 id=\"1-将通信密码连续输入两次并加密\"><a href=\"#1-将通信密码连续输入两次并加密\" class=\"headerlink\" title=\"1. 将通信密码连续输入两次并加密\"></a>1. 将通信密码连续输入两次并加密</h3><p>这样密码破译者知道密文开头的 6 个字母被解密后的明文一定是 3 个字母重复两次的形式</p>\n<h3 id=\"2-通信密码是人为选定的\"><a href=\"#2-通信密码是人为选定的\" class=\"headerlink\" title=\"2. 通信密码是人为选定的\"></a>2. 通信密码是人为选定的</h3><p>有可能使用 aaa、bbb 或者生日，女朋友的名字当做密码。密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。</p>\n<h3 id=\"3-必须派发国防军密码本\"><a href=\"#3-必须派发国防军密码本\" class=\"headerlink\" title=\"3. 必须派发国防军密码本\"></a>3. 必须派发国防军密码本</h3><p>如果落到敌人手里，就会带来大麻烦。如果现在所使用的国防军密码本被敌人得到，哪怕只泄漏了一本，也必须重新制作新的密码本并发到全军。<br>必须配送密钥这个问题，将在第五章详解。</p>\n<h2 id=\"4-9-Enigma-的破译\"><a href=\"#4-9-Enigma-的破译\" class=\"headerlink\" title=\"4.9 Enigma 的破译\"></a>4.9 Enigma 的破译</h2><p>即使得到了 Enigma 的构造，但是由于 Enigma 的设计并不依赖于“隐蔽式安全性”，只要不知道 Enigma的设置（密钥），就无法破译密码。但是，<br>每日密码在一天之内不会变，即一天内截获的所有通信，都是用同一个密码进行加密的；以及通信密码都会重复两次。以 ATCDVT 为例，即知道第一个字母和<br>第四个字母，都是由相同的明文加密得到的；另外，由于一个轮子只有26个可能。最终经过了许多密码专家的破译，包括现代计算机之父阿兰图灵，最终破译了这个密码。</p>\n<h1 id=\"5-思考\"><a href=\"#5-思考\" class=\"headerlink\" title=\"5 思考\"></a>5 思考</h1><h2 id=\"5-1-为什么吗要将密码算法和密钥分开呢\"><a href=\"#5-1-为什么吗要将密码算法和密钥分开呢\" class=\"headerlink\" title=\"5.1 为什么吗要将密码算法和密钥分开呢\"></a>5.1 为什么吗要将密码算法和密钥分开呢</h2><p>我们来列举一下本章介绍过的密码系统的“密码算法”和“密钥”。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">密码系统</th>\n<th style=\"text-align:left\">密码算法</th>\n<th style=\"text-align:left\">密钥</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">凯撒密码</td>\n<td style=\"text-align:left\">将明文中的各个字母按照指定的字母数平移</td>\n<td style=\"text-align:left\">平移的字母数量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">简单替换密码</td>\n<td style=\"text-align:left\">按照替换表对字母表进行替换</td>\n<td style=\"text-align:left\">替换表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Enigma（通信密码的加密）</td>\n<td style=\"text-align:left\">使用Enigma密码机，通过接线板的接线方式、三个转子的顺序、每个转子的旋转位置对字母进行替换</td>\n<td style=\"text-align:left\">接线板的接线方式、转子的顺序、转子的旋转位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Enigma（通信电文的加密）</td>\n<td style=\"text-align:left\">使用接线板的接线方式和三个转子的顺序固定的Enigma密码机，按照每个转子的旋转位置对字母进行替换</td>\n<td style=\"text-align:left\">每个转子的旋转位置</td>\n</tr>\n</tbody>\n</table>\n<p>仔细研究一下每一对密码算法和密钥的组合就会发现，在密码算法中必然存在可变部分，而这些可变部分就相当于密钥。当密码算法和密钥都确定时，加密的方法也就确定了。<br>如果每次加密都必须产生一个新的密码算法，那真是太诡异了。对于已经开发出的一种密码算法，我们总是希望能够重复使用。  </p>\n<p>将密码算法和密钥分开的意义正在于此。密码算法是需要重复使用的，但在重复使用同一种算法的过程中，该算法被破译的可能性也在逐渐增大。因此，<br>我们就在密码算法中准备了一些可变部分，并在每次通信时都对这部分进行改变，而这一可变部分就是密钥。  </p>\n<p>将密码算法和密钥分开考虑，就解决了<strong>希望重复使用，但重复使用会增加风险</strong>这个难题。  </p>\n<p>密钥才是秘密的精华。因此，在密码技术中，如何管理密钥是一个重要的课题。这将在第十一章详解。  </p>\n<blockquote>\n<p>每个人都可以拥有相同品牌的锁，但每个人都有不同的钥匙。锁的设计师公开的——锁匠都带有详细图的书，而且绝大多数好的设计方案都在公开专利<br>中进行了描述——但是钥匙是秘密的。</p>\n</blockquote>\n<h1 id=\"6-本章小结\"><a href=\"#6-本章小结\" class=\"headerlink\" title=\"6 本章小结\"></a>6 本章小结</h1><p>密码系统：凯撒密码、简单替换密码以及 Enigma。<br>密码破译：暴力破解、字母频率分析。</p>\n<h1 id=\"7-小测验\"><a href=\"#7-小测验\" class=\"headerlink\" title=\"7 小测验\"></a>7 小测验</h1><ol>\n<li>凯撒密码中，如果存在如 c -&gt; C， q -&gt; Q这样，明文中的字母被替换成了相同字母的密文的情况。于是Alice就想：如果替换表中不出现这种被替换<br>为相同字母的情况，那么密文应该会更难被破译吧？请问 Alice 的想法正确吗？ </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>本章将介绍历史上几种著名的密码：</p>\n<ol>\n<li>凯撒密码</li>\n<li>简单替换密码</li>\n<li>Enigma  </li>\n</ol>\n<p>此外，还介绍两种破译密码的方法：</p>\n<ol>\n<li>暴力攻击</li>\n<li>频率分析  </li>\n</ol>\n<p>最后，我们还将思考密码算法与密钥之间的关系。<br>本章所介绍的密码在现在都已经不再适用了，但在寻找密码弱点的方法、破译密码的思路以及密码算法与密钥的关系等方面，这些密码与现在密码技术依然是相通的。</p>\n<h1 id=\"2-凯撒密码\"><a href=\"#2-凯撒密码\" class=\"headerlink\" title=\"2 凯撒密码\"></a>2 凯撒密码</h1><h2 id=\"2-1-什么是凯撒密码\"><a href=\"#2-1-什么是凯撒密码\" class=\"headerlink\" title=\"2.1 什么是凯撒密码\"></a>2.1 什么是凯撒密码</h2><p>凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_1.png\" alt=\"\"></p>\n<h2 id=\"2-2-凯撒密码的加密\"><a href=\"#2-2-凯撒密码的加密\" class=\"headerlink\" title=\"2.2 凯撒密码的加密\"></a>2.2 凯撒密码的加密</h2><p>例如，将 yoshiko 这个女性的名字，加密：<br>y -&gt; B<br>o -&gt; R<br>s -&gt; V<br>h -&gt; K<br>i -&gt; L<br>k -&gt; N<br>o -&gt; R<br>这样，明文 yoshiko 就被加密为了密文BRVKLNR。凯撒密码中，将字母表中的字母平移这个操作就是密码的算法，而平移的字母数量则相当于密钥。<br>在本例中，密钥为3：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_2.png\" alt=\"\"></p>\n<h2 id=\"2-3-凯撒密码的解密\"><a href=\"#2-3-凯撒密码的解密\" class=\"headerlink\" title=\"2.3 凯撒密码的解密\"></a>2.3 凯撒密码的解密</h2><p>我们只需要反向平移3个字母就可以解密了：<br>B -&gt; y<br>R -&gt; o<br>V -&gt; s<br>K -&gt; h<br>L -&gt; i<br>N -&gt; k<br>R -&gt; o<br>这样就得到了明文 yoshiko，但是密钥 3 必须由发送者和接受者事先约定好。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_3.png\" alt=\"\">  </p>\n<h2 id=\"2-4-用暴力破解来破译密码\"><a href=\"#2-4-用暴力破解来破译密码\" class=\"headerlink\" title=\"2.4 用暴力破解来破译密码\"></a>2.4 用暴力破解来破译密码</h2><p>通过上面的讲解，我们知道对于发送者用凯撒密码加密过的密文，接受者是能够进行解密的，但是接受者以为的人在看到密文 BRVKLNR ，是否能够进行破译<br>得到明文呢？在凯撒密码中，密钥就是字母表平移的字数。因此可以按顺序将这 26 种密钥都尝试一遍：<br>BRVKLNR -&gt; 用密钥 0 解密 -&gt; brvklnr<br>BRVKLNR -&gt; 用密钥 1 解密 -&gt; aqujkmq<br>BRVKLNR -&gt; 用密钥 2 解密 -&gt; zptijlp<br>BRVKLNR -&gt; 用密钥 3 解密 -&gt; yoshiko<br>……<br>BRVKLNR -&gt; 用密钥 25 解密 -&gt; cswlmos<br>尝试一遍都，发现当密钥为 3 时，可以解密出有意义的字符串 yoshiko 。这就意味着我们仅仅根据密文就推测除了密钥和明文，这样的密码有什么用呢？<br>凯撒密码实在是太脆弱了，无法保护重要的密码。  </p>\n<p>上面介绍的这种密码破译方法，就是讲所有可能的密钥全部尝试一遍，这种方法称为暴力破解（brute-force attack）。由于这种方法的本质是从所有的密钥<br>中找出正确的密钥，因此又称为穷举搜索（exhausive search）。  </p>\n<h1 id=\"3-简单替换密码\"><a href=\"#3-简单替换密码\" class=\"headerlink\" title=\"3 简单替换密码\"></a>3 简单替换密码</h1><h2 id=\"3-1-什么是简单替换密码\"><a href=\"#3-1-什么是简单替换密码\" class=\"headerlink\" title=\"3.1 什么是简单替换密码\"></a>3.1 什么是简单替换密码</h2><p>将明文中所使用的字母表替换为另一套字母表的密码，如下图就是一个简单替换密码的对应表：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_4.png\" alt=\"\"></p>\n<h2 id=\"3-2-简单替换密码的加密\"><a href=\"#3-2-简单替换密码的加密\" class=\"headerlink\" title=\"3.2 简单替换密码的加密\"></a>3.2 简单替换密码的加密</h2><p>按照上图的替换表，对明文 yoshiko　进行加密：<br>y -&gt; K<br>o -&gt; B<br>s -&gt; L<br>h -&gt; T<br>i -&gt; J<br>k -&gt; S<br>o -&gt; B<br>就得到密文：KBLTJSB。</p>\n<h2 id=\"3-3-简单替换密码的解密\"><a href=\"#3-3-简单替换密码的解密\" class=\"headerlink\" title=\"3.3 简单替换密码的解密\"></a>3.3 简单替换密码的解密</h2><p>需要根据使用的替换表进行解密。</p>\n<h2 id=\"3-4-简单替换密码的密钥空间\"><a href=\"#3-4-简单替换密码的密钥空间\" class=\"headerlink\" title=\"3.4 简单替换密码的密钥空间\"></a>3.4 简单替换密码的密钥空间</h2><p>yoshiko 用凯撒密码（密钥为 3 ）加密后的密文是 BRVKLNR ，二用简单替换密码（密钥为上图）加密后的密文则是 KBLTJSB。单从密文上来看，我们无法<br>判断出凯撒密码和简单替换密码到底哪一种更难破解。  </p>\n<p><strong>凯撒密码可以通过暴力破解来破译，但简单替换密码很难通过暴力破解来破译</strong>。这是因为简单替换密码中可以使用的密钥数量，比凯撒密码要多得多。  </p>\n<p>为了确定这一点，我们计算一下简单替换密码中可以使用的密钥总数。一种密码能够使用的“所有密钥的集合”称为密钥空间（keyspace），所有可用密钥的总数就是密钥空间的<br>大小。密钥空间越大，暴力破解就越困难。  </p>\n<p>简单替换密码中，明文字母表中的 a 可以对应A，B，C，…，Z 这 26 个字母中的任意一个，b 可以对应除了 a 所对应的字母以为的剩余 25 个字母中的任意一个。<br>以此类推，我们可以计算出简单替换密码的密钥总数为：<br>26 * 25 * 24 * 23 * … * 1 = 403291461126605635584000000<br>即使美妙能够遍历 10 亿个密钥，也要花费 120 亿年的时间。</p>\n<h2 id=\"3-5-用频率分析来破译密码\"><a href=\"#3-5-用频率分析来破译密码\" class=\"headerlink\" title=\"3.5 用频率分析来破译密码\"></a>3.5 用频率分析来破译密码</h2><p>频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。例如：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_5.png\" alt=\"\">  </p>\n<p>首先，我们统一一下这段密文中<strong>每个字母出现的频率</strong>：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_6.png\" alt=\"\">  </p>\n<p>为了找到破译的线索，我们再来看一下英语文章中所使用的字母的频率，一般的英语文章中出现频率最高的字母是 e 。而上图中出现频率最高的两个字母是 I 和 Y，<br>我们假设它们中的其中一个是 e 。然后将密文中的 Y 全部替换成 e ，替换后的密文如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_7.png\" alt=\"\"><br>英语中出现最多的单词是 the ，因此我们可以寻找一下以 e 结尾的 3 个字母的组合，结果我们发现 MEe 这3个字母的组合是最常出现的，而且 MEe 出现在<br>密文的开头，因此 MEe 很可能就是 the 。于是，我们再假设 M -&gt; t，E -&gt; h。得到如下图的表：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_8.png\" alt=\"\"><br>让我们动员自己所有的英文词汇，在上面的文字中继续寻找可能的组合。我们发现中间有一个词 thPee 比较可以，这个词不会就是 three 吧（P -&gt; r）？<br>除了高频字母以外，密文中的低频字母 Q 也可以找到一些相关的组合。直到得到最后通顺的明文，有以下结论：</p>\n<ul>\n<li>除了高频字母以外，低频字母也能够成为线索。</li>\n<li>搞清开头和结尾能够称为线索，搞清单词之间的分隔也能够成为线索。</li>\n<li>密文越长越容易破译。</li>\n<li>同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）。</li>\n<li>破译的速度会越来越快。</li>\n</ul>\n<h1 id=\"4-Enigma\"><a href=\"#4-Enigma\" class=\"headerlink\" title=\"4 Enigma\"></a>4 Enigma</h1><h2 id=\"4-1-什么是-Enigma\"><a href=\"#4-1-什么是-Enigma\" class=\"headerlink\" title=\"4.1 什么是 Enigma\"></a>4.1 什么是 Enigma</h2><p>Enigma 是由德国人于 20 世纪初发明的一种能够进行加密与解密操作的机器。Enigma 这个名字在德语里是“谜”的意思。</p>\n<h2 id=\"4-2-用-Enigma-进行加密通信\"><a href=\"#4-2-用-Enigma-进行加密通信\" class=\"headerlink\" title=\"4.2 用 Enigma 进行加密通信\"></a>4.2 用 Enigma 进行加密通信</h2><p>Enigma 是一种由键盘、齿轮、电池和灯泡所组成的机器，通过这一台机器就可以完成加密和解密两种操作。  </p>\n<p>发送者和接收者各自拥有一台 Enigma。发送者用 Enigma 将明文加密，将生成的密文通过无线电发送给接收者。接收者将接收到的密文用自己的 Enigma 解密。  </p>\n<p>由于发送者和接收者必须使用相同的密钥才能完成密码通信，因此发送者和接收者会事先收到一份叫<strong>国防军密码本</strong>的册子。发送者和接收者按照册子指示来设置 Enigma。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_9.png\" alt=\"\"></p>\n<h2 id=\"4-3-Enigma-的构造\"><a href=\"#4-3-Enigma-的构造\" class=\"headerlink\" title=\"4.3 Enigma 的构造\"></a>4.3 Enigma 的构造</h2><p>Enigma 的构造如下图。它能对字母表中的 26 个字母进行加密和解密操作，这里将字母的数量简化为 4 个：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_10.png\" alt=\"\"><br>每当按下 Enigma 上的一个键，就会点亮一个灯泡。而接线板和轮子在每次输入的时候都会变化，这样的组合让 Enigma 看起来像是一个能够动态变化的操作。</p>\n<h2 id=\"4-4-Enigma-的加密\"><a href=\"#4-4-Enigma-的加密\" class=\"headerlink\" title=\"4.4 Enigma 的加密\"></a>4.4 Enigma 的加密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_11.png\" alt=\"\"><br>在进行通信之前，发送者金和接收者双方都需要持有国防军密码本，国防军密码本中记载了发送者和接收者需要使用的每日密码。</p>\n<h3 id=\"1-设置-Enigma\"><a href=\"#1-设置-Enigma\" class=\"headerlink\" title=\"1.设置 Enigma\"></a>1.设置 Enigma</h3><p>发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。具体来说，就是接线板和转子排列。</p>\n<h3 id=\"2-加密通信密码\"><a href=\"#2-加密通信密码\" class=\"headerlink\" title=\"2. 加密通信密码\"></a>2. 加密通信密码</h3><p>接下来，发送者需要想出 3 个字母，并将其加密。这 3 个字母称为通信密码。<br>通信密码的加密也是通过 Enigma 完成的。假设发送者选择的通信密码为 psv，则发送者需要在 Enigma 的键盘上输入两次该通信密码，也就是说需要输入<br>psvpsv 这 6 个字母。  </p>\n<p>发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输入全部 6 个字母之后，发送者就记下了它们所对应的密文，<br>假设密文是 ATCDVT（密文用大写字母来表示）。</p>\n<h3 id=\"3-重新设置-Enigma\"><a href=\"#3-重新设置-Enigma\" class=\"headerlink\" title=\"3. 重新设置 Enigma\"></a>3. 重新设置 Enigma</h3><p>接下来，发送者根据通信密码重新设置 Enigma。通信密码中的 3 个字母实际上代表了三个转子的初始位置。每一个转子的上面都印有字母，可以根据字母<br>来设置转子的初始位置。通信密码 psv 就表示需要将转子 1、2、3 分别转到 p、s、v 所对应的位置。</p>\n<h3 id=\"4-加密消息\"><a href=\"#4-加密消息\" class=\"headerlink\" title=\"4. 加密消息\"></a>4. 加密消息</h3><p>接下来，发送者对消息进行加密。发送者将明文逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。例如输入 nacht ，记录下对应的 KXNWP 。</p>\n<h3 id=\"5-拼接\"><a href=\"#5-拼接\" class=\"headerlink\" title=\"5. 拼接\"></a>5. 拼接</h3><p>接下来，发送者将“加密后的通信密码” ATCDVT 与 “加密后的消息” KXNWP 进行拼接，将 ATCDVTKXNWP 作为电文通过无线电发出。  </p>\n<p>上面就是用 Enigma 进行加密的操作步骤，看来还真是挺麻烦的。</p>\n<h2 id=\"4-5-每日密码与通信密码\"><a href=\"#4-5-每日密码与通信密码\" class=\"headerlink\" title=\"4.5 每日密码与通信密码\"></a>4.5 每日密码与通信密码</h2><p>每日密码在这里不是用来加密消息的，而是用来加密通信密码的。也就是说，每日密码是一种用来加密密钥的密钥，这种密钥，一般称为密钥加密密钥（Key Encrypting Key，KEY）。</p>\n<h2 id=\"4-6-避免通信错误\"><a href=\"#4-6-避免通信错误\" class=\"headerlink\" title=\"4.6 避免通信错误\"></a>4.6 避免通信错误</h2><p>在通信密码的加密中，我们需要将通信密码 psv 连续输入两次，即 psvpsv。这是因为接收者可以对通信密码进行校验，避免错误。</p>\n<h2 id=\"4-7-Enigma-的解密\"><a href=\"#4-7-Enigma-的解密\" class=\"headerlink\" title=\"4.7 Enigma 的解密\"></a>4.7 Enigma 的解密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_12.png\" alt=\"\">  </p>\n<h3 id=\"1-分解\"><a href=\"#1-分解\" class=\"headerlink\" title=\"1.分解\"></a>1.分解</h3><p>接收者将接受到的电文分解为两部分，即开头的 6 个字母 ATCDVT 和剩下的字母 KXNWP。</p>\n<h3 id=\"2-设置-Enigma\"><a href=\"#2-设置-Enigma\" class=\"headerlink\" title=\"2. 设置 Enigma\"></a>2. 设置 Enigma</h3><p>接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，这一步和发送者进行的操作是相同的。</p>\n<h3 id=\"3-解密通信密码\"><a href=\"#3-解密通信密码\" class=\"headerlink\" title=\"3. 解密通信密码\"></a>3. 解密通信密码</h3><p>接下来，接收者将加密后的通信密码 ATCDVT 进行解密。接收者在 Enigma 的键盘上输入 ATCDVT 这 6 个字母，然后将亮起的灯泡对应的字母 psvpsv 记下来。<br>因为是 psv 重复两次的形式，所以接收者可以判断在通信过程中没有发生错误。</p>\n<h3 id=\"4-重新设置-Enigma\"><a href=\"#4-重新设置-Enigma\" class=\"headerlink\" title=\"4. 重新设置 Enigma\"></a>4. 重新设置 Enigma</h3><p>接下来，接收者根据通信密码 psv 重新设置 Enigma。</p>\n<h3 id=\"5-解密消息\"><a href=\"#5-解密消息\" class=\"headerlink\" title=\"5. 解密消息\"></a>5. 解密消息</h3><p>接下里，接收者将电文中的剩余部分 KXNWP 逐一输入，将灯泡的结果记下来，得到了 nacht。</p>\n<h2 id=\"4-8-Enigma-的弱点\"><a href=\"#4-8-Enigma-的弱点\" class=\"headerlink\" title=\"4.8 Enigma 的弱点\"></a>4.8 Enigma 的弱点</h2><h3 id=\"1-将通信密码连续输入两次并加密\"><a href=\"#1-将通信密码连续输入两次并加密\" class=\"headerlink\" title=\"1. 将通信密码连续输入两次并加密\"></a>1. 将通信密码连续输入两次并加密</h3><p>这样密码破译者知道密文开头的 6 个字母被解密后的明文一定是 3 个字母重复两次的形式</p>\n<h3 id=\"2-通信密码是人为选定的\"><a href=\"#2-通信密码是人为选定的\" class=\"headerlink\" title=\"2. 通信密码是人为选定的\"></a>2. 通信密码是人为选定的</h3><p>有可能使用 aaa、bbb 或者生日，女朋友的名字当做密码。密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。</p>\n<h3 id=\"3-必须派发国防军密码本\"><a href=\"#3-必须派发国防军密码本\" class=\"headerlink\" title=\"3. 必须派发国防军密码本\"></a>3. 必须派发国防军密码本</h3><p>如果落到敌人手里，就会带来大麻烦。如果现在所使用的国防军密码本被敌人得到，哪怕只泄漏了一本，也必须重新制作新的密码本并发到全军。<br>必须配送密钥这个问题，将在第五章详解。</p>\n<h2 id=\"4-9-Enigma-的破译\"><a href=\"#4-9-Enigma-的破译\" class=\"headerlink\" title=\"4.9 Enigma 的破译\"></a>4.9 Enigma 的破译</h2><p>即使得到了 Enigma 的构造，但是由于 Enigma 的设计并不依赖于“隐蔽式安全性”，只要不知道 Enigma的设置（密钥），就无法破译密码。但是，<br>每日密码在一天之内不会变，即一天内截获的所有通信，都是用同一个密码进行加密的；以及通信密码都会重复两次。以 ATCDVT 为例，即知道第一个字母和<br>第四个字母，都是由相同的明文加密得到的；另外，由于一个轮子只有26个可能。最终经过了许多密码专家的破译，包括现代计算机之父阿兰图灵，最终破译了这个密码。</p>\n<h1 id=\"5-思考\"><a href=\"#5-思考\" class=\"headerlink\" title=\"5 思考\"></a>5 思考</h1><h2 id=\"5-1-为什么吗要将密码算法和密钥分开呢\"><a href=\"#5-1-为什么吗要将密码算法和密钥分开呢\" class=\"headerlink\" title=\"5.1 为什么吗要将密码算法和密钥分开呢\"></a>5.1 为什么吗要将密码算法和密钥分开呢</h2><p>我们来列举一下本章介绍过的密码系统的“密码算法”和“密钥”。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">密码系统</th>\n<th style=\"text-align:left\">密码算法</th>\n<th style=\"text-align:left\">密钥</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">凯撒密码</td>\n<td style=\"text-align:left\">将明文中的各个字母按照指定的字母数平移</td>\n<td style=\"text-align:left\">平移的字母数量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">简单替换密码</td>\n<td style=\"text-align:left\">按照替换表对字母表进行替换</td>\n<td style=\"text-align:left\">替换表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Enigma（通信密码的加密）</td>\n<td style=\"text-align:left\">使用Enigma密码机，通过接线板的接线方式、三个转子的顺序、每个转子的旋转位置对字母进行替换</td>\n<td style=\"text-align:left\">接线板的接线方式、转子的顺序、转子的旋转位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Enigma（通信电文的加密）</td>\n<td style=\"text-align:left\">使用接线板的接线方式和三个转子的顺序固定的Enigma密码机，按照每个转子的旋转位置对字母进行替换</td>\n<td style=\"text-align:left\">每个转子的旋转位置</td>\n</tr>\n</tbody>\n</table>\n<p>仔细研究一下每一对密码算法和密钥的组合就会发现，在密码算法中必然存在可变部分，而这些可变部分就相当于密钥。当密码算法和密钥都确定时，加密的方法也就确定了。<br>如果每次加密都必须产生一个新的密码算法，那真是太诡异了。对于已经开发出的一种密码算法，我们总是希望能够重复使用。  </p>\n<p>将密码算法和密钥分开的意义正在于此。密码算法是需要重复使用的，但在重复使用同一种算法的过程中，该算法被破译的可能性也在逐渐增大。因此，<br>我们就在密码算法中准备了一些可变部分，并在每次通信时都对这部分进行改变，而这一可变部分就是密钥。  </p>\n<p>将密码算法和密钥分开考虑，就解决了<strong>希望重复使用，但重复使用会增加风险</strong>这个难题。  </p>\n<p>密钥才是秘密的精华。因此，在密码技术中，如何管理密钥是一个重要的课题。这将在第十一章详解。  </p>\n<blockquote>\n<p>每个人都可以拥有相同品牌的锁，但每个人都有不同的钥匙。锁的设计师公开的——锁匠都带有详细图的书，而且绝大多数好的设计方案都在公开专利<br>中进行了描述——但是钥匙是秘密的。</p>\n</blockquote>\n<h1 id=\"6-本章小结\"><a href=\"#6-本章小结\" class=\"headerlink\" title=\"6 本章小结\"></a>6 本章小结</h1><p>密码系统：凯撒密码、简单替换密码以及 Enigma。<br>密码破译：暴力破解、字母频率分析。</p>\n<h1 id=\"7-小测验\"><a href=\"#7-小测验\" class=\"headerlink\" title=\"7 小测验\"></a>7 小测验</h1><ol>\n<li>凯撒密码中，如果存在如 c -&gt; C， q -&gt; Q这样，明文中的字母被替换成了相同字母的密文的情况。于是Alice就想：如果替换表中不出现这种被替换<br>为相同字母的情况，那么密文应该会更难被破译吧？请问 Alice 的想法正确吗？ </li>\n</ol>\n"},{"title":"六、混合密码系统","date":"2017-11-17T18:38:00.000Z","updated":"2017-11-18T09:03:00.000Z","comments":1,"_content":"\n# 1 混合动力汽车\n\n在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。  \n电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。\n当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。  \n  \n混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。\n\n# 2 本章概要\n\n本章将学习由对称密码和公钥密码相结合的混合密码系统。  \n  \n混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。\n\n# 3 混合密码系统\n\n# 3.1 对称密码和公钥密码\n\n对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题：  \n1. 公钥密码的处理速度远远低于对称密码\n2. 公钥密码难以抵御中间人攻击  \n  \n本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍\n\n## 3.2 混合密码系统\n\n1. 用对称密码加密信息\n2. 通过伪随机数生成器生成对称密码的会话秘钥\n3. 通过公钥密码加密会话秘钥\n4. 从混合密码系统外部赋予公钥密码加密时使用的秘钥\n  \n混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。  \n即利用了对称密码的解密速度，公钥密码的机密性。  \n![][1]\n\n## 3.3 加密\n\n流程图如下：  \n![][2]  \n  \n### 1. 明文、秘钥、密文\n首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。  \n上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和\n“用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。\n\n### 2. 加密消息\n中间的大虚线方框分成左右两部分。  \n右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。  \n消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。\n这就是右半部分所进行的处理。\n\n### 3. 加密会话秘钥\n左半部分进行的是会话秘钥的生成和加密操作。  \n会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分，\n作为对称密码的秘钥使用。  \n接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。  \n  \n**会话秘钥是对称密码的秘钥，同时也是公钥密码的明文**。请大家一定要理解会话秘钥的双重性！\n\n### 4. 组合\n如何上面的内容都理解了，剩下的就简单多了。  \n我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。  \n组合之后的数据就是混合密码系统整体的密文。\n\n## 3.4 解密\n\n流程图如下：  \n![][3]\n\n### 1. 分离\n只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。\n\n### 2. 解密会话秘钥\n会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。  \n解密后的会话秘钥将被用作解密消息的秘钥。\n\n### 3. 解密消息\n消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。  \n上述流程正好是“混合密码系统的加密”的逆操作。\n\n## 3.5 混合密码系统的具体例子\n\n混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。  \n著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。\n\n# 4 怎样才是高强度的混合密码系统\n\n## 4.1 伪随机数生成器\n\n混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。  \n会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的\n攻击方法，将在第十二章详解。\n\n## 4.2 对称密码\n\n混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。\n\n## 4.3 公钥密码\n\n混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。\n\n## 4.4 秘钥长度的平衡\n\n对称密码和公钥密码的秘钥长度必须具备同等的强度。  \n然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。  \n![][4]\n\n# 5 密码技术的组合\n\n本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。  \n例如，第四章中介绍的**分组密码模式**，就是将只能加密固定长度的数据的\b分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。  \n  \n**三重 DES**是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。  \n  \n对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。  \n在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。  \n  \n数字签名，是由单向散列函数和公钥密码组合而成的。  \n证书，是由公钥和数字签名组合而成的。  \n消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。  \n伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。  \n还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。\n\n# 6 本章小结\n\n\b本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。  \n到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。  \n从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。\n\n# 7 小测验\n\n1. 混合密码系统是用对称密码对消息进行加密的。\n2. 混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。\n3. 由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。\n4. 混合密码系统的解密过程是按照“公钥密码解密”->“对称密码解密”的顺序来进行处理的。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_4.png","source":"_posts/图解密码技术/第六章 混合密码系统.md","raw":"---\ntitle: 六、混合密码系统\ndate: 2017-11-18 02:38:00\nupdated: 2017-11-18 17:03:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/6.html    \n---\n\n# 1 混合动力汽车\n\n在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。  \n电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。\n当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。  \n  \n混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。\n\n# 2 本章概要\n\n本章将学习由对称密码和公钥密码相结合的混合密码系统。  \n  \n混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。\n\n# 3 混合密码系统\n\n# 3.1 对称密码和公钥密码\n\n对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题：  \n1. 公钥密码的处理速度远远低于对称密码\n2. 公钥密码难以抵御中间人攻击  \n  \n本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍\n\n## 3.2 混合密码系统\n\n1. 用对称密码加密信息\n2. 通过伪随机数生成器生成对称密码的会话秘钥\n3. 通过公钥密码加密会话秘钥\n4. 从混合密码系统外部赋予公钥密码加密时使用的秘钥\n  \n混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。  \n即利用了对称密码的解密速度，公钥密码的机密性。  \n![][1]\n\n## 3.3 加密\n\n流程图如下：  \n![][2]  \n  \n### 1. 明文、秘钥、密文\n首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。  \n上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和\n“用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。\n\n### 2. 加密消息\n中间的大虚线方框分成左右两部分。  \n右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。  \n消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。\n这就是右半部分所进行的处理。\n\n### 3. 加密会话秘钥\n左半部分进行的是会话秘钥的生成和加密操作。  \n会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分，\n作为对称密码的秘钥使用。  \n接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。  \n  \n**会话秘钥是对称密码的秘钥，同时也是公钥密码的明文**。请大家一定要理解会话秘钥的双重性！\n\n### 4. 组合\n如何上面的内容都理解了，剩下的就简单多了。  \n我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。  \n组合之后的数据就是混合密码系统整体的密文。\n\n## 3.4 解密\n\n流程图如下：  \n![][3]\n\n### 1. 分离\n只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。\n\n### 2. 解密会话秘钥\n会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。  \n解密后的会话秘钥将被用作解密消息的秘钥。\n\n### 3. 解密消息\n消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。  \n上述流程正好是“混合密码系统的加密”的逆操作。\n\n## 3.5 混合密码系统的具体例子\n\n混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。  \n著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。\n\n# 4 怎样才是高强度的混合密码系统\n\n## 4.1 伪随机数生成器\n\n混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。  \n会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的\n攻击方法，将在第十二章详解。\n\n## 4.2 对称密码\n\n混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。\n\n## 4.3 公钥密码\n\n混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。\n\n## 4.4 秘钥长度的平衡\n\n对称密码和公钥密码的秘钥长度必须具备同等的强度。  \n然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。  \n![][4]\n\n# 5 密码技术的组合\n\n本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。  \n例如，第四章中介绍的**分组密码模式**，就是将只能加密固定长度的数据的\b分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。  \n  \n**三重 DES**是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。  \n  \n对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。  \n在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。  \n  \n数字签名，是由单向散列函数和公钥密码组合而成的。  \n证书，是由公钥和数字签名组合而成的。  \n消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。  \n伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。  \n还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。\n\n# 6 本章小结\n\n\b本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。  \n到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。  \n从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。\n\n# 7 小测验\n\n1. 混合密码系统是用对称密码对消息进行加密的。\n2. 混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。\n3. 由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。\n4. 混合密码系统的解密过程是按照“公钥密码解密”->“对称密码解密”的顺序来进行处理的。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_4.png","slug":"graphic2cryptography/6.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavu002jaxs62ehcftas","content":"<h1 id=\"1-混合动力汽车\"><a href=\"#1-混合动力汽车\" class=\"headerlink\" title=\"1 混合动力汽车\"></a>1 混合动力汽车</h1><p>在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。<br>电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。<br>当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。  </p>\n<p>混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>本章将学习由对称密码和公钥密码相结合的混合密码系统。  </p>\n<p>混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。</p>\n<h1 id=\"3-混合密码系统\"><a href=\"#3-混合密码系统\" class=\"headerlink\" title=\"3 混合密码系统\"></a>3 混合密码系统</h1><h1 id=\"3-1-对称密码和公钥密码\"><a href=\"#3-1-对称密码和公钥密码\" class=\"headerlink\" title=\"3.1 对称密码和公钥密码\"></a>3.1 对称密码和公钥密码</h1><p>对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题：  </p>\n<ol>\n<li>公钥密码的处理速度远远低于对称密码</li>\n<li>公钥密码难以抵御中间人攻击  </li>\n</ol>\n<p>本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍</p>\n<h2 id=\"3-2-混合密码系统\"><a href=\"#3-2-混合密码系统\" class=\"headerlink\" title=\"3.2 混合密码系统\"></a>3.2 混合密码系统</h2><ol>\n<li>用对称密码加密信息</li>\n<li>通过伪随机数生成器生成对称密码的会话秘钥</li>\n<li>通过公钥密码加密会话秘钥</li>\n<li>从混合密码系统外部赋予公钥密码加密时使用的秘钥</li>\n</ol>\n<p>混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。<br>即利用了对称密码的解密速度，公钥密码的机密性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_1.png\" alt=\"\"></p>\n<h2 id=\"3-3-加密\"><a href=\"#3-3-加密\" class=\"headerlink\" title=\"3.3 加密\"></a>3.3 加密</h2><p>流程图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_2.png\" alt=\"\">  </p>\n<h3 id=\"1-明文、秘钥、密文\"><a href=\"#1-明文、秘钥、密文\" class=\"headerlink\" title=\"1. 明文、秘钥、密文\"></a>1. 明文、秘钥、密文</h3><p>首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。<br>上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和<br>“用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。</p>\n<h3 id=\"2-加密消息\"><a href=\"#2-加密消息\" class=\"headerlink\" title=\"2. 加密消息\"></a>2. 加密消息</h3><p>中间的大虚线方框分成左右两部分。<br>右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。<br>消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。<br>这就是右半部分所进行的处理。</p>\n<h3 id=\"3-加密会话秘钥\"><a href=\"#3-加密会话秘钥\" class=\"headerlink\" title=\"3. 加密会话秘钥\"></a>3. 加密会话秘钥</h3><p>左半部分进行的是会话秘钥的生成和加密操作。<br>会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分，<br>作为对称密码的秘钥使用。<br>接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。  </p>\n<p><strong>会话秘钥是对称密码的秘钥，同时也是公钥密码的明文</strong>。请大家一定要理解会话秘钥的双重性！</p>\n<h3 id=\"4-组合\"><a href=\"#4-组合\" class=\"headerlink\" title=\"4. 组合\"></a>4. 组合</h3><p>如何上面的内容都理解了，剩下的就简单多了。<br>我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。<br>组合之后的数据就是混合密码系统整体的密文。</p>\n<h2 id=\"3-4-解密\"><a href=\"#3-4-解密\" class=\"headerlink\" title=\"3.4 解密\"></a>3.4 解密</h2><p>流程图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_3.png\" alt=\"\"></p>\n<h3 id=\"1-分离\"><a href=\"#1-分离\" class=\"headerlink\" title=\"1. 分离\"></a>1. 分离</h3><p>只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。</p>\n<h3 id=\"2-解密会话秘钥\"><a href=\"#2-解密会话秘钥\" class=\"headerlink\" title=\"2. 解密会话秘钥\"></a>2. 解密会话秘钥</h3><p>会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。<br>解密后的会话秘钥将被用作解密消息的秘钥。</p>\n<h3 id=\"3-解密消息\"><a href=\"#3-解密消息\" class=\"headerlink\" title=\"3. 解密消息\"></a>3. 解密消息</h3><p>消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。<br>上述流程正好是“混合密码系统的加密”的逆操作。</p>\n<h2 id=\"3-5-混合密码系统的具体例子\"><a href=\"#3-5-混合密码系统的具体例子\" class=\"headerlink\" title=\"3.5 混合密码系统的具体例子\"></a>3.5 混合密码系统的具体例子</h2><p>混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。<br>著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。</p>\n<h1 id=\"4-怎样才是高强度的混合密码系统\"><a href=\"#4-怎样才是高强度的混合密码系统\" class=\"headerlink\" title=\"4 怎样才是高强度的混合密码系统\"></a>4 怎样才是高强度的混合密码系统</h1><h2 id=\"4-1-伪随机数生成器\"><a href=\"#4-1-伪随机数生成器\" class=\"headerlink\" title=\"4.1 伪随机数生成器\"></a>4.1 伪随机数生成器</h2><p>混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。<br>会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的<br>攻击方法，将在第十二章详解。</p>\n<h2 id=\"4-2-对称密码\"><a href=\"#4-2-对称密码\" class=\"headerlink\" title=\"4.2 对称密码\"></a>4.2 对称密码</h2><p>混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。</p>\n<h2 id=\"4-3-公钥密码\"><a href=\"#4-3-公钥密码\" class=\"headerlink\" title=\"4.3 公钥密码\"></a>4.3 公钥密码</h2><p>混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。</p>\n<h2 id=\"4-4-秘钥长度的平衡\"><a href=\"#4-4-秘钥长度的平衡\" class=\"headerlink\" title=\"4.4 秘钥长度的平衡\"></a>4.4 秘钥长度的平衡</h2><p>对称密码和公钥密码的秘钥长度必须具备同等的强度。<br>然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_4.png\" alt=\"\"></p>\n<h1 id=\"5-密码技术的组合\"><a href=\"#5-密码技术的组合\" class=\"headerlink\" title=\"5 密码技术的组合\"></a>5 密码技术的组合</h1><p>本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。<br>例如，第四章中介绍的<strong>分组密码模式</strong>，就是将只能加密固定长度的数据的\b分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。  </p>\n<p><strong>三重 DES</strong>是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。  </p>\n<p>对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。<br>在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。  </p>\n<p>数字签名，是由单向散列函数和公钥密码组合而成的。<br>证书，是由公钥和数字签名组合而成的。<br>消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。<br>伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。<br>还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。</p>\n<h1 id=\"6-本章小结\"><a href=\"#6-本章小结\" class=\"headerlink\" title=\"6 本章小结\"></a>6 本章小结</h1><p>\b本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。<br>到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。<br>从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。</p>\n<h1 id=\"7-小测验\"><a href=\"#7-小测验\" class=\"headerlink\" title=\"7 小测验\"></a>7 小测验</h1><ol>\n<li>混合密码系统是用对称密码对消息进行加密的。</li>\n<li>混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。</li>\n<li>由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。</li>\n<li>混合密码系统的解密过程是按照“公钥密码解密”-&gt;“对称密码解密”的顺序来进行处理的。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-混合动力汽车\"><a href=\"#1-混合动力汽车\" class=\"headerlink\" title=\"1 混合动力汽车\"></a>1 混合动力汽车</h1><p>在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。<br>电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。<br>当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。  </p>\n<p>混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>本章将学习由对称密码和公钥密码相结合的混合密码系统。  </p>\n<p>混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。</p>\n<h1 id=\"3-混合密码系统\"><a href=\"#3-混合密码系统\" class=\"headerlink\" title=\"3 混合密码系统\"></a>3 混合密码系统</h1><h1 id=\"3-1-对称密码和公钥密码\"><a href=\"#3-1-对称密码和公钥密码\" class=\"headerlink\" title=\"3.1 对称密码和公钥密码\"></a>3.1 对称密码和公钥密码</h1><p>对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题：  </p>\n<ol>\n<li>公钥密码的处理速度远远低于对称密码</li>\n<li>公钥密码难以抵御中间人攻击  </li>\n</ol>\n<p>本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍</p>\n<h2 id=\"3-2-混合密码系统\"><a href=\"#3-2-混合密码系统\" class=\"headerlink\" title=\"3.2 混合密码系统\"></a>3.2 混合密码系统</h2><ol>\n<li>用对称密码加密信息</li>\n<li>通过伪随机数生成器生成对称密码的会话秘钥</li>\n<li>通过公钥密码加密会话秘钥</li>\n<li>从混合密码系统外部赋予公钥密码加密时使用的秘钥</li>\n</ol>\n<p>混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。<br>即利用了对称密码的解密速度，公钥密码的机密性。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_1.png\" alt=\"\"></p>\n<h2 id=\"3-3-加密\"><a href=\"#3-3-加密\" class=\"headerlink\" title=\"3.3 加密\"></a>3.3 加密</h2><p>流程图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_2.png\" alt=\"\">  </p>\n<h3 id=\"1-明文、秘钥、密文\"><a href=\"#1-明文、秘钥、密文\" class=\"headerlink\" title=\"1. 明文、秘钥、密文\"></a>1. 明文、秘钥、密文</h3><p>首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。<br>上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和<br>“用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。</p>\n<h3 id=\"2-加密消息\"><a href=\"#2-加密消息\" class=\"headerlink\" title=\"2. 加密消息\"></a>2. 加密消息</h3><p>中间的大虚线方框分成左右两部分。<br>右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。<br>消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。<br>这就是右半部分所进行的处理。</p>\n<h3 id=\"3-加密会话秘钥\"><a href=\"#3-加密会话秘钥\" class=\"headerlink\" title=\"3. 加密会话秘钥\"></a>3. 加密会话秘钥</h3><p>左半部分进行的是会话秘钥的生成和加密操作。<br>会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分，<br>作为对称密码的秘钥使用。<br>接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。  </p>\n<p><strong>会话秘钥是对称密码的秘钥，同时也是公钥密码的明文</strong>。请大家一定要理解会话秘钥的双重性！</p>\n<h3 id=\"4-组合\"><a href=\"#4-组合\" class=\"headerlink\" title=\"4. 组合\"></a>4. 组合</h3><p>如何上面的内容都理解了，剩下的就简单多了。<br>我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。<br>组合之后的数据就是混合密码系统整体的密文。</p>\n<h2 id=\"3-4-解密\"><a href=\"#3-4-解密\" class=\"headerlink\" title=\"3.4 解密\"></a>3.4 解密</h2><p>流程图如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_3.png\" alt=\"\"></p>\n<h3 id=\"1-分离\"><a href=\"#1-分离\" class=\"headerlink\" title=\"1. 分离\"></a>1. 分离</h3><p>只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。</p>\n<h3 id=\"2-解密会话秘钥\"><a href=\"#2-解密会话秘钥\" class=\"headerlink\" title=\"2. 解密会话秘钥\"></a>2. 解密会话秘钥</h3><p>会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。<br>解密后的会话秘钥将被用作解密消息的秘钥。</p>\n<h3 id=\"3-解密消息\"><a href=\"#3-解密消息\" class=\"headerlink\" title=\"3. 解密消息\"></a>3. 解密消息</h3><p>消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。<br>上述流程正好是“混合密码系统的加密”的逆操作。</p>\n<h2 id=\"3-5-混合密码系统的具体例子\"><a href=\"#3-5-混合密码系统的具体例子\" class=\"headerlink\" title=\"3.5 混合密码系统的具体例子\"></a>3.5 混合密码系统的具体例子</h2><p>混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。<br>著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。</p>\n<h1 id=\"4-怎样才是高强度的混合密码系统\"><a href=\"#4-怎样才是高强度的混合密码系统\" class=\"headerlink\" title=\"4 怎样才是高强度的混合密码系统\"></a>4 怎样才是高强度的混合密码系统</h1><h2 id=\"4-1-伪随机数生成器\"><a href=\"#4-1-伪随机数生成器\" class=\"headerlink\" title=\"4.1 伪随机数生成器\"></a>4.1 伪随机数生成器</h2><p>混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。<br>会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的<br>攻击方法，将在第十二章详解。</p>\n<h2 id=\"4-2-对称密码\"><a href=\"#4-2-对称密码\" class=\"headerlink\" title=\"4.2 对称密码\"></a>4.2 对称密码</h2><p>混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。</p>\n<h2 id=\"4-3-公钥密码\"><a href=\"#4-3-公钥密码\" class=\"headerlink\" title=\"4.3 公钥密码\"></a>4.3 公钥密码</h2><p>混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。</p>\n<h2 id=\"4-4-秘钥长度的平衡\"><a href=\"#4-4-秘钥长度的平衡\" class=\"headerlink\" title=\"4.4 秘钥长度的平衡\"></a>4.4 秘钥长度的平衡</h2><p>对称密码和公钥密码的秘钥长度必须具备同等的强度。<br>然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_4.png\" alt=\"\"></p>\n<h1 id=\"5-密码技术的组合\"><a href=\"#5-密码技术的组合\" class=\"headerlink\" title=\"5 密码技术的组合\"></a>5 密码技术的组合</h1><p>本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。<br>例如，第四章中介绍的<strong>分组密码模式</strong>，就是将只能加密固定长度的数据的\b分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。  </p>\n<p><strong>三重 DES</strong>是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。  </p>\n<p>对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。<br>在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。  </p>\n<p>数字签名，是由单向散列函数和公钥密码组合而成的。<br>证书，是由公钥和数字签名组合而成的。<br>消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。<br>伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。<br>还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。</p>\n<h1 id=\"6-本章小结\"><a href=\"#6-本章小结\" class=\"headerlink\" title=\"6 本章小结\"></a>6 本章小结</h1><p>\b本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。<br>到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。<br>从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。</p>\n<h1 id=\"7-小测验\"><a href=\"#7-小测验\" class=\"headerlink\" title=\"7 小测验\"></a>7 小测验</h1><ol>\n<li>混合密码系统是用对称密码对消息进行加密的。</li>\n<li>混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。</li>\n<li>由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。</li>\n<li>混合密码系统的解密过程是按照“公钥密码解密”-&gt;“对称密码解密”的顺序来进行处理的。</li>\n</ol>\n"},{"title":"十一、秘钥——秘密的精华","date":"2017-11-23T15:42:00.000Z","updated":"2017-12-04T14:14:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。\n\n# 2 什么是秘钥\n\n## 2.1 秘钥就是一个巨大的数字\n\n在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为**秘钥**（key）的巨大数字。然后，数字本身的带下并不重要，重要的是**秘钥空间的大小**，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由**秘钥长度**决定的。\n\n### 1.DES 的秘钥\n对称密码 DES 的秘钥的实质长度为 56 比特。  \n例如，一个 DES 秘钥用二进制可以表示为：  \n01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100  \n用十六进制则可以表示为：  \n51 EC 4B 12 3D 4A A1  \n而用十进制则可以表示为：  \n12309120398102938102983  \n为了显得专业，将统一使用十六进制。\n\n### 2.三重 DES 的秘钥\n在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。  \nDES-EDE2 的秘钥实际长度为 112 比特。  \nDES-EDE3 的秘钥实际长度为 168 比特。\n\n### 3.AES 的秘钥\n对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。  \n  \n>实际长度会更长，因为会加一些用于识别通信错误的校验比特。\n\n## 2.2 秘钥和明文是等价的\n\n对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，**秘钥和明文是等价的**。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。\n\n## 2.3 密码算法与秘钥\n\n信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。\n\n# 3 各种不同的秘钥\n\n## 3.1 对称密码的秘钥与公钥密码的秘钥\n\n在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。  \n![][1]  \n在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。  \n![][2]\n\n## 3.2 消息认证码的秘钥与数字签名的秘钥\n\n在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。  \n![][3]  \n在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。  \n![][4]\n\n## 3.3 用于确保机密性的秘钥与用于认证的秘钥\n\n对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。  \n  \n相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。\n\n## 3.4 会话秘钥与主秘钥\n\n刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。  \n当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为**会话秘钥**（session key）。  \n虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。  \n相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为**主秘钥**（master key）。\n\n## 3.5 用于加密内容的秘钥与用于加密秘钥的秘钥\n\n一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。  \n![][5]  \n  \n在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。\n\n# 4 秘钥的管理\n\n## 4.1 生成秘钥\n\n### 1.用随机数生成秘钥\n\n### 2.用口令生成秘钥\n即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。\n\n## 4.2 配送秘钥\n\n在第五章介绍，可以采用**事先共享秘钥、使用秘钥分配中心、使用公钥密码**等方法。一会将介绍**Diffie-Hellman秘钥交换**。\n\n## 4.3 更新秘钥\n\n有一种提高通信机密性的技术被称为**秘钥更新**（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。  \n  \n在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是**用当前秘钥的散列值作为下一个秘钥**。  \n这种防止破译过去的通信内容的机制，称为**后向安全**（backward security）。\n\n## 4.4 保存秘钥\n\n由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑**保存秘钥**的问题了。\n\n### 1.人类无法记住秘钥\n首先我们必须要理解一个重要的事实，那就是人类是**无法记住具有使用长度的秘钥**的。 \n\n### 2.对秘钥进行加密的意义\n\n例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。\n\n## 4.5 作废秘钥\n\n如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。\n\n# 5 Diffie-Hellman秘钥交换\n\n## 5.1 什么是 Diffie-Hellman 秘钥交换\n\n使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。  \n  \n虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。\n\n## 5.2 Diffie-Hellman 秘钥交换的步骤\n\n![][6]  \n\n### 1.Alice 向 Bob 发送两个质数 P 和 G\nP 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为**生成元**。 G 可以是一个较小的数字。 P 和 G 不需要保密。\n\n### 2.Alice 生成一个随机数 A\nA 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。\n\n### 3.Bob 生成一个随机数 B\nB 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。\n\n### 4.Alice 将 G^A mod P 这个数发送给 Bob\n这个数让 Eve 知道也没关系\n\n### 5.Bob 将 G^B mod P 这个数发送给 Alice\n这个数让 Eve 知道也没关系\n\n### 6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P\n这个数就是共享秘钥。 (G^B mod P)^A mod P\n\n### 7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P\n这个数就是共享秘钥。 (G^A mod P)^B mod P\n\n### 8.这样 Alice 和 Bob 得到的值就是相同的\n\n## 5.3 Eve 能计算出秘钥吗\n\n这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。\n\n# 6 基于口令的密码（PBE）\n\n## 6.1 什么是基于口令的密码\n\n用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。\n\n## 6.2 PBE 加密\n\n![][7]\n\n## 6.3 PBE 解密\n\n![][8]\n\n# 7 本章小结\n\n对秘钥本身做了简单介绍。\n\n# 8 小测验\n\n1. 由于秘钥只是随机的比特序列，因此被别人知道了也没关系。\n2. 私钥是可以公开的。\n3. 在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_8.png","source":"_posts/图解密码技术/第十一章 秘钥.md","raw":"---\ntitle: 十一、秘钥——秘密的精华\ndate: 2017-11-23 23:42:00\nupdated: 2017-12-04 22:14:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/10.html    \n---\n\n# 1 本章概要\n\n密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。\n\n# 2 什么是秘钥\n\n## 2.1 秘钥就是一个巨大的数字\n\n在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为**秘钥**（key）的巨大数字。然后，数字本身的带下并不重要，重要的是**秘钥空间的大小**，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由**秘钥长度**决定的。\n\n### 1.DES 的秘钥\n对称密码 DES 的秘钥的实质长度为 56 比特。  \n例如，一个 DES 秘钥用二进制可以表示为：  \n01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100  \n用十六进制则可以表示为：  \n51 EC 4B 12 3D 4A A1  \n而用十进制则可以表示为：  \n12309120398102938102983  \n为了显得专业，将统一使用十六进制。\n\n### 2.三重 DES 的秘钥\n在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。  \nDES-EDE2 的秘钥实际长度为 112 比特。  \nDES-EDE3 的秘钥实际长度为 168 比特。\n\n### 3.AES 的秘钥\n对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。  \n  \n>实际长度会更长，因为会加一些用于识别通信错误的校验比特。\n\n## 2.2 秘钥和明文是等价的\n\n对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，**秘钥和明文是等价的**。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。\n\n## 2.3 密码算法与秘钥\n\n信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。\n\n# 3 各种不同的秘钥\n\n## 3.1 对称密码的秘钥与公钥密码的秘钥\n\n在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。  \n![][1]  \n在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。  \n![][2]\n\n## 3.2 消息认证码的秘钥与数字签名的秘钥\n\n在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。  \n![][3]  \n在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。  \n![][4]\n\n## 3.3 用于确保机密性的秘钥与用于认证的秘钥\n\n对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。  \n  \n相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。\n\n## 3.4 会话秘钥与主秘钥\n\n刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。  \n当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为**会话秘钥**（session key）。  \n虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。  \n相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为**主秘钥**（master key）。\n\n## 3.5 用于加密内容的秘钥与用于加密秘钥的秘钥\n\n一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。  \n![][5]  \n  \n在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。\n\n# 4 秘钥的管理\n\n## 4.1 生成秘钥\n\n### 1.用随机数生成秘钥\n\n### 2.用口令生成秘钥\n即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。\n\n## 4.2 配送秘钥\n\n在第五章介绍，可以采用**事先共享秘钥、使用秘钥分配中心、使用公钥密码**等方法。一会将介绍**Diffie-Hellman秘钥交换**。\n\n## 4.3 更新秘钥\n\n有一种提高通信机密性的技术被称为**秘钥更新**（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。  \n  \n在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是**用当前秘钥的散列值作为下一个秘钥**。  \n这种防止破译过去的通信内容的机制，称为**后向安全**（backward security）。\n\n## 4.4 保存秘钥\n\n由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑**保存秘钥**的问题了。\n\n### 1.人类无法记住秘钥\n首先我们必须要理解一个重要的事实，那就是人类是**无法记住具有使用长度的秘钥**的。 \n\n### 2.对秘钥进行加密的意义\n\n例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。\n\n## 4.5 作废秘钥\n\n如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。\n\n# 5 Diffie-Hellman秘钥交换\n\n## 5.1 什么是 Diffie-Hellman 秘钥交换\n\n使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。  \n  \n虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。\n\n## 5.2 Diffie-Hellman 秘钥交换的步骤\n\n![][6]  \n\n### 1.Alice 向 Bob 发送两个质数 P 和 G\nP 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为**生成元**。 G 可以是一个较小的数字。 P 和 G 不需要保密。\n\n### 2.Alice 生成一个随机数 A\nA 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。\n\n### 3.Bob 生成一个随机数 B\nB 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。\n\n### 4.Alice 将 G^A mod P 这个数发送给 Bob\n这个数让 Eve 知道也没关系\n\n### 5.Bob 将 G^B mod P 这个数发送给 Alice\n这个数让 Eve 知道也没关系\n\n### 6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P\n这个数就是共享秘钥。 (G^B mod P)^A mod P\n\n### 7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P\n这个数就是共享秘钥。 (G^A mod P)^B mod P\n\n### 8.这样 Alice 和 Bob 得到的值就是相同的\n\n## 5.3 Eve 能计算出秘钥吗\n\n这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。\n\n# 6 基于口令的密码（PBE）\n\n## 6.1 什么是基于口令的密码\n\n用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。\n\n## 6.2 PBE 加密\n\n![][7]\n\n## 6.3 PBE 解密\n\n![][8]\n\n# 7 本章小结\n\n对秘钥本身做了简单介绍。\n\n# 8 小测验\n\n1. 由于秘钥只是随机的比特序列，因此被别人知道了也没关系。\n2. 私钥是可以公开的。\n3. 在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_8.png","slug":"graphic2cryptography/10.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavv002maxs6uhbh9b9k","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。</p>\n<h1 id=\"2-什么是秘钥\"><a href=\"#2-什么是秘钥\" class=\"headerlink\" title=\"2 什么是秘钥\"></a>2 什么是秘钥</h1><h2 id=\"2-1-秘钥就是一个巨大的数字\"><a href=\"#2-1-秘钥就是一个巨大的数字\" class=\"headerlink\" title=\"2.1 秘钥就是一个巨大的数字\"></a>2.1 秘钥就是一个巨大的数字</h2><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为<strong>秘钥</strong>（key）的巨大数字。然后，数字本身的带下并不重要，重要的是<strong>秘钥空间的大小</strong>，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由<strong>秘钥长度</strong>决定的。</p>\n<h3 id=\"1-DES-的秘钥\"><a href=\"#1-DES-的秘钥\" class=\"headerlink\" title=\"1.DES 的秘钥\"></a>1.DES 的秘钥</h3><p>对称密码 DES 的秘钥的实质长度为 56 比特。<br>例如，一个 DES 秘钥用二进制可以表示为：<br>01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100<br>用十六进制则可以表示为：<br>51 EC 4B 12 3D 4A A1<br>而用十进制则可以表示为：<br>12309120398102938102983<br>为了显得专业，将统一使用十六进制。</p>\n<h3 id=\"2-三重-DES-的秘钥\"><a href=\"#2-三重-DES-的秘钥\" class=\"headerlink\" title=\"2.三重 DES 的秘钥\"></a>2.三重 DES 的秘钥</h3><p>在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。<br>DES-EDE2 的秘钥实际长度为 112 比特。<br>DES-EDE3 的秘钥实际长度为 168 比特。</p>\n<h3 id=\"3-AES-的秘钥\"><a href=\"#3-AES-的秘钥\" class=\"headerlink\" title=\"3.AES 的秘钥\"></a>3.AES 的秘钥</h3><p>对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。  </p>\n<blockquote>\n<p>实际长度会更长，因为会加一些用于识别通信错误的校验比特。</p>\n</blockquote>\n<h2 id=\"2-2-秘钥和明文是等价的\"><a href=\"#2-2-秘钥和明文是等价的\" class=\"headerlink\" title=\"2.2 秘钥和明文是等价的\"></a>2.2 秘钥和明文是等价的</h2><p>对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，<strong>秘钥和明文是等价的</strong>。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。</p>\n<h2 id=\"2-3-密码算法与秘钥\"><a href=\"#2-3-密码算法与秘钥\" class=\"headerlink\" title=\"2.3 密码算法与秘钥\"></a>2.3 密码算法与秘钥</h2><p>信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。</p>\n<h1 id=\"3-各种不同的秘钥\"><a href=\"#3-各种不同的秘钥\" class=\"headerlink\" title=\"3 各种不同的秘钥\"></a>3 各种不同的秘钥</h1><h2 id=\"3-1-对称密码的秘钥与公钥密码的秘钥\"><a href=\"#3-1-对称密码的秘钥与公钥密码的秘钥\" class=\"headerlink\" title=\"3.1 对称密码的秘钥与公钥密码的秘钥\"></a>3.1 对称密码的秘钥与公钥密码的秘钥</h2><p>在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_1.png\" alt=\"\"><br>在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_2.png\" alt=\"\"></p>\n<h2 id=\"3-2-消息认证码的秘钥与数字签名的秘钥\"><a href=\"#3-2-消息认证码的秘钥与数字签名的秘钥\" class=\"headerlink\" title=\"3.2 消息认证码的秘钥与数字签名的秘钥\"></a>3.2 消息认证码的秘钥与数字签名的秘钥</h2><p>在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_3.png\" alt=\"\"><br>在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_4.png\" alt=\"\"></p>\n<h2 id=\"3-3-用于确保机密性的秘钥与用于认证的秘钥\"><a href=\"#3-3-用于确保机密性的秘钥与用于认证的秘钥\" class=\"headerlink\" title=\"3.3 用于确保机密性的秘钥与用于认证的秘钥\"></a>3.3 用于确保机密性的秘钥与用于认证的秘钥</h2><p>对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。  </p>\n<p>相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。</p>\n<h2 id=\"3-4-会话秘钥与主秘钥\"><a href=\"#3-4-会话秘钥与主秘钥\" class=\"headerlink\" title=\"3.4 会话秘钥与主秘钥\"></a>3.4 会话秘钥与主秘钥</h2><p>刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。<br>当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为<strong>会话秘钥</strong>（session key）。<br>虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。<br>相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为<strong>主秘钥</strong>（master key）。</p>\n<h2 id=\"3-5-用于加密内容的秘钥与用于加密秘钥的秘钥\"><a href=\"#3-5-用于加密内容的秘钥与用于加密秘钥的秘钥\" class=\"headerlink\" title=\"3.5 用于加密内容的秘钥与用于加密秘钥的秘钥\"></a>3.5 用于加密内容的秘钥与用于加密秘钥的秘钥</h2><p>一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_5.png\" alt=\"\">  </p>\n<p>在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。</p>\n<h1 id=\"4-秘钥的管理\"><a href=\"#4-秘钥的管理\" class=\"headerlink\" title=\"4 秘钥的管理\"></a>4 秘钥的管理</h1><h2 id=\"4-1-生成秘钥\"><a href=\"#4-1-生成秘钥\" class=\"headerlink\" title=\"4.1 生成秘钥\"></a>4.1 生成秘钥</h2><h3 id=\"1-用随机数生成秘钥\"><a href=\"#1-用随机数生成秘钥\" class=\"headerlink\" title=\"1.用随机数生成秘钥\"></a>1.用随机数生成秘钥</h3><h3 id=\"2-用口令生成秘钥\"><a href=\"#2-用口令生成秘钥\" class=\"headerlink\" title=\"2.用口令生成秘钥\"></a>2.用口令生成秘钥</h3><p>即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。</p>\n<h2 id=\"4-2-配送秘钥\"><a href=\"#4-2-配送秘钥\" class=\"headerlink\" title=\"4.2 配送秘钥\"></a>4.2 配送秘钥</h2><p>在第五章介绍，可以采用<strong>事先共享秘钥、使用秘钥分配中心、使用公钥密码</strong>等方法。一会将介绍<strong>Diffie-Hellman秘钥交换</strong>。</p>\n<h2 id=\"4-3-更新秘钥\"><a href=\"#4-3-更新秘钥\" class=\"headerlink\" title=\"4.3 更新秘钥\"></a>4.3 更新秘钥</h2><p>有一种提高通信机密性的技术被称为<strong>秘钥更新</strong>（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。  </p>\n<p>在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是<strong>用当前秘钥的散列值作为下一个秘钥</strong>。<br>这种防止破译过去的通信内容的机制，称为<strong>后向安全</strong>（backward security）。</p>\n<h2 id=\"4-4-保存秘钥\"><a href=\"#4-4-保存秘钥\" class=\"headerlink\" title=\"4.4 保存秘钥\"></a>4.4 保存秘钥</h2><p>由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑<strong>保存秘钥</strong>的问题了。</p>\n<h3 id=\"1-人类无法记住秘钥\"><a href=\"#1-人类无法记住秘钥\" class=\"headerlink\" title=\"1.人类无法记住秘钥\"></a>1.人类无法记住秘钥</h3><p>首先我们必须要理解一个重要的事实，那就是人类是<strong>无法记住具有使用长度的秘钥</strong>的。 </p>\n<h3 id=\"2-对秘钥进行加密的意义\"><a href=\"#2-对秘钥进行加密的意义\" class=\"headerlink\" title=\"2.对秘钥进行加密的意义\"></a>2.对秘钥进行加密的意义</h3><p>例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。</p>\n<h2 id=\"4-5-作废秘钥\"><a href=\"#4-5-作废秘钥\" class=\"headerlink\" title=\"4.5 作废秘钥\"></a>4.5 作废秘钥</h2><p>如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。</p>\n<h1 id=\"5-Diffie-Hellman秘钥交换\"><a href=\"#5-Diffie-Hellman秘钥交换\" class=\"headerlink\" title=\"5 Diffie-Hellman秘钥交换\"></a>5 Diffie-Hellman秘钥交换</h1><h2 id=\"5-1-什么是-Diffie-Hellman-秘钥交换\"><a href=\"#5-1-什么是-Diffie-Hellman-秘钥交换\" class=\"headerlink\" title=\"5.1 什么是 Diffie-Hellman 秘钥交换\"></a>5.1 什么是 Diffie-Hellman 秘钥交换</h2><p>使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。  </p>\n<p>虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。</p>\n<h2 id=\"5-2-Diffie-Hellman-秘钥交换的步骤\"><a href=\"#5-2-Diffie-Hellman-秘钥交换的步骤\" class=\"headerlink\" title=\"5.2 Diffie-Hellman 秘钥交换的步骤\"></a>5.2 Diffie-Hellman 秘钥交换的步骤</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_6.png\" alt=\"\">  </p>\n<h3 id=\"1-Alice-向-Bob-发送两个质数-P-和-G\"><a href=\"#1-Alice-向-Bob-发送两个质数-P-和-G\" class=\"headerlink\" title=\"1.Alice 向 Bob 发送两个质数 P 和 G\"></a>1.Alice 向 Bob 发送两个质数 P 和 G</h3><p>P 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为<strong>生成元</strong>。 G 可以是一个较小的数字。 P 和 G 不需要保密。</p>\n<h3 id=\"2-Alice-生成一个随机数-A\"><a href=\"#2-Alice-生成一个随机数-A\" class=\"headerlink\" title=\"2.Alice 生成一个随机数 A\"></a>2.Alice 生成一个随机数 A</h3><p>A 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。</p>\n<h3 id=\"3-Bob-生成一个随机数-B\"><a href=\"#3-Bob-生成一个随机数-B\" class=\"headerlink\" title=\"3.Bob 生成一个随机数 B\"></a>3.Bob 生成一个随机数 B</h3><p>B 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。</p>\n<h3 id=\"4-Alice-将-G-A-mod-P-这个数发送给-Bob\"><a href=\"#4-Alice-将-G-A-mod-P-这个数发送给-Bob\" class=\"headerlink\" title=\"4.Alice 将 G^A mod P 这个数发送给 Bob\"></a>4.Alice 将 G^A mod P 这个数发送给 Bob</h3><p>这个数让 Eve 知道也没关系</p>\n<h3 id=\"5-Bob-将-G-B-mod-P-这个数发送给-Alice\"><a href=\"#5-Bob-将-G-B-mod-P-这个数发送给-Alice\" class=\"headerlink\" title=\"5.Bob 将 G^B mod P 这个数发送给 Alice\"></a>5.Bob 将 G^B mod P 这个数发送给 Alice</h3><p>这个数让 Eve 知道也没关系</p>\n<h3 id=\"6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P\"><a href=\"#6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P\" class=\"headerlink\" title=\"6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P\"></a>6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^B mod P)^A mod P</p>\n<h3 id=\"7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P\"><a href=\"#7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P\" class=\"headerlink\" title=\"7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P\"></a>7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^A mod P)^B mod P</p>\n<h3 id=\"8-这样-Alice-和-Bob-得到的值就是相同的\"><a href=\"#8-这样-Alice-和-Bob-得到的值就是相同的\" class=\"headerlink\" title=\"8.这样 Alice 和 Bob 得到的值就是相同的\"></a>8.这样 Alice 和 Bob 得到的值就是相同的</h3><h2 id=\"5-3-Eve-能计算出秘钥吗\"><a href=\"#5-3-Eve-能计算出秘钥吗\" class=\"headerlink\" title=\"5.3 Eve 能计算出秘钥吗\"></a>5.3 Eve 能计算出秘钥吗</h2><p>这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。</p>\n<h1 id=\"6-基于口令的密码（PBE）\"><a href=\"#6-基于口令的密码（PBE）\" class=\"headerlink\" title=\"6 基于口令的密码（PBE）\"></a>6 基于口令的密码（PBE）</h1><h2 id=\"6-1-什么是基于口令的密码\"><a href=\"#6-1-什么是基于口令的密码\" class=\"headerlink\" title=\"6.1 什么是基于口令的密码\"></a>6.1 什么是基于口令的密码</h2><p>用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。</p>\n<h2 id=\"6-2-PBE-加密\"><a href=\"#6-2-PBE-加密\" class=\"headerlink\" title=\"6.2 PBE 加密\"></a>6.2 PBE 加密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_7.png\" alt=\"\"></p>\n<h2 id=\"6-3-PBE-解密\"><a href=\"#6-3-PBE-解密\" class=\"headerlink\" title=\"6.3 PBE 解密\"></a>6.3 PBE 解密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_8.png\" alt=\"\"></p>\n<h1 id=\"7-本章小结\"><a href=\"#7-本章小结\" class=\"headerlink\" title=\"7 本章小结\"></a>7 本章小结</h1><p>对秘钥本身做了简单介绍。</p>\n<h1 id=\"8-小测验\"><a href=\"#8-小测验\" class=\"headerlink\" title=\"8 小测验\"></a>8 小测验</h1><ol>\n<li>由于秘钥只是随机的比特序列，因此被别人知道了也没关系。</li>\n<li>私钥是可以公开的。</li>\n<li>在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。</p>\n<h1 id=\"2-什么是秘钥\"><a href=\"#2-什么是秘钥\" class=\"headerlink\" title=\"2 什么是秘钥\"></a>2 什么是秘钥</h1><h2 id=\"2-1-秘钥就是一个巨大的数字\"><a href=\"#2-1-秘钥就是一个巨大的数字\" class=\"headerlink\" title=\"2.1 秘钥就是一个巨大的数字\"></a>2.1 秘钥就是一个巨大的数字</h2><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为<strong>秘钥</strong>（key）的巨大数字。然后，数字本身的带下并不重要，重要的是<strong>秘钥空间的大小</strong>，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由<strong>秘钥长度</strong>决定的。</p>\n<h3 id=\"1-DES-的秘钥\"><a href=\"#1-DES-的秘钥\" class=\"headerlink\" title=\"1.DES 的秘钥\"></a>1.DES 的秘钥</h3><p>对称密码 DES 的秘钥的实质长度为 56 比特。<br>例如，一个 DES 秘钥用二进制可以表示为：<br>01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100<br>用十六进制则可以表示为：<br>51 EC 4B 12 3D 4A A1<br>而用十进制则可以表示为：<br>12309120398102938102983<br>为了显得专业，将统一使用十六进制。</p>\n<h3 id=\"2-三重-DES-的秘钥\"><a href=\"#2-三重-DES-的秘钥\" class=\"headerlink\" title=\"2.三重 DES 的秘钥\"></a>2.三重 DES 的秘钥</h3><p>在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。<br>DES-EDE2 的秘钥实际长度为 112 比特。<br>DES-EDE3 的秘钥实际长度为 168 比特。</p>\n<h3 id=\"3-AES-的秘钥\"><a href=\"#3-AES-的秘钥\" class=\"headerlink\" title=\"3.AES 的秘钥\"></a>3.AES 的秘钥</h3><p>对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。  </p>\n<blockquote>\n<p>实际长度会更长，因为会加一些用于识别通信错误的校验比特。</p>\n</blockquote>\n<h2 id=\"2-2-秘钥和明文是等价的\"><a href=\"#2-2-秘钥和明文是等价的\" class=\"headerlink\" title=\"2.2 秘钥和明文是等价的\"></a>2.2 秘钥和明文是等价的</h2><p>对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，<strong>秘钥和明文是等价的</strong>。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。</p>\n<h2 id=\"2-3-密码算法与秘钥\"><a href=\"#2-3-密码算法与秘钥\" class=\"headerlink\" title=\"2.3 密码算法与秘钥\"></a>2.3 密码算法与秘钥</h2><p>信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。</p>\n<h1 id=\"3-各种不同的秘钥\"><a href=\"#3-各种不同的秘钥\" class=\"headerlink\" title=\"3 各种不同的秘钥\"></a>3 各种不同的秘钥</h1><h2 id=\"3-1-对称密码的秘钥与公钥密码的秘钥\"><a href=\"#3-1-对称密码的秘钥与公钥密码的秘钥\" class=\"headerlink\" title=\"3.1 对称密码的秘钥与公钥密码的秘钥\"></a>3.1 对称密码的秘钥与公钥密码的秘钥</h2><p>在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_1.png\" alt=\"\"><br>在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_2.png\" alt=\"\"></p>\n<h2 id=\"3-2-消息认证码的秘钥与数字签名的秘钥\"><a href=\"#3-2-消息认证码的秘钥与数字签名的秘钥\" class=\"headerlink\" title=\"3.2 消息认证码的秘钥与数字签名的秘钥\"></a>3.2 消息认证码的秘钥与数字签名的秘钥</h2><p>在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_3.png\" alt=\"\"><br>在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_4.png\" alt=\"\"></p>\n<h2 id=\"3-3-用于确保机密性的秘钥与用于认证的秘钥\"><a href=\"#3-3-用于确保机密性的秘钥与用于认证的秘钥\" class=\"headerlink\" title=\"3.3 用于确保机密性的秘钥与用于认证的秘钥\"></a>3.3 用于确保机密性的秘钥与用于认证的秘钥</h2><p>对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。  </p>\n<p>相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。</p>\n<h2 id=\"3-4-会话秘钥与主秘钥\"><a href=\"#3-4-会话秘钥与主秘钥\" class=\"headerlink\" title=\"3.4 会话秘钥与主秘钥\"></a>3.4 会话秘钥与主秘钥</h2><p>刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。<br>当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为<strong>会话秘钥</strong>（session key）。<br>虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。<br>相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为<strong>主秘钥</strong>（master key）。</p>\n<h2 id=\"3-5-用于加密内容的秘钥与用于加密秘钥的秘钥\"><a href=\"#3-5-用于加密内容的秘钥与用于加密秘钥的秘钥\" class=\"headerlink\" title=\"3.5 用于加密内容的秘钥与用于加密秘钥的秘钥\"></a>3.5 用于加密内容的秘钥与用于加密秘钥的秘钥</h2><p>一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_5.png\" alt=\"\">  </p>\n<p>在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。</p>\n<h1 id=\"4-秘钥的管理\"><a href=\"#4-秘钥的管理\" class=\"headerlink\" title=\"4 秘钥的管理\"></a>4 秘钥的管理</h1><h2 id=\"4-1-生成秘钥\"><a href=\"#4-1-生成秘钥\" class=\"headerlink\" title=\"4.1 生成秘钥\"></a>4.1 生成秘钥</h2><h3 id=\"1-用随机数生成秘钥\"><a href=\"#1-用随机数生成秘钥\" class=\"headerlink\" title=\"1.用随机数生成秘钥\"></a>1.用随机数生成秘钥</h3><h3 id=\"2-用口令生成秘钥\"><a href=\"#2-用口令生成秘钥\" class=\"headerlink\" title=\"2.用口令生成秘钥\"></a>2.用口令生成秘钥</h3><p>即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。</p>\n<h2 id=\"4-2-配送秘钥\"><a href=\"#4-2-配送秘钥\" class=\"headerlink\" title=\"4.2 配送秘钥\"></a>4.2 配送秘钥</h2><p>在第五章介绍，可以采用<strong>事先共享秘钥、使用秘钥分配中心、使用公钥密码</strong>等方法。一会将介绍<strong>Diffie-Hellman秘钥交换</strong>。</p>\n<h2 id=\"4-3-更新秘钥\"><a href=\"#4-3-更新秘钥\" class=\"headerlink\" title=\"4.3 更新秘钥\"></a>4.3 更新秘钥</h2><p>有一种提高通信机密性的技术被称为<strong>秘钥更新</strong>（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。  </p>\n<p>在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是<strong>用当前秘钥的散列值作为下一个秘钥</strong>。<br>这种防止破译过去的通信内容的机制，称为<strong>后向安全</strong>（backward security）。</p>\n<h2 id=\"4-4-保存秘钥\"><a href=\"#4-4-保存秘钥\" class=\"headerlink\" title=\"4.4 保存秘钥\"></a>4.4 保存秘钥</h2><p>由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑<strong>保存秘钥</strong>的问题了。</p>\n<h3 id=\"1-人类无法记住秘钥\"><a href=\"#1-人类无法记住秘钥\" class=\"headerlink\" title=\"1.人类无法记住秘钥\"></a>1.人类无法记住秘钥</h3><p>首先我们必须要理解一个重要的事实，那就是人类是<strong>无法记住具有使用长度的秘钥</strong>的。 </p>\n<h3 id=\"2-对秘钥进行加密的意义\"><a href=\"#2-对秘钥进行加密的意义\" class=\"headerlink\" title=\"2.对秘钥进行加密的意义\"></a>2.对秘钥进行加密的意义</h3><p>例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。</p>\n<h2 id=\"4-5-作废秘钥\"><a href=\"#4-5-作废秘钥\" class=\"headerlink\" title=\"4.5 作废秘钥\"></a>4.5 作废秘钥</h2><p>如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。</p>\n<h1 id=\"5-Diffie-Hellman秘钥交换\"><a href=\"#5-Diffie-Hellman秘钥交换\" class=\"headerlink\" title=\"5 Diffie-Hellman秘钥交换\"></a>5 Diffie-Hellman秘钥交换</h1><h2 id=\"5-1-什么是-Diffie-Hellman-秘钥交换\"><a href=\"#5-1-什么是-Diffie-Hellman-秘钥交换\" class=\"headerlink\" title=\"5.1 什么是 Diffie-Hellman 秘钥交换\"></a>5.1 什么是 Diffie-Hellman 秘钥交换</h2><p>使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。  </p>\n<p>虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。</p>\n<h2 id=\"5-2-Diffie-Hellman-秘钥交换的步骤\"><a href=\"#5-2-Diffie-Hellman-秘钥交换的步骤\" class=\"headerlink\" title=\"5.2 Diffie-Hellman 秘钥交换的步骤\"></a>5.2 Diffie-Hellman 秘钥交换的步骤</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_6.png\" alt=\"\">  </p>\n<h3 id=\"1-Alice-向-Bob-发送两个质数-P-和-G\"><a href=\"#1-Alice-向-Bob-发送两个质数-P-和-G\" class=\"headerlink\" title=\"1.Alice 向 Bob 发送两个质数 P 和 G\"></a>1.Alice 向 Bob 发送两个质数 P 和 G</h3><p>P 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为<strong>生成元</strong>。 G 可以是一个较小的数字。 P 和 G 不需要保密。</p>\n<h3 id=\"2-Alice-生成一个随机数-A\"><a href=\"#2-Alice-生成一个随机数-A\" class=\"headerlink\" title=\"2.Alice 生成一个随机数 A\"></a>2.Alice 生成一个随机数 A</h3><p>A 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。</p>\n<h3 id=\"3-Bob-生成一个随机数-B\"><a href=\"#3-Bob-生成一个随机数-B\" class=\"headerlink\" title=\"3.Bob 生成一个随机数 B\"></a>3.Bob 生成一个随机数 B</h3><p>B 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。</p>\n<h3 id=\"4-Alice-将-G-A-mod-P-这个数发送给-Bob\"><a href=\"#4-Alice-将-G-A-mod-P-这个数发送给-Bob\" class=\"headerlink\" title=\"4.Alice 将 G^A mod P 这个数发送给 Bob\"></a>4.Alice 将 G^A mod P 这个数发送给 Bob</h3><p>这个数让 Eve 知道也没关系</p>\n<h3 id=\"5-Bob-将-G-B-mod-P-这个数发送给-Alice\"><a href=\"#5-Bob-将-G-B-mod-P-这个数发送给-Alice\" class=\"headerlink\" title=\"5.Bob 将 G^B mod P 这个数发送给 Alice\"></a>5.Bob 将 G^B mod P 这个数发送给 Alice</h3><p>这个数让 Eve 知道也没关系</p>\n<h3 id=\"6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P\"><a href=\"#6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P\" class=\"headerlink\" title=\"6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P\"></a>6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^B mod P)^A mod P</p>\n<h3 id=\"7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P\"><a href=\"#7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P\" class=\"headerlink\" title=\"7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P\"></a>7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^A mod P)^B mod P</p>\n<h3 id=\"8-这样-Alice-和-Bob-得到的值就是相同的\"><a href=\"#8-这样-Alice-和-Bob-得到的值就是相同的\" class=\"headerlink\" title=\"8.这样 Alice 和 Bob 得到的值就是相同的\"></a>8.这样 Alice 和 Bob 得到的值就是相同的</h3><h2 id=\"5-3-Eve-能计算出秘钥吗\"><a href=\"#5-3-Eve-能计算出秘钥吗\" class=\"headerlink\" title=\"5.3 Eve 能计算出秘钥吗\"></a>5.3 Eve 能计算出秘钥吗</h2><p>这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。</p>\n<h1 id=\"6-基于口令的密码（PBE）\"><a href=\"#6-基于口令的密码（PBE）\" class=\"headerlink\" title=\"6 基于口令的密码（PBE）\"></a>6 基于口令的密码（PBE）</h1><h2 id=\"6-1-什么是基于口令的密码\"><a href=\"#6-1-什么是基于口令的密码\" class=\"headerlink\" title=\"6.1 什么是基于口令的密码\"></a>6.1 什么是基于口令的密码</h2><p>用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。</p>\n<h2 id=\"6-2-PBE-加密\"><a href=\"#6-2-PBE-加密\" class=\"headerlink\" title=\"6.2 PBE 加密\"></a>6.2 PBE 加密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_7.png\" alt=\"\"></p>\n<h2 id=\"6-3-PBE-解密\"><a href=\"#6-3-PBE-解密\" class=\"headerlink\" title=\"6.3 PBE 解密\"></a>6.3 PBE 解密</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_8.png\" alt=\"\"></p>\n<h1 id=\"7-本章小结\"><a href=\"#7-本章小结\" class=\"headerlink\" title=\"7 本章小结\"></a>7 本章小结</h1><p>对秘钥本身做了简单介绍。</p>\n<h1 id=\"8-小测验\"><a href=\"#8-小测验\" class=\"headerlink\" title=\"8 小测验\"></a>8 小测验</h1><ol>\n<li>由于秘钥只是随机的比特序列，因此被别人知道了也没关系。</li>\n<li>私钥是可以公开的。</li>\n<li>在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。</li>\n</ol>\n"},{"title":"五、公钥密码","date":"2017-11-15T04:38:00.000Z","updated":"2017-11-17T18:38:00.000Z","comments":1,"_content":"\n# 1 投币寄物柜的使用方法\n\n介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。  \n只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。  \n  \n因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。\n\n# 2 本章概要\n\n在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用\n公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。  \n  \n本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。\n\n# 3 密钥配送问题\n\n## 3.1 什么是密钥配送问题\n\n在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是\n非常危险的。  \n  \n密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种：  \n1. 通过事先共享密钥来解决\n2. 通过密钥分配中心来解决\n3. 通过 Diffie-Hellman 密钥交换来解决\n4. 通过公钥密码来解决\n\n## 3.2 通过事先共享密钥来解决\n\n事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个\n公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！\n\n# 3.3 通过秘钥分配中心来解决\n\n公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会\n从入职时从秘钥分配中心的计算机上领取自己的秘钥。  \n这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。  \n  \n那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤：  \n1. Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求\n2. 秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥\n3. 秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥\n4. 秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice\n5. 秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob\n6. Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥\n7. Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob\n8. Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥\n9. Bob 用会话秘钥对来自 Alice 的密文进行解密\n10. Alice 和 Bob 删除会话秘钥  \n  \n以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见：  \n1. 随着员工增加，秘钥分配中心负荷增大\n2. 如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪\n3. 攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重\n\n## 3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题\n\n解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。  \n根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。\n\n## 3.5 通过公钥密码来解决秘钥配送问题\n\n第四种方法，就是公钥密码。  \n  \n在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有\n解密秘钥的人才能够进行解密。  \n  \n接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥\n的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。\n\n# 4 公钥密码\n\n## 4.1 什么是公钥密码\n\n公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。  \n加密秘钥和解密秘钥的区别：  \n1. 发送者只需要加密秘钥\n2. 接收者只需要解密秘钥\n3. 解密秘钥不可以被窃听者获取\n4. 加密秘钥被窃听者获取也没问题\n\n也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。  \n  \n公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。\n\n## 4.2 公钥密码的历史\n\n1. 1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。  \n2. 1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。\n3. 1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。\n\n## 4.3 公钥通信的流程\n\nAlice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的：  \n1. Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。\n2. Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。\n3. Alice 用 Bob 的公钥对消息进行加密。\n4. Alice 将密文发送给 Bob 。密文被 Eve 获得。\n5. Bob 用自己的私钥对密文进行解密。\n\n## 4.4 公钥密码无法解决的问题\n\n我们需要判断所得到的公钥是否正确合法，这个问题被称为**公钥认证**问题。这个问题随后将通过对中间人攻击的讲解来探讨。  \n同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。\n\n# 5 时钟算法\n\n在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。\n\n## 5.1 加法\n![][1]  \n指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。  \n  \n因此加法就变成了求余数运算，即 mod 运算。\n\n## 5.2 减法\n\n减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 => x = 6。\n\n## 5.3 乘法\n\n乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 => -9 + 12 = 3。\n\n## 5.4 除法\n\n除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。\n\n## 5.5 乘方\n\n7^4：7^4 mod 12 = 2401 mod 12 = 1\n\n## 5.6 对数\n\n即乘方的逆运算：7^X = Y ，已知 Y 求 X。  \n在时钟运算中的对数称为离散对数。例如：  \n7^X mod 12 = 8，  \n![][2]  \n得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。\n\n## 5.7 从时钟指针到 RSA\n\n我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。\n\n# 6 RSA\n\n## 6.1 什么是 RSA\n\nRSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。  \nRSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。  \nRSA 在 1983年取得了专利，但现在专利已经过期。\n\n## 6.2 RSA 加密\n\n在 RSA 中，**明文、秘钥和密文都是数字**， RSA 的加密过程可以用下列公式来表示：  \n#### 密文 = 明文 ^ E mod N \n也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。  \n就是这么简单。  \n其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。  \n现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。\n\n## 6.3 RSA 解密\n\n#### 明文 = 密文 ^ D mod N\n也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。  \n  \nRSA 的加密和解密整理如下：  \n![][3]  \n![][4]\n\n## 6.4 生成密钥对\n\n由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下：  \n1. 求 N\n2. 求 L（中间值）\n3. 求 E\n4. 求 D\n\n注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。\n\n# 7 对 RSA 的攻击\n\nRSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。  \n破译者知道的信息：密文、E、N。  \n破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。\n\n## 7.1 通过密文来求得明文\n\n密文 = 明文 ^ E mod N  \n如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难，\n因为人类还没有发现求离散对数的高效算法。\n\n## 7.2 通过暴力破解来找出 D\n\n由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。\n\n## 7.3 通过 E 和 N 求出 D\n\n既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。\n\n## 7.4 中间人攻击\n\n下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。  \n  \n假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。  \n1. Alice 向 Bob 发送邮件索要公钥\n2. Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。\n3. Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。\n4. Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。\n5. Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。\n6. Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。\n7. Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。\n8. Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。  \n  \nMallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！  \n  \n我们用公钥密码解决了密钥配送问题，但是又出现新的问题，**如何判断收到的公钥是否来自于正确的接收者**，即是否来自于 Bob 。解决这个问题成为认证，\n将在第十章详解。\n\n# 8 其它公钥密码\n\nRSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。\n这些密码都可以被用于一般的加密和数字签名。\n\n## 8.1 EIGamal 方式\n\nRSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。\n\n## 8.2 Rabin 方式\n\nRabin 利用了 mod N 求平方根的困难度。\n\n## 8.3 椭圆曲线密码\n\n椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。  \n它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。\n\n# 9 关于公钥密码的问答\n\n主要选择一些容易被误解的点解答疑问。\n\n## 9.1 公钥密码的机密性\n\n公钥密码比对称密码的机密性更高吗？  \n这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。\n\n## 9.2 公钥密码与对称密码的密钥长度\n\n采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？  \n不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与\n 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。  \n![][5]\n\n## 9.3 对称密码的未来\n\n因为已经有了公钥密码，今后对称密码会消失吗？  \n不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。\n根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。\n\n## 9.4 RSA 和质数 \n\n随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？  \n512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后：\n100亿人*100亿个*31622400秒*100亿年 < 10^39。  \n另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。\n\n## 9.5 RSA 与质因数分解\n\nRSA 的破译与大整数的质因数分解是等价的吗？  \n不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。\n\n## 9.6 RSA 的长度\n\n要抵御质因数分解，N 的长度需要达到多少比特呢？  \nN 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。\n\n# 10 本章小结\n\n本章学习了公钥密码以及其代表性的实现方法——RSA。  \n使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！  \n对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解\n问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。  \n  \n尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题\n将在第九章和第十章详解。  \n  \n即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码\n提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。\n\n# 11 小测验\n\n1. 秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。  \n为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？\n2. 要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。\n3. 公钥密码的私钥需要和加密后的消息一起被发送给接收者。\n4. 一般来说，对称密码的速度比公钥密码要快。\n\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_5.png\n\n\n\n\n\n","source":"_posts/图解密码技术/第五章 公钥密码.md","raw":"---\ntitle: 五、公钥密码\ndate: 2017-11-15 12:38:00\nupdated: 2017-11-18 02:38:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/5.html    \n---\n\n# 1 投币寄物柜的使用方法\n\n介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。  \n只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。  \n  \n因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。\n\n# 2 本章概要\n\n在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用\n公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。  \n  \n本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。\n\n# 3 密钥配送问题\n\n## 3.1 什么是密钥配送问题\n\n在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是\n非常危险的。  \n  \n密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种：  \n1. 通过事先共享密钥来解决\n2. 通过密钥分配中心来解决\n3. 通过 Diffie-Hellman 密钥交换来解决\n4. 通过公钥密码来解决\n\n## 3.2 通过事先共享密钥来解决\n\n事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个\n公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！\n\n# 3.3 通过秘钥分配中心来解决\n\n公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会\n从入职时从秘钥分配中心的计算机上领取自己的秘钥。  \n这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。  \n  \n那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤：  \n1. Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求\n2. 秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥\n3. 秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥\n4. 秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice\n5. 秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob\n6. Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥\n7. Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob\n8. Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥\n9. Bob 用会话秘钥对来自 Alice 的密文进行解密\n10. Alice 和 Bob 删除会话秘钥  \n  \n以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见：  \n1. 随着员工增加，秘钥分配中心负荷增大\n2. 如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪\n3. 攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重\n\n## 3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题\n\n解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。  \n根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。\n\n## 3.5 通过公钥密码来解决秘钥配送问题\n\n第四种方法，就是公钥密码。  \n  \n在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有\n解密秘钥的人才能够进行解密。  \n  \n接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥\n的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。\n\n# 4 公钥密码\n\n## 4.1 什么是公钥密码\n\n公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。  \n加密秘钥和解密秘钥的区别：  \n1. 发送者只需要加密秘钥\n2. 接收者只需要解密秘钥\n3. 解密秘钥不可以被窃听者获取\n4. 加密秘钥被窃听者获取也没问题\n\n也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。  \n  \n公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。\n\n## 4.2 公钥密码的历史\n\n1. 1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。  \n2. 1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。\n3. 1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。\n\n## 4.3 公钥通信的流程\n\nAlice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的：  \n1. Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。\n2. Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。\n3. Alice 用 Bob 的公钥对消息进行加密。\n4. Alice 将密文发送给 Bob 。密文被 Eve 获得。\n5. Bob 用自己的私钥对密文进行解密。\n\n## 4.4 公钥密码无法解决的问题\n\n我们需要判断所得到的公钥是否正确合法，这个问题被称为**公钥认证**问题。这个问题随后将通过对中间人攻击的讲解来探讨。  \n同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。\n\n# 5 时钟算法\n\n在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。\n\n## 5.1 加法\n![][1]  \n指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。  \n  \n因此加法就变成了求余数运算，即 mod 运算。\n\n## 5.2 减法\n\n减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 => x = 6。\n\n## 5.3 乘法\n\n乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 => -9 + 12 = 3。\n\n## 5.4 除法\n\n除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。\n\n## 5.5 乘方\n\n7^4：7^4 mod 12 = 2401 mod 12 = 1\n\n## 5.6 对数\n\n即乘方的逆运算：7^X = Y ，已知 Y 求 X。  \n在时钟运算中的对数称为离散对数。例如：  \n7^X mod 12 = 8，  \n![][2]  \n得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。\n\n## 5.7 从时钟指针到 RSA\n\n我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。\n\n# 6 RSA\n\n## 6.1 什么是 RSA\n\nRSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。  \nRSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。  \nRSA 在 1983年取得了专利，但现在专利已经过期。\n\n## 6.2 RSA 加密\n\n在 RSA 中，**明文、秘钥和密文都是数字**， RSA 的加密过程可以用下列公式来表示：  \n#### 密文 = 明文 ^ E mod N \n也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。  \n就是这么简单。  \n其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。  \n现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。\n\n## 6.3 RSA 解密\n\n#### 明文 = 密文 ^ D mod N\n也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。  \n  \nRSA 的加密和解密整理如下：  \n![][3]  \n![][4]\n\n## 6.4 生成密钥对\n\n由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下：  \n1. 求 N\n2. 求 L（中间值）\n3. 求 E\n4. 求 D\n\n注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。\n\n# 7 对 RSA 的攻击\n\nRSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。  \n破译者知道的信息：密文、E、N。  \n破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。\n\n## 7.1 通过密文来求得明文\n\n密文 = 明文 ^ E mod N  \n如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难，\n因为人类还没有发现求离散对数的高效算法。\n\n## 7.2 通过暴力破解来找出 D\n\n由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。\n\n## 7.3 通过 E 和 N 求出 D\n\n既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。\n\n## 7.4 中间人攻击\n\n下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。  \n  \n假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。  \n1. Alice 向 Bob 发送邮件索要公钥\n2. Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。\n3. Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。\n4. Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。\n5. Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。\n6. Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。\n7. Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。\n8. Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。  \n  \nMallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！  \n  \n我们用公钥密码解决了密钥配送问题，但是又出现新的问题，**如何判断收到的公钥是否来自于正确的接收者**，即是否来自于 Bob 。解决这个问题成为认证，\n将在第十章详解。\n\n# 8 其它公钥密码\n\nRSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。\n这些密码都可以被用于一般的加密和数字签名。\n\n## 8.1 EIGamal 方式\n\nRSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。\n\n## 8.2 Rabin 方式\n\nRabin 利用了 mod N 求平方根的困难度。\n\n## 8.3 椭圆曲线密码\n\n椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。  \n它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。\n\n# 9 关于公钥密码的问答\n\n主要选择一些容易被误解的点解答疑问。\n\n## 9.1 公钥密码的机密性\n\n公钥密码比对称密码的机密性更高吗？  \n这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。\n\n## 9.2 公钥密码与对称密码的密钥长度\n\n采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？  \n不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与\n 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。  \n![][5]\n\n## 9.3 对称密码的未来\n\n因为已经有了公钥密码，今后对称密码会消失吗？  \n不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。\n根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。\n\n## 9.4 RSA 和质数 \n\n随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？  \n512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后：\n100亿人*100亿个*31622400秒*100亿年 < 10^39。  \n另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。\n\n## 9.5 RSA 与质因数分解\n\nRSA 的破译与大整数的质因数分解是等价的吗？  \n不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。\n\n## 9.6 RSA 的长度\n\n要抵御质因数分解，N 的长度需要达到多少比特呢？  \nN 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。\n\n# 10 本章小结\n\n本章学习了公钥密码以及其代表性的实现方法——RSA。  \n使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！  \n对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解\n问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。  \n  \n尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题\n将在第九章和第十章详解。  \n  \n即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码\n提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。\n\n# 11 小测验\n\n1. 秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。  \n为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？\n2. 要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。\n3. 公钥密码的私钥需要和加密后的消息一起被发送给接收者。\n4. 一般来说，对称密码的速度比公钥密码要快。\n\n\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_5.png\n\n\n\n\n\n","slug":"graphic2cryptography/5.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavw002oaxs6hh40lz08","content":"<h1 id=\"1-投币寄物柜的使用方法\"><a href=\"#1-投币寄物柜的使用方法\" class=\"headerlink\" title=\"1 投币寄物柜的使用方法\"></a>1 投币寄物柜的使用方法</h1><p>介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。<br>只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。  </p>\n<p>因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用<br>公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。  </p>\n<p>本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。</p>\n<h1 id=\"3-密钥配送问题\"><a href=\"#3-密钥配送问题\" class=\"headerlink\" title=\"3 密钥配送问题\"></a>3 密钥配送问题</h1><h2 id=\"3-1-什么是密钥配送问题\"><a href=\"#3-1-什么是密钥配送问题\" class=\"headerlink\" title=\"3.1 什么是密钥配送问题\"></a>3.1 什么是密钥配送问题</h2><p>在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是<br>非常危险的。  </p>\n<p>密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种：  </p>\n<ol>\n<li>通过事先共享密钥来解决</li>\n<li>通过密钥分配中心来解决</li>\n<li>通过 Diffie-Hellman 密钥交换来解决</li>\n<li>通过公钥密码来解决</li>\n</ol>\n<h2 id=\"3-2-通过事先共享密钥来解决\"><a href=\"#3-2-通过事先共享密钥来解决\" class=\"headerlink\" title=\"3.2 通过事先共享密钥来解决\"></a>3.2 通过事先共享密钥来解决</h2><p>事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个<br>公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！</p>\n<h1 id=\"3-3-通过秘钥分配中心来解决\"><a href=\"#3-3-通过秘钥分配中心来解决\" class=\"headerlink\" title=\"3.3 通过秘钥分配中心来解决\"></a>3.3 通过秘钥分配中心来解决</h1><p>公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会<br>从入职时从秘钥分配中心的计算机上领取自己的秘钥。<br>这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。  </p>\n<p>那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤：  </p>\n<ol>\n<li>Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求</li>\n<li>秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥</li>\n<li>秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥</li>\n<li>秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice</li>\n<li>秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob</li>\n<li>Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥</li>\n<li>Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob</li>\n<li>Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥</li>\n<li>Bob 用会话秘钥对来自 Alice 的密文进行解密</li>\n<li>Alice 和 Bob 删除会话秘钥  </li>\n</ol>\n<p>以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见：  </p>\n<ol>\n<li>随着员工增加，秘钥分配中心负荷增大</li>\n<li>如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪</li>\n<li>攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重</li>\n</ol>\n<h2 id=\"3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题\"><a href=\"#3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题\" class=\"headerlink\" title=\"3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题\"></a>3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题</h2><p>解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。<br>根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。</p>\n<h2 id=\"3-5-通过公钥密码来解决秘钥配送问题\"><a href=\"#3-5-通过公钥密码来解决秘钥配送问题\" class=\"headerlink\" title=\"3.5 通过公钥密码来解决秘钥配送问题\"></a>3.5 通过公钥密码来解决秘钥配送问题</h2><p>第四种方法，就是公钥密码。  </p>\n<p>在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有<br>解密秘钥的人才能够进行解密。  </p>\n<p>接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥<br>的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。</p>\n<h1 id=\"4-公钥密码\"><a href=\"#4-公钥密码\" class=\"headerlink\" title=\"4 公钥密码\"></a>4 公钥密码</h1><h2 id=\"4-1-什么是公钥密码\"><a href=\"#4-1-什么是公钥密码\" class=\"headerlink\" title=\"4.1 什么是公钥密码\"></a>4.1 什么是公钥密码</h2><p>公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。<br>加密秘钥和解密秘钥的区别：  </p>\n<ol>\n<li>发送者只需要加密秘钥</li>\n<li>接收者只需要解密秘钥</li>\n<li>解密秘钥不可以被窃听者获取</li>\n<li>加密秘钥被窃听者获取也没问题</li>\n</ol>\n<p>也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。  </p>\n<p>公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。</p>\n<h2 id=\"4-2-公钥密码的历史\"><a href=\"#4-2-公钥密码的历史\" class=\"headerlink\" title=\"4.2 公钥密码的历史\"></a>4.2 公钥密码的历史</h2><ol>\n<li>1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。  </li>\n<li>1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。</li>\n<li>1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。</li>\n</ol>\n<h2 id=\"4-3-公钥通信的流程\"><a href=\"#4-3-公钥通信的流程\" class=\"headerlink\" title=\"4.3 公钥通信的流程\"></a>4.3 公钥通信的流程</h2><p>Alice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的：  </p>\n<ol>\n<li>Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。</li>\n<li>Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。</li>\n<li>Alice 用 Bob 的公钥对消息进行加密。</li>\n<li>Alice 将密文发送给 Bob 。密文被 Eve 获得。</li>\n<li>Bob 用自己的私钥对密文进行解密。</li>\n</ol>\n<h2 id=\"4-4-公钥密码无法解决的问题\"><a href=\"#4-4-公钥密码无法解决的问题\" class=\"headerlink\" title=\"4.4 公钥密码无法解决的问题\"></a>4.4 公钥密码无法解决的问题</h2><p>我们需要判断所得到的公钥是否正确合法，这个问题被称为<strong>公钥认证</strong>问题。这个问题随后将通过对中间人攻击的讲解来探讨。<br>同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。</p>\n<h1 id=\"5-时钟算法\"><a href=\"#5-时钟算法\" class=\"headerlink\" title=\"5 时钟算法\"></a>5 时钟算法</h1><p>在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。</p>\n<h2 id=\"5-1-加法\"><a href=\"#5-1-加法\" class=\"headerlink\" title=\"5.1 加法\"></a>5.1 加法</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_1.png\" alt=\"\"><br>指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。  </p>\n<p>因此加法就变成了求余数运算，即 mod 运算。</p>\n<h2 id=\"5-2-减法\"><a href=\"#5-2-减法\" class=\"headerlink\" title=\"5.2 减法\"></a>5.2 减法</h2><p>减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 =&gt; x = 6。</p>\n<h2 id=\"5-3-乘法\"><a href=\"#5-3-乘法\" class=\"headerlink\" title=\"5.3 乘法\"></a>5.3 乘法</h2><p>乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 =&gt; -9 + 12 = 3。</p>\n<h2 id=\"5-4-除法\"><a href=\"#5-4-除法\" class=\"headerlink\" title=\"5.4 除法\"></a>5.4 除法</h2><p>除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。</p>\n<h2 id=\"5-5-乘方\"><a href=\"#5-5-乘方\" class=\"headerlink\" title=\"5.5 乘方\"></a>5.5 乘方</h2><p>7^4：7^4 mod 12 = 2401 mod 12 = 1</p>\n<h2 id=\"5-6-对数\"><a href=\"#5-6-对数\" class=\"headerlink\" title=\"5.6 对数\"></a>5.6 对数</h2><p>即乘方的逆运算：7^X = Y ，已知 Y 求 X。<br>在时钟运算中的对数称为离散对数。例如：<br>7^X mod 12 = 8，<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_2.png\" alt=\"\"><br>得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。</p>\n<h2 id=\"5-7-从时钟指针到-RSA\"><a href=\"#5-7-从时钟指针到-RSA\" class=\"headerlink\" title=\"5.7 从时钟指针到 RSA\"></a>5.7 从时钟指针到 RSA</h2><p>我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。</p>\n<h1 id=\"6-RSA\"><a href=\"#6-RSA\" class=\"headerlink\" title=\"6 RSA\"></a>6 RSA</h1><h2 id=\"6-1-什么是-RSA\"><a href=\"#6-1-什么是-RSA\" class=\"headerlink\" title=\"6.1 什么是 RSA\"></a>6.1 什么是 RSA</h2><p>RSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。<br>RSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。<br>RSA 在 1983年取得了专利，但现在专利已经过期。</p>\n<h2 id=\"6-2-RSA-加密\"><a href=\"#6-2-RSA-加密\" class=\"headerlink\" title=\"6.2 RSA 加密\"></a>6.2 RSA 加密</h2><p>在 RSA 中，<strong>明文、秘钥和密文都是数字</strong>， RSA 的加密过程可以用下列公式来表示：  </p>\n<h4 id=\"密文-明文-E-mod-N\"><a href=\"#密文-明文-E-mod-N\" class=\"headerlink\" title=\"密文 = 明文 ^ E mod N\"></a>密文 = 明文 ^ E mod N</h4><p>也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。<br>就是这么简单。<br>其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。<br>现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。</p>\n<h2 id=\"6-3-RSA-解密\"><a href=\"#6-3-RSA-解密\" class=\"headerlink\" title=\"6.3 RSA 解密\"></a>6.3 RSA 解密</h2><h4 id=\"明文-密文-D-mod-N\"><a href=\"#明文-密文-D-mod-N\" class=\"headerlink\" title=\"明文 = 密文 ^ D mod N\"></a>明文 = 密文 ^ D mod N</h4><p>也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。  </p>\n<p>RSA 的加密和解密整理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_3.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_4.png\" alt=\"\"></p>\n<h2 id=\"6-4-生成密钥对\"><a href=\"#6-4-生成密钥对\" class=\"headerlink\" title=\"6.4 生成密钥对\"></a>6.4 生成密钥对</h2><p>由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下：  </p>\n<ol>\n<li>求 N</li>\n<li>求 L（中间值）</li>\n<li>求 E</li>\n<li>求 D</li>\n</ol>\n<p>注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。</p>\n<h1 id=\"7-对-RSA-的攻击\"><a href=\"#7-对-RSA-的攻击\" class=\"headerlink\" title=\"7 对 RSA 的攻击\"></a>7 对 RSA 的攻击</h1><p>RSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。<br>破译者知道的信息：密文、E、N。<br>破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。</p>\n<h2 id=\"7-1-通过密文来求得明文\"><a href=\"#7-1-通过密文来求得明文\" class=\"headerlink\" title=\"7.1 通过密文来求得明文\"></a>7.1 通过密文来求得明文</h2><p>密文 = 明文 ^ E mod N<br>如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难，<br>因为人类还没有发现求离散对数的高效算法。</p>\n<h2 id=\"7-2-通过暴力破解来找出-D\"><a href=\"#7-2-通过暴力破解来找出-D\" class=\"headerlink\" title=\"7.2 通过暴力破解来找出 D\"></a>7.2 通过暴力破解来找出 D</h2><p>由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。</p>\n<h2 id=\"7-3-通过-E-和-N-求出-D\"><a href=\"#7-3-通过-E-和-N-求出-D\" class=\"headerlink\" title=\"7.3 通过 E 和 N 求出 D\"></a>7.3 通过 E 和 N 求出 D</h2><p>既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。</p>\n<h2 id=\"7-4-中间人攻击\"><a href=\"#7-4-中间人攻击\" class=\"headerlink\" title=\"7.4 中间人攻击\"></a>7.4 中间人攻击</h2><p>下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。  </p>\n<p>假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。  </p>\n<ol>\n<li>Alice 向 Bob 发送邮件索要公钥</li>\n<li>Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。</li>\n<li>Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。</li>\n<li>Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。</li>\n<li>Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。</li>\n<li>Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。</li>\n<li>Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。</li>\n<li>Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。  </li>\n</ol>\n<p>Mallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！  </p>\n<p>我们用公钥密码解决了密钥配送问题，但是又出现新的问题，<strong>如何判断收到的公钥是否来自于正确的接收者</strong>，即是否来自于 Bob 。解决这个问题成为认证，<br>将在第十章详解。</p>\n<h1 id=\"8-其它公钥密码\"><a href=\"#8-其它公钥密码\" class=\"headerlink\" title=\"8 其它公钥密码\"></a>8 其它公钥密码</h1><p>RSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。<br>这些密码都可以被用于一般的加密和数字签名。</p>\n<h2 id=\"8-1-EIGamal-方式\"><a href=\"#8-1-EIGamal-方式\" class=\"headerlink\" title=\"8.1 EIGamal 方式\"></a>8.1 EIGamal 方式</h2><p>RSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。</p>\n<h2 id=\"8-2-Rabin-方式\"><a href=\"#8-2-Rabin-方式\" class=\"headerlink\" title=\"8.2 Rabin 方式\"></a>8.2 Rabin 方式</h2><p>Rabin 利用了 mod N 求平方根的困难度。</p>\n<h2 id=\"8-3-椭圆曲线密码\"><a href=\"#8-3-椭圆曲线密码\" class=\"headerlink\" title=\"8.3 椭圆曲线密码\"></a>8.3 椭圆曲线密码</h2><p>椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。<br>它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。</p>\n<h1 id=\"9-关于公钥密码的问答\"><a href=\"#9-关于公钥密码的问答\" class=\"headerlink\" title=\"9 关于公钥密码的问答\"></a>9 关于公钥密码的问答</h1><p>主要选择一些容易被误解的点解答疑问。</p>\n<h2 id=\"9-1-公钥密码的机密性\"><a href=\"#9-1-公钥密码的机密性\" class=\"headerlink\" title=\"9.1 公钥密码的机密性\"></a>9.1 公钥密码的机密性</h2><p>公钥密码比对称密码的机密性更高吗？<br>这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。</p>\n<h2 id=\"9-2-公钥密码与对称密码的密钥长度\"><a href=\"#9-2-公钥密码与对称密码的密钥长度\" class=\"headerlink\" title=\"9.2 公钥密码与对称密码的密钥长度\"></a>9.2 公钥密码与对称密码的密钥长度</h2><p>采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？<br>不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与<br> 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_5.png\" alt=\"\"></p>\n<h2 id=\"9-3-对称密码的未来\"><a href=\"#9-3-对称密码的未来\" class=\"headerlink\" title=\"9.3 对称密码的未来\"></a>9.3 对称密码的未来</h2><p>因为已经有了公钥密码，今后对称密码会消失吗？<br>不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。<br>根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。</p>\n<h2 id=\"9-4-RSA-和质数\"><a href=\"#9-4-RSA-和质数\" class=\"headerlink\" title=\"9.4 RSA 和质数\"></a>9.4 RSA 和质数</h2><p>随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？<br>512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后：<br>100亿人<em>100亿个</em>31622400秒*100亿年 &lt; 10^39。<br>另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。</p>\n<h2 id=\"9-5-RSA-与质因数分解\"><a href=\"#9-5-RSA-与质因数分解\" class=\"headerlink\" title=\"9.5 RSA 与质因数分解\"></a>9.5 RSA 与质因数分解</h2><p>RSA 的破译与大整数的质因数分解是等价的吗？<br>不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。</p>\n<h2 id=\"9-6-RSA-的长度\"><a href=\"#9-6-RSA-的长度\" class=\"headerlink\" title=\"9.6 RSA 的长度\"></a>9.6 RSA 的长度</h2><p>要抵御质因数分解，N 的长度需要达到多少比特呢？<br>N 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。</p>\n<h1 id=\"10-本章小结\"><a href=\"#10-本章小结\" class=\"headerlink\" title=\"10 本章小结\"></a>10 本章小结</h1><p>本章学习了公钥密码以及其代表性的实现方法——RSA。<br>使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！<br>对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解<br>问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。  </p>\n<p>尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题<br>将在第九章和第十章详解。  </p>\n<p>即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码<br>提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。</p>\n<h1 id=\"11-小测验\"><a href=\"#11-小测验\" class=\"headerlink\" title=\"11 小测验\"></a>11 小测验</h1><ol>\n<li>秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。<br>为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？</li>\n<li>要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。</li>\n<li>公钥密码的私钥需要和加密后的消息一起被发送给接收者。</li>\n<li>一般来说，对称密码的速度比公钥密码要快。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-投币寄物柜的使用方法\"><a href=\"#1-投币寄物柜的使用方法\" class=\"headerlink\" title=\"1 投币寄物柜的使用方法\"></a>1 投币寄物柜的使用方法</h1><p>介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。<br>只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。  </p>\n<p>因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><p>在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用<br>公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。  </p>\n<p>本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。</p>\n<h1 id=\"3-密钥配送问题\"><a href=\"#3-密钥配送问题\" class=\"headerlink\" title=\"3 密钥配送问题\"></a>3 密钥配送问题</h1><h2 id=\"3-1-什么是密钥配送问题\"><a href=\"#3-1-什么是密钥配送问题\" class=\"headerlink\" title=\"3.1 什么是密钥配送问题\"></a>3.1 什么是密钥配送问题</h2><p>在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是<br>非常危险的。  </p>\n<p>密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种：  </p>\n<ol>\n<li>通过事先共享密钥来解决</li>\n<li>通过密钥分配中心来解决</li>\n<li>通过 Diffie-Hellman 密钥交换来解决</li>\n<li>通过公钥密码来解决</li>\n</ol>\n<h2 id=\"3-2-通过事先共享密钥来解决\"><a href=\"#3-2-通过事先共享密钥来解决\" class=\"headerlink\" title=\"3.2 通过事先共享密钥来解决\"></a>3.2 通过事先共享密钥来解决</h2><p>事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个<br>公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！</p>\n<h1 id=\"3-3-通过秘钥分配中心来解决\"><a href=\"#3-3-通过秘钥分配中心来解决\" class=\"headerlink\" title=\"3.3 通过秘钥分配中心来解决\"></a>3.3 通过秘钥分配中心来解决</h1><p>公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会<br>从入职时从秘钥分配中心的计算机上领取自己的秘钥。<br>这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。  </p>\n<p>那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤：  </p>\n<ol>\n<li>Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求</li>\n<li>秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥</li>\n<li>秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥</li>\n<li>秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice</li>\n<li>秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob</li>\n<li>Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥</li>\n<li>Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob</li>\n<li>Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥</li>\n<li>Bob 用会话秘钥对来自 Alice 的密文进行解密</li>\n<li>Alice 和 Bob 删除会话秘钥  </li>\n</ol>\n<p>以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见：  </p>\n<ol>\n<li>随着员工增加，秘钥分配中心负荷增大</li>\n<li>如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪</li>\n<li>攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重</li>\n</ol>\n<h2 id=\"3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题\"><a href=\"#3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题\" class=\"headerlink\" title=\"3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题\"></a>3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题</h2><p>解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。<br>根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。</p>\n<h2 id=\"3-5-通过公钥密码来解决秘钥配送问题\"><a href=\"#3-5-通过公钥密码来解决秘钥配送问题\" class=\"headerlink\" title=\"3.5 通过公钥密码来解决秘钥配送问题\"></a>3.5 通过公钥密码来解决秘钥配送问题</h2><p>第四种方法，就是公钥密码。  </p>\n<p>在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有<br>解密秘钥的人才能够进行解密。  </p>\n<p>接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥<br>的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。</p>\n<h1 id=\"4-公钥密码\"><a href=\"#4-公钥密码\" class=\"headerlink\" title=\"4 公钥密码\"></a>4 公钥密码</h1><h2 id=\"4-1-什么是公钥密码\"><a href=\"#4-1-什么是公钥密码\" class=\"headerlink\" title=\"4.1 什么是公钥密码\"></a>4.1 什么是公钥密码</h2><p>公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。<br>加密秘钥和解密秘钥的区别：  </p>\n<ol>\n<li>发送者只需要加密秘钥</li>\n<li>接收者只需要解密秘钥</li>\n<li>解密秘钥不可以被窃听者获取</li>\n<li>加密秘钥被窃听者获取也没问题</li>\n</ol>\n<p>也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。  </p>\n<p>公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。</p>\n<h2 id=\"4-2-公钥密码的历史\"><a href=\"#4-2-公钥密码的历史\" class=\"headerlink\" title=\"4.2 公钥密码的历史\"></a>4.2 公钥密码的历史</h2><ol>\n<li>1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。  </li>\n<li>1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。</li>\n<li>1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。</li>\n</ol>\n<h2 id=\"4-3-公钥通信的流程\"><a href=\"#4-3-公钥通信的流程\" class=\"headerlink\" title=\"4.3 公钥通信的流程\"></a>4.3 公钥通信的流程</h2><p>Alice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的：  </p>\n<ol>\n<li>Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。</li>\n<li>Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。</li>\n<li>Alice 用 Bob 的公钥对消息进行加密。</li>\n<li>Alice 将密文发送给 Bob 。密文被 Eve 获得。</li>\n<li>Bob 用自己的私钥对密文进行解密。</li>\n</ol>\n<h2 id=\"4-4-公钥密码无法解决的问题\"><a href=\"#4-4-公钥密码无法解决的问题\" class=\"headerlink\" title=\"4.4 公钥密码无法解决的问题\"></a>4.4 公钥密码无法解决的问题</h2><p>我们需要判断所得到的公钥是否正确合法，这个问题被称为<strong>公钥认证</strong>问题。这个问题随后将通过对中间人攻击的讲解来探讨。<br>同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。</p>\n<h1 id=\"5-时钟算法\"><a href=\"#5-时钟算法\" class=\"headerlink\" title=\"5 时钟算法\"></a>5 时钟算法</h1><p>在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。</p>\n<h2 id=\"5-1-加法\"><a href=\"#5-1-加法\" class=\"headerlink\" title=\"5.1 加法\"></a>5.1 加法</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_1.png\" alt=\"\"><br>指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。  </p>\n<p>因此加法就变成了求余数运算，即 mod 运算。</p>\n<h2 id=\"5-2-减法\"><a href=\"#5-2-减法\" class=\"headerlink\" title=\"5.2 减法\"></a>5.2 减法</h2><p>减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 =&gt; x = 6。</p>\n<h2 id=\"5-3-乘法\"><a href=\"#5-3-乘法\" class=\"headerlink\" title=\"5.3 乘法\"></a>5.3 乘法</h2><p>乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 =&gt; -9 + 12 = 3。</p>\n<h2 id=\"5-4-除法\"><a href=\"#5-4-除法\" class=\"headerlink\" title=\"5.4 除法\"></a>5.4 除法</h2><p>除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。</p>\n<h2 id=\"5-5-乘方\"><a href=\"#5-5-乘方\" class=\"headerlink\" title=\"5.5 乘方\"></a>5.5 乘方</h2><p>7^4：7^4 mod 12 = 2401 mod 12 = 1</p>\n<h2 id=\"5-6-对数\"><a href=\"#5-6-对数\" class=\"headerlink\" title=\"5.6 对数\"></a>5.6 对数</h2><p>即乘方的逆运算：7^X = Y ，已知 Y 求 X。<br>在时钟运算中的对数称为离散对数。例如：<br>7^X mod 12 = 8，<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_2.png\" alt=\"\"><br>得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。</p>\n<h2 id=\"5-7-从时钟指针到-RSA\"><a href=\"#5-7-从时钟指针到-RSA\" class=\"headerlink\" title=\"5.7 从时钟指针到 RSA\"></a>5.7 从时钟指针到 RSA</h2><p>我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。</p>\n<h1 id=\"6-RSA\"><a href=\"#6-RSA\" class=\"headerlink\" title=\"6 RSA\"></a>6 RSA</h1><h2 id=\"6-1-什么是-RSA\"><a href=\"#6-1-什么是-RSA\" class=\"headerlink\" title=\"6.1 什么是 RSA\"></a>6.1 什么是 RSA</h2><p>RSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。<br>RSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。<br>RSA 在 1983年取得了专利，但现在专利已经过期。</p>\n<h2 id=\"6-2-RSA-加密\"><a href=\"#6-2-RSA-加密\" class=\"headerlink\" title=\"6.2 RSA 加密\"></a>6.2 RSA 加密</h2><p>在 RSA 中，<strong>明文、秘钥和密文都是数字</strong>， RSA 的加密过程可以用下列公式来表示：  </p>\n<h4 id=\"密文-明文-E-mod-N\"><a href=\"#密文-明文-E-mod-N\" class=\"headerlink\" title=\"密文 = 明文 ^ E mod N\"></a>密文 = 明文 ^ E mod N</h4><p>也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。<br>就是这么简单。<br>其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。<br>现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。</p>\n<h2 id=\"6-3-RSA-解密\"><a href=\"#6-3-RSA-解密\" class=\"headerlink\" title=\"6.3 RSA 解密\"></a>6.3 RSA 解密</h2><h4 id=\"明文-密文-D-mod-N\"><a href=\"#明文-密文-D-mod-N\" class=\"headerlink\" title=\"明文 = 密文 ^ D mod N\"></a>明文 = 密文 ^ D mod N</h4><p>也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。  </p>\n<p>RSA 的加密和解密整理如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_3.png\" alt=\"\"><br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_4.png\" alt=\"\"></p>\n<h2 id=\"6-4-生成密钥对\"><a href=\"#6-4-生成密钥对\" class=\"headerlink\" title=\"6.4 生成密钥对\"></a>6.4 生成密钥对</h2><p>由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下：  </p>\n<ol>\n<li>求 N</li>\n<li>求 L（中间值）</li>\n<li>求 E</li>\n<li>求 D</li>\n</ol>\n<p>注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。</p>\n<h1 id=\"7-对-RSA-的攻击\"><a href=\"#7-对-RSA-的攻击\" class=\"headerlink\" title=\"7 对 RSA 的攻击\"></a>7 对 RSA 的攻击</h1><p>RSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。<br>破译者知道的信息：密文、E、N。<br>破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。</p>\n<h2 id=\"7-1-通过密文来求得明文\"><a href=\"#7-1-通过密文来求得明文\" class=\"headerlink\" title=\"7.1 通过密文来求得明文\"></a>7.1 通过密文来求得明文</h2><p>密文 = 明文 ^ E mod N<br>如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难，<br>因为人类还没有发现求离散对数的高效算法。</p>\n<h2 id=\"7-2-通过暴力破解来找出-D\"><a href=\"#7-2-通过暴力破解来找出-D\" class=\"headerlink\" title=\"7.2 通过暴力破解来找出 D\"></a>7.2 通过暴力破解来找出 D</h2><p>由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。</p>\n<h2 id=\"7-3-通过-E-和-N-求出-D\"><a href=\"#7-3-通过-E-和-N-求出-D\" class=\"headerlink\" title=\"7.3 通过 E 和 N 求出 D\"></a>7.3 通过 E 和 N 求出 D</h2><p>既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。</p>\n<h2 id=\"7-4-中间人攻击\"><a href=\"#7-4-中间人攻击\" class=\"headerlink\" title=\"7.4 中间人攻击\"></a>7.4 中间人攻击</h2><p>下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。  </p>\n<p>假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。  </p>\n<ol>\n<li>Alice 向 Bob 发送邮件索要公钥</li>\n<li>Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。</li>\n<li>Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。</li>\n<li>Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。</li>\n<li>Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。</li>\n<li>Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。</li>\n<li>Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。</li>\n<li>Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。  </li>\n</ol>\n<p>Mallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！  </p>\n<p>我们用公钥密码解决了密钥配送问题，但是又出现新的问题，<strong>如何判断收到的公钥是否来自于正确的接收者</strong>，即是否来自于 Bob 。解决这个问题成为认证，<br>将在第十章详解。</p>\n<h1 id=\"8-其它公钥密码\"><a href=\"#8-其它公钥密码\" class=\"headerlink\" title=\"8 其它公钥密码\"></a>8 其它公钥密码</h1><p>RSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。<br>这些密码都可以被用于一般的加密和数字签名。</p>\n<h2 id=\"8-1-EIGamal-方式\"><a href=\"#8-1-EIGamal-方式\" class=\"headerlink\" title=\"8.1 EIGamal 方式\"></a>8.1 EIGamal 方式</h2><p>RSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。</p>\n<h2 id=\"8-2-Rabin-方式\"><a href=\"#8-2-Rabin-方式\" class=\"headerlink\" title=\"8.2 Rabin 方式\"></a>8.2 Rabin 方式</h2><p>Rabin 利用了 mod N 求平方根的困难度。</p>\n<h2 id=\"8-3-椭圆曲线密码\"><a href=\"#8-3-椭圆曲线密码\" class=\"headerlink\" title=\"8.3 椭圆曲线密码\"></a>8.3 椭圆曲线密码</h2><p>椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。<br>它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。</p>\n<h1 id=\"9-关于公钥密码的问答\"><a href=\"#9-关于公钥密码的问答\" class=\"headerlink\" title=\"9 关于公钥密码的问答\"></a>9 关于公钥密码的问答</h1><p>主要选择一些容易被误解的点解答疑问。</p>\n<h2 id=\"9-1-公钥密码的机密性\"><a href=\"#9-1-公钥密码的机密性\" class=\"headerlink\" title=\"9.1 公钥密码的机密性\"></a>9.1 公钥密码的机密性</h2><p>公钥密码比对称密码的机密性更高吗？<br>这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。</p>\n<h2 id=\"9-2-公钥密码与对称密码的密钥长度\"><a href=\"#9-2-公钥密码与对称密码的密钥长度\" class=\"headerlink\" title=\"9.2 公钥密码与对称密码的密钥长度\"></a>9.2 公钥密码与对称密码的密钥长度</h2><p>采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？<br>不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与<br> 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_5.png\" alt=\"\"></p>\n<h2 id=\"9-3-对称密码的未来\"><a href=\"#9-3-对称密码的未来\" class=\"headerlink\" title=\"9.3 对称密码的未来\"></a>9.3 对称密码的未来</h2><p>因为已经有了公钥密码，今后对称密码会消失吗？<br>不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。<br>根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。</p>\n<h2 id=\"9-4-RSA-和质数\"><a href=\"#9-4-RSA-和质数\" class=\"headerlink\" title=\"9.4 RSA 和质数\"></a>9.4 RSA 和质数</h2><p>随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？<br>512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后：<br>100亿人<em>100亿个</em>31622400秒*100亿年 &lt; 10^39。<br>另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。</p>\n<h2 id=\"9-5-RSA-与质因数分解\"><a href=\"#9-5-RSA-与质因数分解\" class=\"headerlink\" title=\"9.5 RSA 与质因数分解\"></a>9.5 RSA 与质因数分解</h2><p>RSA 的破译与大整数的质因数分解是等价的吗？<br>不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。</p>\n<h2 id=\"9-6-RSA-的长度\"><a href=\"#9-6-RSA-的长度\" class=\"headerlink\" title=\"9.6 RSA 的长度\"></a>9.6 RSA 的长度</h2><p>要抵御质因数分解，N 的长度需要达到多少比特呢？<br>N 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。</p>\n<h1 id=\"10-本章小结\"><a href=\"#10-本章小结\" class=\"headerlink\" title=\"10 本章小结\"></a>10 本章小结</h1><p>本章学习了公钥密码以及其代表性的实现方法——RSA。<br>使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！<br>对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解<br>问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。  </p>\n<p>尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题<br>将在第九章和第十章详解。  </p>\n<p>即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码<br>提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。</p>\n<h1 id=\"11-小测验\"><a href=\"#11-小测验\" class=\"headerlink\" title=\"11 小测验\"></a>11 小测验</h1><ol>\n<li>秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。<br>为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？</li>\n<li>要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。</li>\n<li>公钥密码的私钥需要和加密后的消息一起被发送给接收者。</li>\n<li>一般来说，对称密码的速度比公钥密码要快。</li>\n</ol>\n"},{"title":"八、消息认证码","date":"2017-11-19T15:09:00.000Z","updated":"2017-11-20T17:07:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。  \n消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。\n\n# 2 消息认证码\n\n## 2.1 汇款请求是正确的吗\n\n我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。  \n消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。  \n消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。  \n本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。\n\n## 2.2 什么是消息认证码\n\n消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 **MAC**。  \n消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。  \n根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。  \n要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。  \n  \n后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：**消息认证码是一种与秘钥相关联的单向散列函数**。  \n![][1]\n\n## 2.3 消息认证码的使用步骤\n\n以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。  \n![][2]  \n1. 发送者 Alice 与接收者 Bob 事先共享秘钥。\n2. 发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。\n3. 发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。\n4. 接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥）\n5. 接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。\n6. 如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。\n\n## 2.4 消息认证码的秘钥配送问题\n\n发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。\n\n# 3 消息认证码的应用实例\n\n## 3.1 SWIFT\n\nSWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。  \n在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。\n\n## 3.2 IPsec\n\nIPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。\n\n## 3.3 SSL/TLS\n\nSSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。\n\n# 4 消息认证码的实现方法\n\n## 4.1 使用单向散列函数实现\n\n使用 SHA-1、MD5 之类的**单向散列函数**可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。\n\n## 4.2 使用分组密码实现\n\n使用 DES、AES 之类的**分组密码**可以实现消息认证码。  \n将分组密码的秘钥作为消息认证码的共享秘钥来使用。\n\n## 4.3 其它实现方法\n\n使用流密码和公钥密码等也可以实现消息认证码。\n\n# 5 HMAC 的详细介绍\n\n## 5.1 什么是 HMAC\n\nHMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。  \nHMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。  \n使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。\n\n## 5.2 HMAC 的步骤\n\n![][3]  \n### 1.秘钥填充\n如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。  \n如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。\n\n### 2.填充后的秘钥与 ipad 的 XOR\n将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。  \nXOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且**和秘钥相关的比特序列**。这里我们将这个比特序列称为 ipadkey。\n\n### 3.与消息组合\n随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。\n\n### 4.计算散列值\n将第三步的结果输入单向散列函数，并计算出散列值。\n\n### 5.填充后的秘钥与 opad 的 XOR\n将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。  \nXOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。  \n![][4]\n\n### 6. 与散列值组合\n将第四步的散列值拼在 opadkey 后面。\n\n### 7.计算散列值\n将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。  \n通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。\n\n# 6 对消息认证码的攻击\n\n## 6.1 重放攻击\n\nMallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。  \n1. Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。\n2. Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。\n3. Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。\n4. Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。\n5. Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。\n6. Mallory 继续重复第四步。\n7. Bob 银行重复第五步。\n\n有几种方法可以防御重放攻击。\n\n### 1.序号\n约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。\n\n### 2.时间戳\n约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。\n\n### 3.nonce\n在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。  \n![][5]\n\n## 6.2 密码推测攻击\n\n和对单向散列函数的攻击一样，对消息认证码也可以进行**暴力破解**以及**生日攻击**（7.6.2节）。  \n对于消息认证码来说，应保证**不能根据 MAC 值推测出通信双方所使用的秘钥**。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。  \n此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。\n\n# 7 消息认证码无法解决的问题\n\n## 7.1 对第三方证明\n\n假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。\n\n## 7.2 防止否认\n\n假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。  \n即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法**防止否认**（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。\n\n# 8 本章小结\n\n本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。  \n其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。  \n消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。  \n下一章的数字签名可以解决这些问题。\n\n# 9 小测验\n\n1. 使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。\n2. 使用消息认证码能够识别出篡改行为。\n3. 使用消息认证码需要发送者和接收者之间共享的秘钥。\n4. 使用消息认证码能够防止否认。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_5.png","source":"_posts/图解密码技术/第八章 消息认证码.md","raw":"---\ntitle: 八、消息认证码\ndate: 2017-11-19 23:09:00\nupdated: 2017-11-21 01:07:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/8.html    \n---\n\n# 1 本章概要\n\n使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。  \n消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。\n\n# 2 消息认证码\n\n## 2.1 汇款请求是正确的吗\n\n我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。  \n消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。  \n消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。  \n本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。\n\n## 2.2 什么是消息认证码\n\n消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 **MAC**。  \n消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。  \n根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。  \n要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。  \n  \n后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：**消息认证码是一种与秘钥相关联的单向散列函数**。  \n![][1]\n\n## 2.3 消息认证码的使用步骤\n\n以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。  \n![][2]  \n1. 发送者 Alice 与接收者 Bob 事先共享秘钥。\n2. 发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。\n3. 发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。\n4. 接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥）\n5. 接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。\n6. 如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。\n\n## 2.4 消息认证码的秘钥配送问题\n\n发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。\n\n# 3 消息认证码的应用实例\n\n## 3.1 SWIFT\n\nSWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。  \n在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。\n\n## 3.2 IPsec\n\nIPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。\n\n## 3.3 SSL/TLS\n\nSSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。\n\n# 4 消息认证码的实现方法\n\n## 4.1 使用单向散列函数实现\n\n使用 SHA-1、MD5 之类的**单向散列函数**可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。\n\n## 4.2 使用分组密码实现\n\n使用 DES、AES 之类的**分组密码**可以实现消息认证码。  \n将分组密码的秘钥作为消息认证码的共享秘钥来使用。\n\n## 4.3 其它实现方法\n\n使用流密码和公钥密码等也可以实现消息认证码。\n\n# 5 HMAC 的详细介绍\n\n## 5.1 什么是 HMAC\n\nHMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。  \nHMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。  \n使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。\n\n## 5.2 HMAC 的步骤\n\n![][3]  \n### 1.秘钥填充\n如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。  \n如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。\n\n### 2.填充后的秘钥与 ipad 的 XOR\n将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。  \nXOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且**和秘钥相关的比特序列**。这里我们将这个比特序列称为 ipadkey。\n\n### 3.与消息组合\n随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。\n\n### 4.计算散列值\n将第三步的结果输入单向散列函数，并计算出散列值。\n\n### 5.填充后的秘钥与 opad 的 XOR\n将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。  \nXOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。  \n![][4]\n\n### 6. 与散列值组合\n将第四步的散列值拼在 opadkey 后面。\n\n### 7.计算散列值\n将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。  \n通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。\n\n# 6 对消息认证码的攻击\n\n## 6.1 重放攻击\n\nMallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。  \n1. Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。\n2. Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。\n3. Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。\n4. Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。\n5. Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。\n6. Mallory 继续重复第四步。\n7. Bob 银行重复第五步。\n\n有几种方法可以防御重放攻击。\n\n### 1.序号\n约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。\n\n### 2.时间戳\n约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。\n\n### 3.nonce\n在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。  \n![][5]\n\n## 6.2 密码推测攻击\n\n和对单向散列函数的攻击一样，对消息认证码也可以进行**暴力破解**以及**生日攻击**（7.6.2节）。  \n对于消息认证码来说，应保证**不能根据 MAC 值推测出通信双方所使用的秘钥**。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。  \n此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。\n\n# 7 消息认证码无法解决的问题\n\n## 7.1 对第三方证明\n\n假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。\n\n## 7.2 防止否认\n\n假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。  \n即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法**防止否认**（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。\n\n# 8 本章小结\n\n本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。  \n其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。  \n消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。  \n下一章的数字签名可以解决这些问题。\n\n# 9 小测验\n\n1. 使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。\n2. 使用消息认证码能够识别出篡改行为。\n3. 使用消息认证码需要发送者和接收者之间共享的秘钥。\n4. 使用消息认证码能够防止否认。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_5.png","slug":"graphic2cryptography/8.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavx002raxs6kfr0gnfp","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。<br>消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。</p>\n<h1 id=\"2-消息认证码\"><a href=\"#2-消息认证码\" class=\"headerlink\" title=\"2 消息认证码\"></a>2 消息认证码</h1><h2 id=\"2-1-汇款请求是正确的吗\"><a href=\"#2-1-汇款请求是正确的吗\" class=\"headerlink\" title=\"2.1 汇款请求是正确的吗\"></a>2.1 汇款请求是正确的吗</h2><p>我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。<br>消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。<br>消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。<br>本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。</p>\n<h2 id=\"2-2-什么是消息认证码\"><a href=\"#2-2-什么是消息认证码\" class=\"headerlink\" title=\"2.2 什么是消息认证码\"></a>2.2 什么是消息认证码</h2><p>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 <strong>MAC</strong>。<br>消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。<br>根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。<br>要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。  </p>\n<p>后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：<strong>消息认证码是一种与秘钥相关联的单向散列函数</strong>。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_1.png\" alt=\"\"></p>\n<h2 id=\"2-3-消息认证码的使用步骤\"><a href=\"#2-3-消息认证码的使用步骤\" class=\"headerlink\" title=\"2.3 消息认证码的使用步骤\"></a>2.3 消息认证码的使用步骤</h2><p>以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_2.png\" alt=\"\">  </p>\n<ol>\n<li>发送者 Alice 与接收者 Bob 事先共享秘钥。</li>\n<li>发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。</li>\n<li>发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。</li>\n<li>接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥）</li>\n<li>接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。</li>\n<li>如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。</li>\n</ol>\n<h2 id=\"2-4-消息认证码的秘钥配送问题\"><a href=\"#2-4-消息认证码的秘钥配送问题\" class=\"headerlink\" title=\"2.4 消息认证码的秘钥配送问题\"></a>2.4 消息认证码的秘钥配送问题</h2><p>发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。</p>\n<h1 id=\"3-消息认证码的应用实例\"><a href=\"#3-消息认证码的应用实例\" class=\"headerlink\" title=\"3 消息认证码的应用实例\"></a>3 消息认证码的应用实例</h1><h2 id=\"3-1-SWIFT\"><a href=\"#3-1-SWIFT\" class=\"headerlink\" title=\"3.1 SWIFT\"></a>3.1 SWIFT</h2><p>SWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。<br>在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。</p>\n<h2 id=\"3-2-IPsec\"><a href=\"#3-2-IPsec\" class=\"headerlink\" title=\"3.2 IPsec\"></a>3.2 IPsec</h2><p>IPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。</p>\n<h2 id=\"3-3-SSL-TLS\"><a href=\"#3-3-SSL-TLS\" class=\"headerlink\" title=\"3.3 SSL/TLS\"></a>3.3 SSL/TLS</h2><p>SSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。</p>\n<h1 id=\"4-消息认证码的实现方法\"><a href=\"#4-消息认证码的实现方法\" class=\"headerlink\" title=\"4 消息认证码的实现方法\"></a>4 消息认证码的实现方法</h1><h2 id=\"4-1-使用单向散列函数实现\"><a href=\"#4-1-使用单向散列函数实现\" class=\"headerlink\" title=\"4.1 使用单向散列函数实现\"></a>4.1 使用单向散列函数实现</h2><p>使用 SHA-1、MD5 之类的<strong>单向散列函数</strong>可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。</p>\n<h2 id=\"4-2-使用分组密码实现\"><a href=\"#4-2-使用分组密码实现\" class=\"headerlink\" title=\"4.2 使用分组密码实现\"></a>4.2 使用分组密码实现</h2><p>使用 DES、AES 之类的<strong>分组密码</strong>可以实现消息认证码。<br>将分组密码的秘钥作为消息认证码的共享秘钥来使用。</p>\n<h2 id=\"4-3-其它实现方法\"><a href=\"#4-3-其它实现方法\" class=\"headerlink\" title=\"4.3 其它实现方法\"></a>4.3 其它实现方法</h2><p>使用流密码和公钥密码等也可以实现消息认证码。</p>\n<h1 id=\"5-HMAC-的详细介绍\"><a href=\"#5-HMAC-的详细介绍\" class=\"headerlink\" title=\"5 HMAC 的详细介绍\"></a>5 HMAC 的详细介绍</h1><h2 id=\"5-1-什么是-HMAC\"><a href=\"#5-1-什么是-HMAC\" class=\"headerlink\" title=\"5.1 什么是 HMAC\"></a>5.1 什么是 HMAC</h2><p>HMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。<br>HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。<br>使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。</p>\n<h2 id=\"5-2-HMAC-的步骤\"><a href=\"#5-2-HMAC-的步骤\" class=\"headerlink\" title=\"5.2 HMAC 的步骤\"></a>5.2 HMAC 的步骤</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_3.png\" alt=\"\">  </p>\n<h3 id=\"1-秘钥填充\"><a href=\"#1-秘钥填充\" class=\"headerlink\" title=\"1.秘钥填充\"></a>1.秘钥填充</h3><p>如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。<br>如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。</p>\n<h3 id=\"2-填充后的秘钥与-ipad-的-XOR\"><a href=\"#2-填充后的秘钥与-ipad-的-XOR\" class=\"headerlink\" title=\"2.填充后的秘钥与 ipad 的 XOR\"></a>2.填充后的秘钥与 ipad 的 XOR</h3><p>将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。<br>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且<strong>和秘钥相关的比特序列</strong>。这里我们将这个比特序列称为 ipadkey。</p>\n<h3 id=\"3-与消息组合\"><a href=\"#3-与消息组合\" class=\"headerlink\" title=\"3.与消息组合\"></a>3.与消息组合</h3><p>随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。</p>\n<h3 id=\"4-计算散列值\"><a href=\"#4-计算散列值\" class=\"headerlink\" title=\"4.计算散列值\"></a>4.计算散列值</h3><p>将第三步的结果输入单向散列函数，并计算出散列值。</p>\n<h3 id=\"5-填充后的秘钥与-opad-的-XOR\"><a href=\"#5-填充后的秘钥与-opad-的-XOR\" class=\"headerlink\" title=\"5.填充后的秘钥与 opad 的 XOR\"></a>5.填充后的秘钥与 opad 的 XOR</h3><p>将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。<br>XOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_4.png\" alt=\"\"></p>\n<h3 id=\"6-与散列值组合\"><a href=\"#6-与散列值组合\" class=\"headerlink\" title=\"6. 与散列值组合\"></a>6. 与散列值组合</h3><p>将第四步的散列值拼在 opadkey 后面。</p>\n<h3 id=\"7-计算散列值\"><a href=\"#7-计算散列值\" class=\"headerlink\" title=\"7.计算散列值\"></a>7.计算散列值</h3><p>将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。<br>通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。</p>\n<h1 id=\"6-对消息认证码的攻击\"><a href=\"#6-对消息认证码的攻击\" class=\"headerlink\" title=\"6 对消息认证码的攻击\"></a>6 对消息认证码的攻击</h1><h2 id=\"6-1-重放攻击\"><a href=\"#6-1-重放攻击\" class=\"headerlink\" title=\"6.1 重放攻击\"></a>6.1 重放攻击</h2><p>Mallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。  </p>\n<ol>\n<li>Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。</li>\n<li>Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。</li>\n<li>Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。</li>\n<li>Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。</li>\n<li>Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。</li>\n<li>Mallory 继续重复第四步。</li>\n<li>Bob 银行重复第五步。</li>\n</ol>\n<p>有几种方法可以防御重放攻击。</p>\n<h3 id=\"1-序号\"><a href=\"#1-序号\" class=\"headerlink\" title=\"1.序号\"></a>1.序号</h3><p>约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。</p>\n<h3 id=\"2-时间戳\"><a href=\"#2-时间戳\" class=\"headerlink\" title=\"2.时间戳\"></a>2.时间戳</h3><p>约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。</p>\n<h3 id=\"3-nonce\"><a href=\"#3-nonce\" class=\"headerlink\" title=\"3.nonce\"></a>3.nonce</h3><p>在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_5.png\" alt=\"\"></p>\n<h2 id=\"6-2-密码推测攻击\"><a href=\"#6-2-密码推测攻击\" class=\"headerlink\" title=\"6.2 密码推测攻击\"></a>6.2 密码推测攻击</h2><p>和对单向散列函数的攻击一样，对消息认证码也可以进行<strong>暴力破解</strong>以及<strong>生日攻击</strong>（7.6.2节）。<br>对于消息认证码来说，应保证<strong>不能根据 MAC 值推测出通信双方所使用的秘钥</strong>。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。<br>此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。</p>\n<h1 id=\"7-消息认证码无法解决的问题\"><a href=\"#7-消息认证码无法解决的问题\" class=\"headerlink\" title=\"7 消息认证码无法解决的问题\"></a>7 消息认证码无法解决的问题</h1><h2 id=\"7-1-对第三方证明\"><a href=\"#7-1-对第三方证明\" class=\"headerlink\" title=\"7.1 对第三方证明\"></a>7.1 对第三方证明</h2><p>假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。</p>\n<h2 id=\"7-2-防止否认\"><a href=\"#7-2-防止否认\" class=\"headerlink\" title=\"7.2 防止否认\"></a>7.2 防止否认</h2><p>假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。<br>即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法<strong>防止否认</strong>（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。<br>其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。<br>消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。<br>下一章的数字签名可以解决这些问题。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><ol>\n<li>使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。</li>\n<li>使用消息认证码能够识别出篡改行为。</li>\n<li>使用消息认证码需要发送者和接收者之间共享的秘钥。</li>\n<li>使用消息认证码能够防止否认。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。<br>消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。</p>\n<h1 id=\"2-消息认证码\"><a href=\"#2-消息认证码\" class=\"headerlink\" title=\"2 消息认证码\"></a>2 消息认证码</h1><h2 id=\"2-1-汇款请求是正确的吗\"><a href=\"#2-1-汇款请求是正确的吗\" class=\"headerlink\" title=\"2.1 汇款请求是正确的吗\"></a>2.1 汇款请求是正确的吗</h2><p>我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。<br>消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。<br>消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。<br>本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。</p>\n<h2 id=\"2-2-什么是消息认证码\"><a href=\"#2-2-什么是消息认证码\" class=\"headerlink\" title=\"2.2 什么是消息认证码\"></a>2.2 什么是消息认证码</h2><p>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 <strong>MAC</strong>。<br>消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。<br>根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。<br>要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。  </p>\n<p>后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：<strong>消息认证码是一种与秘钥相关联的单向散列函数</strong>。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_1.png\" alt=\"\"></p>\n<h2 id=\"2-3-消息认证码的使用步骤\"><a href=\"#2-3-消息认证码的使用步骤\" class=\"headerlink\" title=\"2.3 消息认证码的使用步骤\"></a>2.3 消息认证码的使用步骤</h2><p>以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_2.png\" alt=\"\">  </p>\n<ol>\n<li>发送者 Alice 与接收者 Bob 事先共享秘钥。</li>\n<li>发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。</li>\n<li>发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。</li>\n<li>接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥）</li>\n<li>接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。</li>\n<li>如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。</li>\n</ol>\n<h2 id=\"2-4-消息认证码的秘钥配送问题\"><a href=\"#2-4-消息认证码的秘钥配送问题\" class=\"headerlink\" title=\"2.4 消息认证码的秘钥配送问题\"></a>2.4 消息认证码的秘钥配送问题</h2><p>发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。</p>\n<h1 id=\"3-消息认证码的应用实例\"><a href=\"#3-消息认证码的应用实例\" class=\"headerlink\" title=\"3 消息认证码的应用实例\"></a>3 消息认证码的应用实例</h1><h2 id=\"3-1-SWIFT\"><a href=\"#3-1-SWIFT\" class=\"headerlink\" title=\"3.1 SWIFT\"></a>3.1 SWIFT</h2><p>SWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。<br>在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。</p>\n<h2 id=\"3-2-IPsec\"><a href=\"#3-2-IPsec\" class=\"headerlink\" title=\"3.2 IPsec\"></a>3.2 IPsec</h2><p>IPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。</p>\n<h2 id=\"3-3-SSL-TLS\"><a href=\"#3-3-SSL-TLS\" class=\"headerlink\" title=\"3.3 SSL/TLS\"></a>3.3 SSL/TLS</h2><p>SSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。</p>\n<h1 id=\"4-消息认证码的实现方法\"><a href=\"#4-消息认证码的实现方法\" class=\"headerlink\" title=\"4 消息认证码的实现方法\"></a>4 消息认证码的实现方法</h1><h2 id=\"4-1-使用单向散列函数实现\"><a href=\"#4-1-使用单向散列函数实现\" class=\"headerlink\" title=\"4.1 使用单向散列函数实现\"></a>4.1 使用单向散列函数实现</h2><p>使用 SHA-1、MD5 之类的<strong>单向散列函数</strong>可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。</p>\n<h2 id=\"4-2-使用分组密码实现\"><a href=\"#4-2-使用分组密码实现\" class=\"headerlink\" title=\"4.2 使用分组密码实现\"></a>4.2 使用分组密码实现</h2><p>使用 DES、AES 之类的<strong>分组密码</strong>可以实现消息认证码。<br>将分组密码的秘钥作为消息认证码的共享秘钥来使用。</p>\n<h2 id=\"4-3-其它实现方法\"><a href=\"#4-3-其它实现方法\" class=\"headerlink\" title=\"4.3 其它实现方法\"></a>4.3 其它实现方法</h2><p>使用流密码和公钥密码等也可以实现消息认证码。</p>\n<h1 id=\"5-HMAC-的详细介绍\"><a href=\"#5-HMAC-的详细介绍\" class=\"headerlink\" title=\"5 HMAC 的详细介绍\"></a>5 HMAC 的详细介绍</h1><h2 id=\"5-1-什么是-HMAC\"><a href=\"#5-1-什么是-HMAC\" class=\"headerlink\" title=\"5.1 什么是 HMAC\"></a>5.1 什么是 HMAC</h2><p>HMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。<br>HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。<br>使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。</p>\n<h2 id=\"5-2-HMAC-的步骤\"><a href=\"#5-2-HMAC-的步骤\" class=\"headerlink\" title=\"5.2 HMAC 的步骤\"></a>5.2 HMAC 的步骤</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_3.png\" alt=\"\">  </p>\n<h3 id=\"1-秘钥填充\"><a href=\"#1-秘钥填充\" class=\"headerlink\" title=\"1.秘钥填充\"></a>1.秘钥填充</h3><p>如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。<br>如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。</p>\n<h3 id=\"2-填充后的秘钥与-ipad-的-XOR\"><a href=\"#2-填充后的秘钥与-ipad-的-XOR\" class=\"headerlink\" title=\"2.填充后的秘钥与 ipad 的 XOR\"></a>2.填充后的秘钥与 ipad 的 XOR</h3><p>将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。<br>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且<strong>和秘钥相关的比特序列</strong>。这里我们将这个比特序列称为 ipadkey。</p>\n<h3 id=\"3-与消息组合\"><a href=\"#3-与消息组合\" class=\"headerlink\" title=\"3.与消息组合\"></a>3.与消息组合</h3><p>随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。</p>\n<h3 id=\"4-计算散列值\"><a href=\"#4-计算散列值\" class=\"headerlink\" title=\"4.计算散列值\"></a>4.计算散列值</h3><p>将第三步的结果输入单向散列函数，并计算出散列值。</p>\n<h3 id=\"5-填充后的秘钥与-opad-的-XOR\"><a href=\"#5-填充后的秘钥与-opad-的-XOR\" class=\"headerlink\" title=\"5.填充后的秘钥与 opad 的 XOR\"></a>5.填充后的秘钥与 opad 的 XOR</h3><p>将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。<br>XOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_4.png\" alt=\"\"></p>\n<h3 id=\"6-与散列值组合\"><a href=\"#6-与散列值组合\" class=\"headerlink\" title=\"6. 与散列值组合\"></a>6. 与散列值组合</h3><p>将第四步的散列值拼在 opadkey 后面。</p>\n<h3 id=\"7-计算散列值\"><a href=\"#7-计算散列值\" class=\"headerlink\" title=\"7.计算散列值\"></a>7.计算散列值</h3><p>将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。<br>通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。</p>\n<h1 id=\"6-对消息认证码的攻击\"><a href=\"#6-对消息认证码的攻击\" class=\"headerlink\" title=\"6 对消息认证码的攻击\"></a>6 对消息认证码的攻击</h1><h2 id=\"6-1-重放攻击\"><a href=\"#6-1-重放攻击\" class=\"headerlink\" title=\"6.1 重放攻击\"></a>6.1 重放攻击</h2><p>Mallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。  </p>\n<ol>\n<li>Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。</li>\n<li>Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。</li>\n<li>Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。</li>\n<li>Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。</li>\n<li>Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。</li>\n<li>Mallory 继续重复第四步。</li>\n<li>Bob 银行重复第五步。</li>\n</ol>\n<p>有几种方法可以防御重放攻击。</p>\n<h3 id=\"1-序号\"><a href=\"#1-序号\" class=\"headerlink\" title=\"1.序号\"></a>1.序号</h3><p>约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。</p>\n<h3 id=\"2-时间戳\"><a href=\"#2-时间戳\" class=\"headerlink\" title=\"2.时间戳\"></a>2.时间戳</h3><p>约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。</p>\n<h3 id=\"3-nonce\"><a href=\"#3-nonce\" class=\"headerlink\" title=\"3.nonce\"></a>3.nonce</h3><p>在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_5.png\" alt=\"\"></p>\n<h2 id=\"6-2-密码推测攻击\"><a href=\"#6-2-密码推测攻击\" class=\"headerlink\" title=\"6.2 密码推测攻击\"></a>6.2 密码推测攻击</h2><p>和对单向散列函数的攻击一样，对消息认证码也可以进行<strong>暴力破解</strong>以及<strong>生日攻击</strong>（7.6.2节）。<br>对于消息认证码来说，应保证<strong>不能根据 MAC 值推测出通信双方所使用的秘钥</strong>。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。<br>此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。</p>\n<h1 id=\"7-消息认证码无法解决的问题\"><a href=\"#7-消息认证码无法解决的问题\" class=\"headerlink\" title=\"7 消息认证码无法解决的问题\"></a>7 消息认证码无法解决的问题</h1><h2 id=\"7-1-对第三方证明\"><a href=\"#7-1-对第三方证明\" class=\"headerlink\" title=\"7.1 对第三方证明\"></a>7.1 对第三方证明</h2><p>假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。</p>\n<h2 id=\"7-2-防止否认\"><a href=\"#7-2-防止否认\" class=\"headerlink\" title=\"7.2 防止否认\"></a>7.2 防止否认</h2><p>假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。<br>即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法<strong>防止否认</strong>（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。<br>其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。<br>消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。<br>下一章的数字签名可以解决这些问题。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><ol>\n<li>使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。</li>\n<li>使用消息认证码能够识别出篡改行为。</li>\n<li>使用消息认证码需要发送者和接收者之间共享的秘钥。</li>\n<li>使用消息认证码能够防止否认。</li>\n</ol>\n"},{"title":"十三、PGP——密码技术的完美组合","date":"2017-12-07T15:44:00.000Z","updated":"2017-12-07T15:44:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码技术进行组合的方法。\n\n# 2 PGP简介\n\nPGP 是 1990 年编写的密码软件。\n\n## 2.1 PGP 的功能\n\n### 1.对称密码\n### 2.公钥密码\n### 3.数字签名\n### 4.单向散列函数\n### 5.证书\n### 6.压缩\n### 7.文本数据\n### 8.大文件的拆分和平和\n### 9.钥匙串管理\n\n# 3 生成秘钥对\n\n# 4 加密与解密\n\n# 5 生成和验证数字签名\n\n# 6 生成数字签名并加密以及解密并验证数字签名\n\n# 7 信任网\n\n## 7.1 公钥合法性\n\n在使用 PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换（参 5.7.4节）。  \n第十章介绍的证书就是确认公钥合法性的方法之一。证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。  \n然而，PGP 中却没有使用认证机构，而是采用了一种叫**信任网**（web of trust）的方法。在这种方法中， PGP 用户会**互相对对方的公钥进行数字签名**。  \n信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。  \n下面介绍 PGP 的信任网是如何建立起来的。\n\n### 1.场景1：通过自己的数字签名进行确认\nAlice 和 Bob 约会，在告别的时候， Bob 给了 Alice 一张存储卡，并说“这是我的公钥”。  \nAlice 回到家中，从存储卡中取出 Bob 的公钥，并存放到自己所使用的 PGP 的公钥串中（导入公钥）。由于 Alice 确信刚刚导入的公钥确实是属于 Bob 本人的，因此 Alice 对这个公钥加上了自己的数字签名。  \n对 Bob 的公钥加上数字签名，就相当于 Alice 生命“这个公钥属于 Bob 本人（即这个公钥是合法的）”。  \n随后，Alice 收到了来自 Bob 的邮件，由于这封邮件带有 Bob 的数字签名，因此 Alice 想用 PGP 来验证 Bob 的数字签名。 PGP 将执行下面这些操作：  \n1. 为了验证 Bob 的数字签名， PGP 需要从 Alice 的公钥串中寻找 Bob 的公钥。\n2. Alice 的公钥串中包含 Bob 的公钥，因为前几天约会之后 Alice 导入了 Bob 的公钥。\n3. PGP 发现 Bob 的公钥带有 Alice 的数字签名。\n4. 为了验证 Alice 的数字签名，PGP 需要从 Alice 的公钥串中寻找 Alice 自己的公钥。\n5. PGP 使用 Alice 的公钥对 Bob 的公钥上的 Alice 的数字签名进行验证。如果验证成功，则可以确认这的确就是 Bob 的公钥。\n6. PGP 使用合法的 Bob 的公钥对邮件上附带的 Bob 的数字签名进行验证。\n\n### 2.场景2：通过自己完全信任的人的数字签名进行确认\nAlice 有一个叫 Trent 的男朋友。在 Alice 的公钥串中，也包含带有 Alice 的数字签名的 Trent 的公钥。 Alice 非常信任 Trent ，她想：**经过他签名的公钥一定是合法的**。  \n假设 Alice 收到了一封来自 Carrol 的邮件\n\n# 8 本章小结\n\n# 9 小测验 ","source":"_posts/图解密码技术/第十三章 PGP.md","raw":"---\ntitle: 十三、PGP——密码技术的完美组合\ndate: 2017-12-07 23:44:00\nupdated: 2017-12-07 23:44:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/13.html    \n---\n\n# 1 本章概要\n\n本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码技术进行组合的方法。\n\n# 2 PGP简介\n\nPGP 是 1990 年编写的密码软件。\n\n## 2.1 PGP 的功能\n\n### 1.对称密码\n### 2.公钥密码\n### 3.数字签名\n### 4.单向散列函数\n### 5.证书\n### 6.压缩\n### 7.文本数据\n### 8.大文件的拆分和平和\n### 9.钥匙串管理\n\n# 3 生成秘钥对\n\n# 4 加密与解密\n\n# 5 生成和验证数字签名\n\n# 6 生成数字签名并加密以及解密并验证数字签名\n\n# 7 信任网\n\n## 7.1 公钥合法性\n\n在使用 PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换（参 5.7.4节）。  \n第十章介绍的证书就是确认公钥合法性的方法之一。证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。  \n然而，PGP 中却没有使用认证机构，而是采用了一种叫**信任网**（web of trust）的方法。在这种方法中， PGP 用户会**互相对对方的公钥进行数字签名**。  \n信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。  \n下面介绍 PGP 的信任网是如何建立起来的。\n\n### 1.场景1：通过自己的数字签名进行确认\nAlice 和 Bob 约会，在告别的时候， Bob 给了 Alice 一张存储卡，并说“这是我的公钥”。  \nAlice 回到家中，从存储卡中取出 Bob 的公钥，并存放到自己所使用的 PGP 的公钥串中（导入公钥）。由于 Alice 确信刚刚导入的公钥确实是属于 Bob 本人的，因此 Alice 对这个公钥加上了自己的数字签名。  \n对 Bob 的公钥加上数字签名，就相当于 Alice 生命“这个公钥属于 Bob 本人（即这个公钥是合法的）”。  \n随后，Alice 收到了来自 Bob 的邮件，由于这封邮件带有 Bob 的数字签名，因此 Alice 想用 PGP 来验证 Bob 的数字签名。 PGP 将执行下面这些操作：  \n1. 为了验证 Bob 的数字签名， PGP 需要从 Alice 的公钥串中寻找 Bob 的公钥。\n2. Alice 的公钥串中包含 Bob 的公钥，因为前几天约会之后 Alice 导入了 Bob 的公钥。\n3. PGP 发现 Bob 的公钥带有 Alice 的数字签名。\n4. 为了验证 Alice 的数字签名，PGP 需要从 Alice 的公钥串中寻找 Alice 自己的公钥。\n5. PGP 使用 Alice 的公钥对 Bob 的公钥上的 Alice 的数字签名进行验证。如果验证成功，则可以确认这的确就是 Bob 的公钥。\n6. PGP 使用合法的 Bob 的公钥对邮件上附带的 Bob 的数字签名进行验证。\n\n### 2.场景2：通过自己完全信任的人的数字签名进行确认\nAlice 有一个叫 Trent 的男朋友。在 Alice 的公钥串中，也包含带有 Alice 的数字签名的 Trent 的公钥。 Alice 非常信任 Trent ，她想：**经过他签名的公钥一定是合法的**。  \n假设 Alice 收到了一封来自 Carrol 的邮件\n\n# 8 本章小结\n\n# 9 小测验 ","slug":"graphic2cryptography/13.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavx002taxs63uvxqfw9","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码技术进行组合的方法。</p>\n<h1 id=\"2-PGP简介\"><a href=\"#2-PGP简介\" class=\"headerlink\" title=\"2 PGP简介\"></a>2 PGP简介</h1><p>PGP 是 1990 年编写的密码软件。</p>\n<h2 id=\"2-1-PGP-的功能\"><a href=\"#2-1-PGP-的功能\" class=\"headerlink\" title=\"2.1 PGP 的功能\"></a>2.1 PGP 的功能</h2><h3 id=\"1-对称密码\"><a href=\"#1-对称密码\" class=\"headerlink\" title=\"1.对称密码\"></a>1.对称密码</h3><h3 id=\"2-公钥密码\"><a href=\"#2-公钥密码\" class=\"headerlink\" title=\"2.公钥密码\"></a>2.公钥密码</h3><h3 id=\"3-数字签名\"><a href=\"#3-数字签名\" class=\"headerlink\" title=\"3.数字签名\"></a>3.数字签名</h3><h3 id=\"4-单向散列函数\"><a href=\"#4-单向散列函数\" class=\"headerlink\" title=\"4.单向散列函数\"></a>4.单向散列函数</h3><h3 id=\"5-证书\"><a href=\"#5-证书\" class=\"headerlink\" title=\"5.证书\"></a>5.证书</h3><h3 id=\"6-压缩\"><a href=\"#6-压缩\" class=\"headerlink\" title=\"6.压缩\"></a>6.压缩</h3><h3 id=\"7-文本数据\"><a href=\"#7-文本数据\" class=\"headerlink\" title=\"7.文本数据\"></a>7.文本数据</h3><h3 id=\"8-大文件的拆分和平和\"><a href=\"#8-大文件的拆分和平和\" class=\"headerlink\" title=\"8.大文件的拆分和平和\"></a>8.大文件的拆分和平和</h3><h3 id=\"9-钥匙串管理\"><a href=\"#9-钥匙串管理\" class=\"headerlink\" title=\"9.钥匙串管理\"></a>9.钥匙串管理</h3><h1 id=\"3-生成秘钥对\"><a href=\"#3-生成秘钥对\" class=\"headerlink\" title=\"3 生成秘钥对\"></a>3 生成秘钥对</h1><h1 id=\"4-加密与解密\"><a href=\"#4-加密与解密\" class=\"headerlink\" title=\"4 加密与解密\"></a>4 加密与解密</h1><h1 id=\"5-生成和验证数字签名\"><a href=\"#5-生成和验证数字签名\" class=\"headerlink\" title=\"5 生成和验证数字签名\"></a>5 生成和验证数字签名</h1><h1 id=\"6-生成数字签名并加密以及解密并验证数字签名\"><a href=\"#6-生成数字签名并加密以及解密并验证数字签名\" class=\"headerlink\" title=\"6 生成数字签名并加密以及解密并验证数字签名\"></a>6 生成数字签名并加密以及解密并验证数字签名</h1><h1 id=\"7-信任网\"><a href=\"#7-信任网\" class=\"headerlink\" title=\"7 信任网\"></a>7 信任网</h1><h2 id=\"7-1-公钥合法性\"><a href=\"#7-1-公钥合法性\" class=\"headerlink\" title=\"7.1 公钥合法性\"></a>7.1 公钥合法性</h2><p>在使用 PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换（参 5.7.4节）。<br>第十章介绍的证书就是确认公钥合法性的方法之一。证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。<br>然而，PGP 中却没有使用认证机构，而是采用了一种叫<strong>信任网</strong>（web of trust）的方法。在这种方法中， PGP 用户会<strong>互相对对方的公钥进行数字签名</strong>。<br>信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。<br>下面介绍 PGP 的信任网是如何建立起来的。</p>\n<h3 id=\"1-场景1：通过自己的数字签名进行确认\"><a href=\"#1-场景1：通过自己的数字签名进行确认\" class=\"headerlink\" title=\"1.场景1：通过自己的数字签名进行确认\"></a>1.场景1：通过自己的数字签名进行确认</h3><p>Alice 和 Bob 约会，在告别的时候， Bob 给了 Alice 一张存储卡，并说“这是我的公钥”。<br>Alice 回到家中，从存储卡中取出 Bob 的公钥，并存放到自己所使用的 PGP 的公钥串中（导入公钥）。由于 Alice 确信刚刚导入的公钥确实是属于 Bob 本人的，因此 Alice 对这个公钥加上了自己的数字签名。<br>对 Bob 的公钥加上数字签名，就相当于 Alice 生命“这个公钥属于 Bob 本人（即这个公钥是合法的）”。<br>随后，Alice 收到了来自 Bob 的邮件，由于这封邮件带有 Bob 的数字签名，因此 Alice 想用 PGP 来验证 Bob 的数字签名。 PGP 将执行下面这些操作：  </p>\n<ol>\n<li>为了验证 Bob 的数字签名， PGP 需要从 Alice 的公钥串中寻找 Bob 的公钥。</li>\n<li>Alice 的公钥串中包含 Bob 的公钥，因为前几天约会之后 Alice 导入了 Bob 的公钥。</li>\n<li>PGP 发现 Bob 的公钥带有 Alice 的数字签名。</li>\n<li>为了验证 Alice 的数字签名，PGP 需要从 Alice 的公钥串中寻找 Alice 自己的公钥。</li>\n<li>PGP 使用 Alice 的公钥对 Bob 的公钥上的 Alice 的数字签名进行验证。如果验证成功，则可以确认这的确就是 Bob 的公钥。</li>\n<li>PGP 使用合法的 Bob 的公钥对邮件上附带的 Bob 的数字签名进行验证。</li>\n</ol>\n<h3 id=\"2-场景2：通过自己完全信任的人的数字签名进行确认\"><a href=\"#2-场景2：通过自己完全信任的人的数字签名进行确认\" class=\"headerlink\" title=\"2.场景2：通过自己完全信任的人的数字签名进行确认\"></a>2.场景2：通过自己完全信任的人的数字签名进行确认</h3><p>Alice 有一个叫 Trent 的男朋友。在 Alice 的公钥串中，也包含带有 Alice 的数字签名的 Trent 的公钥。 Alice 非常信任 Trent ，她想：<strong>经过他签名的公钥一定是合法的</strong>。<br>假设 Alice 收到了一封来自 Carrol 的邮件</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码技术进行组合的方法。</p>\n<h1 id=\"2-PGP简介\"><a href=\"#2-PGP简介\" class=\"headerlink\" title=\"2 PGP简介\"></a>2 PGP简介</h1><p>PGP 是 1990 年编写的密码软件。</p>\n<h2 id=\"2-1-PGP-的功能\"><a href=\"#2-1-PGP-的功能\" class=\"headerlink\" title=\"2.1 PGP 的功能\"></a>2.1 PGP 的功能</h2><h3 id=\"1-对称密码\"><a href=\"#1-对称密码\" class=\"headerlink\" title=\"1.对称密码\"></a>1.对称密码</h3><h3 id=\"2-公钥密码\"><a href=\"#2-公钥密码\" class=\"headerlink\" title=\"2.公钥密码\"></a>2.公钥密码</h3><h3 id=\"3-数字签名\"><a href=\"#3-数字签名\" class=\"headerlink\" title=\"3.数字签名\"></a>3.数字签名</h3><h3 id=\"4-单向散列函数\"><a href=\"#4-单向散列函数\" class=\"headerlink\" title=\"4.单向散列函数\"></a>4.单向散列函数</h3><h3 id=\"5-证书\"><a href=\"#5-证书\" class=\"headerlink\" title=\"5.证书\"></a>5.证书</h3><h3 id=\"6-压缩\"><a href=\"#6-压缩\" class=\"headerlink\" title=\"6.压缩\"></a>6.压缩</h3><h3 id=\"7-文本数据\"><a href=\"#7-文本数据\" class=\"headerlink\" title=\"7.文本数据\"></a>7.文本数据</h3><h3 id=\"8-大文件的拆分和平和\"><a href=\"#8-大文件的拆分和平和\" class=\"headerlink\" title=\"8.大文件的拆分和平和\"></a>8.大文件的拆分和平和</h3><h3 id=\"9-钥匙串管理\"><a href=\"#9-钥匙串管理\" class=\"headerlink\" title=\"9.钥匙串管理\"></a>9.钥匙串管理</h3><h1 id=\"3-生成秘钥对\"><a href=\"#3-生成秘钥对\" class=\"headerlink\" title=\"3 生成秘钥对\"></a>3 生成秘钥对</h1><h1 id=\"4-加密与解密\"><a href=\"#4-加密与解密\" class=\"headerlink\" title=\"4 加密与解密\"></a>4 加密与解密</h1><h1 id=\"5-生成和验证数字签名\"><a href=\"#5-生成和验证数字签名\" class=\"headerlink\" title=\"5 生成和验证数字签名\"></a>5 生成和验证数字签名</h1><h1 id=\"6-生成数字签名并加密以及解密并验证数字签名\"><a href=\"#6-生成数字签名并加密以及解密并验证数字签名\" class=\"headerlink\" title=\"6 生成数字签名并加密以及解密并验证数字签名\"></a>6 生成数字签名并加密以及解密并验证数字签名</h1><h1 id=\"7-信任网\"><a href=\"#7-信任网\" class=\"headerlink\" title=\"7 信任网\"></a>7 信任网</h1><h2 id=\"7-1-公钥合法性\"><a href=\"#7-1-公钥合法性\" class=\"headerlink\" title=\"7.1 公钥合法性\"></a>7.1 公钥合法性</h2><p>在使用 PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换（参 5.7.4节）。<br>第十章介绍的证书就是确认公钥合法性的方法之一。证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。<br>然而，PGP 中却没有使用认证机构，而是采用了一种叫<strong>信任网</strong>（web of trust）的方法。在这种方法中， PGP 用户会<strong>互相对对方的公钥进行数字签名</strong>。<br>信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。<br>下面介绍 PGP 的信任网是如何建立起来的。</p>\n<h3 id=\"1-场景1：通过自己的数字签名进行确认\"><a href=\"#1-场景1：通过自己的数字签名进行确认\" class=\"headerlink\" title=\"1.场景1：通过自己的数字签名进行确认\"></a>1.场景1：通过自己的数字签名进行确认</h3><p>Alice 和 Bob 约会，在告别的时候， Bob 给了 Alice 一张存储卡，并说“这是我的公钥”。<br>Alice 回到家中，从存储卡中取出 Bob 的公钥，并存放到自己所使用的 PGP 的公钥串中（导入公钥）。由于 Alice 确信刚刚导入的公钥确实是属于 Bob 本人的，因此 Alice 对这个公钥加上了自己的数字签名。<br>对 Bob 的公钥加上数字签名，就相当于 Alice 生命“这个公钥属于 Bob 本人（即这个公钥是合法的）”。<br>随后，Alice 收到了来自 Bob 的邮件，由于这封邮件带有 Bob 的数字签名，因此 Alice 想用 PGP 来验证 Bob 的数字签名。 PGP 将执行下面这些操作：  </p>\n<ol>\n<li>为了验证 Bob 的数字签名， PGP 需要从 Alice 的公钥串中寻找 Bob 的公钥。</li>\n<li>Alice 的公钥串中包含 Bob 的公钥，因为前几天约会之后 Alice 导入了 Bob 的公钥。</li>\n<li>PGP 发现 Bob 的公钥带有 Alice 的数字签名。</li>\n<li>为了验证 Alice 的数字签名，PGP 需要从 Alice 的公钥串中寻找 Alice 自己的公钥。</li>\n<li>PGP 使用 Alice 的公钥对 Bob 的公钥上的 Alice 的数字签名进行验证。如果验证成功，则可以确认这的确就是 Bob 的公钥。</li>\n<li>PGP 使用合法的 Bob 的公钥对邮件上附带的 Bob 的数字签名进行验证。</li>\n</ol>\n<h3 id=\"2-场景2：通过自己完全信任的人的数字签名进行确认\"><a href=\"#2-场景2：通过自己完全信任的人的数字签名进行确认\" class=\"headerlink\" title=\"2.场景2：通过自己完全信任的人的数字签名进行确认\"></a>2.场景2：通过自己完全信任的人的数字签名进行确认</h3><p>Alice 有一个叫 Trent 的男朋友。在 Alice 的公钥串中，也包含带有 Alice 的数字签名的 Trent 的公钥。 Alice 非常信任 Trent ，她想：<strong>经过他签名的公钥一定是合法的</strong>。<br>假设 Alice 收到了一封来自 Carrol 的邮件</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1>"},{"title":"十四、SSL/TLS-为了更安全的通信","date":"2017-12-04T15:31:00.000Z","updated":"2017-12-06T15:40:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\nSSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。\n\n# 2 什么是 SSL/TLS\n\n## 2.1 客户端与服务器\n\n将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：  \n![][1]  \nAlice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。  \n  \n不过，如果直接发送请求的话，信用卡号就很可能被窃听。\n\n## 2.2 用 SSL/TLS 承载 HTTP\n\n当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。  \n![][2]\n\n## 2.3 SSL/TLS 的工作\n\n进行安全的通信，我们有几个必须要解决的问题：  \n1. Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。\n2. Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。\n3. 确认通信对方的 Web 服务器是真正的 Bob 书店。\n  \n在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。  \n要解决这些问题，让我们在密码学家的工具箱中找一找：  \n要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。  \n要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。  \n要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。  \n好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。\n\n## 2.4 SSL/TLS 也可以保护其它的协议\n\n刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。  \n![][3]\n\n## 2.5 密码套件\n\nSSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。  \n尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为**密码套件**（cipher suite）。\n\n## 2.6 SSL 与 TLS 的区别\n\nSSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。\n\n# 3 使用 SSL/TLS 进行通信\n\n下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。\n\n## 3.1 层次化的协议\n\nTLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：  \n![][4]  \n下面简单介绍一下其中各个协议的功能\n\n### 1.TLS记录协议\nTLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。  \nTLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。\n\n### 2.TLS握手协议\nTLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。\n#### 2-1 握手协议\n**握手协议**是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：  \n客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”  \n服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”  \n在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。\n#### 2-2 密码规格变更协议\n**密码规格变更协议**是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。  \n这个协议所发送的消息，大致相当于下面的对话：  \n客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”  \n当协议中途发生错误时，就会通过下面的警告协议传达给对方。\n#### 2-3 警告协议\n**警告协议**是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。  \n这个协议所发送的消息，大致相当于下面的对话：  \n服务器：“刚才的消息无法正确解密哦！”  \n如果没有发生错误，则会使用下面的应用数据协议来进行通信。\n#### 2-4 应用数据协议\n**应用数据协议**是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。  \n下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。\n\n## 3.2 TLS记录协议\n\n**TLS记录协议**负责消息的压缩、加密以及数据的认证，其处理过程如下：  \n1. 消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。\n2. 经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。\n3. 经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。\n4. 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。\n\n![][5]\n\n## 3.3 TLS握手协议\n\n### 1.握手协议\n**握手协议**是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。  \n握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。  \n由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。  \n![][6]  \n下面我们来详细讲解握手协议中所交换的消息。\n\n### 2.密码规格变更协议\nTLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。  \n那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。\n\n### 3.警告协议\nTLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。\n\n### 4.应用数据协议\n**应用数据协议**是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。  \n当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。\n\n## 3.4 主密码\n\n主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。  \n主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。  \n![][7]\n\n## 3.5 TLS 中使用的密码技术小结\n\n![][8]\n\n# 4 对 SSL/TLS 的攻击\n\n## 4.1 对各个密码技术的攻击\n\n针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。  \n然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。\n\n## 4.2 对伪随机数生成器的攻击\n\n只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。\n\n## 4.3 利用证书的时间差进行攻击\n\nSSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。\n\n# 5 SSL/TLS 用户的注意事项\n\n## 5.1 不要误解证书的含义\n\n在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是**即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，**因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。  \n此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。  \n为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。\n\n## 5.2 密码通信之前的数据时不受保护的\n\nSSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。\n\n## 5.3 密码通信之后的数据时不受保护的\n\nSSL/TLS 也无法保护通信之后的数据。  \n因此信用卡号**不会再通信过程中被第三方获取**，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。\n\n# 6 本章小结\n\nSSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。\n\n# 7 小测验\n\n1. 使用 SSL/TLS 可以确保通信的机密性。\n2. 在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。\n3. 在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。\n4. 在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。\n5. 使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_8.png","source":"_posts/图解密码技术/第十四章 SSL_TLS.md","raw":"---\ntitle: 十四、SSL/TLS-为了更安全的通信\ndate: 2017-12-04 23:31:00\nupdated: 2017-12-06 23:40:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/14.html    \n---\n\n# 1 本章概要\n\nSSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。\n\n# 2 什么是 SSL/TLS\n\n## 2.1 客户端与服务器\n\n将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：  \n![][1]  \nAlice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。  \n  \n不过，如果直接发送请求的话，信用卡号就很可能被窃听。\n\n## 2.2 用 SSL/TLS 承载 HTTP\n\n当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。  \n![][2]\n\n## 2.3 SSL/TLS 的工作\n\n进行安全的通信，我们有几个必须要解决的问题：  \n1. Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。\n2. Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。\n3. 确认通信对方的 Web 服务器是真正的 Bob 书店。\n  \n在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。  \n要解决这些问题，让我们在密码学家的工具箱中找一找：  \n要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。  \n要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。  \n要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。  \n好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。\n\n## 2.4 SSL/TLS 也可以保护其它的协议\n\n刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。  \n![][3]\n\n## 2.5 密码套件\n\nSSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。  \n尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为**密码套件**（cipher suite）。\n\n## 2.6 SSL 与 TLS 的区别\n\nSSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。\n\n# 3 使用 SSL/TLS 进行通信\n\n下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。\n\n## 3.1 层次化的协议\n\nTLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：  \n![][4]  \n下面简单介绍一下其中各个协议的功能\n\n### 1.TLS记录协议\nTLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。  \nTLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。\n\n### 2.TLS握手协议\nTLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。\n#### 2-1 握手协议\n**握手协议**是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：  \n客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”  \n服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”  \n在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。\n#### 2-2 密码规格变更协议\n**密码规格变更协议**是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。  \n这个协议所发送的消息，大致相当于下面的对话：  \n客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”  \n当协议中途发生错误时，就会通过下面的警告协议传达给对方。\n#### 2-3 警告协议\n**警告协议**是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。  \n这个协议所发送的消息，大致相当于下面的对话：  \n服务器：“刚才的消息无法正确解密哦！”  \n如果没有发生错误，则会使用下面的应用数据协议来进行通信。\n#### 2-4 应用数据协议\n**应用数据协议**是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。  \n下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。\n\n## 3.2 TLS记录协议\n\n**TLS记录协议**负责消息的压缩、加密以及数据的认证，其处理过程如下：  \n1. 消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。\n2. 经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。\n3. 经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。\n4. 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。\n\n![][5]\n\n## 3.3 TLS握手协议\n\n### 1.握手协议\n**握手协议**是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。  \n握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。  \n由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。  \n![][6]  \n下面我们来详细讲解握手协议中所交换的消息。\n\n### 2.密码规格变更协议\nTLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。  \n那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。\n\n### 3.警告协议\nTLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。\n\n### 4.应用数据协议\n**应用数据协议**是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。  \n当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。\n\n## 3.4 主密码\n\n主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。  \n主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。  \n![][7]\n\n## 3.5 TLS 中使用的密码技术小结\n\n![][8]\n\n# 4 对 SSL/TLS 的攻击\n\n## 4.1 对各个密码技术的攻击\n\n针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。  \n然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。\n\n## 4.2 对伪随机数生成器的攻击\n\n只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。\n\n## 4.3 利用证书的时间差进行攻击\n\nSSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。\n\n# 5 SSL/TLS 用户的注意事项\n\n## 5.1 不要误解证书的含义\n\n在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是**即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，**因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。  \n此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。  \n为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。\n\n## 5.2 密码通信之前的数据时不受保护的\n\nSSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。\n\n## 5.3 密码通信之后的数据时不受保护的\n\nSSL/TLS 也无法保护通信之后的数据。  \n因此信用卡号**不会再通信过程中被第三方获取**，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。\n\n# 6 本章小结\n\nSSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。\n\n# 7 小测验\n\n1. 使用 SSL/TLS 可以确保通信的机密性。\n2. 在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。\n3. 在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。\n4. 在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。\n5. 使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_5.png\n[6]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_6.png\n[7]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_7.png\n[8]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_8.png","slug":"graphic2cryptography/14.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavz002waxs6sidd3s6e","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>SSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。</p>\n<h1 id=\"2-什么是-SSL-TLS\"><a href=\"#2-什么是-SSL-TLS\" class=\"headerlink\" title=\"2 什么是 SSL/TLS\"></a>2 什么是 SSL/TLS</h1><h2 id=\"2-1-客户端与服务器\"><a href=\"#2-1-客户端与服务器\" class=\"headerlink\" title=\"2.1 客户端与服务器\"></a>2.1 客户端与服务器</h2><p>将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_1.png\" alt=\"\"><br>Alice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。  </p>\n<p>不过，如果直接发送请求的话，信用卡号就很可能被窃听。</p>\n<h2 id=\"2-2-用-SSL-TLS-承载-HTTP\"><a href=\"#2-2-用-SSL-TLS-承载-HTTP\" class=\"headerlink\" title=\"2.2 用 SSL/TLS 承载 HTTP\"></a>2.2 用 SSL/TLS 承载 HTTP</h2><p>当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_2.png\" alt=\"\"></p>\n<h2 id=\"2-3-SSL-TLS-的工作\"><a href=\"#2-3-SSL-TLS-的工作\" class=\"headerlink\" title=\"2.3 SSL/TLS 的工作\"></a>2.3 SSL/TLS 的工作</h2><p>进行安全的通信，我们有几个必须要解决的问题：  </p>\n<ol>\n<li>Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。</li>\n<li>Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。</li>\n<li>确认通信对方的 Web 服务器是真正的 Bob 书店。</li>\n</ol>\n<p>在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。<br>要解决这些问题，让我们在密码学家的工具箱中找一找：<br>要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。<br>要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。<br>要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。<br>好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。</p>\n<h2 id=\"2-4-SSL-TLS-也可以保护其它的协议\"><a href=\"#2-4-SSL-TLS-也可以保护其它的协议\" class=\"headerlink\" title=\"2.4 SSL/TLS 也可以保护其它的协议\"></a>2.4 SSL/TLS 也可以保护其它的协议</h2><p>刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_3.png\" alt=\"\"></p>\n<h2 id=\"2-5-密码套件\"><a href=\"#2-5-密码套件\" class=\"headerlink\" title=\"2.5 密码套件\"></a>2.5 密码套件</h2><p>SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。<br>尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为<strong>密码套件</strong>（cipher suite）。</p>\n<h2 id=\"2-6-SSL-与-TLS-的区别\"><a href=\"#2-6-SSL-与-TLS-的区别\" class=\"headerlink\" title=\"2.6 SSL 与 TLS 的区别\"></a>2.6 SSL 与 TLS 的区别</h2><p>SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。</p>\n<h1 id=\"3-使用-SSL-TLS-进行通信\"><a href=\"#3-使用-SSL-TLS-进行通信\" class=\"headerlink\" title=\"3 使用 SSL/TLS 进行通信\"></a>3 使用 SSL/TLS 进行通信</h1><p>下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。</p>\n<h2 id=\"3-1-层次化的协议\"><a href=\"#3-1-层次化的协议\" class=\"headerlink\" title=\"3.1 层次化的协议\"></a>3.1 层次化的协议</h2><p>TLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_4.png\" alt=\"\"><br>下面简单介绍一下其中各个协议的功能</p>\n<h3 id=\"1-TLS记录协议\"><a href=\"#1-TLS记录协议\" class=\"headerlink\" title=\"1.TLS记录协议\"></a>1.TLS记录协议</h3><p>TLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。<br>TLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。</p>\n<h3 id=\"2-TLS握手协议\"><a href=\"#2-TLS握手协议\" class=\"headerlink\" title=\"2.TLS握手协议\"></a>2.TLS握手协议</h3><p>TLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。</p>\n<h4 id=\"2-1-握手协议\"><a href=\"#2-1-握手协议\" class=\"headerlink\" title=\"2-1 握手协议\"></a>2-1 握手协议</h4><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：<br>客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”<br>服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”<br>在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。</p>\n<h4 id=\"2-2-密码规格变更协议\"><a href=\"#2-2-密码规格变更协议\" class=\"headerlink\" title=\"2-2 密码规格变更协议\"></a>2-2 密码规格变更协议</h4><p><strong>密码规格变更协议</strong>是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。<br>这个协议所发送的消息，大致相当于下面的对话：<br>客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”<br>当协议中途发生错误时，就会通过下面的警告协议传达给对方。</p>\n<h4 id=\"2-3-警告协议\"><a href=\"#2-3-警告协议\" class=\"headerlink\" title=\"2-3 警告协议\"></a>2-3 警告协议</h4><p><strong>警告协议</strong>是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。<br>这个协议所发送的消息，大致相当于下面的对话：<br>服务器：“刚才的消息无法正确解密哦！”<br>如果没有发生错误，则会使用下面的应用数据协议来进行通信。</p>\n<h4 id=\"2-4-应用数据协议\"><a href=\"#2-4-应用数据协议\" class=\"headerlink\" title=\"2-4 应用数据协议\"></a>2-4 应用数据协议</h4><p><strong>应用数据协议</strong>是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。<br>下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。</p>\n<h2 id=\"3-2-TLS记录协议\"><a href=\"#3-2-TLS记录协议\" class=\"headerlink\" title=\"3.2 TLS记录协议\"></a>3.2 TLS记录协议</h2><p><strong>TLS记录协议</strong>负责消息的压缩、加密以及数据的认证，其处理过程如下：  </p>\n<ol>\n<li>消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。</li>\n<li>经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。</li>\n<li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。</li>\n<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。</li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_5.png\" alt=\"\"></p>\n<h2 id=\"3-3-TLS握手协议\"><a href=\"#3-3-TLS握手协议\" class=\"headerlink\" title=\"3.3 TLS握手协议\"></a>3.3 TLS握手协议</h2><h3 id=\"1-握手协议\"><a href=\"#1-握手协议\" class=\"headerlink\" title=\"1.握手协议\"></a>1.握手协议</h3><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。<br>握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。<br>由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_6.png\" alt=\"\"><br>下面我们来详细讲解握手协议中所交换的消息。</p>\n<h3 id=\"2-密码规格变更协议\"><a href=\"#2-密码规格变更协议\" class=\"headerlink\" title=\"2.密码规格变更协议\"></a>2.密码规格变更协议</h3><p>TLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。<br>那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。</p>\n<h3 id=\"3-警告协议\"><a href=\"#3-警告协议\" class=\"headerlink\" title=\"3.警告协议\"></a>3.警告协议</h3><p>TLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。</p>\n<h3 id=\"4-应用数据协议\"><a href=\"#4-应用数据协议\" class=\"headerlink\" title=\"4.应用数据协议\"></a>4.应用数据协议</h3><p><strong>应用数据协议</strong>是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。<br>当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。</p>\n<h2 id=\"3-4-主密码\"><a href=\"#3-4-主密码\" class=\"headerlink\" title=\"3.4 主密码\"></a>3.4 主密码</h2><p>主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。<br>主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_7.png\" alt=\"\"></p>\n<h2 id=\"3-5-TLS-中使用的密码技术小结\"><a href=\"#3-5-TLS-中使用的密码技术小结\" class=\"headerlink\" title=\"3.5 TLS 中使用的密码技术小结\"></a>3.5 TLS 中使用的密码技术小结</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_8.png\" alt=\"\"></p>\n<h1 id=\"4-对-SSL-TLS-的攻击\"><a href=\"#4-对-SSL-TLS-的攻击\" class=\"headerlink\" title=\"4 对 SSL/TLS 的攻击\"></a>4 对 SSL/TLS 的攻击</h1><h2 id=\"4-1-对各个密码技术的攻击\"><a href=\"#4-1-对各个密码技术的攻击\" class=\"headerlink\" title=\"4.1 对各个密码技术的攻击\"></a>4.1 对各个密码技术的攻击</h2><p>针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。<br>然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。</p>\n<h2 id=\"4-2-对伪随机数生成器的攻击\"><a href=\"#4-2-对伪随机数生成器的攻击\" class=\"headerlink\" title=\"4.2 对伪随机数生成器的攻击\"></a>4.2 对伪随机数生成器的攻击</h2><p>只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。</p>\n<h2 id=\"4-3-利用证书的时间差进行攻击\"><a href=\"#4-3-利用证书的时间差进行攻击\" class=\"headerlink\" title=\"4.3 利用证书的时间差进行攻击\"></a>4.3 利用证书的时间差进行攻击</h2><p>SSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。</p>\n<h1 id=\"5-SSL-TLS-用户的注意事项\"><a href=\"#5-SSL-TLS-用户的注意事项\" class=\"headerlink\" title=\"5 SSL/TLS 用户的注意事项\"></a>5 SSL/TLS 用户的注意事项</h1><h2 id=\"5-1-不要误解证书的含义\"><a href=\"#5-1-不要误解证书的含义\" class=\"headerlink\" title=\"5.1 不要误解证书的含义\"></a>5.1 不要误解证书的含义</h2><p>在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是<strong>即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，</strong>因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。<br>此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。<br>为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。</p>\n<h2 id=\"5-2-密码通信之前的数据时不受保护的\"><a href=\"#5-2-密码通信之前的数据时不受保护的\" class=\"headerlink\" title=\"5.2 密码通信之前的数据时不受保护的\"></a>5.2 密码通信之前的数据时不受保护的</h2><p>SSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。</p>\n<h2 id=\"5-3-密码通信之后的数据时不受保护的\"><a href=\"#5-3-密码通信之后的数据时不受保护的\" class=\"headerlink\" title=\"5.3 密码通信之后的数据时不受保护的\"></a>5.3 密码通信之后的数据时不受保护的</h2><p>SSL/TLS 也无法保护通信之后的数据。<br>因此信用卡号<strong>不会再通信过程中被第三方获取</strong>，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。</p>\n<h1 id=\"6-本章小结\"><a href=\"#6-本章小结\" class=\"headerlink\" title=\"6 本章小结\"></a>6 本章小结</h1><p>SSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。</p>\n<h1 id=\"7-小测验\"><a href=\"#7-小测验\" class=\"headerlink\" title=\"7 小测验\"></a>7 小测验</h1><ol>\n<li>使用 SSL/TLS 可以确保通信的机密性。</li>\n<li>在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。</li>\n<li>在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。</li>\n<li>在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。</li>\n<li>使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>SSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。</p>\n<h1 id=\"2-什么是-SSL-TLS\"><a href=\"#2-什么是-SSL-TLS\" class=\"headerlink\" title=\"2 什么是 SSL/TLS\"></a>2 什么是 SSL/TLS</h1><h2 id=\"2-1-客户端与服务器\"><a href=\"#2-1-客户端与服务器\" class=\"headerlink\" title=\"2.1 客户端与服务器\"></a>2.1 客户端与服务器</h2><p>将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_1.png\" alt=\"\"><br>Alice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。  </p>\n<p>不过，如果直接发送请求的话，信用卡号就很可能被窃听。</p>\n<h2 id=\"2-2-用-SSL-TLS-承载-HTTP\"><a href=\"#2-2-用-SSL-TLS-承载-HTTP\" class=\"headerlink\" title=\"2.2 用 SSL/TLS 承载 HTTP\"></a>2.2 用 SSL/TLS 承载 HTTP</h2><p>当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_2.png\" alt=\"\"></p>\n<h2 id=\"2-3-SSL-TLS-的工作\"><a href=\"#2-3-SSL-TLS-的工作\" class=\"headerlink\" title=\"2.3 SSL/TLS 的工作\"></a>2.3 SSL/TLS 的工作</h2><p>进行安全的通信，我们有几个必须要解决的问题：  </p>\n<ol>\n<li>Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。</li>\n<li>Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。</li>\n<li>确认通信对方的 Web 服务器是真正的 Bob 书店。</li>\n</ol>\n<p>在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。<br>要解决这些问题，让我们在密码学家的工具箱中找一找：<br>要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。<br>要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。<br>要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。<br>好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。</p>\n<h2 id=\"2-4-SSL-TLS-也可以保护其它的协议\"><a href=\"#2-4-SSL-TLS-也可以保护其它的协议\" class=\"headerlink\" title=\"2.4 SSL/TLS 也可以保护其它的协议\"></a>2.4 SSL/TLS 也可以保护其它的协议</h2><p>刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_3.png\" alt=\"\"></p>\n<h2 id=\"2-5-密码套件\"><a href=\"#2-5-密码套件\" class=\"headerlink\" title=\"2.5 密码套件\"></a>2.5 密码套件</h2><p>SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。<br>尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为<strong>密码套件</strong>（cipher suite）。</p>\n<h2 id=\"2-6-SSL-与-TLS-的区别\"><a href=\"#2-6-SSL-与-TLS-的区别\" class=\"headerlink\" title=\"2.6 SSL 与 TLS 的区别\"></a>2.6 SSL 与 TLS 的区别</h2><p>SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。</p>\n<h1 id=\"3-使用-SSL-TLS-进行通信\"><a href=\"#3-使用-SSL-TLS-进行通信\" class=\"headerlink\" title=\"3 使用 SSL/TLS 进行通信\"></a>3 使用 SSL/TLS 进行通信</h1><p>下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。</p>\n<h2 id=\"3-1-层次化的协议\"><a href=\"#3-1-层次化的协议\" class=\"headerlink\" title=\"3.1 层次化的协议\"></a>3.1 层次化的协议</h2><p>TLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_4.png\" alt=\"\"><br>下面简单介绍一下其中各个协议的功能</p>\n<h3 id=\"1-TLS记录协议\"><a href=\"#1-TLS记录协议\" class=\"headerlink\" title=\"1.TLS记录协议\"></a>1.TLS记录协议</h3><p>TLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。<br>TLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。</p>\n<h3 id=\"2-TLS握手协议\"><a href=\"#2-TLS握手协议\" class=\"headerlink\" title=\"2.TLS握手协议\"></a>2.TLS握手协议</h3><p>TLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。</p>\n<h4 id=\"2-1-握手协议\"><a href=\"#2-1-握手协议\" class=\"headerlink\" title=\"2-1 握手协议\"></a>2-1 握手协议</h4><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：<br>客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”<br>服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”<br>在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。</p>\n<h4 id=\"2-2-密码规格变更协议\"><a href=\"#2-2-密码规格变更协议\" class=\"headerlink\" title=\"2-2 密码规格变更协议\"></a>2-2 密码规格变更协议</h4><p><strong>密码规格变更协议</strong>是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。<br>这个协议所发送的消息，大致相当于下面的对话：<br>客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”<br>当协议中途发生错误时，就会通过下面的警告协议传达给对方。</p>\n<h4 id=\"2-3-警告协议\"><a href=\"#2-3-警告协议\" class=\"headerlink\" title=\"2-3 警告协议\"></a>2-3 警告协议</h4><p><strong>警告协议</strong>是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。<br>这个协议所发送的消息，大致相当于下面的对话：<br>服务器：“刚才的消息无法正确解密哦！”<br>如果没有发生错误，则会使用下面的应用数据协议来进行通信。</p>\n<h4 id=\"2-4-应用数据协议\"><a href=\"#2-4-应用数据协议\" class=\"headerlink\" title=\"2-4 应用数据协议\"></a>2-4 应用数据协议</h4><p><strong>应用数据协议</strong>是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。<br>下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。</p>\n<h2 id=\"3-2-TLS记录协议\"><a href=\"#3-2-TLS记录协议\" class=\"headerlink\" title=\"3.2 TLS记录协议\"></a>3.2 TLS记录协议</h2><p><strong>TLS记录协议</strong>负责消息的压缩、加密以及数据的认证，其处理过程如下：  </p>\n<ol>\n<li>消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。</li>\n<li>经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。</li>\n<li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。</li>\n<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。</li>\n</ol>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_5.png\" alt=\"\"></p>\n<h2 id=\"3-3-TLS握手协议\"><a href=\"#3-3-TLS握手协议\" class=\"headerlink\" title=\"3.3 TLS握手协议\"></a>3.3 TLS握手协议</h2><h3 id=\"1-握手协议\"><a href=\"#1-握手协议\" class=\"headerlink\" title=\"1.握手协议\"></a>1.握手协议</h3><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。<br>握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。<br>由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_6.png\" alt=\"\"><br>下面我们来详细讲解握手协议中所交换的消息。</p>\n<h3 id=\"2-密码规格变更协议\"><a href=\"#2-密码规格变更协议\" class=\"headerlink\" title=\"2.密码规格变更协议\"></a>2.密码规格变更协议</h3><p>TLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。<br>那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。</p>\n<h3 id=\"3-警告协议\"><a href=\"#3-警告协议\" class=\"headerlink\" title=\"3.警告协议\"></a>3.警告协议</h3><p>TLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。</p>\n<h3 id=\"4-应用数据协议\"><a href=\"#4-应用数据协议\" class=\"headerlink\" title=\"4.应用数据协议\"></a>4.应用数据协议</h3><p><strong>应用数据协议</strong>是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。<br>当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。</p>\n<h2 id=\"3-4-主密码\"><a href=\"#3-4-主密码\" class=\"headerlink\" title=\"3.4 主密码\"></a>3.4 主密码</h2><p>主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。<br>主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_7.png\" alt=\"\"></p>\n<h2 id=\"3-5-TLS-中使用的密码技术小结\"><a href=\"#3-5-TLS-中使用的密码技术小结\" class=\"headerlink\" title=\"3.5 TLS 中使用的密码技术小结\"></a>3.5 TLS 中使用的密码技术小结</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_8.png\" alt=\"\"></p>\n<h1 id=\"4-对-SSL-TLS-的攻击\"><a href=\"#4-对-SSL-TLS-的攻击\" class=\"headerlink\" title=\"4 对 SSL/TLS 的攻击\"></a>4 对 SSL/TLS 的攻击</h1><h2 id=\"4-1-对各个密码技术的攻击\"><a href=\"#4-1-对各个密码技术的攻击\" class=\"headerlink\" title=\"4.1 对各个密码技术的攻击\"></a>4.1 对各个密码技术的攻击</h2><p>针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。<br>然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。</p>\n<h2 id=\"4-2-对伪随机数生成器的攻击\"><a href=\"#4-2-对伪随机数生成器的攻击\" class=\"headerlink\" title=\"4.2 对伪随机数生成器的攻击\"></a>4.2 对伪随机数生成器的攻击</h2><p>只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。</p>\n<h2 id=\"4-3-利用证书的时间差进行攻击\"><a href=\"#4-3-利用证书的时间差进行攻击\" class=\"headerlink\" title=\"4.3 利用证书的时间差进行攻击\"></a>4.3 利用证书的时间差进行攻击</h2><p>SSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。</p>\n<h1 id=\"5-SSL-TLS-用户的注意事项\"><a href=\"#5-SSL-TLS-用户的注意事项\" class=\"headerlink\" title=\"5 SSL/TLS 用户的注意事项\"></a>5 SSL/TLS 用户的注意事项</h1><h2 id=\"5-1-不要误解证书的含义\"><a href=\"#5-1-不要误解证书的含义\" class=\"headerlink\" title=\"5.1 不要误解证书的含义\"></a>5.1 不要误解证书的含义</h2><p>在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是<strong>即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，</strong>因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。<br>此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。<br>为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。</p>\n<h2 id=\"5-2-密码通信之前的数据时不受保护的\"><a href=\"#5-2-密码通信之前的数据时不受保护的\" class=\"headerlink\" title=\"5.2 密码通信之前的数据时不受保护的\"></a>5.2 密码通信之前的数据时不受保护的</h2><p>SSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。</p>\n<h2 id=\"5-3-密码通信之后的数据时不受保护的\"><a href=\"#5-3-密码通信之后的数据时不受保护的\" class=\"headerlink\" title=\"5.3 密码通信之后的数据时不受保护的\"></a>5.3 密码通信之后的数据时不受保护的</h2><p>SSL/TLS 也无法保护通信之后的数据。<br>因此信用卡号<strong>不会再通信过程中被第三方获取</strong>，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。</p>\n<h1 id=\"6-本章小结\"><a href=\"#6-本章小结\" class=\"headerlink\" title=\"6 本章小结\"></a>6 本章小结</h1><p>SSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。</p>\n<h1 id=\"7-小测验\"><a href=\"#7-小测验\" class=\"headerlink\" title=\"7 小测验\"></a>7 小测验</h1><ol>\n<li>使用 SSL/TLS 可以确保通信的机密性。</li>\n<li>在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。</li>\n<li>在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。</li>\n<li>在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。</li>\n<li>使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。</li>\n</ol>\n"},{"title":"十二、随机数——不可预测性的源泉","date":"2017-12-06T15:40:00.000Z","updated":"2017-12-07T15:44:00.000Z","comments":1,"_content":"\n# 1 骡子的锁匠铺\n\n很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。  \n骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。  \n教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。\n\n# 2 本章概要\n\n* 使用随机数的密码技术\n* 随机数的性质\n* 伪随机数生成器\n* 具体的伪随机数生成器\n* 对伪随机数生成器的攻击\n\n# 3 使用随机数的密码技术\n\n## 3.1 随机数是干什么的\n\n1. 生成秘钥：用于对称密码和消息认证码。\n2. 生成密钥对：用于公钥密码和数字签名。\n3. 生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。\n4. 生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。\n5. 生成盐：用于基于口令的密码（PBE）等。\n  \n在这里，请大家记住**为了不让攻击者看穿而使用随机数**这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。\n\n# 4 随机数的性质\n\n## 4.1 对随机数的性质分类\n\n1. 随机性：不存在统计学偏差，是完全杂乱的数列。\n2. 不可预测性：不能从过去的数列推测出下一个出现的数。\n3. 不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。\n\n为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。\n||随机性|不可预测性|不可重现性||\n|:-:|:-:|:-:|:-:|:-:|\n|弱伪随机数|✔️|✘|✘|只具备随机性|\n|强伪随机数|✔️|✔️|✘|具备不可预测性|\n|真随机数|✔️|✔️|✔️|具备不可重现性|\n\n![][1]\n\n## 4.2 随机性\n\n杂乱无章并不代表不会被看穿，因此本书中将只具备随机性的伪随机数称为“弱伪随机数”。\n\n## 4.3 不可预测性\n\n不可预测性（unpredictability），是一种“不可能事先说中”的性质，及不可预测性。即，攻击者在知道过去生成的为随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。\n\n## 4.4 不可重现性\n\n即，无法重现和某一随机数列完全相同的数列的性质。如果除了将随机数列本身保存下来意外，没有其它方法能够重现该数列，则我们就说该随机数列具备不可重现性。  \n要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。\n\n# 5 伪随机数生成器\n\n仅仅靠软件无法生成真随机数，因此要加上一个“伪”。\n\n## 5.1 伪随机数生成器的结构\n\n伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列。  \n![][2]  \n\n### 1.伪随机数生成器的内部状态\n伪随机数生成器的内部状态，是指伪随机数生成器所管理的内存中的数值。伪随机数生成器会根据内存中的数值进行计算，并将计算的结果作为伪随机数输出。随后，为了响应下一个伪随机数请求。伪随机数生成器会改变自己的内部状态。\n\n### 2.伪随机数生成器的种子\n伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。  \n![][3]\n\n# 6 具体的伪随机数生成器\n\n## 6.1 杂乱的方法\n\n用一个程序员都不懂的算法生成，但是这是错误的，不能用于密码技术。因为，周期太短，使用复杂算法所生成的数列大多数都会具有很短的周期（即短数列的不断重复）。另外则是，无法判断所生成的随机数是否具备不可预测性。\n\n## 6.2 线性同余法\n\n线性同余法（linear congruential method）是一种使用很广泛的伪随机数生成器算法。然而，它并不能用于密码技术。  \nA、C、M 都是常量，且 A 和 C 需要小于 M。接下来，根据种子 R0 计算下一个伪随机数 R1：  \nR1 = （A * R0 + C） mod M。  \n当前得到的伪随机数即是下一个伪随机数的种子：  \nRn+1 = (A * Rn + C) mod M。  \n但是这具有周期性，而且可以通过上一个种子得到下一个伪随机数。因此不具备不可预测性，不能将线性同余法用于密码技术。  \n很多伪随机数生成器的库函数都是采用线性同余法编写的。包括 C 语言的库函数 rand。 以及 java 的 java.util.Random 类等。\n\n## 6.3 单向散列函数法\n\n![][4]  \n攻击者要预测下一个伪随机数，需要知道计数器的当前值，以及，破解单向散列函数的单向性。利用了单向散列函数的单向性。\n\n## 6.4 密码法\n\n![][5]  \n密码的机密性是支撑伪随机数生成器不可预测性的基础。\n\n# 7 对伪随机数生成器的攻击\n\n## 7.1 对种子进行攻击\n\n## 7.2 对随机数池进行攻击\n\n一般不会到了需要的时候才当场生成真随机数，而是会事先在一个名为**随机数池**（random pool）的文件中积累随机比特序列。当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。这是不能被攻击所知道的。\n\n# 8 本章小结\n\n由于密码技术的伪随机数生成器，需要使用单向散列函数和密码等技术来确保不可预测性。\n\n# 9 小测验\n\n1. 伪随机数的种子需要对攻击者保密。\n2. 线性同余法可以作为用于密码的伪随机数生成器。\n3. 具备随机性的伪随机数生成器不一定具备不可预测性。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_5.png","source":"_posts/图解密码技术/第十二章 随机数.md","raw":"---\ntitle: 十二、随机数——不可预测性的源泉\ndate: 2017-12-06 23:40:00\nupdated: 2017-12-07 23:44:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/12.html    \n---\n\n# 1 骡子的锁匠铺\n\n很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。  \n骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。  \n教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。\n\n# 2 本章概要\n\n* 使用随机数的密码技术\n* 随机数的性质\n* 伪随机数生成器\n* 具体的伪随机数生成器\n* 对伪随机数生成器的攻击\n\n# 3 使用随机数的密码技术\n\n## 3.1 随机数是干什么的\n\n1. 生成秘钥：用于对称密码和消息认证码。\n2. 生成密钥对：用于公钥密码和数字签名。\n3. 生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。\n4. 生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。\n5. 生成盐：用于基于口令的密码（PBE）等。\n  \n在这里，请大家记住**为了不让攻击者看穿而使用随机数**这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。\n\n# 4 随机数的性质\n\n## 4.1 对随机数的性质分类\n\n1. 随机性：不存在统计学偏差，是完全杂乱的数列。\n2. 不可预测性：不能从过去的数列推测出下一个出现的数。\n3. 不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。\n\n为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。\n||随机性|不可预测性|不可重现性||\n|:-:|:-:|:-:|:-:|:-:|\n|弱伪随机数|✔️|✘|✘|只具备随机性|\n|强伪随机数|✔️|✔️|✘|具备不可预测性|\n|真随机数|✔️|✔️|✔️|具备不可重现性|\n\n![][1]\n\n## 4.2 随机性\n\n杂乱无章并不代表不会被看穿，因此本书中将只具备随机性的伪随机数称为“弱伪随机数”。\n\n## 4.3 不可预测性\n\n不可预测性（unpredictability），是一种“不可能事先说中”的性质，及不可预测性。即，攻击者在知道过去生成的为随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。\n\n## 4.4 不可重现性\n\n即，无法重现和某一随机数列完全相同的数列的性质。如果除了将随机数列本身保存下来意外，没有其它方法能够重现该数列，则我们就说该随机数列具备不可重现性。  \n要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。\n\n# 5 伪随机数生成器\n\n仅仅靠软件无法生成真随机数，因此要加上一个“伪”。\n\n## 5.1 伪随机数生成器的结构\n\n伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列。  \n![][2]  \n\n### 1.伪随机数生成器的内部状态\n伪随机数生成器的内部状态，是指伪随机数生成器所管理的内存中的数值。伪随机数生成器会根据内存中的数值进行计算，并将计算的结果作为伪随机数输出。随后，为了响应下一个伪随机数请求。伪随机数生成器会改变自己的内部状态。\n\n### 2.伪随机数生成器的种子\n伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。  \n![][3]\n\n# 6 具体的伪随机数生成器\n\n## 6.1 杂乱的方法\n\n用一个程序员都不懂的算法生成，但是这是错误的，不能用于密码技术。因为，周期太短，使用复杂算法所生成的数列大多数都会具有很短的周期（即短数列的不断重复）。另外则是，无法判断所生成的随机数是否具备不可预测性。\n\n## 6.2 线性同余法\n\n线性同余法（linear congruential method）是一种使用很广泛的伪随机数生成器算法。然而，它并不能用于密码技术。  \nA、C、M 都是常量，且 A 和 C 需要小于 M。接下来，根据种子 R0 计算下一个伪随机数 R1：  \nR1 = （A * R0 + C） mod M。  \n当前得到的伪随机数即是下一个伪随机数的种子：  \nRn+1 = (A * Rn + C) mod M。  \n但是这具有周期性，而且可以通过上一个种子得到下一个伪随机数。因此不具备不可预测性，不能将线性同余法用于密码技术。  \n很多伪随机数生成器的库函数都是采用线性同余法编写的。包括 C 语言的库函数 rand。 以及 java 的 java.util.Random 类等。\n\n## 6.3 单向散列函数法\n\n![][4]  \n攻击者要预测下一个伪随机数，需要知道计数器的当前值，以及，破解单向散列函数的单向性。利用了单向散列函数的单向性。\n\n## 6.4 密码法\n\n![][5]  \n密码的机密性是支撑伪随机数生成器不可预测性的基础。\n\n# 7 对伪随机数生成器的攻击\n\n## 7.1 对种子进行攻击\n\n## 7.2 对随机数池进行攻击\n\n一般不会到了需要的时候才当场生成真随机数，而是会事先在一个名为**随机数池**（random pool）的文件中积累随机比特序列。当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。这是不能被攻击所知道的。\n\n# 8 本章小结\n\n由于密码技术的伪随机数生成器，需要使用单向散列函数和密码等技术来确保不可预测性。\n\n# 9 小测验\n\n1. 伪随机数的种子需要对攻击者保密。\n2. 线性同余法可以作为用于密码的伪随机数生成器。\n3. 具备随机性的伪随机数生成器不一定具备不可预测性。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_4.png\n[5]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_5.png","slug":"graphic2cryptography/12.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkavz002yaxs6mqvzzw0y","content":"<h1 id=\"1-骡子的锁匠铺\"><a href=\"#1-骡子的锁匠铺\" class=\"headerlink\" title=\"1 骡子的锁匠铺\"></a>1 骡子的锁匠铺</h1><p>很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。<br>骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。<br>教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><ul>\n<li>使用随机数的密码技术</li>\n<li>随机数的性质</li>\n<li>伪随机数生成器</li>\n<li>具体的伪随机数生成器</li>\n<li>对伪随机数生成器的攻击</li>\n</ul>\n<h1 id=\"3-使用随机数的密码技术\"><a href=\"#3-使用随机数的密码技术\" class=\"headerlink\" title=\"3 使用随机数的密码技术\"></a>3 使用随机数的密码技术</h1><h2 id=\"3-1-随机数是干什么的\"><a href=\"#3-1-随机数是干什么的\" class=\"headerlink\" title=\"3.1 随机数是干什么的\"></a>3.1 随机数是干什么的</h2><ol>\n<li>生成秘钥：用于对称密码和消息认证码。</li>\n<li>生成密钥对：用于公钥密码和数字签名。</li>\n<li>生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。</li>\n<li>生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。</li>\n<li>生成盐：用于基于口令的密码（PBE）等。</li>\n</ol>\n<p>在这里，请大家记住<strong>为了不让攻击者看穿而使用随机数</strong>这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。</p>\n<h1 id=\"4-随机数的性质\"><a href=\"#4-随机数的性质\" class=\"headerlink\" title=\"4 随机数的性质\"></a>4 随机数的性质</h1><h2 id=\"4-1-对随机数的性质分类\"><a href=\"#4-1-对随机数的性质分类\" class=\"headerlink\" title=\"4.1 对随机数的性质分类\"></a>4.1 对随机数的性质分类</h2><ol>\n<li>随机性：不存在统计学偏差，是完全杂乱的数列。</li>\n<li>不可预测性：不能从过去的数列推测出下一个出现的数。</li>\n<li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。</li>\n</ol>\n<p>为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。<br>||随机性|不可预测性|不可重现性||<br>|:-:|:-:|:-:|:-:|:-:|<br>|弱伪随机数|✔️|✘|✘|只具备随机性|<br>|强伪随机数|✔️|✔️|✘|具备不可预测性|<br>|真随机数|✔️|✔️|✔️|具备不可重现性|</p>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_1.png\" alt=\"\"></p>\n<h2 id=\"4-2-随机性\"><a href=\"#4-2-随机性\" class=\"headerlink\" title=\"4.2 随机性\"></a>4.2 随机性</h2><p>杂乱无章并不代表不会被看穿，因此本书中将只具备随机性的伪随机数称为“弱伪随机数”。</p>\n<h2 id=\"4-3-不可预测性\"><a href=\"#4-3-不可预测性\" class=\"headerlink\" title=\"4.3 不可预测性\"></a>4.3 不可预测性</h2><p>不可预测性（unpredictability），是一种“不可能事先说中”的性质，及不可预测性。即，攻击者在知道过去生成的为随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。</p>\n<h2 id=\"4-4-不可重现性\"><a href=\"#4-4-不可重现性\" class=\"headerlink\" title=\"4.4 不可重现性\"></a>4.4 不可重现性</h2><p>即，无法重现和某一随机数列完全相同的数列的性质。如果除了将随机数列本身保存下来意外，没有其它方法能够重现该数列，则我们就说该随机数列具备不可重现性。<br>要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。</p>\n<h1 id=\"5-伪随机数生成器\"><a href=\"#5-伪随机数生成器\" class=\"headerlink\" title=\"5 伪随机数生成器\"></a>5 伪随机数生成器</h1><p>仅仅靠软件无法生成真随机数，因此要加上一个“伪”。</p>\n<h2 id=\"5-1-伪随机数生成器的结构\"><a href=\"#5-1-伪随机数生成器的结构\" class=\"headerlink\" title=\"5.1 伪随机数生成器的结构\"></a>5.1 伪随机数生成器的结构</h2><p>伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_2.png\" alt=\"\">  </p>\n<h3 id=\"1-伪随机数生成器的内部状态\"><a href=\"#1-伪随机数生成器的内部状态\" class=\"headerlink\" title=\"1.伪随机数生成器的内部状态\"></a>1.伪随机数生成器的内部状态</h3><p>伪随机数生成器的内部状态，是指伪随机数生成器所管理的内存中的数值。伪随机数生成器会根据内存中的数值进行计算，并将计算的结果作为伪随机数输出。随后，为了响应下一个伪随机数请求。伪随机数生成器会改变自己的内部状态。</p>\n<h3 id=\"2-伪随机数生成器的种子\"><a href=\"#2-伪随机数生成器的种子\" class=\"headerlink\" title=\"2.伪随机数生成器的种子\"></a>2.伪随机数生成器的种子</h3><p>伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_3.png\" alt=\"\"></p>\n<h1 id=\"6-具体的伪随机数生成器\"><a href=\"#6-具体的伪随机数生成器\" class=\"headerlink\" title=\"6 具体的伪随机数生成器\"></a>6 具体的伪随机数生成器</h1><h2 id=\"6-1-杂乱的方法\"><a href=\"#6-1-杂乱的方法\" class=\"headerlink\" title=\"6.1 杂乱的方法\"></a>6.1 杂乱的方法</h2><p>用一个程序员都不懂的算法生成，但是这是错误的，不能用于密码技术。因为，周期太短，使用复杂算法所生成的数列大多数都会具有很短的周期（即短数列的不断重复）。另外则是，无法判断所生成的随机数是否具备不可预测性。</p>\n<h2 id=\"6-2-线性同余法\"><a href=\"#6-2-线性同余法\" class=\"headerlink\" title=\"6.2 线性同余法\"></a>6.2 线性同余法</h2><p>线性同余法（linear congruential method）是一种使用很广泛的伪随机数生成器算法。然而，它并不能用于密码技术。<br>A、C、M 都是常量，且 A 和 C 需要小于 M。接下来，根据种子 R0 计算下一个伪随机数 R1：<br>R1 = （A <em> R0 + C） mod M。<br>当前得到的伪随机数即是下一个伪随机数的种子：<br>Rn+1 = (A </em> Rn + C) mod M。<br>但是这具有周期性，而且可以通过上一个种子得到下一个伪随机数。因此不具备不可预测性，不能将线性同余法用于密码技术。<br>很多伪随机数生成器的库函数都是采用线性同余法编写的。包括 C 语言的库函数 rand。 以及 java 的 java.util.Random 类等。</p>\n<h2 id=\"6-3-单向散列函数法\"><a href=\"#6-3-单向散列函数法\" class=\"headerlink\" title=\"6.3 单向散列函数法\"></a>6.3 单向散列函数法</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_4.png\" alt=\"\"><br>攻击者要预测下一个伪随机数，需要知道计数器的当前值，以及，破解单向散列函数的单向性。利用了单向散列函数的单向性。</p>\n<h2 id=\"6-4-密码法\"><a href=\"#6-4-密码法\" class=\"headerlink\" title=\"6.4 密码法\"></a>6.4 密码法</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_5.png\" alt=\"\"><br>密码的机密性是支撑伪随机数生成器不可预测性的基础。</p>\n<h1 id=\"7-对伪随机数生成器的攻击\"><a href=\"#7-对伪随机数生成器的攻击\" class=\"headerlink\" title=\"7 对伪随机数生成器的攻击\"></a>7 对伪随机数生成器的攻击</h1><h2 id=\"7-1-对种子进行攻击\"><a href=\"#7-1-对种子进行攻击\" class=\"headerlink\" title=\"7.1 对种子进行攻击\"></a>7.1 对种子进行攻击</h2><h2 id=\"7-2-对随机数池进行攻击\"><a href=\"#7-2-对随机数池进行攻击\" class=\"headerlink\" title=\"7.2 对随机数池进行攻击\"></a>7.2 对随机数池进行攻击</h2><p>一般不会到了需要的时候才当场生成真随机数，而是会事先在一个名为<strong>随机数池</strong>（random pool）的文件中积累随机比特序列。当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。这是不能被攻击所知道的。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>由于密码技术的伪随机数生成器，需要使用单向散列函数和密码等技术来确保不可预测性。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><ol>\n<li>伪随机数的种子需要对攻击者保密。</li>\n<li>线性同余法可以作为用于密码的伪随机数生成器。</li>\n<li>具备随机性的伪随机数生成器不一定具备不可预测性。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-骡子的锁匠铺\"><a href=\"#1-骡子的锁匠铺\" class=\"headerlink\" title=\"1 骡子的锁匠铺\"></a>1 骡子的锁匠铺</h1><p>很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。<br>骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。<br>教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。</p>\n<h1 id=\"2-本章概要\"><a href=\"#2-本章概要\" class=\"headerlink\" title=\"2 本章概要\"></a>2 本章概要</h1><ul>\n<li>使用随机数的密码技术</li>\n<li>随机数的性质</li>\n<li>伪随机数生成器</li>\n<li>具体的伪随机数生成器</li>\n<li>对伪随机数生成器的攻击</li>\n</ul>\n<h1 id=\"3-使用随机数的密码技术\"><a href=\"#3-使用随机数的密码技术\" class=\"headerlink\" title=\"3 使用随机数的密码技术\"></a>3 使用随机数的密码技术</h1><h2 id=\"3-1-随机数是干什么的\"><a href=\"#3-1-随机数是干什么的\" class=\"headerlink\" title=\"3.1 随机数是干什么的\"></a>3.1 随机数是干什么的</h2><ol>\n<li>生成秘钥：用于对称密码和消息认证码。</li>\n<li>生成密钥对：用于公钥密码和数字签名。</li>\n<li>生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。</li>\n<li>生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。</li>\n<li>生成盐：用于基于口令的密码（PBE）等。</li>\n</ol>\n<p>在这里，请大家记住<strong>为了不让攻击者看穿而使用随机数</strong>这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。</p>\n<h1 id=\"4-随机数的性质\"><a href=\"#4-随机数的性质\" class=\"headerlink\" title=\"4 随机数的性质\"></a>4 随机数的性质</h1><h2 id=\"4-1-对随机数的性质分类\"><a href=\"#4-1-对随机数的性质分类\" class=\"headerlink\" title=\"4.1 对随机数的性质分类\"></a>4.1 对随机数的性质分类</h2><ol>\n<li>随机性：不存在统计学偏差，是完全杂乱的数列。</li>\n<li>不可预测性：不能从过去的数列推测出下一个出现的数。</li>\n<li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。</li>\n</ol>\n<p>为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。<br>||随机性|不可预测性|不可重现性||<br>|:-:|:-:|:-:|:-:|:-:|<br>|弱伪随机数|✔️|✘|✘|只具备随机性|<br>|强伪随机数|✔️|✔️|✘|具备不可预测性|<br>|真随机数|✔️|✔️|✔️|具备不可重现性|</p>\n<p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_1.png\" alt=\"\"></p>\n<h2 id=\"4-2-随机性\"><a href=\"#4-2-随机性\" class=\"headerlink\" title=\"4.2 随机性\"></a>4.2 随机性</h2><p>杂乱无章并不代表不会被看穿，因此本书中将只具备随机性的伪随机数称为“弱伪随机数”。</p>\n<h2 id=\"4-3-不可预测性\"><a href=\"#4-3-不可预测性\" class=\"headerlink\" title=\"4.3 不可预测性\"></a>4.3 不可预测性</h2><p>不可预测性（unpredictability），是一种“不可能事先说中”的性质，及不可预测性。即，攻击者在知道过去生成的为随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。</p>\n<h2 id=\"4-4-不可重现性\"><a href=\"#4-4-不可重现性\" class=\"headerlink\" title=\"4.4 不可重现性\"></a>4.4 不可重现性</h2><p>即，无法重现和某一随机数列完全相同的数列的性质。如果除了将随机数列本身保存下来意外，没有其它方法能够重现该数列，则我们就说该随机数列具备不可重现性。<br>要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。</p>\n<h1 id=\"5-伪随机数生成器\"><a href=\"#5-伪随机数生成器\" class=\"headerlink\" title=\"5 伪随机数生成器\"></a>5 伪随机数生成器</h1><p>仅仅靠软件无法生成真随机数，因此要加上一个“伪”。</p>\n<h2 id=\"5-1-伪随机数生成器的结构\"><a href=\"#5-1-伪随机数生成器的结构\" class=\"headerlink\" title=\"5.1 伪随机数生成器的结构\"></a>5.1 伪随机数生成器的结构</h2><p>伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_2.png\" alt=\"\">  </p>\n<h3 id=\"1-伪随机数生成器的内部状态\"><a href=\"#1-伪随机数生成器的内部状态\" class=\"headerlink\" title=\"1.伪随机数生成器的内部状态\"></a>1.伪随机数生成器的内部状态</h3><p>伪随机数生成器的内部状态，是指伪随机数生成器所管理的内存中的数值。伪随机数生成器会根据内存中的数值进行计算，并将计算的结果作为伪随机数输出。随后，为了响应下一个伪随机数请求。伪随机数生成器会改变自己的内部状态。</p>\n<h3 id=\"2-伪随机数生成器的种子\"><a href=\"#2-伪随机数生成器的种子\" class=\"headerlink\" title=\"2.伪随机数生成器的种子\"></a>2.伪随机数生成器的种子</h3><p>伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_3.png\" alt=\"\"></p>\n<h1 id=\"6-具体的伪随机数生成器\"><a href=\"#6-具体的伪随机数生成器\" class=\"headerlink\" title=\"6 具体的伪随机数生成器\"></a>6 具体的伪随机数生成器</h1><h2 id=\"6-1-杂乱的方法\"><a href=\"#6-1-杂乱的方法\" class=\"headerlink\" title=\"6.1 杂乱的方法\"></a>6.1 杂乱的方法</h2><p>用一个程序员都不懂的算法生成，但是这是错误的，不能用于密码技术。因为，周期太短，使用复杂算法所生成的数列大多数都会具有很短的周期（即短数列的不断重复）。另外则是，无法判断所生成的随机数是否具备不可预测性。</p>\n<h2 id=\"6-2-线性同余法\"><a href=\"#6-2-线性同余法\" class=\"headerlink\" title=\"6.2 线性同余法\"></a>6.2 线性同余法</h2><p>线性同余法（linear congruential method）是一种使用很广泛的伪随机数生成器算法。然而，它并不能用于密码技术。<br>A、C、M 都是常量，且 A 和 C 需要小于 M。接下来，根据种子 R0 计算下一个伪随机数 R1：<br>R1 = （A <em> R0 + C） mod M。<br>当前得到的伪随机数即是下一个伪随机数的种子：<br>Rn+1 = (A </em> Rn + C) mod M。<br>但是这具有周期性，而且可以通过上一个种子得到下一个伪随机数。因此不具备不可预测性，不能将线性同余法用于密码技术。<br>很多伪随机数生成器的库函数都是采用线性同余法编写的。包括 C 语言的库函数 rand。 以及 java 的 java.util.Random 类等。</p>\n<h2 id=\"6-3-单向散列函数法\"><a href=\"#6-3-单向散列函数法\" class=\"headerlink\" title=\"6.3 单向散列函数法\"></a>6.3 单向散列函数法</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_4.png\" alt=\"\"><br>攻击者要预测下一个伪随机数，需要知道计数器的当前值，以及，破解单向散列函数的单向性。利用了单向散列函数的单向性。</p>\n<h2 id=\"6-4-密码法\"><a href=\"#6-4-密码法\" class=\"headerlink\" title=\"6.4 密码法\"></a>6.4 密码法</h2><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_5.png\" alt=\"\"><br>密码的机密性是支撑伪随机数生成器不可预测性的基础。</p>\n<h1 id=\"7-对伪随机数生成器的攻击\"><a href=\"#7-对伪随机数生成器的攻击\" class=\"headerlink\" title=\"7 对伪随机数生成器的攻击\"></a>7 对伪随机数生成器的攻击</h1><h2 id=\"7-1-对种子进行攻击\"><a href=\"#7-1-对种子进行攻击\" class=\"headerlink\" title=\"7.1 对种子进行攻击\"></a>7.1 对种子进行攻击</h2><h2 id=\"7-2-对随机数池进行攻击\"><a href=\"#7-2-对随机数池进行攻击\" class=\"headerlink\" title=\"7.2 对随机数池进行攻击\"></a>7.2 对随机数池进行攻击</h2><p>一般不会到了需要的时候才当场生成真随机数，而是会事先在一个名为<strong>随机数池</strong>（random pool）的文件中积累随机比特序列。当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。这是不能被攻击所知道的。</p>\n<h1 id=\"8-本章小结\"><a href=\"#8-本章小结\" class=\"headerlink\" title=\"8 本章小结\"></a>8 本章小结</h1><p>由于密码技术的伪随机数生成器，需要使用单向散列函数和密码等技术来确保不可预测性。</p>\n<h1 id=\"9-小测验\"><a href=\"#9-小测验\" class=\"headerlink\" title=\"9 小测验\"></a>9 小测验</h1><ol>\n<li>伪随机数的种子需要对攻击者保密。</li>\n<li>线性同余法可以作为用于密码的伪随机数生成器。</li>\n<li>具备随机性的伪随机数生成器不一定具备不可预测性。</li>\n</ol>\n"},{"title":"Jboot_1","date":"2018-01-10T04:00:00.000Z","updated":"2018-01-12T10:37:00.000Z","comments":1,"_content":"\nJboot的入门demo —— JbooFly。\n\n---\n\n# 1 项目组成\n\n后端基础框架：Jboot\b1.2.7  \n\u001e前端基础框架：Fly Template 社区模版  \n界面渲染框架：JFinal Template Engine\n\n# 2 数据库\n\n使用 Mysql，一共有七张表，暂时使用的只有六张表，即文章分类表、评论表、文章表、用户表、用户行为表、用户收藏表。用户消息表没有用上。\n\n# 3 前端页面\n\n\b1. 社区首页：外层架子（_layout.html），分类导航（_navigation.html），置顶文章（_top_posts.html），内容列表（content()），右边四个小页面（_signin_panel/_recommend/_hot_posts/_links）\n2. 个人页面：外层架子，左侧导航（_user_left_menu.html），我的主页（index.html），我的帖子（post.html/collection.html），基本设置（setting.html），我的消息（message.html），账号激活（activate.html）\n\n# 4 定时任务\n\n1. 文章浏览量，一分钟一次。使用了 `ConcurrentHashMap` + `AtomicLong` 的方式处理线程问题。最后更新缓存（默认缓存开启并有五种）：  \n```java\n/**\n * name: io.jboot.core.cache.JbootCacheConfig\n */\npublic static final String TYPE_EHCACHE = \"ehcache\";\n    public static final String TYPE_REDIS = \"redis\";\n    public static final String TYPE_EHREDIS = \"ehredis\";\n    public static final String TYPE_NONE_CACHE = \"none\";\n    public static final String TYPE_J2CACHE = \"j2cache\";\n\n\n    private String type = TYPE_EHCACHE;\n    ......\n```\n2. 文章评论量，和文章浏览量一样的业务逻辑。\n\n# 5 Caffeine 缓存使用\n\n1. 签到缓存：SigninManager，缓存用户以及签到时间的映射关系，过期时间为两小时。\n2. 消息缓存：MessageManager，作者未开发完，猜测是缓存用户以及用户未读消息的映射关系。\n\n# 6 拦截器\n\n1. 全局强制拦截器 UserIntercepor ，每次请求服务，都会使用解密算法查看存储在 cookie 中的用户信息，并获取该用户的签到缓存以及消息缓存信息。\n2. ajax api 强制拦截器 ApiNeedUser。\n3. 页面强制拦截器 NeedUser。\n\n# 7 本地事件\n\n1. 用户注册事件监听 UserRegister ，作者未开发完，猜测应该是用户注册后发送邮件或者验证码，抑或是通知版主？\n\n# 8 JFinal \n\n1. JFinal Template Engine，查看 JFinal 自定义指令文档即可。主要是 directive 下的文件。\n\n# 9 目的\n\n猜测应该是 JBoot 论坛。\n\n","source":"_posts/技术小结/Jboot1.md","raw":"---\ntitle: Jboot_1\ndate: 2018-01-10 12:00:00\nupdated: 2018-01-12 18:37:00\ncomments: true\ncategories: \n- 小结\npermalink: tech/Jboot_1.html    \n---\n\nJboot的入门demo —— JbooFly。\n\n---\n\n# 1 项目组成\n\n后端基础框架：Jboot\b1.2.7  \n\u001e前端基础框架：Fly Template 社区模版  \n界面渲染框架：JFinal Template Engine\n\n# 2 数据库\n\n使用 Mysql，一共有七张表，暂时使用的只有六张表，即文章分类表、评论表、文章表、用户表、用户行为表、用户收藏表。用户消息表没有用上。\n\n# 3 前端页面\n\n\b1. 社区首页：外层架子（_layout.html），分类导航（_navigation.html），置顶文章（_top_posts.html），内容列表（content()），右边四个小页面（_signin_panel/_recommend/_hot_posts/_links）\n2. 个人页面：外层架子，左侧导航（_user_left_menu.html），我的主页（index.html），我的帖子（post.html/collection.html），基本设置（setting.html），我的消息（message.html），账号激活（activate.html）\n\n# 4 定时任务\n\n1. 文章浏览量，一分钟一次。使用了 `ConcurrentHashMap` + `AtomicLong` 的方式处理线程问题。最后更新缓存（默认缓存开启并有五种）：  \n```java\n/**\n * name: io.jboot.core.cache.JbootCacheConfig\n */\npublic static final String TYPE_EHCACHE = \"ehcache\";\n    public static final String TYPE_REDIS = \"redis\";\n    public static final String TYPE_EHREDIS = \"ehredis\";\n    public static final String TYPE_NONE_CACHE = \"none\";\n    public static final String TYPE_J2CACHE = \"j2cache\";\n\n\n    private String type = TYPE_EHCACHE;\n    ......\n```\n2. 文章评论量，和文章浏览量一样的业务逻辑。\n\n# 5 Caffeine 缓存使用\n\n1. 签到缓存：SigninManager，缓存用户以及签到时间的映射关系，过期时间为两小时。\n2. 消息缓存：MessageManager，作者未开发完，猜测是缓存用户以及用户未读消息的映射关系。\n\n# 6 拦截器\n\n1. 全局强制拦截器 UserIntercepor ，每次请求服务，都会使用解密算法查看存储在 cookie 中的用户信息，并获取该用户的签到缓存以及消息缓存信息。\n2. ajax api 强制拦截器 ApiNeedUser。\n3. 页面强制拦截器 NeedUser。\n\n# 7 本地事件\n\n1. 用户注册事件监听 UserRegister ，作者未开发完，猜测应该是用户注册后发送邮件或者验证码，抑或是通知版主？\n\n# 8 JFinal \n\n1. JFinal Template Engine，查看 JFinal 自定义指令文档即可。主要是 directive 下的文件。\n\n# 9 目的\n\n猜测应该是 JBoot 论坛。\n\n","slug":"tech/Jboot_1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw00031axs6ddtpj6qr","content":"<p>Jboot的入门demo —— JbooFly。</p>\n<hr>\n<h1 id=\"1-项目组成\"><a href=\"#1-项目组成\" class=\"headerlink\" title=\"1 项目组成\"></a>1 项目组成</h1><p>后端基础框架：Jboot\b1.2.7<br>\u001e前端基础框架：Fly Template 社区模版<br>界面渲染框架：JFinal Template Engine</p>\n<h1 id=\"2-数据库\"><a href=\"#2-数据库\" class=\"headerlink\" title=\"2 数据库\"></a>2 数据库</h1><p>使用 Mysql，一共有七张表，暂时使用的只有六张表，即文章分类表、评论表、文章表、用户表、用户行为表、用户收藏表。用户消息表没有用上。</p>\n<h1 id=\"3-前端页面\"><a href=\"#3-前端页面\" class=\"headerlink\" title=\"3 前端页面\"></a>3 前端页面</h1><p>\b1. 社区首页：外层架子（_layout.html），分类导航（_navigation.html），置顶文章（_top_posts.html），内容列表（content()），右边四个小页面（_signin_panel/_recommend/_hot_posts/_links）</p>\n<ol start=\"2\">\n<li>个人页面：外层架子，左侧导航（_user_left_menu.html），我的主页（index.html），我的帖子（post.html/collection.html），基本设置（setting.html），我的消息（message.html），账号激活（activate.html）</li>\n</ol>\n<h1 id=\"4-定时任务\"><a href=\"#4-定时任务\" class=\"headerlink\" title=\"4 定时任务\"></a>4 定时任务</h1><ol>\n<li><p>文章浏览量，一分钟一次。使用了 <code>ConcurrentHashMap</code> + <code>AtomicLong</code> 的方式处理线程问题。最后更新缓存（默认缓存开启并有五种）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * name: io.jboot.core.cache.JbootCacheConfig</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_EHCACHE = <span class=\"string\">\"ehcache\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_REDIS = <span class=\"string\">\"redis\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_EHREDIS = <span class=\"string\">\"ehredis\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_NONE_CACHE = <span class=\"string\">\"none\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_J2CACHE = <span class=\"string\">\"j2cache\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type = TYPE_EHCACHE;</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>文章评论量，和文章浏览量一样的业务逻辑。</p>\n</li>\n</ol>\n<h1 id=\"5-Caffeine-缓存使用\"><a href=\"#5-Caffeine-缓存使用\" class=\"headerlink\" title=\"5 Caffeine 缓存使用\"></a>5 Caffeine 缓存使用</h1><ol>\n<li>签到缓存：SigninManager，缓存用户以及签到时间的映射关系，过期时间为两小时。</li>\n<li>消息缓存：MessageManager，作者未开发完，猜测是缓存用户以及用户未读消息的映射关系。</li>\n</ol>\n<h1 id=\"6-拦截器\"><a href=\"#6-拦截器\" class=\"headerlink\" title=\"6 拦截器\"></a>6 拦截器</h1><ol>\n<li>全局强制拦截器 UserIntercepor ，每次请求服务，都会使用解密算法查看存储在 cookie 中的用户信息，并获取该用户的签到缓存以及消息缓存信息。</li>\n<li>ajax api 强制拦截器 ApiNeedUser。</li>\n<li>页面强制拦截器 NeedUser。</li>\n</ol>\n<h1 id=\"7-本地事件\"><a href=\"#7-本地事件\" class=\"headerlink\" title=\"7 本地事件\"></a>7 本地事件</h1><ol>\n<li>用户注册事件监听 UserRegister ，作者未开发完，猜测应该是用户注册后发送邮件或者验证码，抑或是通知版主？</li>\n</ol>\n<h1 id=\"8-JFinal\"><a href=\"#8-JFinal\" class=\"headerlink\" title=\"8 JFinal\"></a>8 JFinal</h1><ol>\n<li>JFinal Template Engine，查看 JFinal 自定义指令文档即可。主要是 directive 下的文件。</li>\n</ol>\n<h1 id=\"9-目的\"><a href=\"#9-目的\" class=\"headerlink\" title=\"9 目的\"></a>9 目的</h1><p>猜测应该是 JBoot 论坛。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Jboot的入门demo —— JbooFly。</p>\n<hr>\n<h1 id=\"1-项目组成\"><a href=\"#1-项目组成\" class=\"headerlink\" title=\"1 项目组成\"></a>1 项目组成</h1><p>后端基础框架：Jboot\b1.2.7<br>\u001e前端基础框架：Fly Template 社区模版<br>界面渲染框架：JFinal Template Engine</p>\n<h1 id=\"2-数据库\"><a href=\"#2-数据库\" class=\"headerlink\" title=\"2 数据库\"></a>2 数据库</h1><p>使用 Mysql，一共有七张表，暂时使用的只有六张表，即文章分类表、评论表、文章表、用户表、用户行为表、用户收藏表。用户消息表没有用上。</p>\n<h1 id=\"3-前端页面\"><a href=\"#3-前端页面\" class=\"headerlink\" title=\"3 前端页面\"></a>3 前端页面</h1><p>\b1. 社区首页：外层架子（_layout.html），分类导航（_navigation.html），置顶文章（_top_posts.html），内容列表（content()），右边四个小页面（_signin_panel/_recommend/_hot_posts/_links）</p>\n<ol start=\"2\">\n<li>个人页面：外层架子，左侧导航（_user_left_menu.html），我的主页（index.html），我的帖子（post.html/collection.html），基本设置（setting.html），我的消息（message.html），账号激活（activate.html）</li>\n</ol>\n<h1 id=\"4-定时任务\"><a href=\"#4-定时任务\" class=\"headerlink\" title=\"4 定时任务\"></a>4 定时任务</h1><ol>\n<li><p>文章浏览量，一分钟一次。使用了 <code>ConcurrentHashMap</code> + <code>AtomicLong</code> 的方式处理线程问题。最后更新缓存（默认缓存开启并有五种）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * name: io.jboot.core.cache.JbootCacheConfig</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_EHCACHE = <span class=\"string\">\"ehcache\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_REDIS = <span class=\"string\">\"redis\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_EHREDIS = <span class=\"string\">\"ehredis\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_NONE_CACHE = <span class=\"string\">\"none\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_J2CACHE = <span class=\"string\">\"j2cache\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type = TYPE_EHCACHE;</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>文章评论量，和文章浏览量一样的业务逻辑。</p>\n</li>\n</ol>\n<h1 id=\"5-Caffeine-缓存使用\"><a href=\"#5-Caffeine-缓存使用\" class=\"headerlink\" title=\"5 Caffeine 缓存使用\"></a>5 Caffeine 缓存使用</h1><ol>\n<li>签到缓存：SigninManager，缓存用户以及签到时间的映射关系，过期时间为两小时。</li>\n<li>消息缓存：MessageManager，作者未开发完，猜测是缓存用户以及用户未读消息的映射关系。</li>\n</ol>\n<h1 id=\"6-拦截器\"><a href=\"#6-拦截器\" class=\"headerlink\" title=\"6 拦截器\"></a>6 拦截器</h1><ol>\n<li>全局强制拦截器 UserIntercepor ，每次请求服务，都会使用解密算法查看存储在 cookie 中的用户信息，并获取该用户的签到缓存以及消息缓存信息。</li>\n<li>ajax api 强制拦截器 ApiNeedUser。</li>\n<li>页面强制拦截器 NeedUser。</li>\n</ol>\n<h1 id=\"7-本地事件\"><a href=\"#7-本地事件\" class=\"headerlink\" title=\"7 本地事件\"></a>7 本地事件</h1><ol>\n<li>用户注册事件监听 UserRegister ，作者未开发完，猜测应该是用户注册后发送邮件或者验证码，抑或是通知版主？</li>\n</ol>\n<h1 id=\"8-JFinal\"><a href=\"#8-JFinal\" class=\"headerlink\" title=\"8 JFinal\"></a>8 JFinal</h1><ol>\n<li>JFinal Template Engine，查看 JFinal 自定义指令文档即可。主要是 directive 下的文件。</li>\n</ol>\n<h1 id=\"9-目的\"><a href=\"#9-目的\" class=\"headerlink\" title=\"9 目的\"></a>9 目的</h1><p>猜测应该是 JBoot 论坛。</p>\n"},{"title":"如何阅读一本书之图解密码技术","date":"2018-06-11T14:56:00.000Z","updated":"2018-06-11T16:50:00.000Z","comments":1,"_content":"\n# 1 这本书在谈些什么\n\n# 2 作者的主要想法和主要观点是什么\n\n# 3 这本书说的有道理吗，还是只有部分有道理\n\n# 4 这本书跟我有什么关系","source":"_posts/图解密码技术/阅读总结.md","raw":"---\ntitle: 如何阅读一本书之图解密码技术\ndate: 2018-06-11 22:56:00\nupdated: 2018-06-12 00:50:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\n- 如何阅读一本书\npermalink: graphic2cryptography/0.html    \n---\n\n# 1 这本书在谈些什么\n\n# 2 作者的主要想法和主要观点是什么\n\n# 3 这本书说的有道理吗，还是只有部分有道理\n\n# 4 这本书跟我有什么关系","slug":"graphic2cryptography/0.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw10032axs60csyb7cy","content":"<h1 id=\"1-这本书在谈些什么\"><a href=\"#1-这本书在谈些什么\" class=\"headerlink\" title=\"1 这本书在谈些什么\"></a>1 这本书在谈些什么</h1><h1 id=\"2-作者的主要想法和主要观点是什么\"><a href=\"#2-作者的主要想法和主要观点是什么\" class=\"headerlink\" title=\"2 作者的主要想法和主要观点是什么\"></a>2 作者的主要想法和主要观点是什么</h1><h1 id=\"3-这本书说的有道理吗，还是只有部分有道理\"><a href=\"#3-这本书说的有道理吗，还是只有部分有道理\" class=\"headerlink\" title=\"3 这本书说的有道理吗，还是只有部分有道理\"></a>3 这本书说的有道理吗，还是只有部分有道理</h1><h1 id=\"4-这本书跟我有什么关系\"><a href=\"#4-这本书跟我有什么关系\" class=\"headerlink\" title=\"4 这本书跟我有什么关系\"></a>4 这本书跟我有什么关系</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-这本书在谈些什么\"><a href=\"#1-这本书在谈些什么\" class=\"headerlink\" title=\"1 这本书在谈些什么\"></a>1 这本书在谈些什么</h1><h1 id=\"2-作者的主要想法和主要观点是什么\"><a href=\"#2-作者的主要想法和主要观点是什么\" class=\"headerlink\" title=\"2 作者的主要想法和主要观点是什么\"></a>2 作者的主要想法和主要观点是什么</h1><h1 id=\"3-这本书说的有道理吗，还是只有部分有道理\"><a href=\"#3-这本书说的有道理吗，还是只有部分有道理\" class=\"headerlink\" title=\"3 这本书说的有道理吗，还是只有部分有道理\"></a>3 这本书说的有道理吗，还是只有部分有道理</h1><h1 id=\"4-这本书跟我有什么关系\"><a href=\"#4-这本书跟我有什么关系\" class=\"headerlink\" title=\"4 这本书跟我有什么关系\"></a>4 这本书跟我有什么关系</h1>"},{"title":"《MyBatis 从入门到精通》总结","date":"2017-12-18T14:10:00.000Z","updated":"2017-12-18T14:10:00.000Z","comments":1,"_content":"\n笔记总结+源码：https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1  \n在前七章都打了对应的标签，可以通过 git checkout来。  \n![][1]  \n总结就是，将 sql 语句从代码中抽离出来，通过 xml 的配置来实现单表、多表的映射，最后通过动态代理来执行方法，很强的解耦性。  \n把 SQL 放在了 XML 中，然后用一些判断来实现动态 SQL ，最后通过 SqlSession 、SqlSessionFacotry 的生命周期来绑定一级、二级缓存。  \n不学之前感觉很神奇，学完之后也就那么回事，不过还是要多学学基础，例如读取配置、缓存、一级动态代理等。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/mybatis0to1/summary.png","source":"_posts/技术小结/mybatis0to1.md","raw":"---\ntitle: 《MyBatis 从入门到精通》总结\ndate: 2017-12-18 22:10:00\nupdated: 2017-12-18 22:10:00\ncomments: true\ncategories: \n- 小结\npermalink: tech/mybatis0to1.html \n---\n\n笔记总结+源码：https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1  \n在前七章都打了对应的标签，可以通过 git checkout来。  \n![][1]  \n总结就是，将 sql 语句从代码中抽离出来，通过 xml 的配置来实现单表、多表的映射，最后通过动态代理来执行方法，很强的解耦性。  \n把 SQL 放在了 XML 中，然后用一些判断来实现动态 SQL ，最后通过 SqlSession 、SqlSessionFacotry 的生命周期来绑定一级、二级缓存。  \n不学之前感觉很神奇，学完之后也就那么回事，不过还是要多学学基础，例如读取配置、缓存、一级动态代理等。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/mybatis0to1/summary.png","slug":"tech/mybatis0to1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw20035axs6iefsmbr7","content":"<p>笔记总结+源码：<a href=\"https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1\" target=\"_blank\" rel=\"noopener\">https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1</a><br>在前七章都打了对应的标签，可以通过 git checkout来。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/mybatis0to1/summary.png\" alt=\"\"><br>总结就是，将 sql 语句从代码中抽离出来，通过 xml 的配置来实现单表、多表的映射，最后通过动态代理来执行方法，很强的解耦性。<br>把 SQL 放在了 XML 中，然后用一些判断来实现动态 SQL ，最后通过 SqlSession 、SqlSessionFacotry 的生命周期来绑定一级、二级缓存。<br>不学之前感觉很神奇，学完之后也就那么回事，不过还是要多学学基础，例如读取配置、缓存、一级动态代理等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>笔记总结+源码：<a href=\"https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1\" target=\"_blank\" rel=\"noopener\">https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1</a><br>在前七章都打了对应的标签，可以通过 git checkout来。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/mybatis0to1/summary.png\" alt=\"\"><br>总结就是，将 sql 语句从代码中抽离出来，通过 xml 的配置来实现单表、多表的映射，最后通过动态代理来执行方法，很强的解耦性。<br>把 SQL 放在了 XML 中，然后用一些判断来实现动态 SQL ，最后通过 SqlSession 、SqlSessionFacotry 的生命周期来绑定一级、二级缓存。<br>不学之前感觉很神奇，学完之后也就那么回事，不过还是要多学学基础，例如读取配置、缓存、一级动态代理等。</p>\n"},{"title":"Jboot_2","date":"2018-01-10T04:00:00.000Z","updated":"2018-01-12T10:37:00.000Z","comments":1,"_content":"\n# 0 启动流程\n\n1. 解析启动参数，打印 logo。\n2. 通过工厂对配置进行判断获取相应的应用服务器（默认 undertow）。\n3. 判断是否是开发模式（默认），如果是则定期对文件进行扫描（3 * 1010）。\n4. 回调各个 listener 的 onJbootStarted() 方法。\n\n# 1 如何使用 main 文件启动一个应用服务器？\n\n如果你会使用，可以直接跳过这节。\n\npom.xml:  \n```xml\n...\n<dependency>\n    <groupId>org.eclipse.jetty</groupId>\n    <artifactId>jetty-server</artifactId>\n    <version>9.4.8.v20171121</version>\n</dependency>\n\n<dependency>\n    <groupId>org.eclipse.jetty</groupId>\n    <artifactId>jetty-servlet</artifactId>\n    <version>9.4.8.v20171121</version>\n</dependency>\n```\n\nSimpleServer.java:  \n```java\npublic class SimpleServer {\n\n    public static void main(String[] args) throws Exception {\n        InetSocketAddress address = new InetSocketAddress(\"0.0.0.0\", 8081);\n        Server server = new Server(address);\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setResourceBase(\"/Users/liwenguang/Downloads\");\n        server.setHandler(handler);\n        server.start();\n    }\n}\n```\n\n参考资料：http://blog.csdn.net/kiterunner/article/details/51695293\n\n# 2 Jboot 启动精简版\n\nJboot.java 主文件：  \n```java\npublic class Jboot {\n\n    private JbootServer jbootServer;\n\n    public void start() {\n        ensureServerCreated();\n        if (!startServer()) {\n            System.err.println(\"jboot start fail!!!\");\n            return;\n        }\n    }\n\n    private void ensureServerCreated() {\n        if (jbootServer == null) {\n            JbootServerFactory factory = JbootServerFactory.me();\n            jbootServer = factory.buildServer();\n        }\n    }\n\n    private boolean startServer() {\n        return jbootServer.start();\n    }\n\n    public static void main(String[] args) {\n        new Jboot().start();\n    }\n}\n```\n\nJbootServer 抽象类，方便各种应用服务器的工厂创建，其中作者只编写了 undertow 和 jetty 的实现。（可知作者对 tomcat 不大喜欢）：  \n```java\npublic abstract class JbootServer {\n    public abstract boolean start();\n    public abstract boolean restart();\n    public abstract boolean stop();\n}\n``` \nJbootServerFactory 工厂类：\n```java\npublic class JbootServerFactory {\n\n    private static JbootServerFactory me = new JbootServerFactory();\n    public static JbootServerFactory me() {\n        return me;\n    }\n    public JbootServer buildServer() {\n        // switch \n        return new JettyServer();\n    }\n}\n```\n\n接着是应用服务器的配置文件， JbootServerConfig：  \n```java\npublic class JbootServerConfig {\n\n    public static final String TYPE_UNDERTOW = \"undertow\";\n    public static final String TYPE_TOMCAT = \"tomcat\";\n    public static final String TYPE_JETTY = \"jetty\";\n\n    private String type = TYPE_UNDERTOW;\n    private String host = \"0.0.0.0\";\n    private int port = 8080;\n    private String contextPath = \"/\";\n\n    // set/get 省略\n}\n```\n\n最后是实现的 Jetty 应用服务器， JettyServer：\n```java\npublic class JettyServer extends JbootServer {\n\n    private static Log log = Log.getLog(JettyServer.class);\n\n    private JbootServerConfig config;\n    // private JbootWebConfig webConfig;\n\n    private Server jettyServer;\n    private ServletContextHandler handler;\n\n    public JettyServer() {\n        config = new JbootServerConfig();\n        // webConfig = Jboot.config(JbootWebConfig.class);\n    }\n\n    @Override\n    public boolean start() {\n        try {\n            initJettyServer();\n            // JbootAppListenerManager.me().onAppStartBefore(this);\n            jettyServer.start();\n        } catch (Throwable ex) {\n            log.error(ex.toString(), ex);\n            stop();\n            return false;\n        }\n        return true;\n    }\n\n    private void initJettyServer() {\n        InetSocketAddress address = new InetSocketAddress(config.getHost(), config.getPort());\n        jettyServer = new Server(address);\n\n        handler = new ServletContextHandler();\n        handler.setContextPath(config.getContextPath());\n        handler.setClassLoader(new JbootServerClassloader(JettyServer.class.getClassLoader()));\n        handler.setResourceBase(getRootClassPath());\n        /*\n        增加 shiro 全局过滤器\n        JbootShiroConfig shiroConfig = Jboot.config(JbootShiroConfig.class);\n        if (shiroConfig.isConfigOK()) {\n            handler.addEventListener(new EnvironmentLoaderListener());\n            handler.addFilter(ShiroFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n        }\n        */\n        /*\n        增加 Jfinal Handler，Jboot 基于 Jfinal\n        //JFinal\n        FilterHolder jfinalFilter = handler.addFilter(JFinalFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n        jfinalFilter.setInitParameter(\"configClass\", Jboot.me().getJbootConfig().getJfinalConfig());\n        增加 Hystrix 监控 servlet\n        JbootHystrixConfig hystrixConfig = Jboot.config(JbootHystrixConfig.class);\n        if (StringUtils.isNotBlank(hystrixConfig.getUrl())) {\n            handler.addServlet(HystrixMetricsStreamServlet.class, hystrixConfig.getUrl());\n        }\n\n        增加 metric 监控\n        JbootMetricConfig metricsConfig = Jboot.config(JbootMetricConfig.class);\n        if (StringUtils.isNotBlank(metricsConfig.getUrl())) {\n            handler.addEventListener(new JbootMetricServletContextListener());\n            handler.addEventListener(new JbootHealthCheckServletContextListener());\n            handler.addServlet(AdminServlet.class, metricsConfig.getUrl());\n        }\n        最后增加 Jboot 本身的 servlet\n        io.jboot.server.Servlets jbootServlets = new io.jboot.server.Servlets();\n        ContextListeners listeners = new ContextListeners();\n        JbootAppListenerManager.me().onJbootDeploy(jbootServlets, listeners);\n        for (Map.Entry<String, io.jboot.server.Servlets.ServletInfo> entry : jbootServlets.getServlets().entrySet()) {\n            for (String path : entry.getValue().getUrlMapping()) {\n                handler.addServlet(entry.getValue().getServletClass(), path);\n            }\n        }\n        事件监听\n        for (Class<? extends ServletContextListener> listenerClass : listeners.getListeners()) {\n            handler.addEventListener(ClassKits.newInstance(listenerClass));\n        }\n\n        */\n        jettyServer.setHandler(handler);\n    }\n\n    private static String getRootClassPath() {\n        String path = null;\n        try {\n            path = JettyServer.class.getClassLoader().getResource(\"\").toURI().getPath();\n            return new File(path).getAbsolutePath();\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n        return path;\n    }\n\n    @Override\n    public boolean restart() {\n        stop();\n        start();\n        return true;\n    }\n\n    @Override\n    public boolean stop() {\n        try {\n            jettyServer.stop();\n            return true;\n        } catch (Exception ex) {\n            log.error(ex.toString(), ex);\n        }\n        return false;\n    }\n}\n```\n\n最后是自定义 ClassLoader，JbootServerClassLoader：  \n```java\npublic class JbootServerClassloader extends ClassLoader {\n\n    public JbootServerClassloader(ClassLoader parent) {\n        super(parent);\n    }\n\n\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n}\n```\n自定义 ClassLoader 在应用服务器中都会自定义，用于文件的隔离和热更新。  \n  \n目录结构如下：  \n![][1]\n\n# 3 启动到底启动了什么\n\n## 1. 参数解析\n\n类似 JVM options 的 -Dxxx=xxx 参数的作用，用于全局访问，Jboot 将启动参数使用 Jboot.setBootArg() 放在了一个 Map 中，你可以使用 Jboot.getBootArg() 获取。  \nJboot.java  \n```java\nprivate static void parseArgs(String[] args) {\n        if (args == null || args.length == 0) {\n            return;\n        }\n\n        for (String arg : args) {\n            int indexOf = arg.indexOf(\"=\");\n            if (arg.startsWith(\"--\") && indexOf > 0) {\n                String key = arg.substring(2, indexOf);\n                String value = arg.substring(indexOf + 1);\n                setBootArg(key, value);\n            }\n        }\n    }\n```\n\n## 2. 判断启动模式\n\n默认为 dev 模式，查看 JbootConfig.java 文件可知，但是我们可能为想，我们怎么才能设置启动模式呢？  \n  \n没错，使用启动参数！请看 JbootConfigManager 文件，该文件是用于读取配置文件，你可能会想，为什么配置文件都加了 `@PropertyConfig(prefix = \"\")` 这样的注解呢，其实，这是作者为了方便 JavaBean 与 参数 进行转换。直接上代码：  \n  \n第一种：启动参数，如下图：  \n![][2]  \n我们配置了两个参数（对照 JbootConfig 你就知道，只有 mode 有 set 方法，而 version 是只有 get 方法的）。  \n最后启动 debug 的时候你就会发现 Jboot.isDevMode() 方法返回 false 而不是默认的 true。 \n>有很多地方判断了，如果是 dev 模式，则会打印一些参数，例如 JbootEventManager 方法。\n\n第二种：使用 `Jboot.setBootArg(\"jboot.mode\", \"test\");` 这种，从前面的 **参数解析** 一节我们已经知道，其实启动参数底层使用的就是 setBootArg 方法。\n>测试类中很多使用了这种方法，例如 `DubboClientZookeeperDemo`。\n\n如果是 dev 模式，就会定时 3 秒扫描应用服务器文件夹，但是作者注释了，这里不懂作者的意思。  \nAutoDeployManager.java  \n```java\npublic void run() {\n\n        File file = new File(PathKit.getRootClassPath());\n        JbootFileScanner scanner = new JbootFileScanner(file.getAbsolutePath(), 3) {\n            @Override\n            public void onChange(String action, String file) {\n                try {\n//                    System.err.println(\"file changes : \" + file);\n//                    Jboot.me().getServer().restart();\n//                    JbootServerFactory.me().buildServer().start();\n//                    System.err.println(\"Loading complete.\");\n                } catch (Exception e) {\n                    System.err.println(\"Error reconfiguring/restarting webapp after change in watched files\");\n                    LogKit.error(e.getMessage(), e);\n                }\n            }\n        };\n\n        scanner.start();\n    }\n```\n\n## 3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法\n\n在 Jboot 启动的最后一步，实例化了 JbootAppListenerManager 类：\n```java\n private JbootAppListenerManager() {\n    // 扫描获取所有 JbootAppListener 的子类\n    List<Class<JbootAppListener>> allListeners = ClassScanner.scanSubClass(JbootAppListener.class, true);\n    if (allListeners == null || allListeners.size() == 0) {\n        return;\n    }\n    // 去除 JbootAppListenerManager 本身\n    for (Class<? extends JbootAppListener> clazz : allListeners) {\n        if (JbootAppListenerManager.class == clazz || JbootAppListenerBase.class == clazz) {\n            continue;\n        }\n        // 实例化\n        JbootAppListener listener = ClassKits.newInstance(clazz, false);\n        if (listener != null) {\n            listeners.add(listener);\n        }\n    }\n}\n\n@Override\npublic void onJbootStarted() {\n    for (JbootAppListener listener : listeners) {\n        try {\n            listener.onJbootStarted();\n        } catch (Throwable ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n}\n```\n\n并通过 `JbootAppListenerManager.me().onJbootStarted();` 回调了 `onJbootStarted()` 方法，来调用用户的逻辑。\n\n# 4 其它\n\n1. 从一些 Manager 方法看的出作者习惯通过构造方法进行一些必要的初始化，我以前看的 《架构探险——从零开始写Java Web框架》 则喜欢用静态块进行初始化。  \n2. 启动的一些细节需要大家去 debug 一步一步看，看懂了也是很高兴的，毕竟作者也是大牛，更近了一步。  \n3. 作者代码习惯方法名由于注释。说实话初看有点不习惯，因为习惯看注释了，但是作者方法名真的能让你可以不用注释（除却一些必要方法作者加了注释）。\n4. jbootfly 是入门，不要想直接看源码，欲速则不达。\n5. 你要懂 jfinal 的知识，至少看过 jfinal 文档，写过 jfinal 经典的 blog 项目。\n\n## 如果有错误，请指出，谢谢，共勉。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_demo.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_args.png","source":"_posts/技术小结/Jboot2_启动.md","raw":"---\ntitle: Jboot_2\ndate: 2018-01-10 12:00:00\nupdated: 2018-01-12 18:37:00\ncomments: true\ncategories: \n- 小结\npermalink: tech/Jboot_2.html    \n---\n\n# 0 启动流程\n\n1. 解析启动参数，打印 logo。\n2. 通过工厂对配置进行判断获取相应的应用服务器（默认 undertow）。\n3. 判断是否是开发模式（默认），如果是则定期对文件进行扫描（3 * 1010）。\n4. 回调各个 listener 的 onJbootStarted() 方法。\n\n# 1 如何使用 main 文件启动一个应用服务器？\n\n如果你会使用，可以直接跳过这节。\n\npom.xml:  \n```xml\n...\n<dependency>\n    <groupId>org.eclipse.jetty</groupId>\n    <artifactId>jetty-server</artifactId>\n    <version>9.4.8.v20171121</version>\n</dependency>\n\n<dependency>\n    <groupId>org.eclipse.jetty</groupId>\n    <artifactId>jetty-servlet</artifactId>\n    <version>9.4.8.v20171121</version>\n</dependency>\n```\n\nSimpleServer.java:  \n```java\npublic class SimpleServer {\n\n    public static void main(String[] args) throws Exception {\n        InetSocketAddress address = new InetSocketAddress(\"0.0.0.0\", 8081);\n        Server server = new Server(address);\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setResourceBase(\"/Users/liwenguang/Downloads\");\n        server.setHandler(handler);\n        server.start();\n    }\n}\n```\n\n参考资料：http://blog.csdn.net/kiterunner/article/details/51695293\n\n# 2 Jboot 启动精简版\n\nJboot.java 主文件：  \n```java\npublic class Jboot {\n\n    private JbootServer jbootServer;\n\n    public void start() {\n        ensureServerCreated();\n        if (!startServer()) {\n            System.err.println(\"jboot start fail!!!\");\n            return;\n        }\n    }\n\n    private void ensureServerCreated() {\n        if (jbootServer == null) {\n            JbootServerFactory factory = JbootServerFactory.me();\n            jbootServer = factory.buildServer();\n        }\n    }\n\n    private boolean startServer() {\n        return jbootServer.start();\n    }\n\n    public static void main(String[] args) {\n        new Jboot().start();\n    }\n}\n```\n\nJbootServer 抽象类，方便各种应用服务器的工厂创建，其中作者只编写了 undertow 和 jetty 的实现。（可知作者对 tomcat 不大喜欢）：  \n```java\npublic abstract class JbootServer {\n    public abstract boolean start();\n    public abstract boolean restart();\n    public abstract boolean stop();\n}\n``` \nJbootServerFactory 工厂类：\n```java\npublic class JbootServerFactory {\n\n    private static JbootServerFactory me = new JbootServerFactory();\n    public static JbootServerFactory me() {\n        return me;\n    }\n    public JbootServer buildServer() {\n        // switch \n        return new JettyServer();\n    }\n}\n```\n\n接着是应用服务器的配置文件， JbootServerConfig：  \n```java\npublic class JbootServerConfig {\n\n    public static final String TYPE_UNDERTOW = \"undertow\";\n    public static final String TYPE_TOMCAT = \"tomcat\";\n    public static final String TYPE_JETTY = \"jetty\";\n\n    private String type = TYPE_UNDERTOW;\n    private String host = \"0.0.0.0\";\n    private int port = 8080;\n    private String contextPath = \"/\";\n\n    // set/get 省略\n}\n```\n\n最后是实现的 Jetty 应用服务器， JettyServer：\n```java\npublic class JettyServer extends JbootServer {\n\n    private static Log log = Log.getLog(JettyServer.class);\n\n    private JbootServerConfig config;\n    // private JbootWebConfig webConfig;\n\n    private Server jettyServer;\n    private ServletContextHandler handler;\n\n    public JettyServer() {\n        config = new JbootServerConfig();\n        // webConfig = Jboot.config(JbootWebConfig.class);\n    }\n\n    @Override\n    public boolean start() {\n        try {\n            initJettyServer();\n            // JbootAppListenerManager.me().onAppStartBefore(this);\n            jettyServer.start();\n        } catch (Throwable ex) {\n            log.error(ex.toString(), ex);\n            stop();\n            return false;\n        }\n        return true;\n    }\n\n    private void initJettyServer() {\n        InetSocketAddress address = new InetSocketAddress(config.getHost(), config.getPort());\n        jettyServer = new Server(address);\n\n        handler = new ServletContextHandler();\n        handler.setContextPath(config.getContextPath());\n        handler.setClassLoader(new JbootServerClassloader(JettyServer.class.getClassLoader()));\n        handler.setResourceBase(getRootClassPath());\n        /*\n        增加 shiro 全局过滤器\n        JbootShiroConfig shiroConfig = Jboot.config(JbootShiroConfig.class);\n        if (shiroConfig.isConfigOK()) {\n            handler.addEventListener(new EnvironmentLoaderListener());\n            handler.addFilter(ShiroFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n        }\n        */\n        /*\n        增加 Jfinal Handler，Jboot 基于 Jfinal\n        //JFinal\n        FilterHolder jfinalFilter = handler.addFilter(JFinalFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n        jfinalFilter.setInitParameter(\"configClass\", Jboot.me().getJbootConfig().getJfinalConfig());\n        增加 Hystrix 监控 servlet\n        JbootHystrixConfig hystrixConfig = Jboot.config(JbootHystrixConfig.class);\n        if (StringUtils.isNotBlank(hystrixConfig.getUrl())) {\n            handler.addServlet(HystrixMetricsStreamServlet.class, hystrixConfig.getUrl());\n        }\n\n        增加 metric 监控\n        JbootMetricConfig metricsConfig = Jboot.config(JbootMetricConfig.class);\n        if (StringUtils.isNotBlank(metricsConfig.getUrl())) {\n            handler.addEventListener(new JbootMetricServletContextListener());\n            handler.addEventListener(new JbootHealthCheckServletContextListener());\n            handler.addServlet(AdminServlet.class, metricsConfig.getUrl());\n        }\n        最后增加 Jboot 本身的 servlet\n        io.jboot.server.Servlets jbootServlets = new io.jboot.server.Servlets();\n        ContextListeners listeners = new ContextListeners();\n        JbootAppListenerManager.me().onJbootDeploy(jbootServlets, listeners);\n        for (Map.Entry<String, io.jboot.server.Servlets.ServletInfo> entry : jbootServlets.getServlets().entrySet()) {\n            for (String path : entry.getValue().getUrlMapping()) {\n                handler.addServlet(entry.getValue().getServletClass(), path);\n            }\n        }\n        事件监听\n        for (Class<? extends ServletContextListener> listenerClass : listeners.getListeners()) {\n            handler.addEventListener(ClassKits.newInstance(listenerClass));\n        }\n\n        */\n        jettyServer.setHandler(handler);\n    }\n\n    private static String getRootClassPath() {\n        String path = null;\n        try {\n            path = JettyServer.class.getClassLoader().getResource(\"\").toURI().getPath();\n            return new File(path).getAbsolutePath();\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n        return path;\n    }\n\n    @Override\n    public boolean restart() {\n        stop();\n        start();\n        return true;\n    }\n\n    @Override\n    public boolean stop() {\n        try {\n            jettyServer.stop();\n            return true;\n        } catch (Exception ex) {\n            log.error(ex.toString(), ex);\n        }\n        return false;\n    }\n}\n```\n\n最后是自定义 ClassLoader，JbootServerClassLoader：  \n```java\npublic class JbootServerClassloader extends ClassLoader {\n\n    public JbootServerClassloader(ClassLoader parent) {\n        super(parent);\n    }\n\n\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n}\n```\n自定义 ClassLoader 在应用服务器中都会自定义，用于文件的隔离和热更新。  \n  \n目录结构如下：  \n![][1]\n\n# 3 启动到底启动了什么\n\n## 1. 参数解析\n\n类似 JVM options 的 -Dxxx=xxx 参数的作用，用于全局访问，Jboot 将启动参数使用 Jboot.setBootArg() 放在了一个 Map 中，你可以使用 Jboot.getBootArg() 获取。  \nJboot.java  \n```java\nprivate static void parseArgs(String[] args) {\n        if (args == null || args.length == 0) {\n            return;\n        }\n\n        for (String arg : args) {\n            int indexOf = arg.indexOf(\"=\");\n            if (arg.startsWith(\"--\") && indexOf > 0) {\n                String key = arg.substring(2, indexOf);\n                String value = arg.substring(indexOf + 1);\n                setBootArg(key, value);\n            }\n        }\n    }\n```\n\n## 2. 判断启动模式\n\n默认为 dev 模式，查看 JbootConfig.java 文件可知，但是我们可能为想，我们怎么才能设置启动模式呢？  \n  \n没错，使用启动参数！请看 JbootConfigManager 文件，该文件是用于读取配置文件，你可能会想，为什么配置文件都加了 `@PropertyConfig(prefix = \"\")` 这样的注解呢，其实，这是作者为了方便 JavaBean 与 参数 进行转换。直接上代码：  \n  \n第一种：启动参数，如下图：  \n![][2]  \n我们配置了两个参数（对照 JbootConfig 你就知道，只有 mode 有 set 方法，而 version 是只有 get 方法的）。  \n最后启动 debug 的时候你就会发现 Jboot.isDevMode() 方法返回 false 而不是默认的 true。 \n>有很多地方判断了，如果是 dev 模式，则会打印一些参数，例如 JbootEventManager 方法。\n\n第二种：使用 `Jboot.setBootArg(\"jboot.mode\", \"test\");` 这种，从前面的 **参数解析** 一节我们已经知道，其实启动参数底层使用的就是 setBootArg 方法。\n>测试类中很多使用了这种方法，例如 `DubboClientZookeeperDemo`。\n\n如果是 dev 模式，就会定时 3 秒扫描应用服务器文件夹，但是作者注释了，这里不懂作者的意思。  \nAutoDeployManager.java  \n```java\npublic void run() {\n\n        File file = new File(PathKit.getRootClassPath());\n        JbootFileScanner scanner = new JbootFileScanner(file.getAbsolutePath(), 3) {\n            @Override\n            public void onChange(String action, String file) {\n                try {\n//                    System.err.println(\"file changes : \" + file);\n//                    Jboot.me().getServer().restart();\n//                    JbootServerFactory.me().buildServer().start();\n//                    System.err.println(\"Loading complete.\");\n                } catch (Exception e) {\n                    System.err.println(\"Error reconfiguring/restarting webapp after change in watched files\");\n                    LogKit.error(e.getMessage(), e);\n                }\n            }\n        };\n\n        scanner.start();\n    }\n```\n\n## 3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法\n\n在 Jboot 启动的最后一步，实例化了 JbootAppListenerManager 类：\n```java\n private JbootAppListenerManager() {\n    // 扫描获取所有 JbootAppListener 的子类\n    List<Class<JbootAppListener>> allListeners = ClassScanner.scanSubClass(JbootAppListener.class, true);\n    if (allListeners == null || allListeners.size() == 0) {\n        return;\n    }\n    // 去除 JbootAppListenerManager 本身\n    for (Class<? extends JbootAppListener> clazz : allListeners) {\n        if (JbootAppListenerManager.class == clazz || JbootAppListenerBase.class == clazz) {\n            continue;\n        }\n        // 实例化\n        JbootAppListener listener = ClassKits.newInstance(clazz, false);\n        if (listener != null) {\n            listeners.add(listener);\n        }\n    }\n}\n\n@Override\npublic void onJbootStarted() {\n    for (JbootAppListener listener : listeners) {\n        try {\n            listener.onJbootStarted();\n        } catch (Throwable ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n}\n```\n\n并通过 `JbootAppListenerManager.me().onJbootStarted();` 回调了 `onJbootStarted()` 方法，来调用用户的逻辑。\n\n# 4 其它\n\n1. 从一些 Manager 方法看的出作者习惯通过构造方法进行一些必要的初始化，我以前看的 《架构探险——从零开始写Java Web框架》 则喜欢用静态块进行初始化。  \n2. 启动的一些细节需要大家去 debug 一步一步看，看懂了也是很高兴的，毕竟作者也是大牛，更近了一步。  \n3. 作者代码习惯方法名由于注释。说实话初看有点不习惯，因为习惯看注释了，但是作者方法名真的能让你可以不用注释（除却一些必要方法作者加了注释）。\n4. jbootfly 是入门，不要想直接看源码，欲速则不达。\n5. 你要懂 jfinal 的知识，至少看过 jfinal 文档，写过 jfinal 经典的 blog 项目。\n\n## 如果有错误，请指出，谢谢，共勉。\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_demo.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_args.png","slug":"tech/Jboot_2.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw30037axs6kp4txxw2","content":"<h1 id=\"0-启动流程\"><a href=\"#0-启动流程\" class=\"headerlink\" title=\"0 启动流程\"></a>0 启动流程</h1><ol>\n<li>解析启动参数，打印 logo。</li>\n<li>通过工厂对配置进行判断获取相应的应用服务器（默认 undertow）。</li>\n<li>判断是否是开发模式（默认），如果是则定期对文件进行扫描（3 * 1010）。</li>\n<li>回调各个 listener 的 onJbootStarted() 方法。</li>\n</ol>\n<h1 id=\"1-如何使用-main-文件启动一个应用服务器？\"><a href=\"#1-如何使用-main-文件启动一个应用服务器？\" class=\"headerlink\" title=\"1 如何使用 main 文件启动一个应用服务器？\"></a>1 如何使用 main 文件启动一个应用服务器？</h1><p>如果你会使用，可以直接跳过这节。</p>\n<p>pom.xml:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.eclipse.jetty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jetty-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>9.4.8.v20171121<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.eclipse.jetty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jetty-servlet<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>9.4.8.v20171121<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>SimpleServer.java:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"0.0.0.0\"</span>, <span class=\"number\">8081</span>);</span><br><span class=\"line\">        Server server = <span class=\"keyword\">new</span> Server(address);</span><br><span class=\"line\">        ResourceHandler handler = <span class=\"keyword\">new</span> ResourceHandler();</span><br><span class=\"line\">        handler.setDirectoriesListed(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        handler.setResourceBase(<span class=\"string\">\"/Users/liwenguang/Downloads\"</span>);</span><br><span class=\"line\">        server.setHandler(handler);</span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>参考资料：<a href=\"http://blog.csdn.net/kiterunner/article/details/51695293\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kiterunner/article/details/51695293</a></p>\n<h1 id=\"2-Jboot-启动精简版\"><a href=\"#2-Jboot-启动精简版\" class=\"headerlink\" title=\"2 Jboot 启动精简版\"></a>2 Jboot 启动精简版</h1><p>Jboot.java 主文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jboot</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JbootServer jbootServer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ensureServerCreated();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!startServer()) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"jboot start fail!!!\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureServerCreated</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jbootServer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            JbootServerFactory factory = JbootServerFactory.me();</span><br><span class=\"line\">            jbootServer = factory.buildServer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jbootServer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Jboot().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>JbootServer 抽象类，方便各种应用服务器的工厂创建，其中作者只编写了 undertow 和 jetty 的实现。（可知作者对 tomcat 不大喜欢）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">JbootServerFactory 工厂类：</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServerFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JbootServerFactory me = <span class=\"keyword\">new</span> JbootServerFactory();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JbootServerFactory <span class=\"title\">me</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> me;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JbootServer <span class=\"title\">buildServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// switch </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JettyServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着是应用服务器的配置文件， JbootServerConfig：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServerConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_UNDERTOW = <span class=\"string\">\"undertow\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_TOMCAT = <span class=\"string\">\"tomcat\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_JETTY = <span class=\"string\">\"jetty\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type = TYPE_UNDERTOW;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host = <span class=\"string\">\"0.0.0.0\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port = <span class=\"number\">8080</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String contextPath = <span class=\"string\">\"/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set/get 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后是实现的 Jetty 应用服务器， JettyServer：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JettyServer</span> <span class=\"keyword\">extends</span> <span class=\"title\">JbootServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Log log = Log.getLog(JettyServer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JbootServerConfig config;</span><br><span class=\"line\">    <span class=\"comment\">// private JbootWebConfig webConfig;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Server jettyServer;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServletContextHandler handler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JettyServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        config = <span class=\"keyword\">new</span> JbootServerConfig();</span><br><span class=\"line\">        <span class=\"comment\">// webConfig = Jboot.config(JbootWebConfig.class);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            initJettyServer();</span><br><span class=\"line\">            <span class=\"comment\">// JbootAppListenerManager.me().onAppStartBefore(this);</span></span><br><span class=\"line\">            jettyServer.start();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            log.error(ex.toString(), ex);</span><br><span class=\"line\">            stop();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initJettyServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(config.getHost(), config.getPort());</span><br><span class=\"line\">        jettyServer = <span class=\"keyword\">new</span> Server(address);</span><br><span class=\"line\"></span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ServletContextHandler();</span><br><span class=\"line\">        handler.setContextPath(config.getContextPath());</span><br><span class=\"line\">        handler.setClassLoader(<span class=\"keyword\">new</span> JbootServerClassloader(JettyServer.class.getClassLoader()));</span><br><span class=\"line\">        handler.setResourceBase(getRootClassPath());</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        增加 shiro 全局过滤器</span></span><br><span class=\"line\"><span class=\"comment\">        JbootShiroConfig shiroConfig = Jboot.config(JbootShiroConfig.class);</span></span><br><span class=\"line\"><span class=\"comment\">        if (shiroConfig.isConfigOK()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(new EnvironmentLoaderListener());</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addFilter(ShiroFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        增加 Jfinal Handler，Jboot 基于 Jfinal</span></span><br><span class=\"line\"><span class=\"comment\">        //JFinal</span></span><br><span class=\"line\"><span class=\"comment\">        FilterHolder jfinalFilter = handler.addFilter(JFinalFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));</span></span><br><span class=\"line\"><span class=\"comment\">        jfinalFilter.setInitParameter(\"configClass\", Jboot.me().getJbootConfig().getJfinalConfig());</span></span><br><span class=\"line\"><span class=\"comment\">        增加 Hystrix 监控 servlet</span></span><br><span class=\"line\"><span class=\"comment\">        JbootHystrixConfig hystrixConfig = Jboot.config(JbootHystrixConfig.class);</span></span><br><span class=\"line\"><span class=\"comment\">        if (StringUtils.isNotBlank(hystrixConfig.getUrl())) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addServlet(HystrixMetricsStreamServlet.class, hystrixConfig.getUrl());</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        增加 metric 监控</span></span><br><span class=\"line\"><span class=\"comment\">        JbootMetricConfig metricsConfig = Jboot.config(JbootMetricConfig.class);</span></span><br><span class=\"line\"><span class=\"comment\">        if (StringUtils.isNotBlank(metricsConfig.getUrl())) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(new JbootMetricServletContextListener());</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(new JbootHealthCheckServletContextListener());</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addServlet(AdminServlet.class, metricsConfig.getUrl());</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        最后增加 Jboot 本身的 servlet</span></span><br><span class=\"line\"><span class=\"comment\">        io.jboot.server.Servlets jbootServlets = new io.jboot.server.Servlets();</span></span><br><span class=\"line\"><span class=\"comment\">        ContextListeners listeners = new ContextListeners();</span></span><br><span class=\"line\"><span class=\"comment\">        JbootAppListenerManager.me().onJbootDeploy(jbootServlets, listeners);</span></span><br><span class=\"line\"><span class=\"comment\">        for (Map.Entry&lt;String, io.jboot.server.Servlets.ServletInfo&gt; entry : jbootServlets.getServlets().entrySet()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            for (String path : entry.getValue().getUrlMapping()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                handler.addServlet(entry.getValue().getServletClass(), path);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        事件监听</span></span><br><span class=\"line\"><span class=\"comment\">        for (Class&lt;? extends ServletContextListener&gt; listenerClass : listeners.getListeners()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(ClassKits.newInstance(listenerClass));</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        jettyServer.setHandler(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getRootClassPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String path = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            path = JettyServer.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>).toURI().getPath();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(path).getAbsolutePath();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (URISyntaxException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">restart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stop();</span><br><span class=\"line\">        start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            jettyServer.stop();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            log.error(ex.toString(), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后是自定义 ClassLoader，JbootServerClassLoader：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServerClassloader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JbootServerClassloader</span><span class=\"params\">(ClassLoader parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(parent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>自定义 ClassLoader 在应用服务器中都会自定义，用于文件的隔离和热更新。  </p>\n<p>目录结构如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_demo.png\" alt=\"\"></p>\n<h1 id=\"3-启动到底启动了什么\"><a href=\"#3-启动到底启动了什么\" class=\"headerlink\" title=\"3 启动到底启动了什么\"></a>3 启动到底启动了什么</h1><h2 id=\"1-参数解析\"><a href=\"#1-参数解析\" class=\"headerlink\" title=\"1. 参数解析\"></a>1. 参数解析</h2><p>类似 JVM options 的 -Dxxx=xxx 参数的作用，用于全局访问，Jboot 将启动参数使用 Jboot.setBootArg() 放在了一个 Map 中，你可以使用 Jboot.getBootArg() 获取。<br>Jboot.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">parseArgs</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args == <span class=\"keyword\">null</span> || args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String arg : args) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> indexOf = arg.indexOf(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arg.startsWith(<span class=\"string\">\"--\"</span>) &amp;&amp; indexOf &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                String key = arg.substring(<span class=\"number\">2</span>, indexOf);</span><br><span class=\"line\">                String value = arg.substring(indexOf + <span class=\"number\">1</span>);</span><br><span class=\"line\">                setBootArg(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-判断启动模式\"><a href=\"#2-判断启动模式\" class=\"headerlink\" title=\"2. 判断启动模式\"></a>2. 判断启动模式</h2><p>默认为 dev 模式，查看 JbootConfig.java 文件可知，但是我们可能为想，我们怎么才能设置启动模式呢？  </p>\n<p>没错，使用启动参数！请看 JbootConfigManager 文件，该文件是用于读取配置文件，你可能会想，为什么配置文件都加了 <code>@PropertyConfig(prefix = &quot;&quot;)</code> 这样的注解呢，其实，这是作者为了方便 JavaBean 与 参数 进行转换。直接上代码：  </p>\n<p>第一种：启动参数，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_args.png\" alt=\"\"><br>我们配置了两个参数（对照 JbootConfig 你就知道，只有 mode 有 set 方法，而 version 是只有 get 方法的）。<br>最后启动 debug 的时候你就会发现 Jboot.isDevMode() 方法返回 false 而不是默认的 true。 </p>\n<blockquote>\n<p>有很多地方判断了，如果是 dev 模式，则会打印一些参数，例如 JbootEventManager 方法。</p>\n</blockquote>\n<p>第二种：使用 <code>Jboot.setBootArg(&quot;jboot.mode&quot;, &quot;test&quot;);</code> 这种，从前面的 <strong>参数解析</strong> 一节我们已经知道，其实启动参数底层使用的就是 setBootArg 方法。</p>\n<blockquote>\n<p>测试类中很多使用了这种方法，例如 <code>DubboClientZookeeperDemo</code>。</p>\n</blockquote>\n<p>如果是 dev 模式，就会定时 3 秒扫描应用服务器文件夹，但是作者注释了，这里不懂作者的意思。<br>AutoDeployManager.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(PathKit.getRootClassPath());</span><br><span class=\"line\">        JbootFileScanner scanner = <span class=\"keyword\">new</span> JbootFileScanner(file.getAbsolutePath(), <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(String action, String file)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//                    System.err.println(\"file changes : \" + file);</span></span><br><span class=\"line\"><span class=\"comment\">//                    Jboot.me().getServer().restart();</span></span><br><span class=\"line\"><span class=\"comment\">//                    JbootServerFactory.me().buildServer().start();</span></span><br><span class=\"line\"><span class=\"comment\">//                    System.err.println(\"Loading complete.\");</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    System.err.println(<span class=\"string\">\"Error reconfiguring/restarting webapp after change in watched files\"</span>);</span><br><span class=\"line\">                    LogKit.error(e.getMessage(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        scanner.start();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-回调所有-JbootAppListener-实现类的-onJbootStarted-方法\"><a href=\"#3-回调所有-JbootAppListener-实现类的-onJbootStarted-方法\" class=\"headerlink\" title=\"3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法\"></a>3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法</h2><p>在 Jboot 启动的最后一步，实例化了 JbootAppListenerManager 类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">JbootAppListenerManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 扫描获取所有 JbootAppListener 的子类</span></span><br><span class=\"line\">    List&lt;Class&lt;JbootAppListener&gt;&gt; allListeners = ClassScanner.scanSubClass(JbootAppListener.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allListeners == <span class=\"keyword\">null</span> || allListeners.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 去除 JbootAppListenerManager 本身</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;? extends JbootAppListener&gt; clazz : allListeners) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (JbootAppListenerManager.class == clazz || JbootAppListenerBase.class == clazz) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化</span></span><br><span class=\"line\">        JbootAppListener listener = ClassKits.newInstance(clazz, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            listeners.add(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onJbootStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (JbootAppListener listener : listeners) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            listener.onJbootStarted();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            log.error(ex.toString(), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>并通过 <code>JbootAppListenerManager.me().onJbootStarted();</code> 回调了 <code>onJbootStarted()</code> 方法，来调用用户的逻辑。</p>\n<h1 id=\"4-其它\"><a href=\"#4-其它\" class=\"headerlink\" title=\"4 其它\"></a>4 其它</h1><ol>\n<li>从一些 Manager 方法看的出作者习惯通过构造方法进行一些必要的初始化，我以前看的 《架构探险——从零开始写Java Web框架》 则喜欢用静态块进行初始化。  </li>\n<li>启动的一些细节需要大家去 debug 一步一步看，看懂了也是很高兴的，毕竟作者也是大牛，更近了一步。  </li>\n<li>作者代码习惯方法名由于注释。说实话初看有点不习惯，因为习惯看注释了，但是作者方法名真的能让你可以不用注释（除却一些必要方法作者加了注释）。</li>\n<li>jbootfly 是入门，不要想直接看源码，欲速则不达。</li>\n<li>你要懂 jfinal 的知识，至少看过 jfinal 文档，写过 jfinal 经典的 blog 项目。</li>\n</ol>\n<h2 id=\"如果有错误，请指出，谢谢，共勉。\"><a href=\"#如果有错误，请指出，谢谢，共勉。\" class=\"headerlink\" title=\"如果有错误，请指出，谢谢，共勉。\"></a>如果有错误，请指出，谢谢，共勉。</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0-启动流程\"><a href=\"#0-启动流程\" class=\"headerlink\" title=\"0 启动流程\"></a>0 启动流程</h1><ol>\n<li>解析启动参数，打印 logo。</li>\n<li>通过工厂对配置进行判断获取相应的应用服务器（默认 undertow）。</li>\n<li>判断是否是开发模式（默认），如果是则定期对文件进行扫描（3 * 1010）。</li>\n<li>回调各个 listener 的 onJbootStarted() 方法。</li>\n</ol>\n<h1 id=\"1-如何使用-main-文件启动一个应用服务器？\"><a href=\"#1-如何使用-main-文件启动一个应用服务器？\" class=\"headerlink\" title=\"1 如何使用 main 文件启动一个应用服务器？\"></a>1 如何使用 main 文件启动一个应用服务器？</h1><p>如果你会使用，可以直接跳过这节。</p>\n<p>pom.xml:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.eclipse.jetty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jetty-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>9.4.8.v20171121<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.eclipse.jetty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jetty-servlet<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>9.4.8.v20171121<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>SimpleServer.java:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"0.0.0.0\"</span>, <span class=\"number\">8081</span>);</span><br><span class=\"line\">        Server server = <span class=\"keyword\">new</span> Server(address);</span><br><span class=\"line\">        ResourceHandler handler = <span class=\"keyword\">new</span> ResourceHandler();</span><br><span class=\"line\">        handler.setDirectoriesListed(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        handler.setResourceBase(<span class=\"string\">\"/Users/liwenguang/Downloads\"</span>);</span><br><span class=\"line\">        server.setHandler(handler);</span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>参考资料：<a href=\"http://blog.csdn.net/kiterunner/article/details/51695293\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kiterunner/article/details/51695293</a></p>\n<h1 id=\"2-Jboot-启动精简版\"><a href=\"#2-Jboot-启动精简版\" class=\"headerlink\" title=\"2 Jboot 启动精简版\"></a>2 Jboot 启动精简版</h1><p>Jboot.java 主文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jboot</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JbootServer jbootServer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ensureServerCreated();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!startServer()) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"jboot start fail!!!\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureServerCreated</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jbootServer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            JbootServerFactory factory = JbootServerFactory.me();</span><br><span class=\"line\">            jbootServer = factory.buildServer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jbootServer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Jboot().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>JbootServer 抽象类，方便各种应用服务器的工厂创建，其中作者只编写了 undertow 和 jetty 的实现。（可知作者对 tomcat 不大喜欢）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">JbootServerFactory 工厂类：</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServerFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JbootServerFactory me = <span class=\"keyword\">new</span> JbootServerFactory();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JbootServerFactory <span class=\"title\">me</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> me;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JbootServer <span class=\"title\">buildServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// switch </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JettyServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着是应用服务器的配置文件， JbootServerConfig：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServerConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_UNDERTOW = <span class=\"string\">\"undertow\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_TOMCAT = <span class=\"string\">\"tomcat\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TYPE_JETTY = <span class=\"string\">\"jetty\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type = TYPE_UNDERTOW;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host = <span class=\"string\">\"0.0.0.0\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port = <span class=\"number\">8080</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String contextPath = <span class=\"string\">\"/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set/get 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后是实现的 Jetty 应用服务器， JettyServer：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JettyServer</span> <span class=\"keyword\">extends</span> <span class=\"title\">JbootServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Log log = Log.getLog(JettyServer.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JbootServerConfig config;</span><br><span class=\"line\">    <span class=\"comment\">// private JbootWebConfig webConfig;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Server jettyServer;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServletContextHandler handler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JettyServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        config = <span class=\"keyword\">new</span> JbootServerConfig();</span><br><span class=\"line\">        <span class=\"comment\">// webConfig = Jboot.config(JbootWebConfig.class);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            initJettyServer();</span><br><span class=\"line\">            <span class=\"comment\">// JbootAppListenerManager.me().onAppStartBefore(this);</span></span><br><span class=\"line\">            jettyServer.start();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            log.error(ex.toString(), ex);</span><br><span class=\"line\">            stop();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initJettyServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(config.getHost(), config.getPort());</span><br><span class=\"line\">        jettyServer = <span class=\"keyword\">new</span> Server(address);</span><br><span class=\"line\"></span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ServletContextHandler();</span><br><span class=\"line\">        handler.setContextPath(config.getContextPath());</span><br><span class=\"line\">        handler.setClassLoader(<span class=\"keyword\">new</span> JbootServerClassloader(JettyServer.class.getClassLoader()));</span><br><span class=\"line\">        handler.setResourceBase(getRootClassPath());</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        增加 shiro 全局过滤器</span></span><br><span class=\"line\"><span class=\"comment\">        JbootShiroConfig shiroConfig = Jboot.config(JbootShiroConfig.class);</span></span><br><span class=\"line\"><span class=\"comment\">        if (shiroConfig.isConfigOK()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(new EnvironmentLoaderListener());</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addFilter(ShiroFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        增加 Jfinal Handler，Jboot 基于 Jfinal</span></span><br><span class=\"line\"><span class=\"comment\">        //JFinal</span></span><br><span class=\"line\"><span class=\"comment\">        FilterHolder jfinalFilter = handler.addFilter(JFinalFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST));</span></span><br><span class=\"line\"><span class=\"comment\">        jfinalFilter.setInitParameter(\"configClass\", Jboot.me().getJbootConfig().getJfinalConfig());</span></span><br><span class=\"line\"><span class=\"comment\">        增加 Hystrix 监控 servlet</span></span><br><span class=\"line\"><span class=\"comment\">        JbootHystrixConfig hystrixConfig = Jboot.config(JbootHystrixConfig.class);</span></span><br><span class=\"line\"><span class=\"comment\">        if (StringUtils.isNotBlank(hystrixConfig.getUrl())) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addServlet(HystrixMetricsStreamServlet.class, hystrixConfig.getUrl());</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        增加 metric 监控</span></span><br><span class=\"line\"><span class=\"comment\">        JbootMetricConfig metricsConfig = Jboot.config(JbootMetricConfig.class);</span></span><br><span class=\"line\"><span class=\"comment\">        if (StringUtils.isNotBlank(metricsConfig.getUrl())) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(new JbootMetricServletContextListener());</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(new JbootHealthCheckServletContextListener());</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addServlet(AdminServlet.class, metricsConfig.getUrl());</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        最后增加 Jboot 本身的 servlet</span></span><br><span class=\"line\"><span class=\"comment\">        io.jboot.server.Servlets jbootServlets = new io.jboot.server.Servlets();</span></span><br><span class=\"line\"><span class=\"comment\">        ContextListeners listeners = new ContextListeners();</span></span><br><span class=\"line\"><span class=\"comment\">        JbootAppListenerManager.me().onJbootDeploy(jbootServlets, listeners);</span></span><br><span class=\"line\"><span class=\"comment\">        for (Map.Entry&lt;String, io.jboot.server.Servlets.ServletInfo&gt; entry : jbootServlets.getServlets().entrySet()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            for (String path : entry.getValue().getUrlMapping()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                handler.addServlet(entry.getValue().getServletClass(), path);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        事件监听</span></span><br><span class=\"line\"><span class=\"comment\">        for (Class&lt;? extends ServletContextListener&gt; listenerClass : listeners.getListeners()) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            handler.addEventListener(ClassKits.newInstance(listenerClass));</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        jettyServer.setHandler(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getRootClassPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String path = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            path = JettyServer.class.getClassLoader().getResource(<span class=\"string\">\"\"</span>).toURI().getPath();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(path).getAbsolutePath();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (URISyntaxException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">restart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stop();</span><br><span class=\"line\">        start();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            jettyServer.stop();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            log.error(ex.toString(), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后是自定义 ClassLoader，JbootServerClassLoader：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JbootServerClassloader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JbootServerClassloader</span><span class=\"params\">(ClassLoader parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(parent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>自定义 ClassLoader 在应用服务器中都会自定义，用于文件的隔离和热更新。  </p>\n<p>目录结构如下：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_demo.png\" alt=\"\"></p>\n<h1 id=\"3-启动到底启动了什么\"><a href=\"#3-启动到底启动了什么\" class=\"headerlink\" title=\"3 启动到底启动了什么\"></a>3 启动到底启动了什么</h1><h2 id=\"1-参数解析\"><a href=\"#1-参数解析\" class=\"headerlink\" title=\"1. 参数解析\"></a>1. 参数解析</h2><p>类似 JVM options 的 -Dxxx=xxx 参数的作用，用于全局访问，Jboot 将启动参数使用 Jboot.setBootArg() 放在了一个 Map 中，你可以使用 Jboot.getBootArg() 获取。<br>Jboot.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">parseArgs</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args == <span class=\"keyword\">null</span> || args.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String arg : args) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> indexOf = arg.indexOf(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arg.startsWith(<span class=\"string\">\"--\"</span>) &amp;&amp; indexOf &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                String key = arg.substring(<span class=\"number\">2</span>, indexOf);</span><br><span class=\"line\">                String value = arg.substring(indexOf + <span class=\"number\">1</span>);</span><br><span class=\"line\">                setBootArg(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-判断启动模式\"><a href=\"#2-判断启动模式\" class=\"headerlink\" title=\"2. 判断启动模式\"></a>2. 判断启动模式</h2><p>默认为 dev 模式，查看 JbootConfig.java 文件可知，但是我们可能为想，我们怎么才能设置启动模式呢？  </p>\n<p>没错，使用启动参数！请看 JbootConfigManager 文件，该文件是用于读取配置文件，你可能会想，为什么配置文件都加了 <code>@PropertyConfig(prefix = &quot;&quot;)</code> 这样的注解呢，其实，这是作者为了方便 JavaBean 与 参数 进行转换。直接上代码：  </p>\n<p>第一种：启动参数，如下图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_args.png\" alt=\"\"><br>我们配置了两个参数（对照 JbootConfig 你就知道，只有 mode 有 set 方法，而 version 是只有 get 方法的）。<br>最后启动 debug 的时候你就会发现 Jboot.isDevMode() 方法返回 false 而不是默认的 true。 </p>\n<blockquote>\n<p>有很多地方判断了，如果是 dev 模式，则会打印一些参数，例如 JbootEventManager 方法。</p>\n</blockquote>\n<p>第二种：使用 <code>Jboot.setBootArg(&quot;jboot.mode&quot;, &quot;test&quot;);</code> 这种，从前面的 <strong>参数解析</strong> 一节我们已经知道，其实启动参数底层使用的就是 setBootArg 方法。</p>\n<blockquote>\n<p>测试类中很多使用了这种方法，例如 <code>DubboClientZookeeperDemo</code>。</p>\n</blockquote>\n<p>如果是 dev 模式，就会定时 3 秒扫描应用服务器文件夹，但是作者注释了，这里不懂作者的意思。<br>AutoDeployManager.java<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(PathKit.getRootClassPath());</span><br><span class=\"line\">        JbootFileScanner scanner = <span class=\"keyword\">new</span> JbootFileScanner(file.getAbsolutePath(), <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(String action, String file)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//                    System.err.println(\"file changes : \" + file);</span></span><br><span class=\"line\"><span class=\"comment\">//                    Jboot.me().getServer().restart();</span></span><br><span class=\"line\"><span class=\"comment\">//                    JbootServerFactory.me().buildServer().start();</span></span><br><span class=\"line\"><span class=\"comment\">//                    System.err.println(\"Loading complete.\");</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    System.err.println(<span class=\"string\">\"Error reconfiguring/restarting webapp after change in watched files\"</span>);</span><br><span class=\"line\">                    LogKit.error(e.getMessage(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        scanner.start();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-回调所有-JbootAppListener-实现类的-onJbootStarted-方法\"><a href=\"#3-回调所有-JbootAppListener-实现类的-onJbootStarted-方法\" class=\"headerlink\" title=\"3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法\"></a>3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法</h2><p>在 Jboot 启动的最后一步，实例化了 JbootAppListenerManager 类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">JbootAppListenerManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 扫描获取所有 JbootAppListener 的子类</span></span><br><span class=\"line\">    List&lt;Class&lt;JbootAppListener&gt;&gt; allListeners = ClassScanner.scanSubClass(JbootAppListener.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allListeners == <span class=\"keyword\">null</span> || allListeners.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 去除 JbootAppListenerManager 本身</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;? extends JbootAppListener&gt; clazz : allListeners) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (JbootAppListenerManager.class == clazz || JbootAppListenerBase.class == clazz) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化</span></span><br><span class=\"line\">        JbootAppListener listener = ClassKits.newInstance(clazz, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            listeners.add(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onJbootStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (JbootAppListener listener : listeners) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            listener.onJbootStarted();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            log.error(ex.toString(), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>并通过 <code>JbootAppListenerManager.me().onJbootStarted();</code> 回调了 <code>onJbootStarted()</code> 方法，来调用用户的逻辑。</p>\n<h1 id=\"4-其它\"><a href=\"#4-其它\" class=\"headerlink\" title=\"4 其它\"></a>4 其它</h1><ol>\n<li>从一些 Manager 方法看的出作者习惯通过构造方法进行一些必要的初始化，我以前看的 《架构探险——从零开始写Java Web框架》 则喜欢用静态块进行初始化。  </li>\n<li>启动的一些细节需要大家去 debug 一步一步看，看懂了也是很高兴的，毕竟作者也是大牛，更近了一步。  </li>\n<li>作者代码习惯方法名由于注释。说实话初看有点不习惯，因为习惯看注释了，但是作者方法名真的能让你可以不用注释（除却一些必要方法作者加了注释）。</li>\n<li>jbootfly 是入门，不要想直接看源码，欲速则不达。</li>\n<li>你要懂 jfinal 的知识，至少看过 jfinal 文档，写过 jfinal 经典的 blog 项目。</li>\n</ol>\n<h2 id=\"如果有错误，请指出，谢谢，共勉。\"><a href=\"#如果有错误，请指出，谢谢，共勉。\" class=\"headerlink\" title=\"如果有错误，请指出，谢谢，共勉。\"></a>如果有错误，请指出，谢谢，共勉。</h2>"},{"title":"ZK分布式锁","date":"2018-06-15T15:00:00.000Z","updated":"2018-06-18T13:43:00.000Z","comments":1,"_content":"\n# 0 \b前言\n\n\b关于 ZooKeeper实现分布式锁，笔者在武汉小米一面（结果挂了）被问到过，因此记录如下。  \n  \n以下的理论知识源自`《 从Paxos到Zookeeper分布式一致性原理与实践 》`第六章，代码\b完全根据书本理论进行实现，并且经多线程测试，在正常情况可行。  \n  \n源码：https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project\n\n# 1 ZooKeeper实现排他锁\n\n## 1.1 原理\n  \n核心点：  \n1. `抢占式创建相同名称的临时节点`，谁成功创建节点，则代表谁获得了锁。\n2. 没有创建成功该节点，并且该节点存在，则对该名称的节点进行删除监听。\n3. 如果该节点被删除了，则继续重复第 1步。\n\n## 1.2 流程图\n\n原书流程图：  \n![][1_0]  \n我自己理解的流程：  \n![][1_1]\n\n## 1.3 代码实现\n\n统一接口：\n```java\n/**\n * @Author liwenguang\n * @Date 2018/6/15 下午9:16\n * @Description\n */\npublic interface DistributedLock {\n\n    /**\n     * @Author liwenguang\n     * @Date 2018/6/15 下午9:17\n     * @Description 获取锁，默认等待时间\n     */\n    default void tryRead() throws ZkException { throw new RuntimeException(\"子类不支持\"); }\n\n    /**\n     * @Author liwenguang\n     * @Date 2018/6/15 下午9:18\n     * @Description 获取锁，指定超时时间\n     */\n    default void tryRead(long time, TimeUnit unit) { throw new RuntimeException(\"子类不支持\"); }\n\n    void tryWrite() throws ZkException;\n\n    default void tryWrite(long time, TimeUnit unit) { throw new RuntimeException(\"子类不支持\"); }\n\n    /**\n     * @Author liwenguang\n     * @Date 2018/6/15 下午9:18\n     * @Description 释放锁\n     */\n    void release() throws ZkException;\n\n}\n```\n  \n核心代码：  \n```java\nprivate void tryGetLock() {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    while (true) {\n        try {\n            zkClient.createEphemeral(EXCLUSIVE_LOCK_NAMESPACE + lockPath);\n            log.info(Thread.currentThread().getName() + \"获取锁成功\");\n            break;\n        } catch (ZkNodeExistsException e) {\n            // log.warn(Thread.currentThread().getName() + \"获取锁失败\");\n            if (zkClient.exists(EXCLUSIVE_LOCK_NAMESPACE + lockPath)) {\n                MyIZkDataListener myIZkChildListener = new MyIZkDataListener(countDownLatch);\n                zkClient.subscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, myIZkChildListener);\n            } else {\n                countDownLatch.countDown();\n            }\n        }\n        try {\n            // 这里需要阻塞式通知，因此使用 countDownLatch实现\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    log.info(\"获取到了锁\");\n}\n\nclass MyIZkDataListener implements IZkDataListener {\n\n    private CountDownLatch countDownLatch;\n\n\n    public MyIZkDataListener(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void handleDataChange(String dataPath, Object data) throws Exception { }\n\n    @Override\n    public void handleDataDeleted(String dataPath) throws Exception {\n        //log.info(Thread.currentThread().getName() + \"被回调了\");\n        zkClient.unsubscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, this);\n        countDownLatch.countDown();\n    }\n}\n```\n\n# 2 ZooKeeper共享锁\n\n## 2.1 原理\n  \n核心点：  \n1. 无论是读请求（读锁）还是写请求（写锁）都进行创建`顺序`临时节点，只看后缀的数字我们可以理解为\b一种从小到大的队列（例：我们在做订单请求的时候，对订单A做创建->\u001c\b\b支付->\b完成三个操作，对应 ZK节点则节点A下有三个子节点，这时候节点A可以理解为一个队列）。\n![][2_3]\n2. 创建完成之后，对读锁，则判断该队列之前是否有写锁，如果有写锁，则对写锁做删除监听。对写锁，判断队列之前是否有锁，如果有锁，则对序号最大的锁做删除监听。\n3. 删除监听触发，获取该锁节点下所有的子节点（一个节点即代表锁），重复第 2步。\n\n## 2.2 流程图\n\n原书流程图：  \n![][2_0]  \n我自己理解的流程：  \n![][2_1]\n\n## 2.3 代码实现\n\n核心代码：  \n```java\n@Override\npublic void tryRead() throws ZkException {\n    if (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) {\n        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);\n    }\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + \"/\" + SHARED_READ_PRE, null);\n    String curSequence = curNode.split(SHARED_READ_PRE)[1];\n    log.info(curSequence + \"创建读锁-R\");\n    while (true) {\n        List<String> children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);\n        // 记录序号比自己小的写请求\n        List<String> writers = new ArrayList<>();\n        for (String brother : children) {\n            if (brother.startsWith(SHARED_WRITE_PRE)) {\n                String sequence = brother.split(SHARED_WRITE_PRE)[1];\n                if (curSequence.compareTo(sequence) > 0) {\n                    writers.add(brother);\n                }\n            }\n        }\n        if (writers.isEmpty()) {\n            // 没有比自己序号小的写请求，说明自己获取到了读锁\n            //log.info(Thread.currentThread().getName() + \"没有比自己序号小的写请求-R\");\n            break;\n        } else {\n            // 获取最近的那个写锁\n            String lastWriter = SHARED_LOCK_NAMESPACE + lockPath + \"/\" + writers.get(writers.size() - 1);\n            // 判断最近的那个写锁期间是否已经释放了\n            if (zkClient.exists(lastWriter)) {\n                MyReadIZkChildListener myReadIZkChildListener = new MyReadIZkChildListener(lastWriter, countDownLatch);\n                zkClient.subscribeDataChanges(lastWriter, myReadIZkChildListener);\n            } else {\n                countDownLatch.countDown();\n            }\n        }\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    log.info(\"获取到了锁-R\");\n}\n\nclass MyReadIZkChildListener implements IZkDataListener {\n\n    private String lastWriter;\n    private CountDownLatch countDownLatch;\n\n    public MyReadIZkChildListener(String lastWriter, CountDownLatch countDownLatch) {\n        this.lastWriter = lastWriter;\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void handleDataChange(String dataPath, Object data) throws Exception { }\n\n    @Override\n    public void handleDataDeleted(String dataPath) throws Exception {\n        //log.info(Thread.currentThread().getName() + \"比自己序号小的那个写请求被释放了-R\");\n        zkClient.unsubscribeDataChanges(lastWriter, this);\n        // 最近的那个写锁被释放了，但是不排除释放过程中，有其它写锁新加入，因此读锁需要重新获取列表\n        countDownLatch.countDown();\n    }\n}\n\n@Override\npublic void tryWrite() throws ZkException {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    if (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) {\n        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);\n    }\n    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + \"/\" + SHARED_WRITE_PRE, null);\n    String curSequence = curNode.split(SHARED_WRITE_PRE)[1];\n    log.info(curSequence + \"创建写锁-W\");\n    while (true) {\n        List<String> children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);\n        // 记录序号比自己小的请求\n        List<String> writersOrReader = new ArrayList<>();\n        for (String brother : children) {\n            if (brother.equals(SHARED_WRITE_PRE + curSequence)) {\n                // 排除自己\n                continue;\n            }\n            String sequence = \"\";\n            if (brother.contains(SHARED_WRITE_PRE)) {\n                sequence = brother.split(SHARED_WRITE_PRE)[1];\n            } else if (brother.contains(SHARED_READ_PRE)) {\n                sequence = brother.split(SHARED_READ_PRE)[1];\n            } else {\n                // 异常名称节点的处理\n            }\n            if (curSequence.compareTo(sequence) > 0) {\n                writersOrReader.add(brother);\n            }\n        }\n        if (writersOrReader.isEmpty()) {\n            // 没有比自己序号小的请求，说明自己获取到了读锁\n            //log.info(Thread.currentThread().getName() + \"没有比自己序号小的请求-W\");\n            break;\n        } else {\n            // 获取最近的那个锁\n            String lastWriterOrReader = SHARED_LOCK_NAMESPACE + lockPath + \"/\" + writersOrReader.get(writersOrReader.size() - 1);\n            // 判断最近的那个锁期间是否已经释放了\n            if (zkClient.exists(lastWriterOrReader)) {\n                MyWriteIZkChildListener myWriteIZkChildListener = new MyWriteIZkChildListener(lastWriterOrReader, countDownLatch);\n                zkClient.subscribeDataChanges(lastWriterOrReader, myWriteIZkChildListener);\n            } else {\n                countDownLatch.countDown();\n            }\n        }\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    log.info(\"获取到了锁-W\");\n}\n\nclass MyWriteIZkChildListener implements IZkDataListener {\n\n    private String lastWriterOrReader;\n    private CountDownLatch countDownLatch;\n\n    public MyWriteIZkChildListener(String lastWriterOrReader, CountDownLatch countDownLatch) {\n        this.lastWriterOrReader = lastWriterOrReader;\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void handleDataChange(String dataPath, Object data) throws Exception {\n    }\n\n    @Override\n    public void handleDataDeleted(String dataPath) throws Exception {\n        //log.info(Thread.currentThread().getName() + \"比自己序号小的那个请求被释放了，循环-W\");\n        zkClient.unsubscribeDataChanges(lastWriterOrReader, this);\n        countDownLatch.countDown();\n    }\n}\n```\n\n# 3. 待续\n\nreadlock\n\n[1_0]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png\n[1_1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_1.png\n[2_0]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png\n[2_1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_2.png\n[2_3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_shared_lock_1.png","source":"_posts/技术小结/ZK分布式锁.md","raw":"---\ntitle: ZK分布式锁\ndate: 2018-06-15 23:00:00\nupdated: 2018-06-18 21:43:00\ncomments: true\ncategories: \n- 小结\npermalink: tech/zk_distribute_lock.html    \n---\n\n# 0 \b前言\n\n\b关于 ZooKeeper实现分布式锁，笔者在武汉小米一面（结果挂了）被问到过，因此记录如下。  \n  \n以下的理论知识源自`《 从Paxos到Zookeeper分布式一致性原理与实践 》`第六章，代码\b完全根据书本理论进行实现，并且经多线程测试，在正常情况可行。  \n  \n源码：https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project\n\n# 1 ZooKeeper实现排他锁\n\n## 1.1 原理\n  \n核心点：  \n1. `抢占式创建相同名称的临时节点`，谁成功创建节点，则代表谁获得了锁。\n2. 没有创建成功该节点，并且该节点存在，则对该名称的节点进行删除监听。\n3. 如果该节点被删除了，则继续重复第 1步。\n\n## 1.2 流程图\n\n原书流程图：  \n![][1_0]  \n我自己理解的流程：  \n![][1_1]\n\n## 1.3 代码实现\n\n统一接口：\n```java\n/**\n * @Author liwenguang\n * @Date 2018/6/15 下午9:16\n * @Description\n */\npublic interface DistributedLock {\n\n    /**\n     * @Author liwenguang\n     * @Date 2018/6/15 下午9:17\n     * @Description 获取锁，默认等待时间\n     */\n    default void tryRead() throws ZkException { throw new RuntimeException(\"子类不支持\"); }\n\n    /**\n     * @Author liwenguang\n     * @Date 2018/6/15 下午9:18\n     * @Description 获取锁，指定超时时间\n     */\n    default void tryRead(long time, TimeUnit unit) { throw new RuntimeException(\"子类不支持\"); }\n\n    void tryWrite() throws ZkException;\n\n    default void tryWrite(long time, TimeUnit unit) { throw new RuntimeException(\"子类不支持\"); }\n\n    /**\n     * @Author liwenguang\n     * @Date 2018/6/15 下午9:18\n     * @Description 释放锁\n     */\n    void release() throws ZkException;\n\n}\n```\n  \n核心代码：  \n```java\nprivate void tryGetLock() {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    while (true) {\n        try {\n            zkClient.createEphemeral(EXCLUSIVE_LOCK_NAMESPACE + lockPath);\n            log.info(Thread.currentThread().getName() + \"获取锁成功\");\n            break;\n        } catch (ZkNodeExistsException e) {\n            // log.warn(Thread.currentThread().getName() + \"获取锁失败\");\n            if (zkClient.exists(EXCLUSIVE_LOCK_NAMESPACE + lockPath)) {\n                MyIZkDataListener myIZkChildListener = new MyIZkDataListener(countDownLatch);\n                zkClient.subscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, myIZkChildListener);\n            } else {\n                countDownLatch.countDown();\n            }\n        }\n        try {\n            // 这里需要阻塞式通知，因此使用 countDownLatch实现\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    log.info(\"获取到了锁\");\n}\n\nclass MyIZkDataListener implements IZkDataListener {\n\n    private CountDownLatch countDownLatch;\n\n\n    public MyIZkDataListener(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void handleDataChange(String dataPath, Object data) throws Exception { }\n\n    @Override\n    public void handleDataDeleted(String dataPath) throws Exception {\n        //log.info(Thread.currentThread().getName() + \"被回调了\");\n        zkClient.unsubscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, this);\n        countDownLatch.countDown();\n    }\n}\n```\n\n# 2 ZooKeeper共享锁\n\n## 2.1 原理\n  \n核心点：  \n1. 无论是读请求（读锁）还是写请求（写锁）都进行创建`顺序`临时节点，只看后缀的数字我们可以理解为\b一种从小到大的队列（例：我们在做订单请求的时候，对订单A做创建->\u001c\b\b支付->\b完成三个操作，对应 ZK节点则节点A下有三个子节点，这时候节点A可以理解为一个队列）。\n![][2_3]\n2. 创建完成之后，对读锁，则判断该队列之前是否有写锁，如果有写锁，则对写锁做删除监听。对写锁，判断队列之前是否有锁，如果有锁，则对序号最大的锁做删除监听。\n3. 删除监听触发，获取该锁节点下所有的子节点（一个节点即代表锁），重复第 2步。\n\n## 2.2 流程图\n\n原书流程图：  \n![][2_0]  \n我自己理解的流程：  \n![][2_1]\n\n## 2.3 代码实现\n\n核心代码：  \n```java\n@Override\npublic void tryRead() throws ZkException {\n    if (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) {\n        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);\n    }\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + \"/\" + SHARED_READ_PRE, null);\n    String curSequence = curNode.split(SHARED_READ_PRE)[1];\n    log.info(curSequence + \"创建读锁-R\");\n    while (true) {\n        List<String> children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);\n        // 记录序号比自己小的写请求\n        List<String> writers = new ArrayList<>();\n        for (String brother : children) {\n            if (brother.startsWith(SHARED_WRITE_PRE)) {\n                String sequence = brother.split(SHARED_WRITE_PRE)[1];\n                if (curSequence.compareTo(sequence) > 0) {\n                    writers.add(brother);\n                }\n            }\n        }\n        if (writers.isEmpty()) {\n            // 没有比自己序号小的写请求，说明自己获取到了读锁\n            //log.info(Thread.currentThread().getName() + \"没有比自己序号小的写请求-R\");\n            break;\n        } else {\n            // 获取最近的那个写锁\n            String lastWriter = SHARED_LOCK_NAMESPACE + lockPath + \"/\" + writers.get(writers.size() - 1);\n            // 判断最近的那个写锁期间是否已经释放了\n            if (zkClient.exists(lastWriter)) {\n                MyReadIZkChildListener myReadIZkChildListener = new MyReadIZkChildListener(lastWriter, countDownLatch);\n                zkClient.subscribeDataChanges(lastWriter, myReadIZkChildListener);\n            } else {\n                countDownLatch.countDown();\n            }\n        }\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    log.info(\"获取到了锁-R\");\n}\n\nclass MyReadIZkChildListener implements IZkDataListener {\n\n    private String lastWriter;\n    private CountDownLatch countDownLatch;\n\n    public MyReadIZkChildListener(String lastWriter, CountDownLatch countDownLatch) {\n        this.lastWriter = lastWriter;\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void handleDataChange(String dataPath, Object data) throws Exception { }\n\n    @Override\n    public void handleDataDeleted(String dataPath) throws Exception {\n        //log.info(Thread.currentThread().getName() + \"比自己序号小的那个写请求被释放了-R\");\n        zkClient.unsubscribeDataChanges(lastWriter, this);\n        // 最近的那个写锁被释放了，但是不排除释放过程中，有其它写锁新加入，因此读锁需要重新获取列表\n        countDownLatch.countDown();\n    }\n}\n\n@Override\npublic void tryWrite() throws ZkException {\n    CountDownLatch countDownLatch = new CountDownLatch(1);\n    if (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) {\n        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);\n    }\n    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + \"/\" + SHARED_WRITE_PRE, null);\n    String curSequence = curNode.split(SHARED_WRITE_PRE)[1];\n    log.info(curSequence + \"创建写锁-W\");\n    while (true) {\n        List<String> children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);\n        // 记录序号比自己小的请求\n        List<String> writersOrReader = new ArrayList<>();\n        for (String brother : children) {\n            if (brother.equals(SHARED_WRITE_PRE + curSequence)) {\n                // 排除自己\n                continue;\n            }\n            String sequence = \"\";\n            if (brother.contains(SHARED_WRITE_PRE)) {\n                sequence = brother.split(SHARED_WRITE_PRE)[1];\n            } else if (brother.contains(SHARED_READ_PRE)) {\n                sequence = brother.split(SHARED_READ_PRE)[1];\n            } else {\n                // 异常名称节点的处理\n            }\n            if (curSequence.compareTo(sequence) > 0) {\n                writersOrReader.add(brother);\n            }\n        }\n        if (writersOrReader.isEmpty()) {\n            // 没有比自己序号小的请求，说明自己获取到了读锁\n            //log.info(Thread.currentThread().getName() + \"没有比自己序号小的请求-W\");\n            break;\n        } else {\n            // 获取最近的那个锁\n            String lastWriterOrReader = SHARED_LOCK_NAMESPACE + lockPath + \"/\" + writersOrReader.get(writersOrReader.size() - 1);\n            // 判断最近的那个锁期间是否已经释放了\n            if (zkClient.exists(lastWriterOrReader)) {\n                MyWriteIZkChildListener myWriteIZkChildListener = new MyWriteIZkChildListener(lastWriterOrReader, countDownLatch);\n                zkClient.subscribeDataChanges(lastWriterOrReader, myWriteIZkChildListener);\n            } else {\n                countDownLatch.countDown();\n            }\n        }\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    log.info(\"获取到了锁-W\");\n}\n\nclass MyWriteIZkChildListener implements IZkDataListener {\n\n    private String lastWriterOrReader;\n    private CountDownLatch countDownLatch;\n\n    public MyWriteIZkChildListener(String lastWriterOrReader, CountDownLatch countDownLatch) {\n        this.lastWriterOrReader = lastWriterOrReader;\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void handleDataChange(String dataPath, Object data) throws Exception {\n    }\n\n    @Override\n    public void handleDataDeleted(String dataPath) throws Exception {\n        //log.info(Thread.currentThread().getName() + \"比自己序号小的那个请求被释放了，循环-W\");\n        zkClient.unsubscribeDataChanges(lastWriterOrReader, this);\n        countDownLatch.countDown();\n    }\n}\n```\n\n# 3. 待续\n\nreadlock\n\n[1_0]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png\n[1_1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_1.png\n[2_0]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png\n[2_1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_2.png\n[2_3]:http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_shared_lock_1.png","slug":"tech/zk_distribute_lock.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw4003aaxs6atb2gnbe","content":"<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 \b前言\"></a>0 \b前言</h1><p>\b关于 ZooKeeper实现分布式锁，笔者在武汉小米一面（结果挂了）被问到过，因此记录如下。  </p>\n<p>以下的理论知识源自<code>《 从Paxos到Zookeeper分布式一致性原理与实践 》</code>第六章，代码\b完全根据书本理论进行实现，并且经多线程测试，在正常情况可行。  </p>\n<p>源码：<a href=\"https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project\" target=\"_blank\" rel=\"noopener\">https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project</a></p>\n<h1 id=\"1-ZooKeeper实现排他锁\"><a href=\"#1-ZooKeeper实现排他锁\" class=\"headerlink\" title=\"1 ZooKeeper实现排他锁\"></a>1 ZooKeeper实现排他锁</h1><h2 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1 原理\"></a>1.1 原理</h2><p>核心点：  </p>\n<ol>\n<li><code>抢占式创建相同名称的临时节点</code>，谁成功创建节点，则代表谁获得了锁。</li>\n<li>没有创建成功该节点，并且该节点存在，则对该名称的节点进行删除监听。</li>\n<li>如果该节点被删除了，则继续重复第 1步。</li>\n</ol>\n<h2 id=\"1-2-流程图\"><a href=\"#1-2-流程图\" class=\"headerlink\" title=\"1.2 流程图\"></a>1.2 流程图</h2><p>原书流程图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png\" alt=\"\"><br>我自己理解的流程：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_1.png\" alt=\"\"></p>\n<h2 id=\"1-3-代码实现\"><a href=\"#1-3-代码实现\" class=\"headerlink\" title=\"1.3 代码实现\"></a>1.3 代码实现</h2><p>统一接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:16</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DistributedLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:17</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 获取锁，默认等待时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException </span>&#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"子类不支持\"</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:18</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 获取锁，指定超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRead</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> </span>&#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"子类不支持\"</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tryWrite</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">tryWrite</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> </span>&#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"子类不支持\"</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:18</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 释放锁</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tryGetLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zkClient.createEphemeral(EXCLUSIVE_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">            log.info(Thread.currentThread().getName() + <span class=\"string\">\"获取锁成功\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// log.warn(Thread.currentThread().getName() + \"获取锁失败\");</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zkClient.exists(EXCLUSIVE_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class=\"line\">                MyIZkDataListener myIZkChildListener = <span class=\"keyword\">new</span> MyIZkDataListener(countDownLatch);</span><br><span class=\"line\">                zkClient.subscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, myIZkChildListener);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要阻塞式通知，因此使用 countDownLatch实现</span></span><br><span class=\"line\">            countDownLatch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到了锁\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyIZkDataListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">IZkDataListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyIZkDataListener</span><span class=\"params\">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String dataPath, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String dataPath)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"被回调了\");</span></span><br><span class=\"line\">        zkClient.unsubscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-ZooKeeper共享锁\"><a href=\"#2-ZooKeeper共享锁\" class=\"headerlink\" title=\"2 ZooKeeper共享锁\"></a>2 ZooKeeper共享锁</h1><h2 id=\"2-1-原理\"><a href=\"#2-1-原理\" class=\"headerlink\" title=\"2.1 原理\"></a>2.1 原理</h2><p>核心点：  </p>\n<ol>\n<li>无论是读请求（读锁）还是写请求（写锁）都进行创建<code>顺序</code>临时节点，只看后缀的数字我们可以理解为\b一种从小到大的队列（例：我们在做订单请求的时候，对订单A做创建-&gt;\u001c\b\b支付-&gt;\b完成三个操作，对应 ZK节点则节点A下有三个子节点，这时候节点A可以理解为一个队列）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_shared_lock_1.png\" alt=\"\"></li>\n<li>创建完成之后，对读锁，则判断该队列之前是否有写锁，如果有写锁，则对写锁做删除监听。对写锁，判断队列之前是否有锁，如果有锁，则对序号最大的锁做删除监听。</li>\n<li>删除监听触发，获取该锁节点下所有的子节点（一个节点即代表锁），重复第 2步。</li>\n</ol>\n<h2 id=\"2-2-流程图\"><a href=\"#2-2-流程图\" class=\"headerlink\" title=\"2.2 流程图\"></a>2.2 流程图</h2><p>原书流程图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png\" alt=\"\"><br>我自己理解的流程：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_2.png\" alt=\"\"></p>\n<h2 id=\"2-3-代码实现\"><a href=\"#2-3-代码实现\" class=\"headerlink\" title=\"2.3 代码实现\"></a>2.3 代码实现</h2><p>核心代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class=\"line\">        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + SHARED_READ_PRE, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    String curSequence = curNode.split(SHARED_READ_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    log.info(curSequence + <span class=\"string\">\"创建读锁-R\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        List&lt;String&gt; children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">        <span class=\"comment\">// 记录序号比自己小的写请求</span></span><br><span class=\"line\">        List&lt;String&gt; writers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String brother : children) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brother.startsWith(SHARED_WRITE_PRE)) &#123;</span><br><span class=\"line\">                String sequence = brother.split(SHARED_WRITE_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (curSequence.compareTo(sequence) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    writers.add(brother);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writers.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有比自己序号小的写请求，说明自己获取到了读锁</span></span><br><span class=\"line\">            <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"没有比自己序号小的写请求-R\");</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取最近的那个写锁</span></span><br><span class=\"line\">            String lastWriter = SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + writers.get(writers.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 判断最近的那个写锁期间是否已经释放了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zkClient.exists(lastWriter)) &#123;</span><br><span class=\"line\">                MyReadIZkChildListener myReadIZkChildListener = <span class=\"keyword\">new</span> MyReadIZkChildListener(lastWriter, countDownLatch);</span><br><span class=\"line\">                zkClient.subscribeDataChanges(lastWriter, myReadIZkChildListener);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            countDownLatch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到了锁-R\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReadIZkChildListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">IZkDataListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lastWriter;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyReadIZkChildListener</span><span class=\"params\">(String lastWriter, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastWriter = lastWriter;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String dataPath, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String dataPath)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"比自己序号小的那个写请求被释放了-R\");</span></span><br><span class=\"line\">        zkClient.unsubscribeDataChanges(lastWriter, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 最近的那个写锁被释放了，但是不排除释放过程中，有其它写锁新加入，因此读锁需要重新获取列表</span></span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tryWrite</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException </span>&#123;</span><br><span class=\"line\">    CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class=\"line\">        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + SHARED_WRITE_PRE, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    String curSequence = curNode.split(SHARED_WRITE_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    log.info(curSequence + <span class=\"string\">\"创建写锁-W\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        List&lt;String&gt; children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">        <span class=\"comment\">// 记录序号比自己小的请求</span></span><br><span class=\"line\">        List&lt;String&gt; writersOrReader = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String brother : children) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brother.equals(SHARED_WRITE_PRE + curSequence)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 排除自己</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String sequence = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brother.contains(SHARED_WRITE_PRE)) &#123;</span><br><span class=\"line\">                sequence = brother.split(SHARED_WRITE_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (brother.contains(SHARED_READ_PRE)) &#123;</span><br><span class=\"line\">                sequence = brother.split(SHARED_READ_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 异常名称节点的处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curSequence.compareTo(sequence) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                writersOrReader.add(brother);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writersOrReader.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有比自己序号小的请求，说明自己获取到了读锁</span></span><br><span class=\"line\">            <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"没有比自己序号小的请求-W\");</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取最近的那个锁</span></span><br><span class=\"line\">            String lastWriterOrReader = SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + writersOrReader.get(writersOrReader.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 判断最近的那个锁期间是否已经释放了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zkClient.exists(lastWriterOrReader)) &#123;</span><br><span class=\"line\">                MyWriteIZkChildListener myWriteIZkChildListener = <span class=\"keyword\">new</span> MyWriteIZkChildListener(lastWriterOrReader, countDownLatch);</span><br><span class=\"line\">                zkClient.subscribeDataChanges(lastWriterOrReader, myWriteIZkChildListener);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            countDownLatch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到了锁-W\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWriteIZkChildListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">IZkDataListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lastWriterOrReader;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyWriteIZkChildListener</span><span class=\"params\">(String lastWriterOrReader, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastWriterOrReader = lastWriterOrReader;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String dataPath, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String dataPath)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"比自己序号小的那个请求被释放了，循环-W\");</span></span><br><span class=\"line\">        zkClient.unsubscribeDataChanges(lastWriterOrReader, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-待续\"><a href=\"#3-待续\" class=\"headerlink\" title=\"3. 待续\"></a>3. 待续</h1><p>readlock</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 \b前言\"></a>0 \b前言</h1><p>\b关于 ZooKeeper实现分布式锁，笔者在武汉小米一面（结果挂了）被问到过，因此记录如下。  </p>\n<p>以下的理论知识源自<code>《 从Paxos到Zookeeper分布式一致性原理与实践 》</code>第六章，代码\b完全根据书本理论进行实现，并且经多线程测试，在正常情况可行。  </p>\n<p>源码：<a href=\"https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project\" target=\"_blank\" rel=\"noopener\">https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project</a></p>\n<h1 id=\"1-ZooKeeper实现排他锁\"><a href=\"#1-ZooKeeper实现排他锁\" class=\"headerlink\" title=\"1 ZooKeeper实现排他锁\"></a>1 ZooKeeper实现排他锁</h1><h2 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1 原理\"></a>1.1 原理</h2><p>核心点：  </p>\n<ol>\n<li><code>抢占式创建相同名称的临时节点</code>，谁成功创建节点，则代表谁获得了锁。</li>\n<li>没有创建成功该节点，并且该节点存在，则对该名称的节点进行删除监听。</li>\n<li>如果该节点被删除了，则继续重复第 1步。</li>\n</ol>\n<h2 id=\"1-2-流程图\"><a href=\"#1-2-流程图\" class=\"headerlink\" title=\"1.2 流程图\"></a>1.2 流程图</h2><p>原书流程图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png\" alt=\"\"><br>我自己理解的流程：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_1.png\" alt=\"\"></p>\n<h2 id=\"1-3-代码实现\"><a href=\"#1-3-代码实现\" class=\"headerlink\" title=\"1.3 代码实现\"></a>1.3 代码实现</h2><p>统一接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:16</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DistributedLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:17</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 获取锁，默认等待时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException </span>&#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"子类不支持\"</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:18</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 获取锁，指定超时时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRead</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> </span>&#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"子类不支持\"</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tryWrite</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">tryWrite</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> </span>&#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"子类不支持\"</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Author</span> liwenguang</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Date</span> 2018/6/15 下午9:18</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 释放锁</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tryGetLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zkClient.createEphemeral(EXCLUSIVE_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">            log.info(Thread.currentThread().getName() + <span class=\"string\">\"获取锁成功\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// log.warn(Thread.currentThread().getName() + \"获取锁失败\");</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zkClient.exists(EXCLUSIVE_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class=\"line\">                MyIZkDataListener myIZkChildListener = <span class=\"keyword\">new</span> MyIZkDataListener(countDownLatch);</span><br><span class=\"line\">                zkClient.subscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, myIZkChildListener);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要阻塞式通知，因此使用 countDownLatch实现</span></span><br><span class=\"line\">            countDownLatch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到了锁\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyIZkDataListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">IZkDataListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyIZkDataListener</span><span class=\"params\">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String dataPath, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String dataPath)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"被回调了\");</span></span><br><span class=\"line\">        zkClient.unsubscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-ZooKeeper共享锁\"><a href=\"#2-ZooKeeper共享锁\" class=\"headerlink\" title=\"2 ZooKeeper共享锁\"></a>2 ZooKeeper共享锁</h1><h2 id=\"2-1-原理\"><a href=\"#2-1-原理\" class=\"headerlink\" title=\"2.1 原理\"></a>2.1 原理</h2><p>核心点：  </p>\n<ol>\n<li>无论是读请求（读锁）还是写请求（写锁）都进行创建<code>顺序</code>临时节点，只看后缀的数字我们可以理解为\b一种从小到大的队列（例：我们在做订单请求的时候，对订单A做创建-&gt;\u001c\b\b支付-&gt;\b完成三个操作，对应 ZK节点则节点A下有三个子节点，这时候节点A可以理解为一个队列）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_shared_lock_1.png\" alt=\"\"></li>\n<li>创建完成之后，对读锁，则判断该队列之前是否有写锁，如果有写锁，则对写锁做删除监听。对写锁，判断队列之前是否有锁，如果有锁，则对序号最大的锁做删除监听。</li>\n<li>删除监听触发，获取该锁节点下所有的子节点（一个节点即代表锁），重复第 2步。</li>\n</ol>\n<h2 id=\"2-2-流程图\"><a href=\"#2-2-流程图\" class=\"headerlink\" title=\"2.2 流程图\"></a>2.2 流程图</h2><p>原书流程图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png\" alt=\"\"><br>我自己理解的流程：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_2.png\" alt=\"\"></p>\n<h2 id=\"2-3-代码实现\"><a href=\"#2-3-代码实现\" class=\"headerlink\" title=\"2.3 代码实现\"></a>2.3 代码实现</h2><p>核心代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tryRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class=\"line\">        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + SHARED_READ_PRE, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    String curSequence = curNode.split(SHARED_READ_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    log.info(curSequence + <span class=\"string\">\"创建读锁-R\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        List&lt;String&gt; children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">        <span class=\"comment\">// 记录序号比自己小的写请求</span></span><br><span class=\"line\">        List&lt;String&gt; writers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String brother : children) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brother.startsWith(SHARED_WRITE_PRE)) &#123;</span><br><span class=\"line\">                String sequence = brother.split(SHARED_WRITE_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (curSequence.compareTo(sequence) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    writers.add(brother);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writers.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有比自己序号小的写请求，说明自己获取到了读锁</span></span><br><span class=\"line\">            <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"没有比自己序号小的写请求-R\");</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取最近的那个写锁</span></span><br><span class=\"line\">            String lastWriter = SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + writers.get(writers.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 判断最近的那个写锁期间是否已经释放了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zkClient.exists(lastWriter)) &#123;</span><br><span class=\"line\">                MyReadIZkChildListener myReadIZkChildListener = <span class=\"keyword\">new</span> MyReadIZkChildListener(lastWriter, countDownLatch);</span><br><span class=\"line\">                zkClient.subscribeDataChanges(lastWriter, myReadIZkChildListener);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            countDownLatch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到了锁-R\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReadIZkChildListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">IZkDataListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lastWriter;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyReadIZkChildListener</span><span class=\"params\">(String lastWriter, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastWriter = lastWriter;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String dataPath, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String dataPath)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"比自己序号小的那个写请求被释放了-R\");</span></span><br><span class=\"line\">        zkClient.unsubscribeDataChanges(lastWriter, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 最近的那个写锁被释放了，但是不排除释放过程中，有其它写锁新加入，因此读锁需要重新获取列表</span></span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tryWrite</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZkException </span>&#123;</span><br><span class=\"line\">    CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class=\"line\">        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + SHARED_WRITE_PRE, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    String curSequence = curNode.split(SHARED_WRITE_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    log.info(curSequence + <span class=\"string\">\"创建写锁-W\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        List&lt;String&gt; children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class=\"line\">        <span class=\"comment\">// 记录序号比自己小的请求</span></span><br><span class=\"line\">        List&lt;String&gt; writersOrReader = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String brother : children) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brother.equals(SHARED_WRITE_PRE + curSequence)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 排除自己</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String sequence = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brother.contains(SHARED_WRITE_PRE)) &#123;</span><br><span class=\"line\">                sequence = brother.split(SHARED_WRITE_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (brother.contains(SHARED_READ_PRE)) &#123;</span><br><span class=\"line\">                sequence = brother.split(SHARED_READ_PRE)[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 异常名称节点的处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curSequence.compareTo(sequence) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                writersOrReader.add(brother);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writersOrReader.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有比自己序号小的请求，说明自己获取到了读锁</span></span><br><span class=\"line\">            <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"没有比自己序号小的请求-W\");</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取最近的那个锁</span></span><br><span class=\"line\">            String lastWriterOrReader = SHARED_LOCK_NAMESPACE + lockPath + <span class=\"string\">\"/\"</span> + writersOrReader.get(writersOrReader.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 判断最近的那个锁期间是否已经释放了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zkClient.exists(lastWriterOrReader)) &#123;</span><br><span class=\"line\">                MyWriteIZkChildListener myWriteIZkChildListener = <span class=\"keyword\">new</span> MyWriteIZkChildListener(lastWriterOrReader, countDownLatch);</span><br><span class=\"line\">                zkClient.subscribeDataChanges(lastWriterOrReader, myWriteIZkChildListener);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            countDownLatch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到了锁-W\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWriteIZkChildListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">IZkDataListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lastWriterOrReader;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyWriteIZkChildListener</span><span class=\"params\">(String lastWriterOrReader, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lastWriterOrReader = lastWriterOrReader;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String dataPath, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String dataPath)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//log.info(Thread.currentThread().getName() + \"比自己序号小的那个请求被释放了，循环-W\");</span></span><br><span class=\"line\">        zkClient.unsubscribeDataChanges(lastWriterOrReader, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        countDownLatch.countDown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-待续\"><a href=\"#3-待续\" class=\"headerlink\" title=\"3. 待续\"></a>3. 待续</h1><p>readlock</p>\n"},{"title":"十、证书——为公钥加上数字签名","date":"2017-11-22T13:48:00.000Z","updated":"2017-11-22T13:48:00.000Z","comments":1,"_content":"\n# 1 本章概要\n\n第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。  \n  \n我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。\n\n# 2 证书\n\n# 2.1 什么是证书\n\n公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由**认证机构（Certification Authority、Certifying Authority，CA）**施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为**证书**（certificate）。  \n认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。\n\n# 2.2 证书的应用场景\n\n![][1]  \n1. Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。\n2. Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。  \n![][2]\n3. 认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。\n4. Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。\n5. Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。\n6. Alice 用 Bob 的公钥加密消息并发送给 Bob。\n7. Bob 用自己的私钥解密密文得到 Alice 的消息。\n\n# 3 证书标准规范 X.509\n\n1. 签名前的证书——签名对象的信息\n2. 数字签名算法——对证书签名时所使用的算法\n3. 数字签名——对证书施加的数字签名\n\n# 4 公钥基础设施（PKI）\n\n## 4.1 什么是公钥基础设施\n\n**公钥基础设施**（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。\n\n## 4.2 PKI 的组成要素\n\n1. 用户——使用 PKI 的人\n2. 认证机构——颁发证书的人\n3. 仓库——保存证书的数据\n\n## 4.3 认证机构的工作\n\n1. 生成密钥对\n2. 注册证书\n3. 作废证书与 CRL（证书作废清单 Certificate Revocation List）\n\n## 4.4 证书的层级结构\n\n证书颁发：根CA -> 分公司认证机构 -> 办事处认证机构 -> 用户。\n验证证书：根CA -> 分公司认证机构 -> 办事处认证机构 -> 用户。如果连根CA都无法验证说明证书是存在问题的。  \n![][3]\n\n# 5. 对证书的攻击\n\n## 5.1 在公钥注册之前进行攻击\n\n## 5.2 注册相似人名进行攻击\n\n## 5.3 窃取认证机构的私钥进行攻击\n\n## 5.4 攻击者伪装成认证机构进行攻击\n\n## 5.5 钻 CRL 的空子进行攻击\n\nMallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。\n\n# 6. 关于证书的 Q&A\n\n## 6.1 为什么需要证书\n\n疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？  \n回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。\n\n## 6.2 通过自己的方法进行认证是不是更安全\n\n疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？  \n回答：靠隐蔽式来保证安全是错误的！\n\n## 6.3 为什么要相信认证机构\n\n？？？\n\n# 7. 本章小结\n\n从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。  \n无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。\n\n# 8. 小测验 \n\n1. 证书是认证机构将用户的公钥加密后的产物\n2. 要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥\n3. 世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA\n4. 用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构\n5. 用户需要定期从认证机构获取 CRL\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_3.png","source":"_posts/图解密码技术/第十章 证书.md","raw":"---\ntitle: 十、证书——为公钥加上数字签名\ndate: 2017-11-22 21:48:00\nupdated: 2017-11-22 21:48:00\ncomments: true\ncategories: \n- 读书笔记\n- 图解密码技术\npermalink: graphic2cryptography/10.html    \n---\n\n# 1 本章概要\n\n第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。  \n  \n我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。\n\n# 2 证书\n\n# 2.1 什么是证书\n\n公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由**认证机构（Certification Authority、Certifying Authority，CA）**施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为**证书**（certificate）。  \n认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。\n\n# 2.2 证书的应用场景\n\n![][1]  \n1. Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。\n2. Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。  \n![][2]\n3. 认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。\n4. Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。\n5. Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。\n6. Alice 用 Bob 的公钥加密消息并发送给 Bob。\n7. Bob 用自己的私钥解密密文得到 Alice 的消息。\n\n# 3 证书标准规范 X.509\n\n1. 签名前的证书——签名对象的信息\n2. 数字签名算法——对证书签名时所使用的算法\n3. 数字签名——对证书施加的数字签名\n\n# 4 公钥基础设施（PKI）\n\n## 4.1 什么是公钥基础设施\n\n**公钥基础设施**（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。\n\n## 4.2 PKI 的组成要素\n\n1. 用户——使用 PKI 的人\n2. 认证机构——颁发证书的人\n3. 仓库——保存证书的数据\n\n## 4.3 认证机构的工作\n\n1. 生成密钥对\n2. 注册证书\n3. 作废证书与 CRL（证书作废清单 Certificate Revocation List）\n\n## 4.4 证书的层级结构\n\n证书颁发：根CA -> 分公司认证机构 -> 办事处认证机构 -> 用户。\n验证证书：根CA -> 分公司认证机构 -> 办事处认证机构 -> 用户。如果连根CA都无法验证说明证书是存在问题的。  \n![][3]\n\n# 5. 对证书的攻击\n\n## 5.1 在公钥注册之前进行攻击\n\n## 5.2 注册相似人名进行攻击\n\n## 5.3 窃取认证机构的私钥进行攻击\n\n## 5.4 攻击者伪装成认证机构进行攻击\n\n## 5.5 钻 CRL 的空子进行攻击\n\nMallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。\n\n# 6. 关于证书的 Q&A\n\n## 6.1 为什么需要证书\n\n疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？  \n回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。\n\n## 6.2 通过自己的方法进行认证是不是更安全\n\n疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？  \n回答：靠隐蔽式来保证安全是错误的！\n\n## 6.3 为什么要相信认证机构\n\n？？？\n\n# 7. 本章小结\n\n从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。  \n无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。\n\n# 8. 小测验 \n\n1. 证书是认证机构将用户的公钥加密后的产物\n2. 要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥\n3. 世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA\n4. 用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构\n5. 用户需要定期从认证机构获取 CRL\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_3.png","slug":"graphic2cryptography/10.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw5003caxs67befl6zn","content":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。  </p>\n<p>我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。</p>\n<h1 id=\"2-证书\"><a href=\"#2-证书\" class=\"headerlink\" title=\"2 证书\"></a>2 证书</h1><h1 id=\"2-1-什么是证书\"><a href=\"#2-1-什么是证书\" class=\"headerlink\" title=\"2.1 什么是证书\"></a>2.1 什么是证书</h1><p>公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由<strong>认证机构（Certification Authority、Certifying Authority，CA）</strong>施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为<strong>证书</strong>（certificate）。<br>认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。</p>\n<h1 id=\"2-2-证书的应用场景\"><a href=\"#2-2-证书的应用场景\" class=\"headerlink\" title=\"2.2 证书的应用场景\"></a>2.2 证书的应用场景</h1><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_1.png\" alt=\"\">  </p>\n<ol>\n<li>Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。</li>\n<li>Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_2.png\" alt=\"\"></li>\n<li>认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。</li>\n<li>Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。</li>\n<li>Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。</li>\n<li>Alice 用 Bob 的公钥加密消息并发送给 Bob。</li>\n<li>Bob 用自己的私钥解密密文得到 Alice 的消息。</li>\n</ol>\n<h1 id=\"3-证书标准规范-X-509\"><a href=\"#3-证书标准规范-X-509\" class=\"headerlink\" title=\"3 证书标准规范 X.509\"></a>3 证书标准规范 X.509</h1><ol>\n<li>签名前的证书——签名对象的信息</li>\n<li>数字签名算法——对证书签名时所使用的算法</li>\n<li>数字签名——对证书施加的数字签名</li>\n</ol>\n<h1 id=\"4-公钥基础设施（PKI）\"><a href=\"#4-公钥基础设施（PKI）\" class=\"headerlink\" title=\"4 公钥基础设施（PKI）\"></a>4 公钥基础设施（PKI）</h1><h2 id=\"4-1-什么是公钥基础设施\"><a href=\"#4-1-什么是公钥基础设施\" class=\"headerlink\" title=\"4.1 什么是公钥基础设施\"></a>4.1 什么是公钥基础设施</h2><p><strong>公钥基础设施</strong>（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。</p>\n<h2 id=\"4-2-PKI-的组成要素\"><a href=\"#4-2-PKI-的组成要素\" class=\"headerlink\" title=\"4.2 PKI 的组成要素\"></a>4.2 PKI 的组成要素</h2><ol>\n<li>用户——使用 PKI 的人</li>\n<li>认证机构——颁发证书的人</li>\n<li>仓库——保存证书的数据</li>\n</ol>\n<h2 id=\"4-3-认证机构的工作\"><a href=\"#4-3-认证机构的工作\" class=\"headerlink\" title=\"4.3 认证机构的工作\"></a>4.3 认证机构的工作</h2><ol>\n<li>生成密钥对</li>\n<li>注册证书</li>\n<li>作废证书与 CRL（证书作废清单 Certificate Revocation List）</li>\n</ol>\n<h2 id=\"4-4-证书的层级结构\"><a href=\"#4-4-证书的层级结构\" class=\"headerlink\" title=\"4.4 证书的层级结构\"></a>4.4 证书的层级结构</h2><p>证书颁发：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。<br>验证证书：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。如果连根CA都无法验证说明证书是存在问题的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_3.png\" alt=\"\"></p>\n<h1 id=\"5-对证书的攻击\"><a href=\"#5-对证书的攻击\" class=\"headerlink\" title=\"5. 对证书的攻击\"></a>5. 对证书的攻击</h1><h2 id=\"5-1-在公钥注册之前进行攻击\"><a href=\"#5-1-在公钥注册之前进行攻击\" class=\"headerlink\" title=\"5.1 在公钥注册之前进行攻击\"></a>5.1 在公钥注册之前进行攻击</h2><h2 id=\"5-2-注册相似人名进行攻击\"><a href=\"#5-2-注册相似人名进行攻击\" class=\"headerlink\" title=\"5.2 注册相似人名进行攻击\"></a>5.2 注册相似人名进行攻击</h2><h2 id=\"5-3-窃取认证机构的私钥进行攻击\"><a href=\"#5-3-窃取认证机构的私钥进行攻击\" class=\"headerlink\" title=\"5.3 窃取认证机构的私钥进行攻击\"></a>5.3 窃取认证机构的私钥进行攻击</h2><h2 id=\"5-4-攻击者伪装成认证机构进行攻击\"><a href=\"#5-4-攻击者伪装成认证机构进行攻击\" class=\"headerlink\" title=\"5.4 攻击者伪装成认证机构进行攻击\"></a>5.4 攻击者伪装成认证机构进行攻击</h2><h2 id=\"5-5-钻-CRL-的空子进行攻击\"><a href=\"#5-5-钻-CRL-的空子进行攻击\" class=\"headerlink\" title=\"5.5 钻 CRL 的空子进行攻击\"></a>5.5 钻 CRL 的空子进行攻击</h2><p>Mallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。</p>\n<h1 id=\"6-关于证书的-Q-amp-A\"><a href=\"#6-关于证书的-Q-amp-A\" class=\"headerlink\" title=\"6. 关于证书的 Q&amp;A\"></a>6. 关于证书的 Q&amp;A</h1><h2 id=\"6-1-为什么需要证书\"><a href=\"#6-1-为什么需要证书\" class=\"headerlink\" title=\"6.1 为什么需要证书\"></a>6.1 为什么需要证书</h2><p>疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？<br>回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。</p>\n<h2 id=\"6-2-通过自己的方法进行认证是不是更安全\"><a href=\"#6-2-通过自己的方法进行认证是不是更安全\" class=\"headerlink\" title=\"6.2 通过自己的方法进行认证是不是更安全\"></a>6.2 通过自己的方法进行认证是不是更安全</h2><p>疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？<br>回答：靠隐蔽式来保证安全是错误的！</p>\n<h2 id=\"6-3-为什么要相信认证机构\"><a href=\"#6-3-为什么要相信认证机构\" class=\"headerlink\" title=\"6.3 为什么要相信认证机构\"></a>6.3 为什么要相信认证机构</h2><p>？？？</p>\n<h1 id=\"7-本章小结\"><a href=\"#7-本章小结\" class=\"headerlink\" title=\"7. 本章小结\"></a>7. 本章小结</h1><p>从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。<br>无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。</p>\n<h1 id=\"8-小测验\"><a href=\"#8-小测验\" class=\"headerlink\" title=\"8. 小测验\"></a>8. 小测验</h1><ol>\n<li>证书是认证机构将用户的公钥加密后的产物</li>\n<li>要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥</li>\n<li>世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA</li>\n<li>用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构</li>\n<li>用户需要定期从认证机构获取 CRL</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-本章概要\"><a href=\"#1-本章概要\" class=\"headerlink\" title=\"1 本章概要\"></a>1 本章概要</h1><p>第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。  </p>\n<p>我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。</p>\n<h1 id=\"2-证书\"><a href=\"#2-证书\" class=\"headerlink\" title=\"2 证书\"></a>2 证书</h1><h1 id=\"2-1-什么是证书\"><a href=\"#2-1-什么是证书\" class=\"headerlink\" title=\"2.1 什么是证书\"></a>2.1 什么是证书</h1><p>公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由<strong>认证机构（Certification Authority、Certifying Authority，CA）</strong>施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为<strong>证书</strong>（certificate）。<br>认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。</p>\n<h1 id=\"2-2-证书的应用场景\"><a href=\"#2-2-证书的应用场景\" class=\"headerlink\" title=\"2.2 证书的应用场景\"></a>2.2 证书的应用场景</h1><p><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_1.png\" alt=\"\">  </p>\n<ol>\n<li>Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。</li>\n<li>Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_2.png\" alt=\"\"></li>\n<li>认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。</li>\n<li>Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。</li>\n<li>Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。</li>\n<li>Alice 用 Bob 的公钥加密消息并发送给 Bob。</li>\n<li>Bob 用自己的私钥解密密文得到 Alice 的消息。</li>\n</ol>\n<h1 id=\"3-证书标准规范-X-509\"><a href=\"#3-证书标准规范-X-509\" class=\"headerlink\" title=\"3 证书标准规范 X.509\"></a>3 证书标准规范 X.509</h1><ol>\n<li>签名前的证书——签名对象的信息</li>\n<li>数字签名算法——对证书签名时所使用的算法</li>\n<li>数字签名——对证书施加的数字签名</li>\n</ol>\n<h1 id=\"4-公钥基础设施（PKI）\"><a href=\"#4-公钥基础设施（PKI）\" class=\"headerlink\" title=\"4 公钥基础设施（PKI）\"></a>4 公钥基础设施（PKI）</h1><h2 id=\"4-1-什么是公钥基础设施\"><a href=\"#4-1-什么是公钥基础设施\" class=\"headerlink\" title=\"4.1 什么是公钥基础设施\"></a>4.1 什么是公钥基础设施</h2><p><strong>公钥基础设施</strong>（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。</p>\n<h2 id=\"4-2-PKI-的组成要素\"><a href=\"#4-2-PKI-的组成要素\" class=\"headerlink\" title=\"4.2 PKI 的组成要素\"></a>4.2 PKI 的组成要素</h2><ol>\n<li>用户——使用 PKI 的人</li>\n<li>认证机构——颁发证书的人</li>\n<li>仓库——保存证书的数据</li>\n</ol>\n<h2 id=\"4-3-认证机构的工作\"><a href=\"#4-3-认证机构的工作\" class=\"headerlink\" title=\"4.3 认证机构的工作\"></a>4.3 认证机构的工作</h2><ol>\n<li>生成密钥对</li>\n<li>注册证书</li>\n<li>作废证书与 CRL（证书作废清单 Certificate Revocation List）</li>\n</ol>\n<h2 id=\"4-4-证书的层级结构\"><a href=\"#4-4-证书的层级结构\" class=\"headerlink\" title=\"4.4 证书的层级结构\"></a>4.4 证书的层级结构</h2><p>证书颁发：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。<br>验证证书：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。如果连根CA都无法验证说明证书是存在问题的。<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_3.png\" alt=\"\"></p>\n<h1 id=\"5-对证书的攻击\"><a href=\"#5-对证书的攻击\" class=\"headerlink\" title=\"5. 对证书的攻击\"></a>5. 对证书的攻击</h1><h2 id=\"5-1-在公钥注册之前进行攻击\"><a href=\"#5-1-在公钥注册之前进行攻击\" class=\"headerlink\" title=\"5.1 在公钥注册之前进行攻击\"></a>5.1 在公钥注册之前进行攻击</h2><h2 id=\"5-2-注册相似人名进行攻击\"><a href=\"#5-2-注册相似人名进行攻击\" class=\"headerlink\" title=\"5.2 注册相似人名进行攻击\"></a>5.2 注册相似人名进行攻击</h2><h2 id=\"5-3-窃取认证机构的私钥进行攻击\"><a href=\"#5-3-窃取认证机构的私钥进行攻击\" class=\"headerlink\" title=\"5.3 窃取认证机构的私钥进行攻击\"></a>5.3 窃取认证机构的私钥进行攻击</h2><h2 id=\"5-4-攻击者伪装成认证机构进行攻击\"><a href=\"#5-4-攻击者伪装成认证机构进行攻击\" class=\"headerlink\" title=\"5.4 攻击者伪装成认证机构进行攻击\"></a>5.4 攻击者伪装成认证机构进行攻击</h2><h2 id=\"5-5-钻-CRL-的空子进行攻击\"><a href=\"#5-5-钻-CRL-的空子进行攻击\" class=\"headerlink\" title=\"5.5 钻 CRL 的空子进行攻击\"></a>5.5 钻 CRL 的空子进行攻击</h2><p>Mallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。</p>\n<h1 id=\"6-关于证书的-Q-amp-A\"><a href=\"#6-关于证书的-Q-amp-A\" class=\"headerlink\" title=\"6. 关于证书的 Q&amp;A\"></a>6. 关于证书的 Q&amp;A</h1><h2 id=\"6-1-为什么需要证书\"><a href=\"#6-1-为什么需要证书\" class=\"headerlink\" title=\"6.1 为什么需要证书\"></a>6.1 为什么需要证书</h2><p>疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？<br>回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。</p>\n<h2 id=\"6-2-通过自己的方法进行认证是不是更安全\"><a href=\"#6-2-通过自己的方法进行认证是不是更安全\" class=\"headerlink\" title=\"6.2 通过自己的方法进行认证是不是更安全\"></a>6.2 通过自己的方法进行认证是不是更安全</h2><p>疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？<br>回答：靠隐蔽式来保证安全是错误的！</p>\n<h2 id=\"6-3-为什么要相信认证机构\"><a href=\"#6-3-为什么要相信认证机构\" class=\"headerlink\" title=\"6.3 为什么要相信认证机构\"></a>6.3 为什么要相信认证机构</h2><p>？？？</p>\n<h1 id=\"7-本章小结\"><a href=\"#7-本章小结\" class=\"headerlink\" title=\"7. 本章小结\"></a>7. 本章小结</h1><p>从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。<br>无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。</p>\n<h1 id=\"8-小测验\"><a href=\"#8-小测验\" class=\"headerlink\" title=\"8. 小测验\"></a>8. 小测验</h1><ol>\n<li>证书是认证机构将用户的公钥加密后的产物</li>\n<li>要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥</li>\n<li>世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA</li>\n<li>用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构</li>\n<li>用户需要定期从认证机构获取 CRL</li>\n</ol>\n"},{"title":"ThreadLocal 的心得","date":"2017-12-21T17:24:00.000Z","updated":"2017-12-21T17:24:00.000Z","comments":1,"_content":"\n在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：  \nThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLoaclMap）实例，这样不同的Thread 有不同的 ThreadLocalMap 实例，就不用考虑锁的问题。  \n另外为了避免内存泄漏、回收不及时等问题，从而让 ThreadLocalMap 的 key 使用弱引用。  \n同时，为了保证当 key 为 null 时，value 无法正常释放时，在每次 set 时，都会遍历 key ，当 key 为 null 则会执行 replaceStaleEntry()，即将 key 为 null 的 value 值也置为 null，从而来让其回收。    \n这里讲解更加详细：http://www.jasongj.com/java/threadlocal/","source":"_posts/技术小结/threadLocal1.md","raw":"---\ntitle: ThreadLocal 的心得\ndate: 2017-12-22 01:24:00\nupdated: 2017-12-22 01:24:00\ncomments: true\ncategories: \n- 小结\npermalink: tech/threadlocal_1.html \n---\n\n在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：  \nThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLoaclMap）实例，这样不同的Thread 有不同的 ThreadLocalMap 实例，就不用考虑锁的问题。  \n另外为了避免内存泄漏、回收不及时等问题，从而让 ThreadLocalMap 的 key 使用弱引用。  \n同时，为了保证当 key 为 null 时，value 无法正常释放时，在每次 set 时，都会遍历 key ，当 key 为 null 则会执行 replaceStaleEntry()，即将 key 为 null 的 value 值也置为 null，从而来让其回收。    \n这里讲解更加详细：http://www.jasongj.com/java/threadlocal/","slug":"tech/threadlocal_1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw7003faxs689b5zyrt","content":"<p>在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：<br>ThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLoaclMap）实例，这样不同的Thread 有不同的 ThreadLocalMap 实例，就不用考虑锁的问题。<br>另外为了避免内存泄漏、回收不及时等问题，从而让 ThreadLocalMap 的 key 使用弱引用。<br>同时，为了保证当 key 为 null 时，value 无法正常释放时，在每次 set 时，都会遍历 key ，当 key 为 null 则会执行 replaceStaleEntry()，即将 key 为 null 的 value 值也置为 null，从而来让其回收。<br>这里讲解更加详细：<a href=\"http://www.jasongj.com/java/threadlocal/\" target=\"_blank\" rel=\"noopener\">http://www.jasongj.com/java/threadlocal/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：<br>ThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLoaclMap）实例，这样不同的Thread 有不同的 ThreadLocalMap 实例，就不用考虑锁的问题。<br>另外为了避免内存泄漏、回收不及时等问题，从而让 ThreadLocalMap 的 key 使用弱引用。<br>同时，为了保证当 key 为 null 时，value 无法正常释放时，在每次 set 时，都会遍历 key ，当 key 为 null 则会执行 replaceStaleEntry()，即将 key 为 null 的 value 值也置为 null，从而来让其回收。<br>这里讲解更加详细：<a href=\"http://www.jasongj.com/java/threadlocal/\" target=\"_blank\" rel=\"noopener\">http://www.jasongj.com/java/threadlocal/</a></p>\n"},{"title":"去中心化","date":"2017-12-04T17:06:00.000Z","updated":"2017-12-04T17:06:00.000Z","comments":1,"_content":"\n>作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。\n\n---\n\n编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。  \n  \n“去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。  \n  \n但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图：  \n![][1]  \n  \n现在再来看看Quora上面有关“[分布式和去中心化的区别][i_1]”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的[图解][i_2]，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。\n\n## 三种类型的去中心化\n\n当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是：  \n1. 结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？\n2. 政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？\n3. 逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？\n  \n我们可以把这三个维度用下面这张表来表示：  \n![][2]  \n  \n要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况：  \n* 传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。\n* 民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。\n* 语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。\n* BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。\n* 区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。  \n  \n很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的[文章][i_3]）。  \n  \n结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。  \n  \n逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。\n\n## 去中心化的三个原因\n\n接下来的问题就是为什么去中心化会有用？这通常会有几种观点：  \n* 可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。\n* 抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。\n\n* 抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。\n\n这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到[原文][i_4]了解进一步的讨论。\n\n---\n\n此文转载自：[<去中心化的三个维度_36氪>][i_5]\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_2.png\n[i_1]: https://www.quora.com/Whats-the-difference-between-distributed-and-decentralized-in-Bitcoin-land\n[i_2]: https://ethereum.stackexchange.com/questions/7812/question-on-the-terms-distributed-and-decentralised\n[i_3]: http://scuttlebot.io/more/articles/design-challenge-avoid-centralization-and-singletons.html\n[i_4]: https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274\n[i_5]: https://36kr.com/p/5063699.html","source":"_posts/闲聊/Decentralization.md","raw":"---\ntitle: 去中心化\ndate: 2017-12-05 01:06:00\nupdated: 2017-12-05 01:06:00\ncomments: true\ncategories: \n- 闲聊\npermalink: talker/decentralization_1.html    \n---\n\n>作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。\n\n---\n\n编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。  \n  \n“去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。  \n  \n但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图：  \n![][1]  \n  \n现在再来看看Quora上面有关“[分布式和去中心化的区别][i_1]”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的[图解][i_2]，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。\n\n## 三种类型的去中心化\n\n当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是：  \n1. 结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？\n2. 政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？\n3. 逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？\n  \n我们可以把这三个维度用下面这张表来表示：  \n![][2]  \n  \n要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况：  \n* 传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。\n* 民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。\n* 语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。\n* BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。\n* 区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。  \n  \n很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的[文章][i_3]）。  \n  \n结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。  \n  \n逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。\n\n## 去中心化的三个原因\n\n接下来的问题就是为什么去中心化会有用？这通常会有几种观点：  \n* 可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。\n* 抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。\n\n* 抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。\n\n这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到[原文][i_4]了解进一步的讨论。\n\n---\n\n此文转载自：[<去中心化的三个维度_36氪>][i_5]\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_2.png\n[i_1]: https://www.quora.com/Whats-the-difference-between-distributed-and-decentralized-in-Bitcoin-land\n[i_2]: https://ethereum.stackexchange.com/questions/7812/question-on-the-terms-distributed-and-decentralised\n[i_3]: http://scuttlebot.io/more/articles/design-challenge-avoid-centralization-and-singletons.html\n[i_4]: https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274\n[i_5]: https://36kr.com/p/5063699.html","slug":"talker/decentralization_1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkaw8003haxs6pmjfkhqi","content":"<blockquote>\n<p>作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。</p>\n</blockquote>\n<hr>\n<p>编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。  </p>\n<p>“去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。  </p>\n<p>但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_1.png\" alt=\"\">  </p>\n<p>现在再来看看Quora上面有关“<a href=\"https://www.quora.com/Whats-the-difference-between-distributed-and-decentralized-in-Bitcoin-land\" target=\"_blank\" rel=\"noopener\">分布式和去中心化的区别</a>”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的<a href=\"https://ethereum.stackexchange.com/questions/7812/question-on-the-terms-distributed-and-decentralised\" target=\"_blank\" rel=\"noopener\">图解</a>，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。</p>\n<h2 id=\"三种类型的去中心化\"><a href=\"#三种类型的去中心化\" class=\"headerlink\" title=\"三种类型的去中心化\"></a>三种类型的去中心化</h2><p>当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是：  </p>\n<ol>\n<li>结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？</li>\n<li>政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？</li>\n<li>逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？</li>\n</ol>\n<p>我们可以把这三个维度用下面这张表来表示：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_2.png\" alt=\"\">  </p>\n<p>要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况：  </p>\n<ul>\n<li>传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。</li>\n<li>民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。</li>\n<li>语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。</li>\n<li>BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。</li>\n<li>区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。  </li>\n</ul>\n<p>很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的<a href=\"http://scuttlebot.io/more/articles/design-challenge-avoid-centralization-and-singletons.html\" target=\"_blank\" rel=\"noopener\">文章</a>）。  </p>\n<p>结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。  </p>\n<p>逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。</p>\n<h2 id=\"去中心化的三个原因\"><a href=\"#去中心化的三个原因\" class=\"headerlink\" title=\"去中心化的三个原因\"></a>去中心化的三个原因</h2><p>接下来的问题就是为什么去中心化会有用？这通常会有几种观点：  </p>\n<ul>\n<li>可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。</li>\n<li><p>抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。</p>\n</li>\n<li><p>抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。</p>\n</li>\n</ul>\n<p>这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到<a href=\"https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274\" target=\"_blank\" rel=\"noopener\">原文</a>了解进一步的讨论。</p>\n<hr>\n<p>此文转载自：<a href=\"https://36kr.com/p/5063699.html\" target=\"_blank\" rel=\"noopener\">&lt;去中心化的三个维度_36氪&gt;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。</p>\n</blockquote>\n<hr>\n<p>编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。  </p>\n<p>“去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。  </p>\n<p>但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_1.png\" alt=\"\">  </p>\n<p>现在再来看看Quora上面有关“<a href=\"https://www.quora.com/Whats-the-difference-between-distributed-and-decentralized-in-Bitcoin-land\" target=\"_blank\" rel=\"noopener\">分布式和去中心化的区别</a>”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的<a href=\"https://ethereum.stackexchange.com/questions/7812/question-on-the-terms-distributed-and-decentralised\" target=\"_blank\" rel=\"noopener\">图解</a>，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。</p>\n<h2 id=\"三种类型的去中心化\"><a href=\"#三种类型的去中心化\" class=\"headerlink\" title=\"三种类型的去中心化\"></a>三种类型的去中心化</h2><p>当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是：  </p>\n<ol>\n<li>结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？</li>\n<li>政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？</li>\n<li>逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？</li>\n</ol>\n<p>我们可以把这三个维度用下面这张表来表示：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_2.png\" alt=\"\">  </p>\n<p>要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况：  </p>\n<ul>\n<li>传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。</li>\n<li>民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。</li>\n<li>语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。</li>\n<li>BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。</li>\n<li>区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。  </li>\n</ul>\n<p>很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的<a href=\"http://scuttlebot.io/more/articles/design-challenge-avoid-centralization-and-singletons.html\" target=\"_blank\" rel=\"noopener\">文章</a>）。  </p>\n<p>结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。  </p>\n<p>逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。</p>\n<h2 id=\"去中心化的三个原因\"><a href=\"#去中心化的三个原因\" class=\"headerlink\" title=\"去中心化的三个原因\"></a>去中心化的三个原因</h2><p>接下来的问题就是为什么去中心化会有用？这通常会有几种观点：  </p>\n<ul>\n<li>可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。</li>\n<li><p>抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。</p>\n</li>\n<li><p>抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。</p>\n</li>\n</ul>\n<p>这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到<a href=\"https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274\" target=\"_blank\" rel=\"noopener\">原文</a>了解进一步的讨论。</p>\n<hr>\n<p>此文转载自：<a href=\"https://36kr.com/p/5063699.html\" target=\"_blank\" rel=\"noopener\">&lt;去中心化的三个维度_36氪&gt;</a></p>\n"},{"title":"面试自我反省总结","date":"2018-05-08T13:51:00.000Z","updated":"2018-05-16T15:51:00.000Z","comments":1,"_content":"\n### 1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。\n\b\n主要问了 java 集合，包括里面 List、Set、Map 各个区别以及相关算法、Spring 的设计模式、Spring MVC 和 Servlet 的联系区别、Spring 的相关源码，我当时只说了 Spring MVC 启动、运行源码流程，@Autowire 注入的时候的 AutowireAnnotationBeanPostProcessor 的相关逻辑，顺带讲了 Bean 的生命周期，循环注入等，还有一些常见的面试题给忘了。\n\n### 2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\n\n一面先问 hashmap 的 put，currenthashmap 的 put，以及 size，然后是 ThreadLocal，订阅模式、命令模式、代理模式，sql，组合索引，手写一些 sql 问是否用到了索引，\n手写一个 幻读，隔离级别与事务传播，那个幻读没写出来，然后被一面的面试官评价为基础可以但是 sql 不行，唉，然后问我最得意的项目，我说的是一个基于 ZooKeeper 的一个项目，然后问了 zk 的一些知识，两阶段提交、paxos（这个没答出来）、CAP、BASE，然后问如何实现一个分布式锁，然后问了项目的一些问题，涉及到了线程池。\b  \n二面直接让我把一个 BI 的项目技术架构图画出来，然后问 ETL ，RPC 和 http 的区别，然后其它一些小问题，跟我说要多敲代码，不是本专业只能要非常突出的代码能力才行。。。然后谈论了业务和技术，最后直接跟我说没过。比较奇怪没有问 JVM，可能是三面才会问这么高深的吧。。。  \n事后也把我做的项目都复习总结拿出来重新过了一遍，学了很多，然后好好复习，准备下一个面试。\n\n### 3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。\n\n笔试：两个类A extend B，考察静态方法和构造方法的执行顺序，二分查找法，mysql 的 having order 等。  \n技术面试，一问 hashmap 然后问简历项目。最后问多个线程同时下载报表如何下载。主问简历。  \n二轮BOS，一问 某个业务从请求到最后日志记录的业务全过程。然后聊了很多，treemap 和 hashmap，git rebase merge，最后一个问题是一千个排好序的文件，如果成为一个大的排序好的文件。大概这么多\n\n### 4. 第四个面试是上海同事推荐，两面技术，拿到 offer。\n\n一面电话：集合、threadlocal、锁、线程池。多态、继承、封装的理解，主要是基础，具体问的大概忘了，并不深入。  \n二面聊天：一问，nginx 实现负载均衡的方式，底层如何实现负载均衡，zk 的实际案例，为什么用 zk，内部如何选举。大概这么多。","source":"_posts/技术小结/面经.md","raw":"---\ntitle: 面试自我反省总结\ndate: 2018-05-08 21:51:00\nupdated: 2018-05-16 23:51:00\ncomments: true\ncategories: \n- 小结\npermalink: tech/learn_what_how_why.html \n---\n\n### 1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。\n\b\n主要问了 java 集合，包括里面 List、Set、Map 各个区别以及相关算法、Spring 的设计模式、Spring MVC 和 Servlet 的联系区别、Spring 的相关源码，我当时只说了 Spring MVC 启动、运行源码流程，@Autowire 注入的时候的 AutowireAnnotationBeanPostProcessor 的相关逻辑，顺带讲了 Bean 的生命周期，循环注入等，还有一些常见的面试题给忘了。\n\n### 2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\n\n一面先问 hashmap 的 put，currenthashmap 的 put，以及 size，然后是 ThreadLocal，订阅模式、命令模式、代理模式，sql，组合索引，手写一些 sql 问是否用到了索引，\n手写一个 幻读，隔离级别与事务传播，那个幻读没写出来，然后被一面的面试官评价为基础可以但是 sql 不行，唉，然后问我最得意的项目，我说的是一个基于 ZooKeeper 的一个项目，然后问了 zk 的一些知识，两阶段提交、paxos（这个没答出来）、CAP、BASE，然后问如何实现一个分布式锁，然后问了项目的一些问题，涉及到了线程池。\b  \n二面直接让我把一个 BI 的项目技术架构图画出来，然后问 ETL ，RPC 和 http 的区别，然后其它一些小问题，跟我说要多敲代码，不是本专业只能要非常突出的代码能力才行。。。然后谈论了业务和技术，最后直接跟我说没过。比较奇怪没有问 JVM，可能是三面才会问这么高深的吧。。。  \n事后也把我做的项目都复习总结拿出来重新过了一遍，学了很多，然后好好复习，准备下一个面试。\n\n### 3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。\n\n笔试：两个类A extend B，考察静态方法和构造方法的执行顺序，二分查找法，mysql 的 having order 等。  \n技术面试，一问 hashmap 然后问简历项目。最后问多个线程同时下载报表如何下载。主问简历。  \n二轮BOS，一问 某个业务从请求到最后日志记录的业务全过程。然后聊了很多，treemap 和 hashmap，git rebase merge，最后一个问题是一千个排好序的文件，如果成为一个大的排序好的文件。大概这么多\n\n### 4. 第四个面试是上海同事推荐，两面技术，拿到 offer。\n\n一面电话：集合、threadlocal、锁、线程池。多态、继承、封装的理解，主要是基础，具体问的大概忘了，并不深入。  \n二面聊天：一问，nginx 实现负载均衡的方式，底层如何实现负载均衡，zk 的实际案例，为什么用 zk，内部如何选举。大概这么多。","slug":"tech/learn_what_how_why.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawa003kaxs69vubvn4i","content":"<h3 id=\"1-第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做-ERP-这类的系统，最后-HR-等年后通知就没通知了。\"><a href=\"#1-第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做-ERP-这类的系统，最后-HR-等年后通知就没通知了。\" class=\"headerlink\" title=\"1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。\"></a>1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。</h3><p>\b<br>主要问了 java 集合，包括里面 List、Set、Map 各个区别以及相关算法、Spring 的设计模式、Spring MVC 和 Servlet 的联系区别、Spring 的相关源码，我当时只说了 Spring MVC 启动、运行源码流程，@Autowire 注入的时候的 AutowireAnnotationBeanPostProcessor 的相关逻辑，顺带讲了 Bean 的生命周期，循环注入等，还有一些常见的面试题给忘了。</p>\n<h3 id=\"2-第二个面试是4-26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\"><a href=\"#2-第二个面试是4-26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\" class=\"headerlink\" title=\"2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\"></a>2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。</h3><p>一面先问 hashmap 的 put，currenthashmap 的 put，以及 size，然后是 ThreadLocal，订阅模式、命令模式、代理模式，sql，组合索引，手写一些 sql 问是否用到了索引，<br>手写一个 幻读，隔离级别与事务传播，那个幻读没写出来，然后被一面的面试官评价为基础可以但是 sql 不行，唉，然后问我最得意的项目，我说的是一个基于 ZooKeeper 的一个项目，然后问了 zk 的一些知识，两阶段提交、paxos（这个没答出来）、CAP、BASE，然后问如何实现一个分布式锁，然后问了项目的一些问题，涉及到了线程池。\b<br>二面直接让我把一个 BI 的项目技术架构图画出来，然后问 ETL ，RPC 和 http 的区别，然后其它一些小问题，跟我说要多敲代码，不是本专业只能要非常突出的代码能力才行。。。然后谈论了业务和技术，最后直接跟我说没过。比较奇怪没有问 JVM，可能是三面才会问这么高深的吧。。。<br>事后也把我做的项目都复习总结拿出来重新过了一遍，学了很多，然后好好复习，准备下一个面试。</p>\n<h3 id=\"3-第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到-offer-没去。\"><a href=\"#3-第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到-offer-没去。\" class=\"headerlink\" title=\"3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。\"></a>3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。</h3><p>笔试：两个类A extend B，考察静态方法和构造方法的执行顺序，二分查找法，mysql 的 having order 等。<br>技术面试，一问 hashmap 然后问简历项目。最后问多个线程同时下载报表如何下载。主问简历。<br>二轮BOS，一问 某个业务从请求到最后日志记录的业务全过程。然后聊了很多，treemap 和 hashmap，git rebase merge，最后一个问题是一千个排好序的文件，如果成为一个大的排序好的文件。大概这么多</p>\n<h3 id=\"4-第四个面试是上海同事推荐，两面技术，拿到-offer。\"><a href=\"#4-第四个面试是上海同事推荐，两面技术，拿到-offer。\" class=\"headerlink\" title=\"4. 第四个面试是上海同事推荐，两面技术，拿到 offer。\"></a>4. 第四个面试是上海同事推荐，两面技术，拿到 offer。</h3><p>一面电话：集合、threadlocal、锁、线程池。多态、继承、封装的理解，主要是基础，具体问的大概忘了，并不深入。<br>二面聊天：一问，nginx 实现负载均衡的方式，底层如何实现负载均衡，zk 的实际案例，为什么用 zk，内部如何选举。大概这么多。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做-ERP-这类的系统，最后-HR-等年后通知就没通知了。\"><a href=\"#1-第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做-ERP-这类的系统，最后-HR-等年后通知就没通知了。\" class=\"headerlink\" title=\"1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。\"></a>1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。</h3><p>\b<br>主要问了 java 集合，包括里面 List、Set、Map 各个区别以及相关算法、Spring 的设计模式、Spring MVC 和 Servlet 的联系区别、Spring 的相关源码，我当时只说了 Spring MVC 启动、运行源码流程，@Autowire 注入的时候的 AutowireAnnotationBeanPostProcessor 的相关逻辑，顺带讲了 Bean 的生命周期，循环注入等，还有一些常见的面试题给忘了。</p>\n<h3 id=\"2-第二个面试是4-26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\"><a href=\"#2-第二个面试是4-26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\" class=\"headerlink\" title=\"2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。\"></a>2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。</h3><p>一面先问 hashmap 的 put，currenthashmap 的 put，以及 size，然后是 ThreadLocal，订阅模式、命令模式、代理模式，sql，组合索引，手写一些 sql 问是否用到了索引，<br>手写一个 幻读，隔离级别与事务传播，那个幻读没写出来，然后被一面的面试官评价为基础可以但是 sql 不行，唉，然后问我最得意的项目，我说的是一个基于 ZooKeeper 的一个项目，然后问了 zk 的一些知识，两阶段提交、paxos（这个没答出来）、CAP、BASE，然后问如何实现一个分布式锁，然后问了项目的一些问题，涉及到了线程池。\b<br>二面直接让我把一个 BI 的项目技术架构图画出来，然后问 ETL ，RPC 和 http 的区别，然后其它一些小问题，跟我说要多敲代码，不是本专业只能要非常突出的代码能力才行。。。然后谈论了业务和技术，最后直接跟我说没过。比较奇怪没有问 JVM，可能是三面才会问这么高深的吧。。。<br>事后也把我做的项目都复习总结拿出来重新过了一遍，学了很多，然后好好复习，准备下一个面试。</p>\n<h3 id=\"3-第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到-offer-没去。\"><a href=\"#3-第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到-offer-没去。\" class=\"headerlink\" title=\"3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。\"></a>3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。</h3><p>笔试：两个类A extend B，考察静态方法和构造方法的执行顺序，二分查找法，mysql 的 having order 等。<br>技术面试，一问 hashmap 然后问简历项目。最后问多个线程同时下载报表如何下载。主问简历。<br>二轮BOS，一问 某个业务从请求到最后日志记录的业务全过程。然后聊了很多，treemap 和 hashmap，git rebase merge，最后一个问题是一千个排好序的文件，如果成为一个大的排序好的文件。大概这么多</p>\n<h3 id=\"4-第四个面试是上海同事推荐，两面技术，拿到-offer。\"><a href=\"#4-第四个面试是上海同事推荐，两面技术，拿到-offer。\" class=\"headerlink\" title=\"4. 第四个面试是上海同事推荐，两面技术，拿到 offer。\"></a>4. 第四个面试是上海同事推荐，两面技术，拿到 offer。</h3><p>一面电话：集合、threadlocal、锁、线程池。多态、继承、封装的理解，主要是基础，具体问的大概忘了，并不深入。<br>二面聊天：一问，nginx 实现负载均衡的方式，底层如何实现负载均衡，zk 的实际案例，为什么用 zk，内部如何选举。大概这么多。</p>\n"},{"title":"电影《内在美》有感~","date":"2017-11-15T03:50:00.000Z","updated":"2017-11-15T03:50:00.000Z","comments":1,"_content":"\n看完这部电影，不得不说，最后被男主拿出的戒指感动到了~戒指没有不见，它一直在那里。  \n回想女主第一次拒绝结婚的理由让人熟悉而又无奈，这不是我们每个男生都害怕听到的理由吗？  \n>**我还没有准备好**   \n  \n幸好，最后结局有情人终成眷属了。回想起剧情，就像溪水，可能会流的慢，但是总会流到那里。  \n  \n最后女主结婚的理由才像她自己：\n>我害怕世人眼光，但更害怕没有你的日子~\n\n啊~我需要买一个桌子，带音响的那种。\n\n---\n\n男主默默的制作家具，给人一种非常沉稳优雅的气质，不得不说，这个职业非常非常适合这个角色，在捷克依然孤独的与家居为伴，\n这不是真是我们吗？终日与代码为伴，但是我们也要沉稳、也要优雅\n>优雅的代码千篇一律，给人赏心悦目；肮脏代码各有不同，总会让你感叹，代码还能这么脏？！  \n\n---\n\ncode also can be elegant。","source":"_posts/闲聊/True Romance.md","raw":"---\ntitle: 电影《内在美》有感~\ndate: 2017-11-15 11:50:00\nupdated: 2017-11-15 11:50:00\ncomments: true\ncategories: \n- 闲聊\npermalink: talker/1.html    \n---\n\n看完这部电影，不得不说，最后被男主拿出的戒指感动到了~戒指没有不见，它一直在那里。  \n回想女主第一次拒绝结婚的理由让人熟悉而又无奈，这不是我们每个男生都害怕听到的理由吗？  \n>**我还没有准备好**   \n  \n幸好，最后结局有情人终成眷属了。回想起剧情，就像溪水，可能会流的慢，但是总会流到那里。  \n  \n最后女主结婚的理由才像她自己：\n>我害怕世人眼光，但更害怕没有你的日子~\n\n啊~我需要买一个桌子，带音响的那种。\n\n---\n\n男主默默的制作家具，给人一种非常沉稳优雅的气质，不得不说，这个职业非常非常适合这个角色，在捷克依然孤独的与家居为伴，\n这不是真是我们吗？终日与代码为伴，但是我们也要沉稳、也要优雅\n>优雅的代码千篇一律，给人赏心悦目；肮脏代码各有不同，总会让你感叹，代码还能这么脏？！  \n\n---\n\ncode also can be elegant。","slug":"talker/1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawb003maxs63ys7stlj","content":"<p>看完这部电影，不得不说，最后被男主拿出的戒指感动到了~戒指没有不见，它一直在那里。<br>回想女主第一次拒绝结婚的理由让人熟悉而又无奈，这不是我们每个男生都害怕听到的理由吗？  </p>\n<blockquote>\n<p><strong>我还没有准备好</strong>   </p>\n</blockquote>\n<p>幸好，最后结局有情人终成眷属了。回想起剧情，就像溪水，可能会流的慢，但是总会流到那里。  </p>\n<p>最后女主结婚的理由才像她自己：</p>\n<blockquote>\n<p>我害怕世人眼光，但更害怕没有你的日子~</p>\n</blockquote>\n<p>啊~我需要买一个桌子，带音响的那种。</p>\n<hr>\n<p>男主默默的制作家具，给人一种非常沉稳优雅的气质，不得不说，这个职业非常非常适合这个角色，在捷克依然孤独的与家居为伴，<br>这不是真是我们吗？终日与代码为伴，但是我们也要沉稳、也要优雅</p>\n<blockquote>\n<p>优雅的代码千篇一律，给人赏心悦目；肮脏代码各有不同，总会让你感叹，代码还能这么脏？！  </p>\n</blockquote>\n<hr>\n<p>code also can be elegant。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>看完这部电影，不得不说，最后被男主拿出的戒指感动到了~戒指没有不见，它一直在那里。<br>回想女主第一次拒绝结婚的理由让人熟悉而又无奈，这不是我们每个男生都害怕听到的理由吗？  </p>\n<blockquote>\n<p><strong>我还没有准备好</strong>   </p>\n</blockquote>\n<p>幸好，最后结局有情人终成眷属了。回想起剧情，就像溪水，可能会流的慢，但是总会流到那里。  </p>\n<p>最后女主结婚的理由才像她自己：</p>\n<blockquote>\n<p>我害怕世人眼光，但更害怕没有你的日子~</p>\n</blockquote>\n<p>啊~我需要买一个桌子，带音响的那种。</p>\n<hr>\n<p>男主默默的制作家具，给人一种非常沉稳优雅的气质，不得不说，这个职业非常非常适合这个角色，在捷克依然孤独的与家居为伴，<br>这不是真是我们吗？终日与代码为伴，但是我们也要沉稳、也要优雅</p>\n<blockquote>\n<p>优雅的代码千篇一律，给人赏心悦目；肮脏代码各有不同，总会让你感叹，代码还能这么脏？！  </p>\n</blockquote>\n<hr>\n<p>code also can be elegant。</p>\n"},{"title":"电影《一个叫欧维的男人决定去死》有感~","date":"2017-11-23T15:11:00.000Z","updated":"2017-11-23T15:11:00.000Z","comments":1,"_content":"\n整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  \n  \n他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。\n  \n他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。  \n  \n我以为应该是个美好结局。  \n\n“这才是人生”。 \n\n---\n\nlife is not easy. So is suicide.\n\n>《En Man Som Heter Ove》","source":"_posts/闲聊/En Man Som Heter Ove.md","raw":"---\ntitle: 电影《一个叫欧维的男人决定去死》有感~\ndate: 2017-11-23 23:11:00\nupdated: 2017-11-23 23:11:00\ncomments: true\ncategories: \n- 闲聊\npermalink: talker/2.html    \n---\n\n整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  \n  \n他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。\n  \n他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。  \n  \n我以为应该是个美好结局。  \n\n“这才是人生”。 \n\n---\n\nlife is not easy. So is suicide.\n\n>《En Man Som Heter Ove》","slug":"talker/2.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawc003paxs64ean5mtf","content":"<p>整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  </p>\n<p>他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。</p>\n<p>他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。  </p>\n<p>我以为应该是个美好结局。  </p>\n<p>“这才是人生”。 </p>\n<hr>\n<p>life is not easy. So is suicide.</p>\n<blockquote>\n<p>《En Man Som Heter Ove》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  </p>\n<p>他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。</p>\n<p>他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。  </p>\n<p>我以为应该是个美好结局。  </p>\n<p>“这才是人生”。 </p>\n<hr>\n<p>life is not easy. So is suicide.</p>\n<blockquote>\n<p>《En Man Som Heter Ove》</p>\n</blockquote>\n"},{"title":"电影《帕丁顿熊》有感","date":"2017-12-12T16:33:00.000Z","updated":"2017-12-12T16:33:00.000Z","comments":1,"_content":"\nPlease look after this bear, thank you.\n\n联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  \n\n每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  \n  \n---\n\n城市应该有它自己的包容心。","source":"_posts/闲聊/Paddington Bear.md","raw":"---\ntitle: 电影《帕丁顿熊》有感\ndate: 2017-12-13 00:33:00\nupdated: 2017-12-13 00:33:00\ncomments: true\ncategories: \n- 闲聊\npermalink: talker/paddington.html    \n---\n\nPlease look after this bear, thank you.\n\n联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  \n\n每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  \n  \n---\n\n城市应该有它自己的包容心。","slug":"talker/paddington.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawd003raxs62o6o93g4","content":"<p>Please look after this bear, thank you.</p>\n<p>联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  </p>\n<p>每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  </p>\n<hr>\n<p>城市应该有它自己的包容心。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Please look after this bear, thank you.</p>\n<p>联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  </p>\n<p>每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  </p>\n<hr>\n<p>城市应该有它自己的包容心。</p>\n"},{"title":"2017 总结","date":"2017-12-31T14:58:00.000Z","updated":"2017-12-31T14:58:00.000Z","comments":1,"_content":"\n书在 10.1 之后明显看的比以前多了，学的也比以前更多了，  \n看完书才发现，其实书籍比博客对初学者更友好，因为书是一个只是的体系，  \n它会完整的介绍某个技术，而不像博客，毕竟博客只有那么长，书却是一本，  \n感觉对我而言，书籍适合技术沉淀，博客适合应对工作。  \n但是，博客比书看的更轻松。  \n另外，虽然说有的书应该看第二遍，但是我个人觉得，  \n我现在应该多看点书，然后再从某些精华书选出值得看第二遍的书。  \n最近一个星期感觉看书看不进去，因此准备新年换个方式看书，  \n原来是一个章节一个章节的读，原因在于，我以前没尝试完完整整的读完一本书。  \n新的伪一年，截止到真正意义上的过年前，我尝试看书只写一篇笔记，  \n如果是偏代码的书籍，我会建议一个项目，并将思维导图以及代码放在 `github`，  \n这样一本书就变成了一个图和代码库，而本博客也变成总结的以及写些自己的感想，  \n例如，读书感想，以及在不同的技术点应该看什么书，当然，肯定是以我自己为准，  \n不然我都没看过，就介绍，那不就尴尬吗，而且有的书，是需要有某些技术的基础看的才会学习的更快。  \n新的一年，希望自己能朝着自己想要的方向发展。  \n\n","source":"_posts/闲聊/Mind.md","raw":"---\ntitle: 2017 总结\ndate: 2017-12-31 22:58:00\nupdated: 2017-12-31 22:58:00\ncomments: true\ncategories: \n- 闲聊\npermalink: talker/mind_1.html   \n---\n\n书在 10.1 之后明显看的比以前多了，学的也比以前更多了，  \n看完书才发现，其实书籍比博客对初学者更友好，因为书是一个只是的体系，  \n它会完整的介绍某个技术，而不像博客，毕竟博客只有那么长，书却是一本，  \n感觉对我而言，书籍适合技术沉淀，博客适合应对工作。  \n但是，博客比书看的更轻松。  \n另外，虽然说有的书应该看第二遍，但是我个人觉得，  \n我现在应该多看点书，然后再从某些精华书选出值得看第二遍的书。  \n最近一个星期感觉看书看不进去，因此准备新年换个方式看书，  \n原来是一个章节一个章节的读，原因在于，我以前没尝试完完整整的读完一本书。  \n新的伪一年，截止到真正意义上的过年前，我尝试看书只写一篇笔记，  \n如果是偏代码的书籍，我会建议一个项目，并将思维导图以及代码放在 `github`，  \n这样一本书就变成了一个图和代码库，而本博客也变成总结的以及写些自己的感想，  \n例如，读书感想，以及在不同的技术点应该看什么书，当然，肯定是以我自己为准，  \n不然我都没看过，就介绍，那不就尴尬吗，而且有的书，是需要有某些技术的基础看的才会学习的更快。  \n新的一年，希望自己能朝着自己想要的方向发展。  \n\n","slug":"talker/mind_1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawe003uaxs6s8txgk0t","content":"<p>书在 10.1 之后明显看的比以前多了，学的也比以前更多了，<br>看完书才发现，其实书籍比博客对初学者更友好，因为书是一个只是的体系，<br>它会完整的介绍某个技术，而不像博客，毕竟博客只有那么长，书却是一本，<br>感觉对我而言，书籍适合技术沉淀，博客适合应对工作。<br>但是，博客比书看的更轻松。<br>另外，虽然说有的书应该看第二遍，但是我个人觉得，<br>我现在应该多看点书，然后再从某些精华书选出值得看第二遍的书。<br>最近一个星期感觉看书看不进去，因此准备新年换个方式看书，<br>原来是一个章节一个章节的读，原因在于，我以前没尝试完完整整的读完一本书。<br>新的伪一年，截止到真正意义上的过年前，我尝试看书只写一篇笔记，<br>如果是偏代码的书籍，我会建议一个项目，并将思维导图以及代码放在 <code>github</code>，<br>这样一本书就变成了一个图和代码库，而本博客也变成总结的以及写些自己的感想，<br>例如，读书感想，以及在不同的技术点应该看什么书，当然，肯定是以我自己为准，<br>不然我都没看过，就介绍，那不就尴尬吗，而且有的书，是需要有某些技术的基础看的才会学习的更快。<br>新的一年，希望自己能朝着自己想要的方向发展。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>书在 10.1 之后明显看的比以前多了，学的也比以前更多了，<br>看完书才发现，其实书籍比博客对初学者更友好，因为书是一个只是的体系，<br>它会完整的介绍某个技术，而不像博客，毕竟博客只有那么长，书却是一本，<br>感觉对我而言，书籍适合技术沉淀，博客适合应对工作。<br>但是，博客比书看的更轻松。<br>另外，虽然说有的书应该看第二遍，但是我个人觉得，<br>我现在应该多看点书，然后再从某些精华书选出值得看第二遍的书。<br>最近一个星期感觉看书看不进去，因此准备新年换个方式看书，<br>原来是一个章节一个章节的读，原因在于，我以前没尝试完完整整的读完一本书。<br>新的伪一年，截止到真正意义上的过年前，我尝试看书只写一篇笔记，<br>如果是偏代码的书籍，我会建议一个项目，并将思维导图以及代码放在 <code>github</code>，<br>这样一本书就变成了一个图和代码库，而本博客也变成总结的以及写些自己的感想，<br>例如，读书感想，以及在不同的技术点应该看什么书，当然，肯定是以我自己为准，<br>不然我都没看过，就介绍，那不就尴尬吗，而且有的书，是需要有某些技术的基础看的才会学习的更快。<br>新的一年，希望自己能朝着自己想要的方向发展。  </p>\n"},{"title":"2018.06.09 同学聚会","date":"2018-06-01T15:00:00.000Z","updated":"2018-06-01T15:00:00.000Z","comments":1,"_content":"\n| 序号 | 名  | 达到日期 | 起始时间 | \b起始地点 | 车次号 | \b婚育概要 |\n| :-: | :-: |   :-:   |   :-:   |  :-:   |  :-:  |   :-:  | \n| 1 | 陈佳慧 | \b\b2018-06-08 | 全天 | 南京~南京 | \b无 | \b\b未婚 | \n| 2 | 孔令洲 | 2018-06-08 | 全天 | 南京~南京 | 无 | \b\b未婚 |\n| 3 | 高帅星 | 2018-06-08 | 全天 | 南京~南京 | 无 | \b\b未婚 |\n| 4 | 蒋鑫   | 2018-06-08 | 全天 | 南京~南京 | 无 | \b\b未婚 |\n| 5 | 王雨木 | 2018-06-08 | 16:10~18:45 | 长春~南京禄口 | \bDZ6258 | \b\b未婚 |\n| 6 | 黄菡璐 | 2018-06-08 | 20:09~22:10 | 义乌~南京南 | \bG1504 | \b\b未婚 |\n| 7 | 谢飘飘 | 2018-06-08 | 20:42~22:10 | 杭州东~南京南 | G1504 | \b\b未婚 |\n| 8 | 陈圳   | 2018-06-08 | 18:39~22:12 | 汉口~南京南 | D2374 | \b\b未婚 |\n| 9 | 吴琦薇 | 2018-06-08 | 20:35~22:27 | 上海~南京南 | G7286 | \b\b未婚 |\n| 10 | 李文广| 2018-06-08 | 20:35~22:27 | 上海~南京南 | G7286 | \b\b未婚 |\n| 11 | 孙任 | \b？ | ？ | ？| ？|  \b\b未婚 | \n| 12 | \b\b李婷婷 | \b？ | ？ | ？| ？|  \b\b未婚 | \n| 13 | 黄璐菡 | \b？ | ？ | ？| ？|  未婚 | ","source":"_posts/闲聊/聚会.md","raw":"---\ntitle: 2018.06.09 同学聚会\ndate: 2018-06-01 23:00:00\nupdated: 2018-06-01 23:00:00\ncomments: true\ncategories: \n- 闲聊\npermalink: talker/schoolmate01.html    \n---\n\n| 序号 | 名  | 达到日期 | 起始时间 | \b起始地点 | 车次号 | \b婚育概要 |\n| :-: | :-: |   :-:   |   :-:   |  :-:   |  :-:  |   :-:  | \n| 1 | 陈佳慧 | \b\b2018-06-08 | 全天 | 南京~南京 | \b无 | \b\b未婚 | \n| 2 | 孔令洲 | 2018-06-08 | 全天 | 南京~南京 | 无 | \b\b未婚 |\n| 3 | 高帅星 | 2018-06-08 | 全天 | 南京~南京 | 无 | \b\b未婚 |\n| 4 | 蒋鑫   | 2018-06-08 | 全天 | 南京~南京 | 无 | \b\b未婚 |\n| 5 | 王雨木 | 2018-06-08 | 16:10~18:45 | 长春~南京禄口 | \bDZ6258 | \b\b未婚 |\n| 6 | 黄菡璐 | 2018-06-08 | 20:09~22:10 | 义乌~南京南 | \bG1504 | \b\b未婚 |\n| 7 | 谢飘飘 | 2018-06-08 | 20:42~22:10 | 杭州东~南京南 | G1504 | \b\b未婚 |\n| 8 | 陈圳   | 2018-06-08 | 18:39~22:12 | 汉口~南京南 | D2374 | \b\b未婚 |\n| 9 | 吴琦薇 | 2018-06-08 | 20:35~22:27 | 上海~南京南 | G7286 | \b\b未婚 |\n| 10 | 李文广| 2018-06-08 | 20:35~22:27 | 上海~南京南 | G7286 | \b\b未婚 |\n| 11 | 孙任 | \b？ | ？ | ？| ？|  \b\b未婚 | \n| 12 | \b\b李婷婷 | \b？ | ？ | ？| ？|  \b\b未婚 | \n| 13 | 黄璐菡 | \b？ | ？ | ？| ？|  未婚 | ","slug":"talker/schoolmate01.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawf003waxs6zut8wdgw","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">名</th>\n<th style=\"text-align:center\">达到日期</th>\n<th style=\"text-align:center\">起始时间</th>\n<th style=\"text-align:center\">\b起始地点</th>\n<th style=\"text-align:center\">车次号</th>\n<th style=\"text-align:center\">\b婚育概要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">陈佳慧</td>\n<td style=\"text-align:center\">\b\b2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">\b无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">孔令洲</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">高帅星</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">蒋鑫</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">王雨木</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">16:10~18:45</td>\n<td style=\"text-align:center\">长春~南京禄口</td>\n<td style=\"text-align:center\">\bDZ6258</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">黄菡璐</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:09~22:10</td>\n<td style=\"text-align:center\">义乌~南京南</td>\n<td style=\"text-align:center\">\bG1504</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">谢飘飘</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:42~22:10</td>\n<td style=\"text-align:center\">杭州东~南京南</td>\n<td style=\"text-align:center\">G1504</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">陈圳</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">18:39~22:12</td>\n<td style=\"text-align:center\">汉口~南京南</td>\n<td style=\"text-align:center\">D2374</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">吴琦薇</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:35~22:27</td>\n<td style=\"text-align:center\">上海~南京南</td>\n<td style=\"text-align:center\">G7286</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">李文广</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:35~22:27</td>\n<td style=\"text-align:center\">上海~南京南</td>\n<td style=\"text-align:center\">G7286</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">孙任</td>\n<td style=\"text-align:center\">\b？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">\b\b李婷婷</td>\n<td style=\"text-align:center\">\b？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">黄璐菡</td>\n<td style=\"text-align:center\">\b？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">未婚</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">名</th>\n<th style=\"text-align:center\">达到日期</th>\n<th style=\"text-align:center\">起始时间</th>\n<th style=\"text-align:center\">\b起始地点</th>\n<th style=\"text-align:center\">车次号</th>\n<th style=\"text-align:center\">\b婚育概要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">陈佳慧</td>\n<td style=\"text-align:center\">\b\b2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">\b无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">孔令洲</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">高帅星</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">蒋鑫</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">全天</td>\n<td style=\"text-align:center\">南京~南京</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">王雨木</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">16:10~18:45</td>\n<td style=\"text-align:center\">长春~南京禄口</td>\n<td style=\"text-align:center\">\bDZ6258</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">黄菡璐</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:09~22:10</td>\n<td style=\"text-align:center\">义乌~南京南</td>\n<td style=\"text-align:center\">\bG1504</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">谢飘飘</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:42~22:10</td>\n<td style=\"text-align:center\">杭州东~南京南</td>\n<td style=\"text-align:center\">G1504</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">陈圳</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">18:39~22:12</td>\n<td style=\"text-align:center\">汉口~南京南</td>\n<td style=\"text-align:center\">D2374</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">吴琦薇</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:35~22:27</td>\n<td style=\"text-align:center\">上海~南京南</td>\n<td style=\"text-align:center\">G7286</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">李文广</td>\n<td style=\"text-align:center\">2018-06-08</td>\n<td style=\"text-align:center\">20:35~22:27</td>\n<td style=\"text-align:center\">上海~南京南</td>\n<td style=\"text-align:center\">G7286</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">孙任</td>\n<td style=\"text-align:center\">\b？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">\b\b李婷婷</td>\n<td style=\"text-align:center\">\b？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">\b\b未婚</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">黄璐菡</td>\n<td style=\"text-align:center\">\b？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">？</td>\n<td style=\"text-align:center\">未婚</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"阻塞队列的低版本实现","date":"2017-12-28T12:14:00.000Z","updated":"2017-12-28T12:14:00.000Z","comments":1,"_content":"\n在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  \n\n```java\npublic class SimulateBlockingQueue {\n\n    // 底层队列\n    private LinkedList list = new LinkedList();\n\n    // 队列数据的上下限\n    private final int minSize = 0;\n    private final int maxSize;\n\n    public SimulateBlockingQueue(int size) {\n        this.maxSize = size - 1;\n    }\n\n    private Object lock = new Object();\n\n    /**\n     * 存数据\n     * @param obj\n     */\n    public void put(Object obj) {\n        synchronized (lock) {\n            while (list.size() == this.maxSize) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            list.add(obj);\n            lock.notify();\n        }\n    }\n\n    /**\n     * 取数据\n     * @return\n     */\n    public Object get() {\n        Object result = null;\n        synchronized (lock) {\n            while (list.size() == this.minSize) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            result = list.removeFirst();\n            lock.notify();\n        }\n        return result;\n    }\n\n    public int getSize() {\n        return list.size();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final SimulateBlockingQueue mq = new SimulateBlockingQueue(5);\n\n        Thread t1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    mq.put(i);\n                    System.out.println(\"++增加：\" + i);\n                }\n            }\n        }, \"t1\");\n        t1.start();\n\n        Thread t2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    System.out.println(\"移除：\" + mq.get());\n                }\n            }\n        }, \"t2\");\n        t2.start();\n\n        TimeUnit.SECONDS.sleep(2);\n    }\n\n}\n```\n\n最后发现不是 list.size() 的问题，是打印的问题，代码改为如下：\n\n```java\npublic class SimulateBlockingQueue {\n\n    // 底层队列\n    private LinkedList list = new LinkedList();\n    // 原子性\n    private AtomicInteger count = new AtomicInteger(0);\n\n    // 队列数据的上下限\n    private final int minSize = 0;\n    private final int maxSize;\n\n\n    public SimulateBlockingQueue(int size) {\n        this.maxSize = size;\n    }\n\n    private Object lock = new Object();\n\n    /**\n     * 存数据\n     * @param obj\n     */\n    public void put(Object obj) {\n        synchronized (lock) {\n            while (list.size() == this.maxSize) {  // 对比可以使用count\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"++++增加：\" + obj);\n            list.add(obj);\n            count.incrementAndGet();\n            lock.notify();\n        }\n    }\n\n    /**\n     * 取数据\n     * @return\n     */\n    public Object get() {\n        Object result;\n        synchronized (lock) {\n            while (list.size() == this.minSize) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            result = list.removeFirst();\n            System.out.println(\"--移除：\" + result);\n            count.decrementAndGet();\n            lock.notify();\n        }\n        return result;\n    }\n\n    public int getSize() {\n        return list.size();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final SimulateBlockingQueue mq = new SimulateBlockingQueue(5);\n\n        Thread t1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    mq.put(i);\n                }\n            }\n        }, \"t1\");\n        t1.start();\n\n        Thread t2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    mq.get();\n                }\n            }\n        }, \"t2\");\n        t2.start();\n\n        TimeUnit.SECONDS.sleep(2);\n    }\n\n}\n```\n\n思路来源：https://www.jianshu.com/p/99b7ef411988","source":"_posts/闲聊/阻塞队列的低版本实现.md","raw":"---\ntitle: 阻塞队列的低版本实现\ndate: 2017-12-28 20:14:00\nupdated: 2017-12-28 20:14:00\ncomments: true\ncategories: \n- 读书笔记\n- 并发\npermalink: current/1.html    \n---\n\n在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  \n\n```java\npublic class SimulateBlockingQueue {\n\n    // 底层队列\n    private LinkedList list = new LinkedList();\n\n    // 队列数据的上下限\n    private final int minSize = 0;\n    private final int maxSize;\n\n    public SimulateBlockingQueue(int size) {\n        this.maxSize = size - 1;\n    }\n\n    private Object lock = new Object();\n\n    /**\n     * 存数据\n     * @param obj\n     */\n    public void put(Object obj) {\n        synchronized (lock) {\n            while (list.size() == this.maxSize) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            list.add(obj);\n            lock.notify();\n        }\n    }\n\n    /**\n     * 取数据\n     * @return\n     */\n    public Object get() {\n        Object result = null;\n        synchronized (lock) {\n            while (list.size() == this.minSize) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            result = list.removeFirst();\n            lock.notify();\n        }\n        return result;\n    }\n\n    public int getSize() {\n        return list.size();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final SimulateBlockingQueue mq = new SimulateBlockingQueue(5);\n\n        Thread t1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    mq.put(i);\n                    System.out.println(\"++增加：\" + i);\n                }\n            }\n        }, \"t1\");\n        t1.start();\n\n        Thread t2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    System.out.println(\"移除：\" + mq.get());\n                }\n            }\n        }, \"t2\");\n        t2.start();\n\n        TimeUnit.SECONDS.sleep(2);\n    }\n\n}\n```\n\n最后发现不是 list.size() 的问题，是打印的问题，代码改为如下：\n\n```java\npublic class SimulateBlockingQueue {\n\n    // 底层队列\n    private LinkedList list = new LinkedList();\n    // 原子性\n    private AtomicInteger count = new AtomicInteger(0);\n\n    // 队列数据的上下限\n    private final int minSize = 0;\n    private final int maxSize;\n\n\n    public SimulateBlockingQueue(int size) {\n        this.maxSize = size;\n    }\n\n    private Object lock = new Object();\n\n    /**\n     * 存数据\n     * @param obj\n     */\n    public void put(Object obj) {\n        synchronized (lock) {\n            while (list.size() == this.maxSize) {  // 对比可以使用count\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"++++增加：\" + obj);\n            list.add(obj);\n            count.incrementAndGet();\n            lock.notify();\n        }\n    }\n\n    /**\n     * 取数据\n     * @return\n     */\n    public Object get() {\n        Object result;\n        synchronized (lock) {\n            while (list.size() == this.minSize) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            result = list.removeFirst();\n            System.out.println(\"--移除：\" + result);\n            count.decrementAndGet();\n            lock.notify();\n        }\n        return result;\n    }\n\n    public int getSize() {\n        return list.size();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final SimulateBlockingQueue mq = new SimulateBlockingQueue(5);\n\n        Thread t1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    mq.put(i);\n                }\n            }\n        }, \"t1\");\n        t1.start();\n\n        Thread t2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    mq.get();\n                }\n            }\n        }, \"t2\");\n        t2.start();\n\n        TimeUnit.SECONDS.sleep(2);\n    }\n\n}\n```\n\n思路来源：https://www.jianshu.com/p/99b7ef411988","slug":"current/1.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawg003zaxs6c1y5wzhf","content":"<p>在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimulateBlockingQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 底层队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList list = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 队列数据的上下限</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> minSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimulateBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.maxSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            list.add(obj);</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Object result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.minSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result = list.removeFirst();</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimulateBlockingQueue mq = <span class=\"keyword\">new</span> SimulateBlockingQueue(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    mq.put(i);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"++增加：\"</span> + i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"移除：\"</span> + mq.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后发现不是 list.size() 的问题，是打印的问题，代码改为如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimulateBlockingQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 底层队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList list = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    <span class=\"comment\">// 原子性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 队列数据的上下限</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> minSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimulateBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.maxSize) &#123;  <span class=\"comment\">// 对比可以使用count</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"++++增加：\"</span> + obj);</span><br><span class=\"line\">            list.add(obj);</span><br><span class=\"line\">            count.incrementAndGet();</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Object result;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.minSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result = list.removeFirst();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"--移除：\"</span> + result);</span><br><span class=\"line\">            count.decrementAndGet();</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimulateBlockingQueue mq = <span class=\"keyword\">new</span> SimulateBlockingQueue(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    mq.put(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    mq.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路来源：<a href=\"https://www.jianshu.com/p/99b7ef411988\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/99b7ef411988</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimulateBlockingQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 底层队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList list = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 队列数据的上下限</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> minSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimulateBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.maxSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            list.add(obj);</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Object result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.minSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result = list.removeFirst();</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimulateBlockingQueue mq = <span class=\"keyword\">new</span> SimulateBlockingQueue(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    mq.put(i);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"++增加：\"</span> + i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"移除：\"</span> + mq.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后发现不是 list.size() 的问题，是打印的问题，代码改为如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimulateBlockingQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 底层队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList list = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    <span class=\"comment\">// 原子性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 队列数据的上下限</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> minSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxSize;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimulateBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxSize = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.maxSize) &#123;  <span class=\"comment\">// 对比可以使用count</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"++++增加：\"</span> + obj);</span><br><span class=\"line\">            list.add(obj);</span><br><span class=\"line\">            count.incrementAndGet();</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 取数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Object result;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (list.size() == <span class=\"keyword\">this</span>.minSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result = list.removeFirst();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"--移除：\"</span> + result);</span><br><span class=\"line\">            count.decrementAndGet();</span><br><span class=\"line\">            lock.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimulateBlockingQueue mq = <span class=\"keyword\">new</span> SimulateBlockingQueue(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    mq.put(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    mq.get();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路来源：<a href=\"https://www.jianshu.com/p/99b7ef411988\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/99b7ef411988</a></p>\n"},{"title":"五、创建高性能的索引","date":"2017-12-27T16:28:00.000Z","updated":"2017-12-27T16:28:00.000Z","comments":1,"_content":"\n索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。\n\n# 1 索引基础\n\n## 1.1 索引的类型\n\n在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准。即使多个存储引擎支持同一种类型的索引，其底层的事先也可能不同。\n\n### 1. B-Tree 索引\n\nInnoDB 本质是“B+Tree”。假设有如下数据表：  \n\n```sql\nCREATE TABLE People(\n    last_name  varchar(50)    not null,\n    first_name varchar(50)    not null,\n    dob        date           not null,\n    gender     enum('m', 'f') not null,\n    key(last_name, first_name, dob)\n)\n```\n\n对于表中的每一行数据，索引中包含了 last_name、first_name和 dob 列的值，下图显示了该索引是如何组织数据的存储的：  \n![][1]  \n注：索引对多个值进行排序的依据是`CREATE TABLE`语句中定义索引时列的顺序。\n\n1. 全值匹配：指和索引中的所有列进行匹配。\n2. 匹配最左前缀：前面提到的索引可用于查询所有姓为 Allen 的人，即只使用索引的第一列。\n3. 匹配列前缀：例如查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。\n4. 匹配范围值：例如查找姓在 Allen 和 Barrymore 之间的人。\n5. 精确匹配某一列并范围匹配另外一列：查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。\n6. 只访问索引的查询\n\n因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的`ORDER BY`操作（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果`ORDER BY`子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。  \n  \n下面是一些关于 B-Tree 索引的限制：\n- 如果不是按照索引的最左列开始查找，则无法使用索引。例，上面的例子的索引无法查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。这是关于`like '%关键字'`的知乎讨论：https://www.zhihu.com/question/52718330?sort=created\n- 不能跳过索引中的列。\n- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。\n\n有些限制并不是 B-Tree 本身导致的，而是 MySQL 优化器和存储引擎使用索引的方式导致的，这部分限制在未来的版本中可能就不再是限制了。\n\b\n### 2. 哈希索引\n\n哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。  \n\n1. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况这一点对性能的影响并不明显。\n2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。\n3. 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例，在（A,B）建立哈希索引，如果查询只有 A ，则无法使用该索引。\n4. 访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针。\n\n当字段过大，例如存储 URL 时，可以额外使用一个列，用于存储该列的哈希，用于排序。但为了避免哈希冲突的问题，需要`where url = 'http://www.mysql.com' AND url_crc=CRC32('http://www.mysql.com')`，这样的性能会非常高。（可以使用触发器来自身插入哈希列）。\n\n### 3. 空间数据索引（R-Tree）\n\nMyISAM 表支持空间索引。\n\n### 4. 全文索引\n\n使用`MATCH AGAINST`操作，而不是普通的`WHERE`。\n\n# 2 索引的优点\n\n最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 `ORDER BY` 和 `GROUP BY` 操作。因为数据时有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询：  \n1. 索引大大减少了服务器需要扫描的数据量。\n2. 索引可以帮助服务器避免排序和临时表。\n3. 索引可以将随机 I/O 变为顺序 I/O。\n\n对于中到大型表，索引就非常有效。但对于特大型表，需要技术直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例，分区技术：建立元数据信息表，例，假如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。\n\n# 3 高性能索引的索引策略\n\n## 3.1 前缀索引和索引选择性\n\n索引选择性：不重复的索引值/数据表的记录总数，范围在0~1间，越高则查询越快。唯一索引的选择性是1，性能也是最好的。  \n列值过长，可以使用部分字段`LEFT(city,3)`作为前缀索引，这个值是通过`COUNT(DISTINCT LEFT(city,5))/COUNT(*)`的值来决定的，结果在 0.031 基本上就可用了。接着创建：`ALTER TABLE sakila.city_demo ADD KEY(city(5));`  \n但是前缀索引虽然使索引更小、更快，但是无法使用前缀索引做`ORDER BY`和`GROUP BY`，也无法使用前缀索引做覆盖扫描。\n>后缀索引（suffix index）也很有用途（电子邮箱），可以使用字符串反转后存储。\n\n## 3.2 多列索引\n\n为每个列创建独立的索引，从`SHOW CREATE TABLE`中很容易看到这种情况：\n\n```sql\nCREATE TABLE t(\n    c1 INT,\n    c2 INT,\n    c3 INT,\n    key(c1),\n    key(c2),\n    key(c3)\n)\n```\n\n这种索引策略是由于“把 WHERE 条件里面的列都建上索引”这样模糊的建议导致的。这最多是“一星”索引。例，`WHERE c1 = '1' OR c2 = '2'`，虽然在 MySQL5.0+ 会优化使用这两个索引，但是在 `explain` 的 `extra` 中会有 `Using union`，因此说明了索引的糟糕：  \n1. 出现多个 `AND` 条件，则需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。\n2. 多个 `OR` 或者联合操作时，如果有些索引的选择性不高，需要合并扫描返回的大量数据。\n3. 如果在 `EXPLAIN` 中看到有索引合并，应该好好检查查询和表的结构，也可以通过参数 `optimizer_switch` 来关闭索引合并功能，也可以使用 `IGNORE INDEX` 提示让优化器忽略掉某些索引。\n\n## 3.3 选择合适的索引列顺序\n \n最好通过 `pt-query-digest` 这样的工具报告重提取“最差”查询，再按照索引顺序进行优化。如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局性和选择性，而不是某个具体查询：  \n![][2]  \n`customer_id` 的选择性更高，所以答案是将其作为索引列的第一列。\n\n## 3.4 覆盖索引\n\n如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”。  \n1. 因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。\n2. 并不是所有类型的索引都可以称为覆盖索引。覆盖索引必须要存储索引列的值。\n\n当发起一个被覆盖的查询，在 `EXPLAIN` 的 `Extra` 列可以看到 `Using index` 的信息。\n>`type` 列的 `index` 和 `Extra` 列的 `Using index` 是完全不同，前者和覆盖索引毫无关系，它只是表示这个查询访问数据的方式。\n\n索引覆盖查询还有很多陷阱可能导致无法实现优化：  \n![][3]  \n1. 没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。\n2. MySQL 不能再索引中执行 `LIKE` 操作，MySQL5.5- 只允许在索引中做简单比较操作，MySQL 能在索引中做最左前缀匹配的 `LIKE` 查询，因为该操作可以转为简单的比较操作，但是如果是通配符开头的 `LIKE` 查询，存储引擎就无法做比较匹配。这种情况下，MySQL 服务器只能提取数据行的值，而不是索引值来做比较。\n\n也有办法解决上面说的两个问题，重写查询并巧妙地设计索引。先将索引扩展至三个数据列（artist，title，prod_id），然后按如下方式重写查询：  \n![][4]\n\n## 3.5 使用索引扫描来做排序\n\nMySQL 有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描；如果 `EXPLAIN` 出来的 type 列的值为 “index”，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）。  \n扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。  \n如果查询需要关联多张表，则只有当 `ORDER BY` 子句引用的字段全部为第一个表时，才能使用索引做排序。\n  \n例： \n\n```sql\nCREATE TABLE rental(\n    PRIMARY KEY(rental_id),\n    UNIQUE KEY rental_date(rental_date, inventory_id, customer_id),\n    KEY idx_fk_inventory_id(inventory_id),\n    KEY idx_fk_customer_id(customer_id),\n    KEY idx_fk_staff_id(staff_id),\n    ...\n)\n```\n\n`WHERE rental_date = '2015-05-25' ORDER BY inventory_id, customer_id` 因为索引第一列被指定为一个常数，所以查询排序。  \n`WHERE rental_date = '2015-05-25' ORDER BY inventory_id` 也可以使用查询排序。  \n`WHERE rental_date > '2005-05-25 ORDER BY rental_date, inventory_id` 也可以。  \n下面是不能使用索引做排序的查询：  \n1. `WHERE rental_date = '2015-05-25' ORDER BY inventory_id DESC, customer_id ASC;` 因为索引列都是正序排序。\n2. `WHERE rental_date = '2015-05-25' ORDER BY inventory_id, staff_id;` 因为引用了一个不再索引中的列。\n3. `WHERE rental_date = '2015-05-25' ORDER BY customer_id;` 无法组成索引的最左前缀。\n4. `WHERE rental_date > '2015-05-25' ORDER BY inventory_id, customer_id;` 因为第一列上是范围条件。\n5. `WHERE rental_date = '2015-05-25' AND inventory_id IN (1,2) ORDER BY customer_id;` 还是范围查询。\n\n# 4 索引案例学习\n\n# 5 维护索引和表\n\n# 6 总结\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_4.png","source":"_posts/高性能 MySQL/第五章 创建高性能的索引.md","raw":"---\ntitle: 五、创建高性能的索引\ndate: 2017-12-28 00:28:00\nupdated: 2017-12-28 00:28:00\ncomments: true\ncategories: \n- 读书笔记\n- 高性能MySQL\npermalink: high_performance_MySQL/5.html    \n---\n\n索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。\n\n# 1 索引基础\n\n## 1.1 索引的类型\n\n在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准。即使多个存储引擎支持同一种类型的索引，其底层的事先也可能不同。\n\n### 1. B-Tree 索引\n\nInnoDB 本质是“B+Tree”。假设有如下数据表：  \n\n```sql\nCREATE TABLE People(\n    last_name  varchar(50)    not null,\n    first_name varchar(50)    not null,\n    dob        date           not null,\n    gender     enum('m', 'f') not null,\n    key(last_name, first_name, dob)\n)\n```\n\n对于表中的每一行数据，索引中包含了 last_name、first_name和 dob 列的值，下图显示了该索引是如何组织数据的存储的：  \n![][1]  \n注：索引对多个值进行排序的依据是`CREATE TABLE`语句中定义索引时列的顺序。\n\n1. 全值匹配：指和索引中的所有列进行匹配。\n2. 匹配最左前缀：前面提到的索引可用于查询所有姓为 Allen 的人，即只使用索引的第一列。\n3. 匹配列前缀：例如查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。\n4. 匹配范围值：例如查找姓在 Allen 和 Barrymore 之间的人。\n5. 精确匹配某一列并范围匹配另外一列：查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。\n6. 只访问索引的查询\n\n因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的`ORDER BY`操作（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果`ORDER BY`子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。  \n  \n下面是一些关于 B-Tree 索引的限制：\n- 如果不是按照索引的最左列开始查找，则无法使用索引。例，上面的例子的索引无法查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。这是关于`like '%关键字'`的知乎讨论：https://www.zhihu.com/question/52718330?sort=created\n- 不能跳过索引中的列。\n- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。\n\n有些限制并不是 B-Tree 本身导致的，而是 MySQL 优化器和存储引擎使用索引的方式导致的，这部分限制在未来的版本中可能就不再是限制了。\n\b\n### 2. 哈希索引\n\n哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。  \n\n1. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况这一点对性能的影响并不明显。\n2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。\n3. 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例，在（A,B）建立哈希索引，如果查询只有 A ，则无法使用该索引。\n4. 访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针。\n\n当字段过大，例如存储 URL 时，可以额外使用一个列，用于存储该列的哈希，用于排序。但为了避免哈希冲突的问题，需要`where url = 'http://www.mysql.com' AND url_crc=CRC32('http://www.mysql.com')`，这样的性能会非常高。（可以使用触发器来自身插入哈希列）。\n\n### 3. 空间数据索引（R-Tree）\n\nMyISAM 表支持空间索引。\n\n### 4. 全文索引\n\n使用`MATCH AGAINST`操作，而不是普通的`WHERE`。\n\n# 2 索引的优点\n\n最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 `ORDER BY` 和 `GROUP BY` 操作。因为数据时有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询：  \n1. 索引大大减少了服务器需要扫描的数据量。\n2. 索引可以帮助服务器避免排序和临时表。\n3. 索引可以将随机 I/O 变为顺序 I/O。\n\n对于中到大型表，索引就非常有效。但对于特大型表，需要技术直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例，分区技术：建立元数据信息表，例，假如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。\n\n# 3 高性能索引的索引策略\n\n## 3.1 前缀索引和索引选择性\n\n索引选择性：不重复的索引值/数据表的记录总数，范围在0~1间，越高则查询越快。唯一索引的选择性是1，性能也是最好的。  \n列值过长，可以使用部分字段`LEFT(city,3)`作为前缀索引，这个值是通过`COUNT(DISTINCT LEFT(city,5))/COUNT(*)`的值来决定的，结果在 0.031 基本上就可用了。接着创建：`ALTER TABLE sakila.city_demo ADD KEY(city(5));`  \n但是前缀索引虽然使索引更小、更快，但是无法使用前缀索引做`ORDER BY`和`GROUP BY`，也无法使用前缀索引做覆盖扫描。\n>后缀索引（suffix index）也很有用途（电子邮箱），可以使用字符串反转后存储。\n\n## 3.2 多列索引\n\n为每个列创建独立的索引，从`SHOW CREATE TABLE`中很容易看到这种情况：\n\n```sql\nCREATE TABLE t(\n    c1 INT,\n    c2 INT,\n    c3 INT,\n    key(c1),\n    key(c2),\n    key(c3)\n)\n```\n\n这种索引策略是由于“把 WHERE 条件里面的列都建上索引”这样模糊的建议导致的。这最多是“一星”索引。例，`WHERE c1 = '1' OR c2 = '2'`，虽然在 MySQL5.0+ 会优化使用这两个索引，但是在 `explain` 的 `extra` 中会有 `Using union`，因此说明了索引的糟糕：  \n1. 出现多个 `AND` 条件，则需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。\n2. 多个 `OR` 或者联合操作时，如果有些索引的选择性不高，需要合并扫描返回的大量数据。\n3. 如果在 `EXPLAIN` 中看到有索引合并，应该好好检查查询和表的结构，也可以通过参数 `optimizer_switch` 来关闭索引合并功能，也可以使用 `IGNORE INDEX` 提示让优化器忽略掉某些索引。\n\n## 3.3 选择合适的索引列顺序\n \n最好通过 `pt-query-digest` 这样的工具报告重提取“最差”查询，再按照索引顺序进行优化。如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局性和选择性，而不是某个具体查询：  \n![][2]  \n`customer_id` 的选择性更高，所以答案是将其作为索引列的第一列。\n\n## 3.4 覆盖索引\n\n如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”。  \n1. 因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。\n2. 并不是所有类型的索引都可以称为覆盖索引。覆盖索引必须要存储索引列的值。\n\n当发起一个被覆盖的查询，在 `EXPLAIN` 的 `Extra` 列可以看到 `Using index` 的信息。\n>`type` 列的 `index` 和 `Extra` 列的 `Using index` 是完全不同，前者和覆盖索引毫无关系，它只是表示这个查询访问数据的方式。\n\n索引覆盖查询还有很多陷阱可能导致无法实现优化：  \n![][3]  \n1. 没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。\n2. MySQL 不能再索引中执行 `LIKE` 操作，MySQL5.5- 只允许在索引中做简单比较操作，MySQL 能在索引中做最左前缀匹配的 `LIKE` 查询，因为该操作可以转为简单的比较操作，但是如果是通配符开头的 `LIKE` 查询，存储引擎就无法做比较匹配。这种情况下，MySQL 服务器只能提取数据行的值，而不是索引值来做比较。\n\n也有办法解决上面说的两个问题，重写查询并巧妙地设计索引。先将索引扩展至三个数据列（artist，title，prod_id），然后按如下方式重写查询：  \n![][4]\n\n## 3.5 使用索引扫描来做排序\n\nMySQL 有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描；如果 `EXPLAIN` 出来的 type 列的值为 “index”，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）。  \n扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。  \n如果查询需要关联多张表，则只有当 `ORDER BY` 子句引用的字段全部为第一个表时，才能使用索引做排序。\n  \n例： \n\n```sql\nCREATE TABLE rental(\n    PRIMARY KEY(rental_id),\n    UNIQUE KEY rental_date(rental_date, inventory_id, customer_id),\n    KEY idx_fk_inventory_id(inventory_id),\n    KEY idx_fk_customer_id(customer_id),\n    KEY idx_fk_staff_id(staff_id),\n    ...\n)\n```\n\n`WHERE rental_date = '2015-05-25' ORDER BY inventory_id, customer_id` 因为索引第一列被指定为一个常数，所以查询排序。  \n`WHERE rental_date = '2015-05-25' ORDER BY inventory_id` 也可以使用查询排序。  \n`WHERE rental_date > '2005-05-25 ORDER BY rental_date, inventory_id` 也可以。  \n下面是不能使用索引做排序的查询：  \n1. `WHERE rental_date = '2015-05-25' ORDER BY inventory_id DESC, customer_id ASC;` 因为索引列都是正序排序。\n2. `WHERE rental_date = '2015-05-25' ORDER BY inventory_id, staff_id;` 因为引用了一个不再索引中的列。\n3. `WHERE rental_date = '2015-05-25' ORDER BY customer_id;` 无法组成索引的最左前缀。\n4. `WHERE rental_date > '2015-05-25' ORDER BY inventory_id, customer_id;` 因为第一列上是范围条件。\n5. `WHERE rental_date = '2015-05-25' AND inventory_id IN (1,2) ORDER BY customer_id;` 还是范围查询。\n\n# 4 索引案例学习\n\n# 5 维护索引和表\n\n# 6 总结\n\n\n[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_1.png\n[2]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_2.png\n[3]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_3.png\n[4]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_4.png","slug":"high_performance_MySQL/5.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawh0041axs6sng4ayho","content":"<p>索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。</p>\n<h1 id=\"1-索引基础\"><a href=\"#1-索引基础\" class=\"headerlink\" title=\"1 索引基础\"></a>1 索引基础</h1><h2 id=\"1-1-索引的类型\"><a href=\"#1-1-索引的类型\" class=\"headerlink\" title=\"1.1 索引的类型\"></a>1.1 索引的类型</h2><p>在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准。即使多个存储引擎支持同一种类型的索引，其底层的事先也可能不同。</p>\n<h3 id=\"1-B-Tree-索引\"><a href=\"#1-B-Tree-索引\" class=\"headerlink\" title=\"1. B-Tree 索引\"></a>1. B-Tree 索引</h3><p>InnoDB 本质是“B+Tree”。假设有如下数据表：  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> People(</span><br><span class=\"line\">    last_name  <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>)    <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    first_name <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>)    <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    dob        <span class=\"built_in\">date</span>           <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    gender     enum(<span class=\"string\">'m'</span>, <span class=\"string\">'f'</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(last_name, first_name, dob)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>对于表中的每一行数据，索引中包含了 last_name、first_name和 dob 列的值，下图显示了该索引是如何组织数据的存储的：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_1.png\" alt=\"\"><br>注：索引对多个值进行排序的依据是<code>CREATE TABLE</code>语句中定义索引时列的顺序。</p>\n<ol>\n<li>全值匹配：指和索引中的所有列进行匹配。</li>\n<li>匹配最左前缀：前面提到的索引可用于查询所有姓为 Allen 的人，即只使用索引的第一列。</li>\n<li>匹配列前缀：例如查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。</li>\n<li>匹配范围值：例如查找姓在 Allen 和 Barrymore 之间的人。</li>\n<li>精确匹配某一列并范围匹配另外一列：查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</li>\n<li>只访问索引的查询</li>\n</ol>\n<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的<code>ORDER BY</code>操作（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果<code>ORDER BY</code>子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。  </p>\n<p>下面是一些关于 B-Tree 索引的限制：</p>\n<ul>\n<li>如果不是按照索引的最左列开始查找，则无法使用索引。例，上面的例子的索引无法查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。这是关于<code>like &#39;%关键字&#39;</code>的知乎讨论：<a href=\"https://www.zhihu.com/question/52718330?sort=created\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/52718330?sort=created</a></li>\n<li>不能跳过索引中的列。</li>\n<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。</li>\n</ul>\n<p>有些限制并不是 B-Tree 本身导致的，而是 MySQL 优化器和存储引擎使用索引的方式导致的，这部分限制在未来的版本中可能就不再是限制了。<br>\b</p>\n<h3 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h3><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。  </p>\n<ol>\n<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况这一点对性能的影响并不明显。</li>\n<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>\n<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例，在（A,B）建立哈希索引，如果查询只有 A ，则无法使用该索引。</li>\n<li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针。</li>\n</ol>\n<p>当字段过大，例如存储 URL 时，可以额外使用一个列，用于存储该列的哈希，用于排序。但为了避免哈希冲突的问题，需要<code>where url = &#39;http://www.mysql.com&#39; AND url_crc=CRC32(&#39;http://www.mysql.com&#39;)</code>，这样的性能会非常高。（可以使用触发器来自身插入哈希列）。</p>\n<h3 id=\"3-空间数据索引（R-Tree）\"><a href=\"#3-空间数据索引（R-Tree）\" class=\"headerlink\" title=\"3. 空间数据索引（R-Tree）\"></a>3. 空间数据索引（R-Tree）</h3><p>MyISAM 表支持空间索引。</p>\n<h3 id=\"4-全文索引\"><a href=\"#4-全文索引\" class=\"headerlink\" title=\"4. 全文索引\"></a>4. 全文索引</h3><p>使用<code>MATCH AGAINST</code>操作，而不是普通的<code>WHERE</code>。</p>\n<h1 id=\"2-索引的优点\"><a href=\"#2-索引的优点\" class=\"headerlink\" title=\"2 索引的优点\"></a>2 索引的优点</h1><p>最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据时有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询：  </p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量。</li>\n<li>索引可以帮助服务器避免排序和临时表。</li>\n<li>索引可以将随机 I/O 变为顺序 I/O。</li>\n</ol>\n<p>对于中到大型表，索引就非常有效。但对于特大型表，需要技术直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例，分区技术：建立元数据信息表，例，假如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。</p>\n<h1 id=\"3-高性能索引的索引策略\"><a href=\"#3-高性能索引的索引策略\" class=\"headerlink\" title=\"3 高性能索引的索引策略\"></a>3 高性能索引的索引策略</h1><h2 id=\"3-1-前缀索引和索引选择性\"><a href=\"#3-1-前缀索引和索引选择性\" class=\"headerlink\" title=\"3.1 前缀索引和索引选择性\"></a>3.1 前缀索引和索引选择性</h2><p>索引选择性：不重复的索引值/数据表的记录总数，范围在0~1间，越高则查询越快。唯一索引的选择性是1，性能也是最好的。<br>列值过长，可以使用部分字段<code>LEFT(city,3)</code>作为前缀索引，这个值是通过<code>COUNT(DISTINCT LEFT(city,5))/COUNT(*)</code>的值来决定的，结果在 0.031 基本上就可用了。接着创建：<code>ALTER TABLE sakila.city_demo ADD KEY(city(5));</code><br>但是前缀索引虽然使索引更小、更快，但是无法使用前缀索引做<code>ORDER BY</code>和<code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。</p>\n<blockquote>\n<p>后缀索引（suffix index）也很有用途（电子邮箱），可以使用字符串反转后存储。</p>\n</blockquote>\n<h2 id=\"3-2-多列索引\"><a href=\"#3-2-多列索引\" class=\"headerlink\" title=\"3.2 多列索引\"></a>3.2 多列索引</h2><p>为每个列创建独立的索引，从<code>SHOW CREATE TABLE</code>中很容易看到这种情况：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t(</span><br><span class=\"line\">    c1 <span class=\"built_in\">INT</span>,</span><br><span class=\"line\">    c2 <span class=\"built_in\">INT</span>,</span><br><span class=\"line\">    c3 <span class=\"built_in\">INT</span>,</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(c1),</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(c2),</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(c3)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这种索引策略是由于“把 WHERE 条件里面的列都建上索引”这样模糊的建议导致的。这最多是“一星”索引。例，<code>WHERE c1 = &#39;1&#39; OR c2 = &#39;2&#39;</code>，虽然在 MySQL5.0+ 会优化使用这两个索引，但是在 <code>explain</code> 的 <code>extra</code> 中会有 <code>Using union</code>，因此说明了索引的糟糕：  </p>\n<ol>\n<li>出现多个 <code>AND</code> 条件，则需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li>\n<li>多个 <code>OR</code> 或者联合操作时，如果有些索引的选择性不高，需要合并扫描返回的大量数据。</li>\n<li>如果在 <code>EXPLAIN</code> 中看到有索引合并，应该好好检查查询和表的结构，也可以通过参数 <code>optimizer_switch</code> 来关闭索引合并功能，也可以使用 <code>IGNORE INDEX</code> 提示让优化器忽略掉某些索引。</li>\n</ol>\n<h2 id=\"3-3-选择合适的索引列顺序\"><a href=\"#3-3-选择合适的索引列顺序\" class=\"headerlink\" title=\"3.3 选择合适的索引列顺序\"></a>3.3 选择合适的索引列顺序</h2><p>最好通过 <code>pt-query-digest</code> 这样的工具报告重提取“最差”查询，再按照索引顺序进行优化。如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局性和选择性，而不是某个具体查询：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_2.png\" alt=\"\"><br><code>customer_id</code> 的选择性更高，所以答案是将其作为索引列的第一列。</p>\n<h2 id=\"3-4-覆盖索引\"><a href=\"#3-4-覆盖索引\" class=\"headerlink\" title=\"3.4 覆盖索引\"></a>3.4 覆盖索引</h2><p>如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”。  </p>\n<ol>\n<li>因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。</li>\n<li>并不是所有类型的索引都可以称为覆盖索引。覆盖索引必须要存储索引列的值。</li>\n</ol>\n<p>当发起一个被覆盖的查询，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>Using index</code> 的信息。</p>\n<blockquote>\n<p><code>type</code> 列的 <code>index</code> 和 <code>Extra</code> 列的 <code>Using index</code> 是完全不同，前者和覆盖索引毫无关系，它只是表示这个查询访问数据的方式。</p>\n</blockquote>\n<p>索引覆盖查询还有很多陷阱可能导致无法实现优化：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_3.png\" alt=\"\">  </p>\n<ol>\n<li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。</li>\n<li>MySQL 不能再索引中执行 <code>LIKE</code> 操作，MySQL5.5- 只允许在索引中做简单比较操作，MySQL 能在索引中做最左前缀匹配的 <code>LIKE</code> 查询，因为该操作可以转为简单的比较操作，但是如果是通配符开头的 <code>LIKE</code> 查询，存储引擎就无法做比较匹配。这种情况下，MySQL 服务器只能提取数据行的值，而不是索引值来做比较。</li>\n</ol>\n<p>也有办法解决上面说的两个问题，重写查询并巧妙地设计索引。先将索引扩展至三个数据列（artist，title，prod_id），然后按如下方式重写查询：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_4.png\" alt=\"\"></p>\n<h2 id=\"3-5-使用索引扫描来做排序\"><a href=\"#3-5-使用索引扫描来做排序\" class=\"headerlink\" title=\"3.5 使用索引扫描来做排序\"></a>3.5 使用索引扫描来做排序</h2><p>MySQL 有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描；如果 <code>EXPLAIN</code> 出来的 type 列的值为 “index”，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）。<br>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。<br>如果查询需要关联多张表，则只有当 <code>ORDER BY</code> 子句引用的字段全部为第一个表时，才能使用索引做排序。</p>\n<p>例： </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> rental(</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span>(rental_id),</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> rental_date(rental_date, inventory_id, customer_id),</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_fk_inventory_id(inventory_id),</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_fk_customer_id(customer_id),</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_fk_staff_id(staff_id),</span><br><span class=\"line\">    ...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id</code> 因为索引第一列被指定为一个常数，所以查询排序。<br><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id</code> 也可以使用查询排序。<br><code>WHERE rental_date &gt; &#39;2005-05-25 ORDER BY rental_date, inventory_id</code> 也可以。<br>下面是不能使用索引做排序的查询：  </p>\n<ol>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id DESC, customer_id ASC;</code> 因为索引列都是正序排序。</li>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, staff_id;</code> 因为引用了一个不再索引中的列。</li>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY customer_id;</code> 无法组成索引的最左前缀。</li>\n<li><code>WHERE rental_date &gt; &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id;</code> 因为第一列上是范围条件。</li>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; AND inventory_id IN (1,2) ORDER BY customer_id;</code> 还是范围查询。</li>\n</ol>\n<h1 id=\"4-索引案例学习\"><a href=\"#4-索引案例学习\" class=\"headerlink\" title=\"4 索引案例学习\"></a>4 索引案例学习</h1><h1 id=\"5-维护索引和表\"><a href=\"#5-维护索引和表\" class=\"headerlink\" title=\"5 维护索引和表\"></a>5 维护索引和表</h1><h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h1>","site":{"data":{}},"excerpt":"","more":"<p>索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。</p>\n<h1 id=\"1-索引基础\"><a href=\"#1-索引基础\" class=\"headerlink\" title=\"1 索引基础\"></a>1 索引基础</h1><h2 id=\"1-1-索引的类型\"><a href=\"#1-1-索引的类型\" class=\"headerlink\" title=\"1.1 索引的类型\"></a>1.1 索引的类型</h2><p>在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准。即使多个存储引擎支持同一种类型的索引，其底层的事先也可能不同。</p>\n<h3 id=\"1-B-Tree-索引\"><a href=\"#1-B-Tree-索引\" class=\"headerlink\" title=\"1. B-Tree 索引\"></a>1. B-Tree 索引</h3><p>InnoDB 本质是“B+Tree”。假设有如下数据表：  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> People(</span><br><span class=\"line\">    last_name  <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>)    <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    first_name <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>)    <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    dob        <span class=\"built_in\">date</span>           <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    gender     enum(<span class=\"string\">'m'</span>, <span class=\"string\">'f'</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(last_name, first_name, dob)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>对于表中的每一行数据，索引中包含了 last_name、first_name和 dob 列的值，下图显示了该索引是如何组织数据的存储的：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_1.png\" alt=\"\"><br>注：索引对多个值进行排序的依据是<code>CREATE TABLE</code>语句中定义索引时列的顺序。</p>\n<ol>\n<li>全值匹配：指和索引中的所有列进行匹配。</li>\n<li>匹配最左前缀：前面提到的索引可用于查询所有姓为 Allen 的人，即只使用索引的第一列。</li>\n<li>匹配列前缀：例如查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。</li>\n<li>匹配范围值：例如查找姓在 Allen 和 Barrymore 之间的人。</li>\n<li>精确匹配某一列并范围匹配另外一列：查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</li>\n<li>只访问索引的查询</li>\n</ol>\n<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的<code>ORDER BY</code>操作（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果<code>ORDER BY</code>子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。  </p>\n<p>下面是一些关于 B-Tree 索引的限制：</p>\n<ul>\n<li>如果不是按照索引的最左列开始查找，则无法使用索引。例，上面的例子的索引无法查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。这是关于<code>like &#39;%关键字&#39;</code>的知乎讨论：<a href=\"https://www.zhihu.com/question/52718330?sort=created\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/52718330?sort=created</a></li>\n<li>不能跳过索引中的列。</li>\n<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。</li>\n</ul>\n<p>有些限制并不是 B-Tree 本身导致的，而是 MySQL 优化器和存储引擎使用索引的方式导致的，这部分限制在未来的版本中可能就不再是限制了。<br>\b</p>\n<h3 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h3><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。  </p>\n<ol>\n<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况这一点对性能的影响并不明显。</li>\n<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>\n<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例，在（A,B）建立哈希索引，如果查询只有 A ，则无法使用该索引。</li>\n<li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针。</li>\n</ol>\n<p>当字段过大，例如存储 URL 时，可以额外使用一个列，用于存储该列的哈希，用于排序。但为了避免哈希冲突的问题，需要<code>where url = &#39;http://www.mysql.com&#39; AND url_crc=CRC32(&#39;http://www.mysql.com&#39;)</code>，这样的性能会非常高。（可以使用触发器来自身插入哈希列）。</p>\n<h3 id=\"3-空间数据索引（R-Tree）\"><a href=\"#3-空间数据索引（R-Tree）\" class=\"headerlink\" title=\"3. 空间数据索引（R-Tree）\"></a>3. 空间数据索引（R-Tree）</h3><p>MyISAM 表支持空间索引。</p>\n<h3 id=\"4-全文索引\"><a href=\"#4-全文索引\" class=\"headerlink\" title=\"4. 全文索引\"></a>4. 全文索引</h3><p>使用<code>MATCH AGAINST</code>操作，而不是普通的<code>WHERE</code>。</p>\n<h1 id=\"2-索引的优点\"><a href=\"#2-索引的优点\" class=\"headerlink\" title=\"2 索引的优点\"></a>2 索引的优点</h1><p>最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据时有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询：  </p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量。</li>\n<li>索引可以帮助服务器避免排序和临时表。</li>\n<li>索引可以将随机 I/O 变为顺序 I/O。</li>\n</ol>\n<p>对于中到大型表，索引就非常有效。但对于特大型表，需要技术直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例，分区技术：建立元数据信息表，例，假如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。</p>\n<h1 id=\"3-高性能索引的索引策略\"><a href=\"#3-高性能索引的索引策略\" class=\"headerlink\" title=\"3 高性能索引的索引策略\"></a>3 高性能索引的索引策略</h1><h2 id=\"3-1-前缀索引和索引选择性\"><a href=\"#3-1-前缀索引和索引选择性\" class=\"headerlink\" title=\"3.1 前缀索引和索引选择性\"></a>3.1 前缀索引和索引选择性</h2><p>索引选择性：不重复的索引值/数据表的记录总数，范围在0~1间，越高则查询越快。唯一索引的选择性是1，性能也是最好的。<br>列值过长，可以使用部分字段<code>LEFT(city,3)</code>作为前缀索引，这个值是通过<code>COUNT(DISTINCT LEFT(city,5))/COUNT(*)</code>的值来决定的，结果在 0.031 基本上就可用了。接着创建：<code>ALTER TABLE sakila.city_demo ADD KEY(city(5));</code><br>但是前缀索引虽然使索引更小、更快，但是无法使用前缀索引做<code>ORDER BY</code>和<code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。</p>\n<blockquote>\n<p>后缀索引（suffix index）也很有用途（电子邮箱），可以使用字符串反转后存储。</p>\n</blockquote>\n<h2 id=\"3-2-多列索引\"><a href=\"#3-2-多列索引\" class=\"headerlink\" title=\"3.2 多列索引\"></a>3.2 多列索引</h2><p>为每个列创建独立的索引，从<code>SHOW CREATE TABLE</code>中很容易看到这种情况：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t(</span><br><span class=\"line\">    c1 <span class=\"built_in\">INT</span>,</span><br><span class=\"line\">    c2 <span class=\"built_in\">INT</span>,</span><br><span class=\"line\">    c3 <span class=\"built_in\">INT</span>,</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(c1),</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(c2),</span><br><span class=\"line\">    <span class=\"keyword\">key</span>(c3)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这种索引策略是由于“把 WHERE 条件里面的列都建上索引”这样模糊的建议导致的。这最多是“一星”索引。例，<code>WHERE c1 = &#39;1&#39; OR c2 = &#39;2&#39;</code>，虽然在 MySQL5.0+ 会优化使用这两个索引，但是在 <code>explain</code> 的 <code>extra</code> 中会有 <code>Using union</code>，因此说明了索引的糟糕：  </p>\n<ol>\n<li>出现多个 <code>AND</code> 条件，则需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li>\n<li>多个 <code>OR</code> 或者联合操作时，如果有些索引的选择性不高，需要合并扫描返回的大量数据。</li>\n<li>如果在 <code>EXPLAIN</code> 中看到有索引合并，应该好好检查查询和表的结构，也可以通过参数 <code>optimizer_switch</code> 来关闭索引合并功能，也可以使用 <code>IGNORE INDEX</code> 提示让优化器忽略掉某些索引。</li>\n</ol>\n<h2 id=\"3-3-选择合适的索引列顺序\"><a href=\"#3-3-选择合适的索引列顺序\" class=\"headerlink\" title=\"3.3 选择合适的索引列顺序\"></a>3.3 选择合适的索引列顺序</h2><p>最好通过 <code>pt-query-digest</code> 这样的工具报告重提取“最差”查询，再按照索引顺序进行优化。如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局性和选择性，而不是某个具体查询：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_2.png\" alt=\"\"><br><code>customer_id</code> 的选择性更高，所以答案是将其作为索引列的第一列。</p>\n<h2 id=\"3-4-覆盖索引\"><a href=\"#3-4-覆盖索引\" class=\"headerlink\" title=\"3.4 覆盖索引\"></a>3.4 覆盖索引</h2><p>如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”。  </p>\n<ol>\n<li>因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。</li>\n<li>并不是所有类型的索引都可以称为覆盖索引。覆盖索引必须要存储索引列的值。</li>\n</ol>\n<p>当发起一个被覆盖的查询，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>Using index</code> 的信息。</p>\n<blockquote>\n<p><code>type</code> 列的 <code>index</code> 和 <code>Extra</code> 列的 <code>Using index</code> 是完全不同，前者和覆盖索引毫无关系，它只是表示这个查询访问数据的方式。</p>\n</blockquote>\n<p>索引覆盖查询还有很多陷阱可能导致无法实现优化：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_3.png\" alt=\"\">  </p>\n<ol>\n<li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。</li>\n<li>MySQL 不能再索引中执行 <code>LIKE</code> 操作，MySQL5.5- 只允许在索引中做简单比较操作，MySQL 能在索引中做最左前缀匹配的 <code>LIKE</code> 查询，因为该操作可以转为简单的比较操作，但是如果是通配符开头的 <code>LIKE</code> 查询，存储引擎就无法做比较匹配。这种情况下，MySQL 服务器只能提取数据行的值，而不是索引值来做比较。</li>\n</ol>\n<p>也有办法解决上面说的两个问题，重写查询并巧妙地设计索引。先将索引扩展至三个数据列（artist，title，prod_id），然后按如下方式重写查询：<br><img src=\"http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_4.png\" alt=\"\"></p>\n<h2 id=\"3-5-使用索引扫描来做排序\"><a href=\"#3-5-使用索引扫描来做排序\" class=\"headerlink\" title=\"3.5 使用索引扫描来做排序\"></a>3.5 使用索引扫描来做排序</h2><p>MySQL 有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描；如果 <code>EXPLAIN</code> 出来的 type 列的值为 “index”，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）。<br>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。<br>如果查询需要关联多张表，则只有当 <code>ORDER BY</code> 子句引用的字段全部为第一个表时，才能使用索引做排序。</p>\n<p>例： </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> rental(</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span>(rental_id),</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> rental_date(rental_date, inventory_id, customer_id),</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_fk_inventory_id(inventory_id),</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_fk_customer_id(customer_id),</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_fk_staff_id(staff_id),</span><br><span class=\"line\">    ...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id</code> 因为索引第一列被指定为一个常数，所以查询排序。<br><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id</code> 也可以使用查询排序。<br><code>WHERE rental_date &gt; &#39;2005-05-25 ORDER BY rental_date, inventory_id</code> 也可以。<br>下面是不能使用索引做排序的查询：  </p>\n<ol>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id DESC, customer_id ASC;</code> 因为索引列都是正序排序。</li>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, staff_id;</code> 因为引用了一个不再索引中的列。</li>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY customer_id;</code> 无法组成索引的最左前缀。</li>\n<li><code>WHERE rental_date &gt; &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id;</code> 因为第一列上是范围条件。</li>\n<li><code>WHERE rental_date = &#39;2015-05-25&#39; AND inventory_id IN (1,2) ORDER BY customer_id;</code> 还是范围查询。</li>\n</ol>\n<h1 id=\"4-索引案例学习\"><a href=\"#4-索引案例学习\" class=\"headerlink\" title=\"4 索引案例学习\"></a>4 索引案例学习</h1><h1 id=\"5-维护索引和表\"><a href=\"#5-维护索引和表\" class=\"headerlink\" title=\"5 维护索引和表\"></a>5 维护索引和表</h1><h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h1>"},{"title":"四、Schema与数据类型优化","date":"2017-12-25T04:31:00.000Z","updated":"2017-12-27T16:28:00.000Z","comments":1,"_content":"\n# 1 选择优化的数据类型\n\n1. 更小的通常更好\n2. 简单就好：整型比字符操作代价更低，使用 MySQL 内建的类型而不是字符串来存储日期和时间，以及使用整型存储 IP 地址\n3. 尽量避免 NULL：可为 NULL 的列会使用更多的存储空间。 InnoDB 使用单独的位（bit）存储 NULL 值，但这不适用于 MyISAM\n\n在为列选择数据类型时，先确定大类型：数字、字符串、时间等。下一步是选择具体类型，很多数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。例如， TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，另一方面， TIMESTAMP 允许的时间范围要小得多。  \n  \n本章只讨论基本的数据类型。 MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC ，它们只是别名，使用 SHOW CREATE TABLE 检查， MYSQL 报告的是基本类型，而不是别名。\n\n## 1.1 整数类型\n\nTINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8、16、24、32、64 位存储空间。它们可以存储的值得范围 -2^(N-1) ~ 2^(N-1) - 1，其中 N 是存储空间的位数。整数类型有可选的 UNSIGNED 属性，表示不允许负数，这样可以提高一倍的正数上限。  \n  \n整数计算一般使用 64 位的 BIGINT 整数。整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如 MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。\n\n## 1.2 实数类型\n\n实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也不支持不精确类型。\n因为 CPU 不支持对 DECIMAL 的直接计算，所以在 MySQL5.0+ MySQL 服务器自身实现了 DECIMAL 的高精度计算，相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。  \nDECIMAL 的字节存储：每四个字节存储 9 个数字，例：DECIMAL(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。  \n浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。 DOUBLE 占用 8 个字节。MySQL 使用 DOUBLE 作为内部浮点计算的类型。  \n将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。（根据小数的位数乘以相应的倍数）\n\n## 1.3 字符串类型\n\n### 1.VARCHAR 和 CHAR 类型\n\n#### VARCHAR\n\nVARCHAR 类型用于存储可变长字符串，如果 MySQL \b表使用 ROW_\bFORMAT = FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。  \nVARCHAR 在列最大长度 <=255 字节的时候，额外用 1 个字节用于记录字符串的长度。\b例：VARCHAR(10) 的列需要 11 个字节的存储空间。VARCHAR(1000) 的列则需要 1002 个字节，因为需要 2 个字节存储长度信息。  \nMySQL5.0+ 在存储和检索时会保留末尾空格。  \n但是，由于行是变长的，在 UPDATE 时可能使行变得比原来长，这就导致需要额外的工作。  \n另外，InnoDB 可以把过长的 VARCHAR 存储为 BLOB，稍后讨论该问题。\n\n#### CHAR\n\nCHAR 类型是定长的，MySQL 总是根据定义的字符串长度分配足够的空间。  \n存储 CHAR 值时，MySQL 会删除所有的末尾空格。\n\n#### CHAR VS VARCHAR\n\nCHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例：存储密码的 MD5 值，因为这是一个定长的值。  \n对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。  \n对于非常短的值， CHAR(1) 比 VARCHAR(1) 在存储空间上也更有效率（后者需要额外一个字节存储长度）。  \nVARCHAR(100) 和 VARCHAR(200) 虽然在存储空间相同，但是在内存消耗不同，后者更大。尤其在排序和临时表（中间表）时。  \n\b摘自：http://tech.it168.com/a2011/0426/1183/000001183173.shtml\n\n### 2. BLOB 和 TEXT 类型\n\nBLOB 采用二进制存储、TEXT 采用字符存储。  \n与其它类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。当其太大时， InnoDB 会使用专门的“外部”存储区域进行存储。此时每个值在行内需要 1~4 个字节存储一个指针，然后再外部存储区域实际的值。  \n排序：MySQL 只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。可以减少 max_sort_length 的值或者使用 ORDER BY SUBSTRING(column, length)。  \nMySQL 不能讲 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。  \n进行 ORDER BY 为了防止临时表过大，可以使用 SUBSTRING(column, length) 进行长度切割。\n\n### 3. 使用枚举（ENUM） 代替字符串类型\n\nMySQL 在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “数字-字符串”映射关系的“查找表”。  \n在 VARCHAR 与 ENUM 互相 JOIN 关联时，ENUM 与 ENUM 最快。因此如果不是必须和 VARCHAR 列进行关联，那么转换这些列为 ENUM 就是个好主意。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。\n\n## 1.4 日期和时间类型\n\n### 1.DATETIME\n\n这个类型能保存大范围的值，精度为秒。使用 8 个字节的存储空间。\n\n### 2.TIMESTAMP\n\n保存了从 1970年1月1日~2038年，MySQL 提供了 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数将日期和 Unix 时间戳转换。使用 4 个字节存储。\n\n## 1.5 位数据类型\n\n### 1.BIT\n\n尽量少用。\n\n### 2.SET\n\n如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间。缺点是改变列的定义代价较高：需要 ALTER TABLE（这对大表是非常昂贵的操作，但是后面给出了解决方法）。一般来说，也无法再 SET 列上通过索引查找。\n>在整数列进行按位操作\n>```sql\n>SET @CAN_READ   := 1 << 0,\n>     @CAN_WRITE  := 1 << 1,\n>     @CAN_DELETE := 1 << 2;\n>CREATE TABLE acl (\n>     perms TINYINT UNSIGNED NOT NULL DEFAULT 0    \n>);\n>INSERT INTO acl(perms) VALUES (@CAN_READ+@CAN_DELETE);\n>SELECT perms FROM acl WHERE perms & @CAN_READ;\n>```\n>当然，也可以使用代码变量而不是 MySQL 变量。\n\n## 1.6 \b选择标识符（identifier）\n\n标识列与其它值进行比较（例，在关联操作中），或通过标识列寻找其它列。标识列也可能在另外的表中作为外键使用。  \n选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。例， MySQL 在内部使用整数存储 ENUM 和 SET 类型，然后在做比较操作时转换为字符串。  \n在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。例如，TINYINT 比 INT 少了 3 个字节，但是可能导致很大的性能差异。  \n尽量使用整数。如果存储 UUID 值，用 UNHEX() 函数转换为 16 字节的数字存储，并且存储在一个 BINARY(16) 列中。\n\n## 1.7 特殊类型数据\n\n例，IPv4 地址人们通常使用 VARCHAR(15) 列来存储 IP 地址。然而，它们实际上是 32 位无符号整数，不是字符串。所以应该用无符号整数存储 IP 地址。 MySQL 提供 INET_ATON() 和 INET_NTOA() 函数在这两种表示方法之间转换。\n\n# 2 MySQL schema 设计中的陷阱\n\n## 2.1 太多的列\n\nMySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。列转行的操作代价是非常高的。\n\n## 2.2 太多的关联\n\n阿里手册规定单次关联不能超过 3 张表。\n\n## 2.3 全能的枚举\n\nCREATE TABLE ... ( country enum('', '0', '1', ... , '31'))  \n当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，在 MySQL5.0- 这是一种阻塞操作，即使在 MySQL5.0+ ，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE。\n\n## 2.4 变相的枚举\n\n枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值的一个或多个值。这会导致混乱。\n\n## 2.5 非此发明（Not Invent Here）的 NULL\n\nCREATE TABLE ... (dt DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00')  \n伪造的全 0 值可能导致很多问题。（可以配置 MySQL 的 SQL_MODE 来禁止不可能的日期，对于新应用这是个非常好的实践经验）。\n\n# 3 缓存表和汇总表\n\n有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。\n\n## 3.1 计数器表\n\n创建一张独立的表存储计数器通常是个好主意。例，有一个计数器表，只有一行数据，记录网站的点击次数：  \n\n```sql\nCREATE TABLE hit_counter (\n    cnt int unsigned not null\n) engine=InnoDB;\n```\n\n每次点击：`UPDATE hit_counter SET cnt = cnt + 1;`  \n问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex）。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。  \n要获得统计结果：`SELECT SUM(cnt) FROM hit_count;`。  \n一个常见的需求是每隔一段时间开始一个新的计数器（例，每天一个）。如果需要这么做，则可以再简单地修改一下表设计：  \n\n```sql\nCREATE TABLE hit_counter (\n    day date not null,\n    slot tinyint unsigned not null,\n    cnt int unsigned not null,\n    primary key(day, slot)\n) ENGINE=InnoDB;\n```\n\n在这个场景下，可以不用像前面的例子那样预先生成行，而是`ON DUPLICATE KEY UPDATE`代替。  \n\n```sql\nINSERT INTO daily_hit_counter(day, slot, cnt)\n    VALUES (CURRENT_DATE, RAND() * 100, 1)\n    ON DUPLICATE KEY UPDATE cnt = cnt + 1;\n```\n\n如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到 0 号槽，并删除所有其它的槽：\n\n```sql\nUPDATE daily_hit_counter as c\n    INNER JOIN (\n        SELECT day, SUM(cnt) AS cnt, MIN(slot) AS mslot\n        FROM daily_hit_counter\n        GROUP BY day\n    ) AS x USING(day)\nSET c.cnt  = IF(c.slot = x.mslot, x.cnt, 0),\n    c.slot = IF(c.slot = x.mslot, 0, c.slot); \nDELETE FROM daily_hit_counter WHERE slot <> 0 AND cnt = 0;\n```\n\n# 4 加快 ALTER TABLE 操作的速度\n\n假如要修改电影的默认租赁期限，从三天改到五天，下面是很慢的方式：\n\n```sql\nALTER TABLE film \nMODIFY COLUMN rental_duration tinyint(3) not null default 5;\n```\n\n`show status`语句显示这个语句做了 1000 次读和 1000 次插入操作。换句话说，它拷贝了整张表到一张新表。  \n理论上，MySQL 可以跳过创建新表的步骤，即直接修改 .frm 文件而不设计表数据：\n\n```sql\nALTER TABLE film\nALTER COLUMN rental_duraion SET DEFAULT 5;\n```\n\n# 5 总结\n\n1. 避免过度设计\n2. 使用小而简单的合适数据类型，避免使用 NULL 值\n3. 关联标识符尽量使用相同的数据类型\n4. 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存\n5. 尽量使用整型定义标识列\n6. 小心使用 ENUM 和 SET\n7. `ALTER TABLE`在大部分情况下都会锁表并且重建整张表。建议先在备库执行`ALTER`完成后将其切换为主库","source":"_posts/高性能 MySQL/第四章 Schema 与数据类型优化.md","raw":"---\ntitle: 四、Schema与数据类型优化\ndate: 2017-12-25 12:31:00\nupdated: 2017-12-28 00:28:00\ncomments: true\ncategories: \n- 读书笔记\n- 高性能MySQL\npermalink: high_performance_MySQL/4.html    \n---\n\n# 1 选择优化的数据类型\n\n1. 更小的通常更好\n2. 简单就好：整型比字符操作代价更低，使用 MySQL 内建的类型而不是字符串来存储日期和时间，以及使用整型存储 IP 地址\n3. 尽量避免 NULL：可为 NULL 的列会使用更多的存储空间。 InnoDB 使用单独的位（bit）存储 NULL 值，但这不适用于 MyISAM\n\n在为列选择数据类型时，先确定大类型：数字、字符串、时间等。下一步是选择具体类型，很多数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。例如， TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，另一方面， TIMESTAMP 允许的时间范围要小得多。  \n  \n本章只讨论基本的数据类型。 MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC ，它们只是别名，使用 SHOW CREATE TABLE 检查， MYSQL 报告的是基本类型，而不是别名。\n\n## 1.1 整数类型\n\nTINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8、16、24、32、64 位存储空间。它们可以存储的值得范围 -2^(N-1) ~ 2^(N-1) - 1，其中 N 是存储空间的位数。整数类型有可选的 UNSIGNED 属性，表示不允许负数，这样可以提高一倍的正数上限。  \n  \n整数计算一般使用 64 位的 BIGINT 整数。整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如 MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。\n\n## 1.2 实数类型\n\n实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也不支持不精确类型。\n因为 CPU 不支持对 DECIMAL 的直接计算，所以在 MySQL5.0+ MySQL 服务器自身实现了 DECIMAL 的高精度计算，相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。  \nDECIMAL 的字节存储：每四个字节存储 9 个数字，例：DECIMAL(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。  \n浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。 DOUBLE 占用 8 个字节。MySQL 使用 DOUBLE 作为内部浮点计算的类型。  \n将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。（根据小数的位数乘以相应的倍数）\n\n## 1.3 字符串类型\n\n### 1.VARCHAR 和 CHAR 类型\n\n#### VARCHAR\n\nVARCHAR 类型用于存储可变长字符串，如果 MySQL \b表使用 ROW_\bFORMAT = FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。  \nVARCHAR 在列最大长度 <=255 字节的时候，额外用 1 个字节用于记录字符串的长度。\b例：VARCHAR(10) 的列需要 11 个字节的存储空间。VARCHAR(1000) 的列则需要 1002 个字节，因为需要 2 个字节存储长度信息。  \nMySQL5.0+ 在存储和检索时会保留末尾空格。  \n但是，由于行是变长的，在 UPDATE 时可能使行变得比原来长，这就导致需要额外的工作。  \n另外，InnoDB 可以把过长的 VARCHAR 存储为 BLOB，稍后讨论该问题。\n\n#### CHAR\n\nCHAR 类型是定长的，MySQL 总是根据定义的字符串长度分配足够的空间。  \n存储 CHAR 值时，MySQL 会删除所有的末尾空格。\n\n#### CHAR VS VARCHAR\n\nCHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例：存储密码的 MD5 值，因为这是一个定长的值。  \n对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。  \n对于非常短的值， CHAR(1) 比 VARCHAR(1) 在存储空间上也更有效率（后者需要额外一个字节存储长度）。  \nVARCHAR(100) 和 VARCHAR(200) 虽然在存储空间相同，但是在内存消耗不同，后者更大。尤其在排序和临时表（中间表）时。  \n\b摘自：http://tech.it168.com/a2011/0426/1183/000001183173.shtml\n\n### 2. BLOB 和 TEXT 类型\n\nBLOB 采用二进制存储、TEXT 采用字符存储。  \n与其它类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。当其太大时， InnoDB 会使用专门的“外部”存储区域进行存储。此时每个值在行内需要 1~4 个字节存储一个指针，然后再外部存储区域实际的值。  \n排序：MySQL 只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。可以减少 max_sort_length 的值或者使用 ORDER BY SUBSTRING(column, length)。  \nMySQL 不能讲 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。  \n进行 ORDER BY 为了防止临时表过大，可以使用 SUBSTRING(column, length) 进行长度切割。\n\n### 3. 使用枚举（ENUM） 代替字符串类型\n\nMySQL 在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “数字-字符串”映射关系的“查找表”。  \n在 VARCHAR 与 ENUM 互相 JOIN 关联时，ENUM 与 ENUM 最快。因此如果不是必须和 VARCHAR 列进行关联，那么转换这些列为 ENUM 就是个好主意。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。\n\n## 1.4 日期和时间类型\n\n### 1.DATETIME\n\n这个类型能保存大范围的值，精度为秒。使用 8 个字节的存储空间。\n\n### 2.TIMESTAMP\n\n保存了从 1970年1月1日~2038年，MySQL 提供了 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数将日期和 Unix 时间戳转换。使用 4 个字节存储。\n\n## 1.5 位数据类型\n\n### 1.BIT\n\n尽量少用。\n\n### 2.SET\n\n如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间。缺点是改变列的定义代价较高：需要 ALTER TABLE（这对大表是非常昂贵的操作，但是后面给出了解决方法）。一般来说，也无法再 SET 列上通过索引查找。\n>在整数列进行按位操作\n>```sql\n>SET @CAN_READ   := 1 << 0,\n>     @CAN_WRITE  := 1 << 1,\n>     @CAN_DELETE := 1 << 2;\n>CREATE TABLE acl (\n>     perms TINYINT UNSIGNED NOT NULL DEFAULT 0    \n>);\n>INSERT INTO acl(perms) VALUES (@CAN_READ+@CAN_DELETE);\n>SELECT perms FROM acl WHERE perms & @CAN_READ;\n>```\n>当然，也可以使用代码变量而不是 MySQL 变量。\n\n## 1.6 \b选择标识符（identifier）\n\n标识列与其它值进行比较（例，在关联操作中），或通过标识列寻找其它列。标识列也可能在另外的表中作为外键使用。  \n选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。例， MySQL 在内部使用整数存储 ENUM 和 SET 类型，然后在做比较操作时转换为字符串。  \n在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。例如，TINYINT 比 INT 少了 3 个字节，但是可能导致很大的性能差异。  \n尽量使用整数。如果存储 UUID 值，用 UNHEX() 函数转换为 16 字节的数字存储，并且存储在一个 BINARY(16) 列中。\n\n## 1.7 特殊类型数据\n\n例，IPv4 地址人们通常使用 VARCHAR(15) 列来存储 IP 地址。然而，它们实际上是 32 位无符号整数，不是字符串。所以应该用无符号整数存储 IP 地址。 MySQL 提供 INET_ATON() 和 INET_NTOA() 函数在这两种表示方法之间转换。\n\n# 2 MySQL schema 设计中的陷阱\n\n## 2.1 太多的列\n\nMySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。列转行的操作代价是非常高的。\n\n## 2.2 太多的关联\n\n阿里手册规定单次关联不能超过 3 张表。\n\n## 2.3 全能的枚举\n\nCREATE TABLE ... ( country enum('', '0', '1', ... , '31'))  \n当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，在 MySQL5.0- 这是一种阻塞操作，即使在 MySQL5.0+ ，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE。\n\n## 2.4 变相的枚举\n\n枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值的一个或多个值。这会导致混乱。\n\n## 2.5 非此发明（Not Invent Here）的 NULL\n\nCREATE TABLE ... (dt DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00')  \n伪造的全 0 值可能导致很多问题。（可以配置 MySQL 的 SQL_MODE 来禁止不可能的日期，对于新应用这是个非常好的实践经验）。\n\n# 3 缓存表和汇总表\n\n有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。\n\n## 3.1 计数器表\n\n创建一张独立的表存储计数器通常是个好主意。例，有一个计数器表，只有一行数据，记录网站的点击次数：  \n\n```sql\nCREATE TABLE hit_counter (\n    cnt int unsigned not null\n) engine=InnoDB;\n```\n\n每次点击：`UPDATE hit_counter SET cnt = cnt + 1;`  \n问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex）。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。  \n要获得统计结果：`SELECT SUM(cnt) FROM hit_count;`。  \n一个常见的需求是每隔一段时间开始一个新的计数器（例，每天一个）。如果需要这么做，则可以再简单地修改一下表设计：  \n\n```sql\nCREATE TABLE hit_counter (\n    day date not null,\n    slot tinyint unsigned not null,\n    cnt int unsigned not null,\n    primary key(day, slot)\n) ENGINE=InnoDB;\n```\n\n在这个场景下，可以不用像前面的例子那样预先生成行，而是`ON DUPLICATE KEY UPDATE`代替。  \n\n```sql\nINSERT INTO daily_hit_counter(day, slot, cnt)\n    VALUES (CURRENT_DATE, RAND() * 100, 1)\n    ON DUPLICATE KEY UPDATE cnt = cnt + 1;\n```\n\n如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到 0 号槽，并删除所有其它的槽：\n\n```sql\nUPDATE daily_hit_counter as c\n    INNER JOIN (\n        SELECT day, SUM(cnt) AS cnt, MIN(slot) AS mslot\n        FROM daily_hit_counter\n        GROUP BY day\n    ) AS x USING(day)\nSET c.cnt  = IF(c.slot = x.mslot, x.cnt, 0),\n    c.slot = IF(c.slot = x.mslot, 0, c.slot); \nDELETE FROM daily_hit_counter WHERE slot <> 0 AND cnt = 0;\n```\n\n# 4 加快 ALTER TABLE 操作的速度\n\n假如要修改电影的默认租赁期限，从三天改到五天，下面是很慢的方式：\n\n```sql\nALTER TABLE film \nMODIFY COLUMN rental_duration tinyint(3) not null default 5;\n```\n\n`show status`语句显示这个语句做了 1000 次读和 1000 次插入操作。换句话说，它拷贝了整张表到一张新表。  \n理论上，MySQL 可以跳过创建新表的步骤，即直接修改 .frm 文件而不设计表数据：\n\n```sql\nALTER TABLE film\nALTER COLUMN rental_duraion SET DEFAULT 5;\n```\n\n# 5 总结\n\n1. 避免过度设计\n2. 使用小而简单的合适数据类型，避免使用 NULL 值\n3. 关联标识符尽量使用相同的数据类型\n4. 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存\n5. 尽量使用整型定义标识列\n6. 小心使用 ENUM 和 SET\n7. `ALTER TABLE`在大部分情况下都会锁表并且重建整张表。建议先在备库执行`ALTER`完成后将其切换为主库","slug":"high_performance_MySQL/4.html","published":1,"layout":"post","photos":[],"link":"","_id":"cjoojkawi0044axs6hwbrjrex","content":"<h1 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1 选择优化的数据类型\"></a>1 选择优化的数据类型</h1><ol>\n<li>更小的通常更好</li>\n<li>简单就好：整型比字符操作代价更低，使用 MySQL 内建的类型而不是字符串来存储日期和时间，以及使用整型存储 IP 地址</li>\n<li>尽量避免 NULL：可为 NULL 的列会使用更多的存储空间。 InnoDB 使用单独的位（bit）存储 NULL 值，但这不适用于 MyISAM</li>\n</ol>\n<p>在为列选择数据类型时，先确定大类型：数字、字符串、时间等。下一步是选择具体类型，很多数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。例如， TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，另一方面， TIMESTAMP 允许的时间范围要小得多。  </p>\n<p>本章只讨论基本的数据类型。 MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC ，它们只是别名，使用 SHOW CREATE TABLE 检查， MYSQL 报告的是基本类型，而不是别名。</p>\n<h2 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h2><p>TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8、16、24、32、64 位存储空间。它们可以存储的值得范围 -2^(N-1) ~ 2^(N-1) - 1，其中 N 是存储空间的位数。整数类型有可选的 UNSIGNED 属性，表示不允许负数，这样可以提高一倍的正数上限。  </p>\n<p>整数计算一般使用 64 位的 BIGINT 整数。整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如 MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。</p>\n<h2 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h2><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也不支持不精确类型。<br>因为 CPU 不支持对 DECIMAL 的直接计算，所以在 MySQL5.0+ MySQL 服务器自身实现了 DECIMAL 的高精度计算，相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。<br>DECIMAL 的字节存储：每四个字节存储 9 个数字，例：DECIMAL(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。<br>浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。 DOUBLE 占用 8 个字节。MySQL 使用 DOUBLE 作为内部浮点计算的类型。<br>将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。（根据小数的位数乘以相应的倍数）</p>\n<h2 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h2><h3 id=\"1-VARCHAR-和-CHAR-类型\"><a href=\"#1-VARCHAR-和-CHAR-类型\" class=\"headerlink\" title=\"1.VARCHAR 和 CHAR 类型\"></a>1.VARCHAR 和 CHAR 类型</h3><h4 id=\"VARCHAR\"><a href=\"#VARCHAR\" class=\"headerlink\" title=\"VARCHAR\"></a>VARCHAR</h4><p>VARCHAR 类型用于存储可变长字符串，如果 MySQL \b表使用 ROW_\bFORMAT = FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。<br>VARCHAR 在列最大长度 &lt;=255 字节的时候，额外用 1 个字节用于记录字符串的长度。\b例：VARCHAR(10) 的列需要 11 个字节的存储空间。VARCHAR(1000) 的列则需要 1002 个字节，因为需要 2 个字节存储长度信息。<br>MySQL5.0+ 在存储和检索时会保留末尾空格。<br>但是，由于行是变长的，在 UPDATE 时可能使行变得比原来长，这就导致需要额外的工作。<br>另外，InnoDB 可以把过长的 VARCHAR 存储为 BLOB，稍后讨论该问题。</p>\n<h4 id=\"CHAR\"><a href=\"#CHAR\" class=\"headerlink\" title=\"CHAR\"></a>CHAR</h4><p>CHAR 类型是定长的，MySQL 总是根据定义的字符串长度分配足够的空间。<br>存储 CHAR 值时，MySQL 会删除所有的末尾空格。</p>\n<h4 id=\"CHAR-VS-VARCHAR\"><a href=\"#CHAR-VS-VARCHAR\" class=\"headerlink\" title=\"CHAR VS VARCHAR\"></a>CHAR VS VARCHAR</h4><p>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例：存储密码的 MD5 值，因为这是一个定长的值。<br>对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。<br>对于非常短的值， CHAR(1) 比 VARCHAR(1) 在存储空间上也更有效率（后者需要额外一个字节存储长度）。<br>VARCHAR(100) 和 VARCHAR(200) 虽然在存储空间相同，但是在内存消耗不同，后者更大。尤其在排序和临时表（中间表）时。<br>\b摘自：<a href=\"http://tech.it168.com/a2011/0426/1183/000001183173.shtml\" target=\"_blank\" rel=\"noopener\">http://tech.it168.com/a2011/0426/1183/000001183173.shtml</a></p>\n<h3 id=\"2-BLOB-和-TEXT-类型\"><a href=\"#2-BLOB-和-TEXT-类型\" class=\"headerlink\" title=\"2. BLOB 和 TEXT 类型\"></a>2. BLOB 和 TEXT 类型</h3><p>BLOB 采用二进制存储、TEXT 采用字符存储。<br>与其它类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。当其太大时， InnoDB 会使用专门的“外部”存储区域进行存储。此时每个值在行内需要 1~4 个字节存储一个指针，然后再外部存储区域实际的值。<br>排序：MySQL 只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。可以减少 max_sort_length 的值或者使用 ORDER BY SUBSTRING(column, length)。<br>MySQL 不能讲 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。<br>进行 ORDER BY 为了防止临时表过大，可以使用 SUBSTRING(column, length) 进行长度切割。</p>\n<h3 id=\"3-使用枚举（ENUM）-代替字符串类型\"><a href=\"#3-使用枚举（ENUM）-代替字符串类型\" class=\"headerlink\" title=\"3. 使用枚举（ENUM） 代替字符串类型\"></a>3. 使用枚举（ENUM） 代替字符串类型</h3><p>MySQL 在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “数字-字符串”映射关系的“查找表”。<br>在 VARCHAR 与 ENUM 互相 JOIN 关联时，ENUM 与 ENUM 最快。因此如果不是必须和 VARCHAR 列进行关联，那么转换这些列为 ENUM 就是个好主意。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。</p>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2><h3 id=\"1-DATETIME\"><a href=\"#1-DATETIME\" class=\"headerlink\" title=\"1.DATETIME\"></a>1.DATETIME</h3><p>这个类型能保存大范围的值，精度为秒。使用 8 个字节的存储空间。</p>\n<h3 id=\"2-TIMESTAMP\"><a href=\"#2-TIMESTAMP\" class=\"headerlink\" title=\"2.TIMESTAMP\"></a>2.TIMESTAMP</h3><p>保存了从 1970年1月1日~2038年，MySQL 提供了 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数将日期和 Unix 时间戳转换。使用 4 个字节存储。</p>\n<h2 id=\"1-5-位数据类型\"><a href=\"#1-5-位数据类型\" class=\"headerlink\" title=\"1.5 位数据类型\"></a>1.5 位数据类型</h2><h3 id=\"1-BIT\"><a href=\"#1-BIT\" class=\"headerlink\" title=\"1.BIT\"></a>1.BIT</h3><p>尽量少用。</p>\n<h3 id=\"2-SET\"><a href=\"#2-SET\" class=\"headerlink\" title=\"2.SET\"></a>2.SET</h3><p>如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间。缺点是改变列的定义代价较高：需要 ALTER TABLE（这对大表是非常昂贵的操作，但是后面给出了解决方法）。一般来说，也无法再 SET 列上通过索引查找。</p>\n<blockquote>\n<p>在整数列进行按位操作<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;SET @CAN_READ   := 1 &lt;&lt; 0,</span><br><span class=\"line\">&gt;     @CAN_WRITE  := 1 &lt;&lt; 1,</span><br><span class=\"line\">&gt;     @CAN_DELETE := 1 &lt;&lt; 2;</span><br><span class=\"line\">&gt;CREATE TABLE acl (</span><br><span class=\"line\">&gt;     perms TINYINT UNSIGNED NOT NULL DEFAULT 0    </span><br><span class=\"line\">&gt;);</span><br><span class=\"line\">&gt;INSERT INTO acl(perms) VALUES (@CAN_READ+@CAN_DELETE);</span><br><span class=\"line\">&gt;SELECT perms FROM acl WHERE perms &amp; @CAN_READ;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>当然，也可以使用代码变量而不是 MySQL 变量。</p>\n</blockquote>\n<h2 id=\"1-6-选择标识符（identifier）\"><a href=\"#1-6-选择标识符（identifier）\" class=\"headerlink\" title=\"1.6 \b选择标识符（identifier）\"></a>1.6 \b选择标识符（identifier）</h2><p>标识列与其它值进行比较（例，在关联操作中），或通过标识列寻找其它列。标识列也可能在另外的表中作为外键使用。<br>选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。例， MySQL 在内部使用整数存储 ENUM 和 SET 类型，然后在做比较操作时转换为字符串。<br>在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。例如，TINYINT 比 INT 少了 3 个字节，但是可能导致很大的性能差异。<br>尽量使用整数。如果存储 UUID 值，用 UNHEX() 函数转换为 16 字节的数字存储，并且存储在一个 BINARY(16) 列中。</p>\n<h2 id=\"1-7-特殊类型数据\"><a href=\"#1-7-特殊类型数据\" class=\"headerlink\" title=\"1.7 特殊类型数据\"></a>1.7 特殊类型数据</h2><p>例，IPv4 地址人们通常使用 VARCHAR(15) 列来存储 IP 地址。然而，它们实际上是 32 位无符号整数，不是字符串。所以应该用无符号整数存储 IP 地址。 MySQL 提供 INET_ATON() 和 INET_NTOA() 函数在这两种表示方法之间转换。</p>\n<h1 id=\"2-MySQL-schema-设计中的陷阱\"><a href=\"#2-MySQL-schema-设计中的陷阱\" class=\"headerlink\" title=\"2 MySQL schema 设计中的陷阱\"></a>2 MySQL schema 设计中的陷阱</h1><h2 id=\"2-1-太多的列\"><a href=\"#2-1-太多的列\" class=\"headerlink\" title=\"2.1 太多的列\"></a>2.1 太多的列</h2><p>MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。列转行的操作代价是非常高的。</p>\n<h2 id=\"2-2-太多的关联\"><a href=\"#2-2-太多的关联\" class=\"headerlink\" title=\"2.2 太多的关联\"></a>2.2 太多的关联</h2><p>阿里手册规定单次关联不能超过 3 张表。</p>\n<h2 id=\"2-3-全能的枚举\"><a href=\"#2-3-全能的枚举\" class=\"headerlink\" title=\"2.3 全能的枚举\"></a>2.3 全能的枚举</h2><p>CREATE TABLE … ( country enum(‘’, ‘0’, ‘1’, … , ‘31’))<br>当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，在 MySQL5.0- 这是一种阻塞操作，即使在 MySQL5.0+ ，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE。</p>\n<h2 id=\"2-4-变相的枚举\"><a href=\"#2-4-变相的枚举\" class=\"headerlink\" title=\"2.4 变相的枚举\"></a>2.4 变相的枚举</h2><p>枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值的一个或多个值。这会导致混乱。</p>\n<h2 id=\"2-5-非此发明（Not-Invent-Here）的-NULL\"><a href=\"#2-5-非此发明（Not-Invent-Here）的-NULL\" class=\"headerlink\" title=\"2.5 非此发明（Not Invent Here）的 NULL\"></a>2.5 非此发明（Not Invent Here）的 NULL</h2><p>CREATE TABLE … (dt DATETIME NOT NULL DEFAULT ‘0000-00-00 00:00:00’)<br>伪造的全 0 值可能导致很多问题。（可以配置 MySQL 的 SQL_MODE 来禁止不可能的日期，对于新应用这是个非常好的实践经验）。</p>\n<h1 id=\"3-缓存表和汇总表\"><a href=\"#3-缓存表和汇总表\" class=\"headerlink\" title=\"3 缓存表和汇总表\"></a>3 缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。</p>\n<h2 id=\"3-1-计数器表\"><a href=\"#3-1-计数器表\" class=\"headerlink\" title=\"3.1 计数器表\"></a>3.1 计数器表</h2><p>创建一张独立的表存储计数器通常是个好主意。例，有一个计数器表，只有一行数据，记录网站的点击次数：  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> hit_counter (</span><br><span class=\"line\">    cnt <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">) <span class=\"keyword\">engine</span>=<span class=\"keyword\">InnoDB</span>;</span><br></pre></td></tr></table></figure>\n<p>每次点击：<code>UPDATE hit_counter SET cnt = cnt + 1;</code><br>问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex）。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。<br>要获得统计结果：<code>SELECT SUM(cnt) FROM hit_count;</code>。<br>一个常见的需求是每隔一段时间开始一个新的计数器（例，每天一个）。如果需要这么做，则可以再简单地修改一下表设计：  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> hit_counter (</span><br><span class=\"line\">    <span class=\"keyword\">day</span> <span class=\"built_in\">date</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    slot tinyint <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    cnt <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>(<span class=\"keyword\">day</span>, slot)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span>;</span><br></pre></td></tr></table></figure>\n<p>在这个场景下，可以不用像前面的例子那样预先生成行，而是<code>ON DUPLICATE KEY UPDATE</code>代替。  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> daily_hit_counter(<span class=\"keyword\">day</span>, slot, cnt)</span><br><span class=\"line\">    <span class=\"keyword\">VALUES</span> (<span class=\"keyword\">CURRENT_DATE</span>, <span class=\"keyword\">RAND</span>() * <span class=\"number\">100</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> <span class=\"keyword\">DUPLICATE</span> <span class=\"keyword\">KEY</span> <span class=\"keyword\">UPDATE</span> cnt = cnt + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到 0 号槽，并删除所有其它的槽：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> daily_hit_counter <span class=\"keyword\">as</span> c</span><br><span class=\"line\">    <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> (</span><br><span class=\"line\">        <span class=\"keyword\">SELECT</span> <span class=\"keyword\">day</span>, <span class=\"keyword\">SUM</span>(cnt) <span class=\"keyword\">AS</span> cnt, <span class=\"keyword\">MIN</span>(slot) <span class=\"keyword\">AS</span> mslot</span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> daily_hit_counter</span><br><span class=\"line\">        <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">day</span></span><br><span class=\"line\">    ) <span class=\"keyword\">AS</span> x <span class=\"keyword\">USING</span>(<span class=\"keyword\">day</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span> c.cnt  = <span class=\"keyword\">IF</span>(c.slot = x.mslot, x.cnt, <span class=\"number\">0</span>),</span><br><span class=\"line\">    c.slot = <span class=\"keyword\">IF</span>(c.slot = x.mslot, <span class=\"number\">0</span>, c.slot); </span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> daily_hit_counter <span class=\"keyword\">WHERE</span> slot &lt;&gt; <span class=\"number\">0</span> <span class=\"keyword\">AND</span> cnt = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-加快-ALTER-TABLE-操作的速度\"><a href=\"#4-加快-ALTER-TABLE-操作的速度\" class=\"headerlink\" title=\"4 加快 ALTER TABLE 操作的速度\"></a>4 加快 ALTER TABLE 操作的速度</h1><p>假如要修改电影的默认租赁期限，从三天改到五天，下面是很慢的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> film </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> <span class=\"keyword\">COLUMN</span> rental_duration tinyint(<span class=\"number\">3</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p><code>show status</code>语句显示这个语句做了 1000 次读和 1000 次插入操作。换句话说，它拷贝了整张表到一张新表。<br>理论上，MySQL 可以跳过创建新表的步骤，即直接修改 .frm 文件而不设计表数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> film</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> rental_duraion <span class=\"keyword\">SET</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h1><ol>\n<li>避免过度设计</li>\n<li>使用小而简单的合适数据类型，避免使用 NULL 值</li>\n<li>关联标识符尽量使用相同的数据类型</li>\n<li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存</li>\n<li>尽量使用整型定义标识列</li>\n<li>小心使用 ENUM 和 SET</li>\n<li><code>ALTER TABLE</code>在大部分情况下都会锁表并且重建整张表。建议先在备库执行<code>ALTER</code>完成后将其切换为主库</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1 选择优化的数据类型\"></a>1 选择优化的数据类型</h1><ol>\n<li>更小的通常更好</li>\n<li>简单就好：整型比字符操作代价更低，使用 MySQL 内建的类型而不是字符串来存储日期和时间，以及使用整型存储 IP 地址</li>\n<li>尽量避免 NULL：可为 NULL 的列会使用更多的存储空间。 InnoDB 使用单独的位（bit）存储 NULL 值，但这不适用于 MyISAM</li>\n</ol>\n<p>在为列选择数据类型时，先确定大类型：数字、字符串、时间等。下一步是选择具体类型，很多数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。例如， TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，另一方面， TIMESTAMP 允许的时间范围要小得多。  </p>\n<p>本章只讨论基本的数据类型。 MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC ，它们只是别名，使用 SHOW CREATE TABLE 检查， MYSQL 报告的是基本类型，而不是别名。</p>\n<h2 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h2><p>TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8、16、24、32、64 位存储空间。它们可以存储的值得范围 -2^(N-1) ~ 2^(N-1) - 1，其中 N 是存储空间的位数。整数类型有可选的 UNSIGNED 属性，表示不允许负数，这样可以提高一倍的正数上限。  </p>\n<p>整数计算一般使用 64 位的 BIGINT 整数。整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如 MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。</p>\n<h2 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h2><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也不支持不精确类型。<br>因为 CPU 不支持对 DECIMAL 的直接计算，所以在 MySQL5.0+ MySQL 服务器自身实现了 DECIMAL 的高精度计算，相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。<br>DECIMAL 的字节存储：每四个字节存储 9 个数字，例：DECIMAL(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。<br>浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。 DOUBLE 占用 8 个字节。MySQL 使用 DOUBLE 作为内部浮点计算的类型。<br>将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。（根据小数的位数乘以相应的倍数）</p>\n<h2 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h2><h3 id=\"1-VARCHAR-和-CHAR-类型\"><a href=\"#1-VARCHAR-和-CHAR-类型\" class=\"headerlink\" title=\"1.VARCHAR 和 CHAR 类型\"></a>1.VARCHAR 和 CHAR 类型</h3><h4 id=\"VARCHAR\"><a href=\"#VARCHAR\" class=\"headerlink\" title=\"VARCHAR\"></a>VARCHAR</h4><p>VARCHAR 类型用于存储可变长字符串，如果 MySQL \b表使用 ROW_\bFORMAT = FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。<br>VARCHAR 在列最大长度 &lt;=255 字节的时候，额外用 1 个字节用于记录字符串的长度。\b例：VARCHAR(10) 的列需要 11 个字节的存储空间。VARCHAR(1000) 的列则需要 1002 个字节，因为需要 2 个字节存储长度信息。<br>MySQL5.0+ 在存储和检索时会保留末尾空格。<br>但是，由于行是变长的，在 UPDATE 时可能使行变得比原来长，这就导致需要额外的工作。<br>另外，InnoDB 可以把过长的 VARCHAR 存储为 BLOB，稍后讨论该问题。</p>\n<h4 id=\"CHAR\"><a href=\"#CHAR\" class=\"headerlink\" title=\"CHAR\"></a>CHAR</h4><p>CHAR 类型是定长的，MySQL 总是根据定义的字符串长度分配足够的空间。<br>存储 CHAR 值时，MySQL 会删除所有的末尾空格。</p>\n<h4 id=\"CHAR-VS-VARCHAR\"><a href=\"#CHAR-VS-VARCHAR\" class=\"headerlink\" title=\"CHAR VS VARCHAR\"></a>CHAR VS VARCHAR</h4><p>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例：存储密码的 MD5 值，因为这是一个定长的值。<br>对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。<br>对于非常短的值， CHAR(1) 比 VARCHAR(1) 在存储空间上也更有效率（后者需要额外一个字节存储长度）。<br>VARCHAR(100) 和 VARCHAR(200) 虽然在存储空间相同，但是在内存消耗不同，后者更大。尤其在排序和临时表（中间表）时。<br>\b摘自：<a href=\"http://tech.it168.com/a2011/0426/1183/000001183173.shtml\" target=\"_blank\" rel=\"noopener\">http://tech.it168.com/a2011/0426/1183/000001183173.shtml</a></p>\n<h3 id=\"2-BLOB-和-TEXT-类型\"><a href=\"#2-BLOB-和-TEXT-类型\" class=\"headerlink\" title=\"2. BLOB 和 TEXT 类型\"></a>2. BLOB 和 TEXT 类型</h3><p>BLOB 采用二进制存储、TEXT 采用字符存储。<br>与其它类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。当其太大时， InnoDB 会使用专门的“外部”存储区域进行存储。此时每个值在行内需要 1~4 个字节存储一个指针，然后再外部存储区域实际的值。<br>排序：MySQL 只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。可以减少 max_sort_length 的值或者使用 ORDER BY SUBSTRING(column, length)。<br>MySQL 不能讲 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。<br>进行 ORDER BY 为了防止临时表过大，可以使用 SUBSTRING(column, length) 进行长度切割。</p>\n<h3 id=\"3-使用枚举（ENUM）-代替字符串类型\"><a href=\"#3-使用枚举（ENUM）-代替字符串类型\" class=\"headerlink\" title=\"3. 使用枚举（ENUM） 代替字符串类型\"></a>3. 使用枚举（ENUM） 代替字符串类型</h3><p>MySQL 在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “数字-字符串”映射关系的“查找表”。<br>在 VARCHAR 与 ENUM 互相 JOIN 关联时，ENUM 与 ENUM 最快。因此如果不是必须和 VARCHAR 列进行关联，那么转换这些列为 ENUM 就是个好主意。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。</p>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2><h3 id=\"1-DATETIME\"><a href=\"#1-DATETIME\" class=\"headerlink\" title=\"1.DATETIME\"></a>1.DATETIME</h3><p>这个类型能保存大范围的值，精度为秒。使用 8 个字节的存储空间。</p>\n<h3 id=\"2-TIMESTAMP\"><a href=\"#2-TIMESTAMP\" class=\"headerlink\" title=\"2.TIMESTAMP\"></a>2.TIMESTAMP</h3><p>保存了从 1970年1月1日~2038年，MySQL 提供了 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数将日期和 Unix 时间戳转换。使用 4 个字节存储。</p>\n<h2 id=\"1-5-位数据类型\"><a href=\"#1-5-位数据类型\" class=\"headerlink\" title=\"1.5 位数据类型\"></a>1.5 位数据类型</h2><h3 id=\"1-BIT\"><a href=\"#1-BIT\" class=\"headerlink\" title=\"1.BIT\"></a>1.BIT</h3><p>尽量少用。</p>\n<h3 id=\"2-SET\"><a href=\"#2-SET\" class=\"headerlink\" title=\"2.SET\"></a>2.SET</h3><p>如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间。缺点是改变列的定义代价较高：需要 ALTER TABLE（这对大表是非常昂贵的操作，但是后面给出了解决方法）。一般来说，也无法再 SET 列上通过索引查找。</p>\n<blockquote>\n<p>在整数列进行按位操作<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;SET @CAN_READ   := 1 &lt;&lt; 0,</span><br><span class=\"line\">&gt;     @CAN_WRITE  := 1 &lt;&lt; 1,</span><br><span class=\"line\">&gt;     @CAN_DELETE := 1 &lt;&lt; 2;</span><br><span class=\"line\">&gt;CREATE TABLE acl (</span><br><span class=\"line\">&gt;     perms TINYINT UNSIGNED NOT NULL DEFAULT 0    </span><br><span class=\"line\">&gt;);</span><br><span class=\"line\">&gt;INSERT INTO acl(perms) VALUES (@CAN_READ+@CAN_DELETE);</span><br><span class=\"line\">&gt;SELECT perms FROM acl WHERE perms &amp; @CAN_READ;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>当然，也可以使用代码变量而不是 MySQL 变量。</p>\n</blockquote>\n<h2 id=\"1-6-选择标识符（identifier）\"><a href=\"#1-6-选择标识符（identifier）\" class=\"headerlink\" title=\"1.6 \b选择标识符（identifier）\"></a>1.6 \b选择标识符（identifier）</h2><p>标识列与其它值进行比较（例，在关联操作中），或通过标识列寻找其它列。标识列也可能在另外的表中作为外键使用。<br>选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。例， MySQL 在内部使用整数存储 ENUM 和 SET 类型，然后在做比较操作时转换为字符串。<br>在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。例如，TINYINT 比 INT 少了 3 个字节，但是可能导致很大的性能差异。<br>尽量使用整数。如果存储 UUID 值，用 UNHEX() 函数转换为 16 字节的数字存储，并且存储在一个 BINARY(16) 列中。</p>\n<h2 id=\"1-7-特殊类型数据\"><a href=\"#1-7-特殊类型数据\" class=\"headerlink\" title=\"1.7 特殊类型数据\"></a>1.7 特殊类型数据</h2><p>例，IPv4 地址人们通常使用 VARCHAR(15) 列来存储 IP 地址。然而，它们实际上是 32 位无符号整数，不是字符串。所以应该用无符号整数存储 IP 地址。 MySQL 提供 INET_ATON() 和 INET_NTOA() 函数在这两种表示方法之间转换。</p>\n<h1 id=\"2-MySQL-schema-设计中的陷阱\"><a href=\"#2-MySQL-schema-设计中的陷阱\" class=\"headerlink\" title=\"2 MySQL schema 设计中的陷阱\"></a>2 MySQL schema 设计中的陷阱</h1><h2 id=\"2-1-太多的列\"><a href=\"#2-1-太多的列\" class=\"headerlink\" title=\"2.1 太多的列\"></a>2.1 太多的列</h2><p>MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。列转行的操作代价是非常高的。</p>\n<h2 id=\"2-2-太多的关联\"><a href=\"#2-2-太多的关联\" class=\"headerlink\" title=\"2.2 太多的关联\"></a>2.2 太多的关联</h2><p>阿里手册规定单次关联不能超过 3 张表。</p>\n<h2 id=\"2-3-全能的枚举\"><a href=\"#2-3-全能的枚举\" class=\"headerlink\" title=\"2.3 全能的枚举\"></a>2.3 全能的枚举</h2><p>CREATE TABLE … ( country enum(‘’, ‘0’, ‘1’, … , ‘31’))<br>当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，在 MySQL5.0- 这是一种阻塞操作，即使在 MySQL5.0+ ，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE。</p>\n<h2 id=\"2-4-变相的枚举\"><a href=\"#2-4-变相的枚举\" class=\"headerlink\" title=\"2.4 变相的枚举\"></a>2.4 变相的枚举</h2><p>枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值的一个或多个值。这会导致混乱。</p>\n<h2 id=\"2-5-非此发明（Not-Invent-Here）的-NULL\"><a href=\"#2-5-非此发明（Not-Invent-Here）的-NULL\" class=\"headerlink\" title=\"2.5 非此发明（Not Invent Here）的 NULL\"></a>2.5 非此发明（Not Invent Here）的 NULL</h2><p>CREATE TABLE … (dt DATETIME NOT NULL DEFAULT ‘0000-00-00 00:00:00’)<br>伪造的全 0 值可能导致很多问题。（可以配置 MySQL 的 SQL_MODE 来禁止不可能的日期，对于新应用这是个非常好的实践经验）。</p>\n<h1 id=\"3-缓存表和汇总表\"><a href=\"#3-缓存表和汇总表\" class=\"headerlink\" title=\"3 缓存表和汇总表\"></a>3 缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。</p>\n<h2 id=\"3-1-计数器表\"><a href=\"#3-1-计数器表\" class=\"headerlink\" title=\"3.1 计数器表\"></a>3.1 计数器表</h2><p>创建一张独立的表存储计数器通常是个好主意。例，有一个计数器表，只有一行数据，记录网站的点击次数：  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> hit_counter (</span><br><span class=\"line\">    cnt <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">) <span class=\"keyword\">engine</span>=<span class=\"keyword\">InnoDB</span>;</span><br></pre></td></tr></table></figure>\n<p>每次点击：<code>UPDATE hit_counter SET cnt = cnt + 1;</code><br>问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex）。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。<br>要获得统计结果：<code>SELECT SUM(cnt) FROM hit_count;</code>。<br>一个常见的需求是每隔一段时间开始一个新的计数器（例，每天一个）。如果需要这么做，则可以再简单地修改一下表设计：  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> hit_counter (</span><br><span class=\"line\">    <span class=\"keyword\">day</span> <span class=\"built_in\">date</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    slot tinyint <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    cnt <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>(<span class=\"keyword\">day</span>, slot)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span>;</span><br></pre></td></tr></table></figure>\n<p>在这个场景下，可以不用像前面的例子那样预先生成行，而是<code>ON DUPLICATE KEY UPDATE</code>代替。  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> daily_hit_counter(<span class=\"keyword\">day</span>, slot, cnt)</span><br><span class=\"line\">    <span class=\"keyword\">VALUES</span> (<span class=\"keyword\">CURRENT_DATE</span>, <span class=\"keyword\">RAND</span>() * <span class=\"number\">100</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> <span class=\"keyword\">DUPLICATE</span> <span class=\"keyword\">KEY</span> <span class=\"keyword\">UPDATE</span> cnt = cnt + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到 0 号槽，并删除所有其它的槽：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> daily_hit_counter <span class=\"keyword\">as</span> c</span><br><span class=\"line\">    <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> (</span><br><span class=\"line\">        <span class=\"keyword\">SELECT</span> <span class=\"keyword\">day</span>, <span class=\"keyword\">SUM</span>(cnt) <span class=\"keyword\">AS</span> cnt, <span class=\"keyword\">MIN</span>(slot) <span class=\"keyword\">AS</span> mslot</span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> daily_hit_counter</span><br><span class=\"line\">        <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">day</span></span><br><span class=\"line\">    ) <span class=\"keyword\">AS</span> x <span class=\"keyword\">USING</span>(<span class=\"keyword\">day</span>)</span><br><span class=\"line\"><span class=\"keyword\">SET</span> c.cnt  = <span class=\"keyword\">IF</span>(c.slot = x.mslot, x.cnt, <span class=\"number\">0</span>),</span><br><span class=\"line\">    c.slot = <span class=\"keyword\">IF</span>(c.slot = x.mslot, <span class=\"number\">0</span>, c.slot); </span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> daily_hit_counter <span class=\"keyword\">WHERE</span> slot &lt;&gt; <span class=\"number\">0</span> <span class=\"keyword\">AND</span> cnt = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-加快-ALTER-TABLE-操作的速度\"><a href=\"#4-加快-ALTER-TABLE-操作的速度\" class=\"headerlink\" title=\"4 加快 ALTER TABLE 操作的速度\"></a>4 加快 ALTER TABLE 操作的速度</h1><p>假如要修改电影的默认租赁期限，从三天改到五天，下面是很慢的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> film </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> <span class=\"keyword\">COLUMN</span> rental_duration tinyint(<span class=\"number\">3</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p><code>show status</code>语句显示这个语句做了 1000 次读和 1000 次插入操作。换句话说，它拷贝了整张表到一张新表。<br>理论上，MySQL 可以跳过创建新表的步骤，即直接修改 .frm 文件而不设计表数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> film</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> rental_duraion <span class=\"keyword\">SET</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h1><ol>\n<li>避免过度设计</li>\n<li>使用小而简单的合适数据类型，避免使用 NULL 值</li>\n<li>关联标识符尽量使用相同的数据类型</li>\n<li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存</li>\n<li>尽量使用整型定义标识列</li>\n<li>小心使用 ENUM 和 SET</li>\n<li><code>ALTER TABLE</code>在大部分情况下都会锁表并且重建整张表。建议先在备库执行<code>ALTER</code>完成后将其切换为主库</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjoojkaun0006axs6r70bwbeb","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkauz000kaxs6mvgf0hwu"},{"post_id":"cjoojkaun0006axs6r70bwbeb","category_id":"cjoojkauw000eaxs64jmdclzz","_id":"cjoojkav1000naxs6zyqbbmq8"},{"post_id":"cjoojkauh0002axs6fr8vxgul","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkav2000qaxs6lhef4x9j"},{"post_id":"cjoojkauh0002axs6fr8vxgul","category_id":"cjoojkauy000haxs6z4go3xmk","_id":"cjoojkav3000saxs6sh08lqtz"},{"post_id":"cjoojkauo0007axs6o43woe6u","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkav3000vaxs6m4q2vtu6"},{"post_id":"cjoojkauo0007axs6o43woe6u","category_id":"cjoojkauw000eaxs64jmdclzz","_id":"cjoojkav4000xaxs6zm4jx2k7"},{"post_id":"cjoojkauq0009axs6dboejpsa","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkav50010axs6ydkvtf5g"},{"post_id":"cjoojkauq0009axs6dboejpsa","category_id":"cjoojkauw000eaxs64jmdclzz","_id":"cjoojkav60012axs6kxd1x5dk"},{"post_id":"cjoojkauk0003axs6vz9vycay","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkav70015axs6emv44jtr"},{"post_id":"cjoojkauk0003axs6vz9vycay","category_id":"cjoojkauy000haxs6z4go3xmk","_id":"cjoojkav80017axs6q0ktjsht"},{"post_id":"cjoojkaur000aaxs61jpapgs6","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkav9001aaxs6w32q3df1"},{"post_id":"cjoojkaur000aaxs61jpapgs6","category_id":"cjoojkauw000eaxs64jmdclzz","_id":"cjoojkavb001caxs65kgunxqz"},{"post_id":"cjoojkaut000caxs6qhpfsyrr","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavc001faxs6y9fkeq1p"},{"post_id":"cjoojkaut000caxs6qhpfsyrr","category_id":"cjoojkauy000haxs6z4go3xmk","_id":"cjoojkavd001haxs6xs21jn5m"},{"post_id":"cjoojkaum0005axs6ppmrr420","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavf001jaxs6sz81bhtt"},{"post_id":"cjoojkaum0005axs6ppmrr420","category_id":"cjoojkauy000haxs6z4go3xmk","_id":"cjoojkavg001maxs6f545yuak"},{"post_id":"cjoojkauu000daxs6rlep4kzu","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavg001oaxs64hhtvyw4"},{"post_id":"cjoojkauu000daxs6rlep4kzu","category_id":"cjoojkavc001eaxs68ckdsrvd","_id":"cjoojkavi001raxs6afp054hc"},{"post_id":"cjoojkauw000faxs6tgg6oq3o","category_id":"cjoojkavf001kaxs6ifixia88","_id":"cjoojkavk001vaxs6tyxroxm7"},{"post_id":"cjoojkaux000gaxs6948v6aq2","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavm001zaxs6crznfrzj"},{"post_id":"cjoojkaux000gaxs6948v6aq2","category_id":"cjoojkavc001eaxs68ckdsrvd","_id":"cjoojkavm0021axs65mk828s2"},{"post_id":"cjoojkauy000iaxs6yyhlj1qt","category_id":"cjoojkavf001kaxs6ifixia88","_id":"cjoojkavn0024axs6cw0ckfad"},{"post_id":"cjoojkauz000jaxs6j787taln","category_id":"cjoojkavf001kaxs6ifixia88","_id":"cjoojkavp0027axs6lc3reo2h"},{"post_id":"cjoojkav0000maxs6sel9w4xl","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavr002caxs6w3qafqja"},{"post_id":"cjoojkav0000maxs6sel9w4xl","category_id":"cjoojkavn0023axs6b2229bqa","_id":"cjoojkavs002eaxs6glblk2g8"},{"post_id":"cjoojkav1000oaxs6a64uqa4l","category_id":"cjoojkavf001kaxs6ifixia88","_id":"cjoojkavt002gaxs6zf12phk8"},{"post_id":"cjoojkav2000raxs65mqjry7d","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavv002laxs63g6t85i8"},{"post_id":"cjoojkav2000raxs65mqjry7d","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkavw002naxs6gwi0klrr"},{"post_id":"cjoojkav3000taxs6bactihvx","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavx002qaxs6zvox9uvn"},{"post_id":"cjoojkav3000taxs6bactihvx","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkavx002saxs6sdw828yb"},{"post_id":"cjoojkav4000waxs6ilp7hzwu","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkavy002vaxs6p1eom8eo"},{"post_id":"cjoojkav4000waxs6ilp7hzwu","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkavz002xaxs6aglhy81y"},{"post_id":"cjoojkav4000yaxs6b2fmenma","category_id":"cjoojkavf001kaxs6ifixia88","_id":"cjoojkaw00030axs6lyumzwa0"},{"post_id":"cjoojkav50011axs6jovhaz9u","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaw20034axs6sp1eturn"},{"post_id":"cjoojkav50011axs6jovhaz9u","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkaw20036axs6nejnj3d6"},{"post_id":"cjoojkav60013axs67imx1ltz","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaw40039axs62q2ox8fz"},{"post_id":"cjoojkav60013axs67imx1ltz","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkaw5003baxs6wqhjm3nj"},{"post_id":"cjoojkav70016axs6ygtcmp4t","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaw6003eaxs69vanf51z"},{"post_id":"cjoojkav70016axs6ygtcmp4t","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkaw8003gaxs6qez4xhch"},{"post_id":"cjoojkav80018axs6eui1tbfq","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawa003jaxs6f8632v7p"},{"post_id":"cjoojkav80018axs6eui1tbfq","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawb003laxs6aqttmwif"},{"post_id":"cjoojkava001baxs6l3f983tf","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawc003oaxs6aie9zh2w"},{"post_id":"cjoojkava001baxs6l3f983tf","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawd003qaxs6v34o2vkn"},{"post_id":"cjoojkavb001daxs67720jsjs","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawe003taxs6g17g9fnl"},{"post_id":"cjoojkavb001daxs67720jsjs","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawf003vaxs6eowel55p"},{"post_id":"cjoojkavc001gaxs69g9zbdpo","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawg003yaxs6xgi3tlnz"},{"post_id":"cjoojkavc001gaxs69g9zbdpo","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawh0040axs6h6w40xq2"},{"post_id":"cjoojkavd001iaxs6izbudul7","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawi0043axs6oqdgnpvp"},{"post_id":"cjoojkavd001iaxs6izbudul7","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawi0045axs6n1bnem08"},{"post_id":"cjoojkavf001laxs66jkxaye8","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawj0047axs6j2878y6y"},{"post_id":"cjoojkavf001laxs66jkxaye8","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawj0048axs62x2dqjab"},{"post_id":"cjoojkavg001naxs6kr6lr7nt","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawj004aaxs67jp4ezh8"},{"post_id":"cjoojkavg001naxs6kr6lr7nt","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawk004baxs6zguo36if"},{"post_id":"cjoojkavg001paxs641jsduh5","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawk004daxs6wd9emdpt"},{"post_id":"cjoojkavg001paxs641jsduh5","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawk004eaxs64yuhvv9c"},{"post_id":"cjoojkavi001saxs6dncmqtkx","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawl004gaxs6ahjz1suk"},{"post_id":"cjoojkavi001saxs6dncmqtkx","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawl004haxs6nklozpjl"},{"post_id":"cjoojkavj001taxs6wv0dcxw4","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawl004jaxs6ur2i1nrk"},{"post_id":"cjoojkavj001taxs6wv0dcxw4","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawl004kaxs6rxibx800"},{"post_id":"cjoojkavk001waxs6ui4lyyg5","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawm004maxs6iynkatu5"},{"post_id":"cjoojkavk001waxs6ui4lyyg5","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawm004naxs6prz28udd"},{"post_id":"cjoojkavl001xaxs6olsw2kpk","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawn004paxs6g5mirpom"},{"post_id":"cjoojkavl001xaxs6olsw2kpk","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawn004qaxs6ryqr0g29"},{"post_id":"cjoojkavm0020axs6jdpcdcl4","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawn004saxs6hytzcuxb"},{"post_id":"cjoojkavm0020axs6jdpcdcl4","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawn004taxs6qxlk0n06"},{"post_id":"cjoojkavn0022axs6s1hmfk49","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawo004vaxs6a619qzx5"},{"post_id":"cjoojkavn0022axs6s1hmfk49","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawo004waxs66mw5n4r0"},{"post_id":"cjoojkavo0026axs6qy84v768","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawp004yaxs6lxqfjenh"},{"post_id":"cjoojkavo0026axs6qy84v768","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkawp0050axs63bo4d3kr"},{"post_id":"cjoojkavp0029axs65x4ep2ln","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawp0052axs6spamrbvf"},{"post_id":"cjoojkavp0029axs65x4ep2ln","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawq0053axs6iyuizwh1"},{"post_id":"cjoojkavq002aaxs61wnsggvg","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawq0055axs6e6mjcm2e"},{"post_id":"cjoojkavq002aaxs61wnsggvg","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawq0056axs6m9qtmmc3"},{"post_id":"cjoojkavr002daxs6u7ggnjz4","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawr0058axs6tjox8au4"},{"post_id":"cjoojkavr002daxs6u7ggnjz4","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkaws0059axs6d4wnw5jf"},{"post_id":"cjoojkavs002faxs6w8nbot14","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaws005baxs6tctoq53y"},{"post_id":"cjoojkavs002faxs6w8nbot14","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkaws005caxs6sjaj7842"},{"post_id":"cjoojkavt002iaxs6sik9zyy8","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawt005eaxs6wdn4mqpn"},{"post_id":"cjoojkavt002iaxs6sik9zyy8","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawt005faxs643l7joqa"},{"post_id":"cjoojkavu002jaxs62ehcftas","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawt005haxs674hkrghp"},{"post_id":"cjoojkavu002jaxs62ehcftas","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawu005iaxs6fj3ltfmr"},{"post_id":"cjoojkavv002maxs6uhbh9b9k","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawu005kaxs6jxah0yhx"},{"post_id":"cjoojkavv002maxs6uhbh9b9k","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawu005laxs6yo6jk6pg"},{"post_id":"cjoojkavw002oaxs6hh40lz08","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawu005naxs6st916odr"},{"post_id":"cjoojkavw002oaxs6hh40lz08","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawv005oaxs6gvtfx5v5"},{"post_id":"cjoojkavx002raxs6kfr0gnfp","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawv005qaxs6op4lyvvr"},{"post_id":"cjoojkavx002raxs6kfr0gnfp","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkaww005raxs6zgabdyq7"},{"post_id":"cjoojkavx002taxs63uvxqfw9","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaww005taxs6s3ajpb30"},{"post_id":"cjoojkavx002taxs63uvxqfw9","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkaww005uaxs6a2ouaeba"},{"post_id":"cjoojkavz002waxs6sidd3s6e","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawx005waxs6z9st1vxc"},{"post_id":"cjoojkavz002waxs6sidd3s6e","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawx005xaxs6a2fvr9w9"},{"post_id":"cjoojkavz002yaxs6mqvzzw0y","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkawx005yaxs6iidrup1g"},{"post_id":"cjoojkavz002yaxs6mqvzzw0y","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkawx0060axs6ypteyit8"},{"post_id":"cjoojkaw00031axs6ddtpj6qr","category_id":"cjoojkaww005vaxs6aa1jmjo5","_id":"cjoojkawy0062axs6d3bxss24"},{"post_id":"cjoojkaw20035axs6iefsmbr7","category_id":"cjoojkaww005vaxs6aa1jmjo5","_id":"cjoojkawy0065axs6a6rgqmyj"},{"post_id":"cjoojkaw30037axs6kp4txxw2","category_id":"cjoojkaww005vaxs6aa1jmjo5","_id":"cjoojkawz0067axs63jjctm2m"},{"post_id":"cjoojkaw4003aaxs6atb2gnbe","category_id":"cjoojkaww005vaxs6aa1jmjo5","_id":"cjoojkawz0069axs63qukpuh8"},{"post_id":"cjoojkaw5003caxs67befl6zn","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkax0006baxs63pzgkdih"},{"post_id":"cjoojkaw5003caxs67befl6zn","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkax0006caxs67s9q7haf"},{"post_id":"cjoojkaw7003faxs689b5zyrt","category_id":"cjoojkaww005vaxs6aa1jmjo5","_id":"cjoojkax0006daxs6kfk2x23l"},{"post_id":"cjoojkaw8003haxs6pmjfkhqi","category_id":"cjoojkax0006aaxs6p86t4sh2","_id":"cjoojkax1006gaxs6ybvwwfhl"},{"post_id":"cjoojkawa003kaxs69vubvn4i","category_id":"cjoojkaww005vaxs6aa1jmjo5","_id":"cjoojkax1006iaxs6ovfg9uzl"},{"post_id":"cjoojkawb003maxs63ys7stlj","category_id":"cjoojkax0006aaxs6p86t4sh2","_id":"cjoojkax2006kaxs6lt3iuiox"},{"post_id":"cjoojkawc003paxs64ean5mtf","category_id":"cjoojkax0006aaxs6p86t4sh2","_id":"cjoojkax2006maxs6ws9jayw1"},{"post_id":"cjoojkawd003raxs62o6o93g4","category_id":"cjoojkax0006aaxs6p86t4sh2","_id":"cjoojkax3006oaxs6nvr0f1g9"},{"post_id":"cjoojkawe003uaxs6s8txgk0t","category_id":"cjoojkax0006aaxs6p86t4sh2","_id":"cjoojkax8006qaxs6u4b9lzaf"},{"post_id":"cjoojkawf003waxs6zut8wdgw","category_id":"cjoojkax0006aaxs6p86t4sh2","_id":"cjoojkax8006raxs6zc07afza"},{"post_id":"cjoojkawg003zaxs6c1y5wzhf","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkax8006taxs6o2texda0"},{"post_id":"cjoojkawg003zaxs6c1y5wzhf","category_id":"cjoojkax7006paxs6q0run3l1","_id":"cjoojkax9006vaxs66r8hktvy"},{"post_id":"cjoojkawh0041axs6sng4ayho","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkax9006xaxs643umfv8t"},{"post_id":"cjoojkawh0041axs6sng4ayho","category_id":"cjoojkax8006saxs65lwc5tet","_id":"cjoojkax9006yaxs6k1zoducj"},{"post_id":"cjoojkawi0044axs6hwbrjrex","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkax9006zaxs685iq5491"},{"post_id":"cjoojkawi0044axs6hwbrjrex","category_id":"cjoojkax8006saxs65lwc5tet","_id":"cjoojkaxa0071axs6raz9mjua"},{"post_id":"cjoojkavo0025axs63pw9knkh","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaxa0072axs6iz2i15c4"},{"post_id":"cjoojkavo0025axs63pw9knkh","category_id":"cjoojkavr002baxs6843vh09t","_id":"cjoojkaxa0073axs6267wciy7"},{"post_id":"cjoojkavo0025axs63pw9knkh","category_id":"cjoojkax9006waxs6oytld147","_id":"cjoojkaxa0074axs6ay7v54t9"},{"post_id":"cjoojkaw10032axs60csyb7cy","category_id":"cjoojkaul0004axs6utinuvdd","_id":"cjoojkaxa0075axs6xwgs1f6o"},{"post_id":"cjoojkaw10032axs60csyb7cy","category_id":"cjoojkawo004xaxs67pzykmjr","_id":"cjoojkaxa0076axs62x9pxwq9"},{"post_id":"cjoojkaw10032axs60csyb7cy","category_id":"cjoojkax90070axs6ab02nxtp","_id":"cjoojkaxa0077axs687dsnahi"}],"PostTag":[],"Tag":[]}}