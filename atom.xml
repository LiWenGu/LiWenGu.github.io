<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello</title>
  
  <subtitle>严律己，宽待人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.liwenguang.cn/"/>
  <updated>2017-12-31T14:58:00.000Z</updated>
  <id>http://www.liwenguang.cn/</id>
  
  <author>
    <name>TheOhters</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017 总结</title>
    <link href="http://www.liwenguang.cn/2017/12/31/talker/mind_1.html/"/>
    <id>http://www.liwenguang.cn/2017/12/31/talker/mind_1.html/</id>
    <published>2017-12-31T14:58:00.000Z</published>
    <updated>2017-12-31T14:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>书在 10.1 之后明显看的比以前多了，学的也比以前更多了，<br>看完书才发现，其实书籍比博客对初学者更友好，因为书是一个只是的体系，<br>它会完整的介绍某个技术，而不像博客，毕竟博客只有那么长，书却是一本，<br>感觉对我而言，书籍适合技术沉淀，博客适合应对工作。<br>但是，博客比书看的更轻松。<br>另外，虽然说有的书应该看第二遍，但是我个人觉得，<br>我现在应该多看点书，然后再从某些精华书选出值得看第二遍的书。<br>最近一个星期感觉看书看不进去，因此准备新年换个方式看书，<br>原来是一个章节一个章节的读，原因在于，我以前没尝试完完整整的读完一本书。<br>新的伪一年，截止到真正意义上的过年前，我尝试看书只写一篇笔记，<br>如果是偏代码的书籍，我会建议一个项目，并将思维导图以及代码放在 <code>github</code>，<br>这样一本书就变成了一个图和代码库，而本博客也变成总结的以及写些自己的感想，<br>例如，读书感想，以及在不同的技术点应该看什么书，当然，肯定是以我自己为准，<br>不然我都没看过，就介绍，那不就尴尬吗，而且有的书，是需要有某些技术的基础看的才会学习的更快。<br>新的一年，希望自己能朝着自己想要的方向发展。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;书在 10.1 之后明显看的比以前多了，学的也比以前更多了，&lt;br&gt;看完书才发现，其实书籍比博客对初学者更友好，因为书是一个只是的体系，&lt;br&gt;它会完整的介绍某个技术，而不像博客，毕竟博客只有那么长，书却是一本，&lt;br&gt;感觉对我而言，书籍适合技术沉淀，博客适合应对工作。&lt;b
      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.liwenguang.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>阻塞队列的低版本实现</title>
    <link href="http://www.liwenguang.cn/2017/12/28/current/1.html/"/>
    <id>http://www.liwenguang.cn/2017/12/28/current/1.html/</id>
    <published>2017-12-28T12:14:00.000Z</published>
    <updated>2017-12-28T12:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulateBlockingQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 底层队列</span></div><div class="line">    <span class="keyword">private</span> LinkedList list = <span class="keyword">new</span> LinkedList();</div><div class="line"></div><div class="line">    <span class="comment">// 队列数据的上下限</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimulateBlockingQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.maxSize = size - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 存数据</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="keyword">while</span> (list.size() == <span class="keyword">this</span>.maxSize) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            list.add(obj);</div><div class="line">            lock.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取数据</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="keyword">while</span> (list.size() == <span class="keyword">this</span>.minSize) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            result = list.removeFirst();</div><div class="line">            lock.notify();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> list.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> SimulateBlockingQueue mq = <span class="keyword">new</span> SimulateBlockingQueue(<span class="number">5</span>);</div><div class="line"></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">                    mq.put(i);</div><div class="line">                    System.out.println(<span class="string">"++增加："</span> + i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"t1"</span>);</div><div class="line">        t1.start();</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">                    System.out.println(<span class="string">"移除："</span> + mq.get());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"t2"</span>);</div><div class="line">        t2.start();</div><div class="line"></div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后发现不是 list.size() 的问题，是打印的问题，代码改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulateBlockingQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 底层队列</span></div><div class="line">    <span class="keyword">private</span> LinkedList list = <span class="keyword">new</span> LinkedList();</div><div class="line">    <span class="comment">// 原子性</span></div><div class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 队列数据的上下限</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minSize = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimulateBlockingQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.maxSize = size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 存数据</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="keyword">while</span> (list.size() == <span class="keyword">this</span>.maxSize) &#123;  <span class="comment">// 对比可以使用count</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"++++增加："</span> + obj);</div><div class="line">            list.add(obj);</div><div class="line">            count.incrementAndGet();</div><div class="line">            lock.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取数据</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object result;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="keyword">while</span> (list.size() == <span class="keyword">this</span>.minSize) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            result = list.removeFirst();</div><div class="line">            System.out.println(<span class="string">"--移除："</span> + result);</div><div class="line">            count.decrementAndGet();</div><div class="line">            lock.notify();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> list.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> SimulateBlockingQueue mq = <span class="keyword">new</span> SimulateBlockingQueue(<span class="number">5</span>);</div><div class="line"></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">                    mq.put(i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"t1"</span>);</div><div class="line">        t1.start();</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">                    mq.get();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"t2"</span>);</div><div class="line">        t2.start();</div><div class="line"></div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>思路来源：<a href="https://www.jianshu.com/p/99b7ef411988" target="_blank" rel="external">https://www.jianshu.com/p/99b7ef411988</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在复习阻塞队列时，使用原生的 wait、notify 自己实现的阻塞队列竟然出现超最大长度的问题，有问题的代码如下：  &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div c
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="并发" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>五、创建高性能的索引</title>
    <link href="http://www.liwenguang.cn/2017/12/28/high_performance_MySQL/5.html/"/>
    <id>http://www.liwenguang.cn/2017/12/28/high_performance_MySQL/5.html/</id>
    <published>2017-12-27T16:28:00.000Z</published>
    <updated>2017-12-27T16:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。</p><h1 id="1-索引基础"><a href="#1-索引基础" class="headerlink" title="1 索引基础"></a>1 索引基础</h1><h2 id="1-1-索引的类型"><a href="#1-1-索引的类型" class="headerlink" title="1.1 索引的类型"></a>1.1 索引的类型</h2><p>在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准。即使多个存储引擎支持同一种类型的索引，其底层的事先也可能不同。</p><h3 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B-Tree 索引"></a>1. B-Tree 索引</h3><p>InnoDB 本质是“B+Tree”。假设有如下数据表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</div><div class="line">    last_name  <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    first_name <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    dob        <span class="built_in">date</span>           <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    gender     enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">key</span>(last_name, first_name, dob)</div><div class="line">)</div></pre></td></tr></table></figure><p>对于表中的每一行数据，索引中包含了 last_name、first_name和 dob 列的值，下图显示了该索引是如何组织数据的存储的：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_1.png" alt=""><br>注：索引对多个值进行排序的依据是<code>CREATE TABLE</code>语句中定义索引时列的顺序。</p><ol><li>全值匹配：指和索引中的所有列进行匹配。</li><li>匹配最左前缀：前面提到的索引可用于查询所有姓为 Allen 的人，即只使用索引的第一列。</li><li>匹配列前缀：例如查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。</li><li>匹配范围值：例如查找姓在 Allen 和 Barrymore 之间的人。</li><li>精确匹配某一列并范围匹配另外一列：查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</li><li>只访问索引的查询</li></ol><p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的<code>ORDER BY</code>操作（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果<code>ORDER BY</code>子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。  </p><p>下面是一些关于 B-Tree 索引的限制：</p><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引。例，上面的例子的索引无法查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。这是关于<code>like &#39;%关键字&#39;</code>的知乎讨论：<a href="https://www.zhihu.com/question/52718330?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/52718330?sort=created</a></li><li>不能跳过索引中的列。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。</li></ul><p>有些限制并不是 B-Tree 本身导致的，而是 MySQL 优化器和存储引擎使用索引的方式导致的，这部分限制在未来的版本中可能就不再是限制了。</p><h3 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h3><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。  </p><ol><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况这一点对性能的影响并不明显。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li><li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例，在（A,B）建立哈希索引，如果查询只有 A ，则无法使用该索引。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针。</li></ol><p>当字段过大，例如存储 URL 时，可以额外使用一个列，用于存储该列的哈希，用于排序。但为了避免哈希冲突的问题，需要<code>where url = &#39;http://www.mysql.com&#39; AND url_crc=CRC32(&#39;http://www.mysql.com&#39;)</code>，这样的性能会非常高。（可以使用触发器来自身插入哈希列）。</p><h3 id="3-空间数据索引（R-Tree）"><a href="#3-空间数据索引（R-Tree）" class="headerlink" title="3. 空间数据索引（R-Tree）"></a>3. 空间数据索引（R-Tree）</h3><p>MyISAM 表支持空间索引。</p><h3 id="4-全文索引"><a href="#4-全文索引" class="headerlink" title="4. 全文索引"></a>4. 全文索引</h3><p>使用<code>MATCH AGAINST</code>操作，而不是普通的<code>WHERE</code>。</p><h1 id="2-索引的优点"><a href="#2-索引的优点" class="headerlink" title="2 索引的优点"></a>2 索引的优点</h1><p>最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据时有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询：  </p><ol><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机 I/O 变为顺序 I/O。</li></ol><p>对于中到大型表，索引就非常有效。但对于特大型表，需要技术直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例，分区技术：建立元数据信息表，例，假如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。</p><h1 id="3-高性能索引的索引策略"><a href="#3-高性能索引的索引策略" class="headerlink" title="3 高性能索引的索引策略"></a>3 高性能索引的索引策略</h1><h2 id="3-1-前缀索引和索引选择性"><a href="#3-1-前缀索引和索引选择性" class="headerlink" title="3.1 前缀索引和索引选择性"></a>3.1 前缀索引和索引选择性</h2><p>索引选择性：不重复的索引值/数据表的记录总数，范围在0~1间，越高则查询越快。唯一索引的选择性是1，性能也是最好的。<br>列值过长，可以使用部分字段<code>LEFT(city,3)</code>作为前缀索引，这个值是通过<code>COUNT(DISTINCT LEFT(city,5))/COUNT(*)</code>的值来决定的，结果在 0.031 基本上就可用了。接着创建：<code>ALTER TABLE sakila.city_demo ADD KEY(city(5));</code><br>但是前缀索引虽然使索引更小、更快，但是无法使用前缀索引做<code>ORDER BY</code>和<code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。</p><blockquote><p>后缀索引（suffix index）也很有用途（电子邮箱），可以使用字符串反转后存储。</p></blockquote><h2 id="3-2-多列索引"><a href="#3-2-多列索引" class="headerlink" title="3.2 多列索引"></a>3.2 多列索引</h2><p>为每个列创建独立的索引，从<code>SHOW CREATE TABLE</code>中很容易看到这种情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(</div><div class="line">    c1 <span class="built_in">INT</span>,</div><div class="line">    c2 <span class="built_in">INT</span>,</div><div class="line">    c3 <span class="built_in">INT</span>,</div><div class="line">    <span class="keyword">key</span>(c1),</div><div class="line">    <span class="keyword">key</span>(c2),</div><div class="line">    <span class="keyword">key</span>(c3)</div><div class="line">)</div></pre></td></tr></table></figure><p>这种索引策略是由于“把 WHERE 条件里面的列都建上索引”这样模糊的建议导致的。这最多是“一星”索引。例，<code>WHERE c1 = &#39;1&#39; OR c2 = &#39;2&#39;</code>，虽然在 MySQL5.0+ 会优化使用这两个索引，但是在 <code>explain</code> 的 <code>extra</code> 中会有 <code>Using union</code>，因此说明了索引的糟糕：  </p><ol><li>出现多个 <code>AND</code> 条件，则需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li><li>多个 <code>OR</code> 或者联合操作时，如果有些索引的选择性不高，需要合并扫描返回的大量数据。</li><li>如果在 <code>EXPLAIN</code> 中看到有索引合并，应该好好检查查询和表的结构，也可以通过参数 <code>optimizer_switch</code> 来关闭索引合并功能，也可以使用 <code>IGNORE INDEX</code> 提示让优化器忽略掉某些索引。</li></ol><h2 id="3-3-选择合适的索引列顺序"><a href="#3-3-选择合适的索引列顺序" class="headerlink" title="3.3 选择合适的索引列顺序"></a>3.3 选择合适的索引列顺序</h2><p>最好通过 <code>pt-query-digest</code> 这样的工具报告重提取“最差”查询，再按照索引顺序进行优化。如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局性和选择性，而不是某个具体查询：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_2.png" alt=""><br><code>customer_id</code> 的选择性更高，所以答案是将其作为索引列的第一列。</p><h2 id="3-4-覆盖索引"><a href="#3-4-覆盖索引" class="headerlink" title="3.4 覆盖索引"></a>3.4 覆盖索引</h2><p>如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”。  </p><ol><li>因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。</li><li>并不是所有类型的索引都可以称为覆盖索引。覆盖索引必须要存储索引列的值。</li></ol><p>当发起一个被覆盖的查询，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>Using index</code> 的信息。</p><blockquote><p><code>type</code> 列的 <code>index</code> 和 <code>Extra</code> 列的 <code>Using index</code> 是完全不同，前者和覆盖索引毫无关系，它只是表示这个查询访问数据的方式。</p></blockquote><p>索引覆盖查询还有很多陷阱可能导致无法实现优化：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_3.png" alt="">  </p><ol><li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。</li><li>MySQL 不能再索引中执行 <code>LIKE</code> 操作，MySQL5.5- 只允许在索引中做简单比较操作，MySQL 能在索引中做最左前缀匹配的 <code>LIKE</code> 查询，因为该操作可以转为简单的比较操作，但是如果是通配符开头的 <code>LIKE</code> 查询，存储引擎就无法做比较匹配。这种情况下，MySQL 服务器只能提取数据行的值，而不是索引值来做比较。</li></ol><p>也有办法解决上面说的两个问题，重写查询并巧妙地设计索引。先将索引扩展至三个数据列（artist，title，prod_id），然后按如下方式重写查询：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_4.png" alt=""></p><h2 id="3-5-使用索引扫描来做排序"><a href="#3-5-使用索引扫描来做排序" class="headerlink" title="3.5 使用索引扫描来做排序"></a>3.5 使用索引扫描来做排序</h2><p>MySQL 有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描；如果 <code>EXPLAIN</code> 出来的 type 列的值为 “index”，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）。<br>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。<br>如果查询需要关联多张表，则只有当 <code>ORDER BY</code> 子句引用的字段全部为第一个表时，才能使用索引做排序。</p><p>例： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rental(</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(rental_id),</div><div class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> rental_date(rental_date, inventory_id, customer_id),</div><div class="line">    <span class="keyword">KEY</span> idx_fk_inventory_id(inventory_id),</div><div class="line">    <span class="keyword">KEY</span> idx_fk_customer_id(customer_id),</div><div class="line">    <span class="keyword">KEY</span> idx_fk_staff_id(staff_id),</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure><p><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id</code> 因为索引第一列被指定为一个常数，所以查询排序。<br><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id</code> 也可以使用查询排序。<br><code>WHERE rental_date &gt; &#39;2005-05-25 ORDER BY rental_date, inventory_id</code> 也可以。<br>下面是不能使用索引做排序的查询：  </p><ol><li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id DESC, customer_id ASC;</code> 因为索引列都是正序排序。</li><li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, staff_id;</code> 因为引用了一个不再索引中的列。</li><li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY customer_id;</code> 无法组成索引的最左前缀。</li><li><code>WHERE rental_date &gt; &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id;</code> 因为第一列上是范围条件。</li><li><code>WHERE rental_date = &#39;2015-05-25&#39; AND inventory_id IN (1,2) ORDER BY customer_id;</code> 还是范围查询。</li></ol><h1 id="4-索引案例学习"><a href="#4-索引案例学习" class="headerlink" title="4 索引案例学习"></a>4 索引案例学习</h1><h1 id="5-维护索引和表"><a href="#5-维护索引和表" class="headerlink" title="5 维护索引和表"></a>5 维护索引和表</h1><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。&lt;/p&gt;
&lt;h1 id=&quot;1-索引基础&quot;&gt;&lt;a href=&quot;#1-索引基础&quot; class=&quot;headerlink&quot; title=&quot;1 索
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="高性能MySQL" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty实战笔记</title>
    <link href="http://www.liwenguang.cn/2017/12/26/netty_in_action/1.html/"/>
    <id>http://www.liwenguang.cn/2017/12/26/netty_in_action/1.html/</id>
    <published>2017-12-26T14:46:00.000Z</published>
    <updated>2017-12-26T14:46:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty实战" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>四、Schema与数据类型优化</title>
    <link href="http://www.liwenguang.cn/2017/12/25/high_performance_MySQL/4.html/"/>
    <id>http://www.liwenguang.cn/2017/12/25/high_performance_MySQL/4.html/</id>
    <published>2017-12-25T04:31:00.000Z</published>
    <updated>2017-12-27T16:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-选择优化的数据类型"><a href="#1-选择优化的数据类型" class="headerlink" title="1 选择优化的数据类型"></a>1 选择优化的数据类型</h1><ol><li>更小的通常更好</li><li>简单就好：整型比字符操作代价更低，使用 MySQL 内建的类型而不是字符串来存储日期和时间，以及使用整型存储 IP 地址</li><li>尽量避免 NULL：可为 NULL 的列会使用更多的存储空间。 InnoDB 使用单独的位（bit）存储 NULL 值，但这不适用于 MyISAM</li></ol><p>在为列选择数据类型时，先确定大类型：数字、字符串、时间等。下一步是选择具体类型，很多数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。例如， TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，另一方面， TIMESTAMP 允许的时间范围要小得多。  </p><p>本章只讨论基本的数据类型。 MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC ，它们只是别名，使用 SHOW CREATE TABLE 检查， MYSQL 报告的是基本类型，而不是别名。</p><h2 id="1-1-整数类型"><a href="#1-1-整数类型" class="headerlink" title="1.1 整数类型"></a>1.1 整数类型</h2><p>TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8、16、24、32、64 位存储空间。它们可以存储的值得范围 -2^(N-1) ~ 2^(N-1) - 1，其中 N 是存储空间的位数。整数类型有可选的 UNSIGNED 属性，表示不允许负数，这样可以提高一倍的正数上限。  </p><p>整数计算一般使用 64 位的 BIGINT 整数。整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如 MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。</p><h2 id="1-2-实数类型"><a href="#1-2-实数类型" class="headerlink" title="1.2 实数类型"></a>1.2 实数类型</h2><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也不支持不精确类型。因为 CPU 不支持对 DECIMAL 的直接计算，所以在 MySQL5.0+ MySQL 服务器自身实现了 DECIMAL 的高精度计算，相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。<br>DECIMAL 的字节存储：每四个字节存储 9 个数字，例：DECIMAL(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。<br>浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。 DOUBLE 占用 8 个字节。MySQL 使用 DOUBLE 作为内部浮点计算的类型。<br>将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。（根据小数的位数乘以相应的倍数）</p><h2 id="1-3-字符串类型"><a href="#1-3-字符串类型" class="headerlink" title="1.3 字符串类型"></a>1.3 字符串类型</h2><h3 id="1-VARCHAR-和-CHAR-类型"><a href="#1-VARCHAR-和-CHAR-类型" class="headerlink" title="1.VARCHAR 和 CHAR 类型"></a>1.VARCHAR 和 CHAR 类型</h3><h4 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h4><p>VARCHAR 类型用于存储可变长字符串，如果 MySQL 表使用 ROW_FORMAT = FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。<br>VARCHAR 在列最大长度 &lt;=255 字节的时候，额外用 1 个字节用于记录字符串的长度。例：VARCHAR(10) 的列需要 11 个字节的存储空间。VARCHAR(1000) 的列则需要 1002 个字节，因为需要 2 个字节存储长度信息。<br>MySQL5.0+ 在存储和检索时会保留末尾空格。<br>但是，由于行是变长的，在 UPDATE 时可能使行变得比原来长，这就导致需要额外的工作。<br>另外，InnoDB 可以把过长的 VARCHAR 存储为 BLOB，稍后讨论该问题。</p><h4 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h4><p>CHAR 类型是定长的，MySQL 总是根据定义的字符串长度分配足够的空间。<br>存储 CHAR 值时，MySQL 会删除所有的末尾空格。</p><h4 id="CHAR-VS-VARCHAR"><a href="#CHAR-VS-VARCHAR" class="headerlink" title="CHAR VS VARCHAR"></a>CHAR VS VARCHAR</h4><p>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例：存储密码的 MD5 值，因为这是一个定长的值。<br>对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。<br>对于非常短的值， CHAR(1) 比 VARCHAR(1) 在存储空间上也更有效率（后者需要额外一个字节存储长度）。<br>VARCHAR(100) 和 VARCHAR(200) 虽然在存储空间相同，但是在内存消耗不同，后者更大。尤其在排序和临时表（中间表）时。<br>摘自：<a href="http://tech.it168.com/a2011/0426/1183/000001183173.shtml" target="_blank" rel="external">http://tech.it168.com/a2011/0426/1183/000001183173.shtml</a></p><h3 id="2-BLOB-和-TEXT-类型"><a href="#2-BLOB-和-TEXT-类型" class="headerlink" title="2. BLOB 和 TEXT 类型"></a>2. BLOB 和 TEXT 类型</h3><p>BLOB 采用二进制存储、TEXT 采用字符存储。<br>与其它类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。当其太大时， InnoDB 会使用专门的“外部”存储区域进行存储。此时每个值在行内需要 1~4 个字节存储一个指针，然后再外部存储区域实际的值。<br>排序：MySQL 只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。可以减少 max_sort_length 的值或者使用 ORDER BY SUBSTRING(column, length)。<br>MySQL 不能讲 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。<br>进行 ORDER BY 为了防止临时表过大，可以使用 SUBSTRING(column, length) 进行长度切割。</p><h3 id="3-使用枚举（ENUM）-代替字符串类型"><a href="#3-使用枚举（ENUM）-代替字符串类型" class="headerlink" title="3. 使用枚举（ENUM） 代替字符串类型"></a>3. 使用枚举（ENUM） 代替字符串类型</h3><p>MySQL 在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “数字-字符串”映射关系的“查找表”。<br>在 VARCHAR 与 ENUM 互相 JOIN 关联时，ENUM 与 ENUM 最快。因此如果不是必须和 VARCHAR 列进行关联，那么转换这些列为 ENUM 就是个好主意。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。</p><h2 id="1-4-日期和时间类型"><a href="#1-4-日期和时间类型" class="headerlink" title="1.4 日期和时间类型"></a>1.4 日期和时间类型</h2><h3 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1.DATETIME"></a>1.DATETIME</h3><p>这个类型能保存大范围的值，精度为秒。使用 8 个字节的存储空间。</p><h3 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2.TIMESTAMP"></a>2.TIMESTAMP</h3><p>保存了从 1970年1月1日~2038年，MySQL 提供了 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数将日期和 Unix 时间戳转换。使用 4 个字节存储。</p><h2 id="1-5-位数据类型"><a href="#1-5-位数据类型" class="headerlink" title="1.5 位数据类型"></a>1.5 位数据类型</h2><h3 id="1-BIT"><a href="#1-BIT" class="headerlink" title="1.BIT"></a>1.BIT</h3><p>尽量少用。</p><h3 id="2-SET"><a href="#2-SET" class="headerlink" title="2.SET"></a>2.SET</h3><p>如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间。缺点是改变列的定义代价较高：需要 ALTER TABLE（这对大表是非常昂贵的操作，但是后面给出了解决方法）。一般来说，也无法再 SET 列上通过索引查找。</p><blockquote><p>在整数列进行按位操作<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;SET @CAN_READ   := 1 &lt;&lt; 0,</div><div class="line">&gt;     @CAN_WRITE  := 1 &lt;&lt; 1,</div><div class="line">&gt;     @CAN_DELETE := 1 &lt;&lt; 2;</div><div class="line">&gt;CREATE TABLE acl (</div><div class="line">&gt;     perms TINYINT UNSIGNED NOT NULL DEFAULT 0    </div><div class="line">&gt;);</div><div class="line">&gt;INSERT INTO acl(perms) VALUES (@CAN_READ+@CAN_DELETE);</div><div class="line">&gt;SELECT perms FROM acl WHERE perms &amp; @CAN_READ;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p><p>当然，也可以使用代码变量而不是 MySQL 变量。</p></blockquote><h2 id="1-6-选择标识符（identifier）"><a href="#1-6-选择标识符（identifier）" class="headerlink" title="1.6 选择标识符（identifier）"></a>1.6 选择标识符（identifier）</h2><p>标识列与其它值进行比较（例，在关联操作中），或通过标识列寻找其它列。标识列也可能在另外的表中作为外键使用。<br>选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。例， MySQL 在内部使用整数存储 ENUM 和 SET 类型，然后在做比较操作时转换为字符串。<br>在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。例如，TINYINT 比 INT 少了 3 个字节，但是可能导致很大的性能差异。<br>尽量使用整数。如果存储 UUID 值，用 UNHEX() 函数转换为 16 字节的数字存储，并且存储在一个 BINARY(16) 列中。</p><h2 id="1-7-特殊类型数据"><a href="#1-7-特殊类型数据" class="headerlink" title="1.7 特殊类型数据"></a>1.7 特殊类型数据</h2><p>例，IPv4 地址人们通常使用 VARCHAR(15) 列来存储 IP 地址。然而，它们实际上是 32 位无符号整数，不是字符串。所以应该用无符号整数存储 IP 地址。 MySQL 提供 INET_ATON() 和 INET_NTOA() 函数在这两种表示方法之间转换。</p><h1 id="2-MySQL-schema-设计中的陷阱"><a href="#2-MySQL-schema-设计中的陷阱" class="headerlink" title="2 MySQL schema 设计中的陷阱"></a>2 MySQL schema 设计中的陷阱</h1><h2 id="2-1-太多的列"><a href="#2-1-太多的列" class="headerlink" title="2.1 太多的列"></a>2.1 太多的列</h2><p>MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。列转行的操作代价是非常高的。</p><h2 id="2-2-太多的关联"><a href="#2-2-太多的关联" class="headerlink" title="2.2 太多的关联"></a>2.2 太多的关联</h2><p>阿里手册规定单次关联不能超过 3 张表。</p><h2 id="2-3-全能的枚举"><a href="#2-3-全能的枚举" class="headerlink" title="2.3 全能的枚举"></a>2.3 全能的枚举</h2><p>CREATE TABLE … ( country enum(‘’, ‘0’, ‘1’, … , ‘31’))<br>当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，在 MySQL5.0- 这是一种阻塞操作，即使在 MySQL5.0+ ，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE。</p><h2 id="2-4-变相的枚举"><a href="#2-4-变相的枚举" class="headerlink" title="2.4 变相的枚举"></a>2.4 变相的枚举</h2><p>枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值的一个或多个值。这会导致混乱。</p><h2 id="2-5-非此发明（Not-Invent-Here）的-NULL"><a href="#2-5-非此发明（Not-Invent-Here）的-NULL" class="headerlink" title="2.5 非此发明（Not Invent Here）的 NULL"></a>2.5 非此发明（Not Invent Here）的 NULL</h2><p>CREATE TABLE … (dt DATETIME NOT NULL DEFAULT ‘0000-00-00 00:00:00’)<br>伪造的全 0 值可能导致很多问题。（可以配置 MySQL 的 SQL_MODE 来禁止不可能的日期，对于新应用这是个非常好的实践经验）。</p><h1 id="3-缓存表和汇总表"><a href="#3-缓存表和汇总表" class="headerlink" title="3 缓存表和汇总表"></a>3 缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。</p><h2 id="3-1-计数器表"><a href="#3-1-计数器表" class="headerlink" title="3.1 计数器表"></a>3.1 计数器表</h2><p>创建一张独立的表存储计数器通常是个好主意。例，有一个计数器表，只有一行数据，记录网站的点击次数：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</div><div class="line">    cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span></div><div class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</div></pre></td></tr></table></figure><p>每次点击：<code>UPDATE hit_counter SET cnt = cnt + 1;</code><br>问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex）。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。<br>要获得统计结果：<code>SELECT SUM(cnt) FROM hit_count;</code>。<br>一个常见的需求是每隔一段时间开始一个新的计数器（例，每天一个）。如果需要这么做，则可以再简单地修改一下表设计：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</div><div class="line">    <span class="keyword">day</span> <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    slot tinyint <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    primary <span class="keyword">key</span>(<span class="keyword">day</span>, slot)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</div></pre></td></tr></table></figure><p>在这个场景下，可以不用像前面的例子那样预先生成行，而是<code>ON DUPLICATE KEY UPDATE</code>代替。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> daily_hit_counter(<span class="keyword">day</span>, slot, cnt)</div><div class="line">    <span class="keyword">VALUES</span> (<span class="keyword">CURRENT_DATE</span>, <span class="keyword">RAND</span>() * <span class="number">100</span>, <span class="number">1</span>)</div><div class="line">    <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> cnt = cnt + <span class="number">1</span>;</div></pre></td></tr></table></figure><p>如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到 0 号槽，并删除所有其它的槽：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> daily_hit_counter <span class="keyword">as</span> c</div><div class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</div><div class="line">        <span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="keyword">SUM</span>(cnt) <span class="keyword">AS</span> cnt, <span class="keyword">MIN</span>(slot) <span class="keyword">AS</span> mslot</div><div class="line">        <span class="keyword">FROM</span> daily_hit_counter</div><div class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></div><div class="line">    ) <span class="keyword">AS</span> x <span class="keyword">USING</span>(<span class="keyword">day</span>)</div><div class="line"><span class="keyword">SET</span> c.cnt  = <span class="keyword">IF</span>(c.slot = x.mslot, x.cnt, <span class="number">0</span>),</div><div class="line">    c.slot = <span class="keyword">IF</span>(c.slot = x.mslot, <span class="number">0</span>, c.slot); </div><div class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> daily_hit_counter <span class="keyword">WHERE</span> slot &lt;&gt; <span class="number">0</span> <span class="keyword">AND</span> cnt = <span class="number">0</span>;</div></pre></td></tr></table></figure><h1 id="4-加快-ALTER-TABLE-操作的速度"><a href="#4-加快-ALTER-TABLE-操作的速度" class="headerlink" title="4 加快 ALTER TABLE 操作的速度"></a>4 加快 ALTER TABLE 操作的速度</h1><p>假如要修改电影的默认租赁期限，从三天改到五天，下面是很慢的方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film </div><div class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> rental_duration tinyint(<span class="number">3</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">5</span>;</div></pre></td></tr></table></figure><p><code>show status</code>语句显示这个语句做了 1000 次读和 1000 次插入操作。换句话说，它拷贝了整张表到一张新表。<br>理论上，MySQL 可以跳过创建新表的步骤，即直接修改 .frm 文件而不设计表数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> rental_duraion <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</div></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ol><li>避免过度设计</li><li>使用小而简单的合适数据类型，避免使用 NULL 值</li><li>关联标识符尽量使用相同的数据类型</li><li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存</li><li>尽量使用整型定义标识列</li><li>小心使用 ENUM 和 SET</li><li><code>ALTER TABLE</code>在大部分情况下都会锁表并且重建整张表。建议先在备库执行<code>ALTER</code>完成后将其切换为主库</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-选择优化的数据类型&quot;&gt;&lt;a href=&quot;#1-选择优化的数据类型&quot; class=&quot;headerlink&quot; title=&quot;1 选择优化的数据类型&quot;&gt;&lt;/a&gt;1 选择优化的数据类型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;更小的通常更好&lt;/li&gt;
&lt;li&gt;简单就好：整型比字符操
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="高性能MySQL" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal 的心得</title>
    <link href="http://www.liwenguang.cn/2017/12/22/tech/threadlocal_1.html/"/>
    <id>http://www.liwenguang.cn/2017/12/22/tech/threadlocal_1.html/</id>
    <published>2017-12-21T17:24:00.000Z</published>
    <updated>2017-12-21T17:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：<br>ThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLoaclMap）实例，这样不同的Thread 有不同的 ThreadLocalMap 实例，就不用考虑锁的问题。<br>另外为了避免内存泄漏、回收不及时等问题，从而让 ThreadLocalMap 的 key 使用弱引用。<br>同时，为了保证当 key 为 null 时，value 无法正常释放时，在每次 set 时，都会遍历 key ，当 key 为 null 则会执行 replaceStaleEntry()，即将 key 为 null 的 value 值也置为 null，从而来让其回收。<br>这里讲解更加详细：<a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="external">http://www.jasongj.com/java/threadlocal/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：&lt;br&gt;ThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLo
      
    
    </summary>
    
      <category term="小结" scheme="http://www.liwenguang.cn/categories/%E5%B0%8F%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>《MyBatis 从入门到精通》总结</title>
    <link href="http://www.liwenguang.cn/2017/12/18/tech/mybatis0to1.html/"/>
    <id>http://www.liwenguang.cn/2017/12/18/tech/mybatis0to1.html/</id>
    <published>2017-12-18T14:10:00.000Z</published>
    <updated>2017-12-18T14:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔记总结+源码：<a href="https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1" target="_blank" rel="external">https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1</a><br>在前七章都打了对应的标签，可以通过 git checkout来。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/mybatis0to1/summary.png" alt=""><br>总结就是，将 sql 语句从代码中抽离出来，通过 xml 的配置来实现单表、多表的映射，最后通过动态代理来执行方法，很强的解耦性。<br>把 SQL 放在了 XML 中，然后用一些判断来实现动态 SQL ，最后通过 SqlSession 、SqlSessionFacotry 的生命周期来绑定一级、二级缓存。<br>不学之前感觉很神奇，学完之后也就那么回事，不过还是要多学学基础，例如读取配置、缓存、一级动态代理等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔记总结+源码：&lt;a href=&quot;https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/LiWen
      
    
    </summary>
    
      <category term="小结" scheme="http://www.liwenguang.cn/categories/%E5%B0%8F%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>电影《帕丁顿熊》有感</title>
    <link href="http://www.liwenguang.cn/2017/12/13/talker/paddington.html/"/>
    <id>http://www.liwenguang.cn/2017/12/13/talker/paddington.html/</id>
    <published>2017-12-12T16:33:00.000Z</published>
    <updated>2017-12-12T16:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Please look after this bear, thank you.</p><p>联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  </p><p>每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  </p><hr><p>城市应该有它自己的包容心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Please look after this bear, thank you.&lt;/p&gt;
&lt;p&gt;联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  &lt;/p&gt;
&lt;p&gt;每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  &lt;
      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.liwenguang.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>十三、PGP——密码技术的完美组合</title>
    <link href="http://www.liwenguang.cn/2017/12/07/graphic2cryptography/13.html/"/>
    <id>http://www.liwenguang.cn/2017/12/07/graphic2cryptography/13.html/</id>
    <published>2017-12-07T15:44:00.000Z</published>
    <updated>2017-12-07T15:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码技术进行组合的方法。</p><h1 id="2-PGP简介"><a href="#2-PGP简介" class="headerlink" title="2 PGP简介"></a>2 PGP简介</h1><p>PGP 是 1990 年编写的密码软件。</p><h2 id="2-1-PGP-的功能"><a href="#2-1-PGP-的功能" class="headerlink" title="2.1 PGP 的功能"></a>2.1 PGP 的功能</h2><h3 id="1-对称密码"><a href="#1-对称密码" class="headerlink" title="1.对称密码"></a>1.对称密码</h3><h3 id="2-公钥密码"><a href="#2-公钥密码" class="headerlink" title="2.公钥密码"></a>2.公钥密码</h3><h3 id="3-数字签名"><a href="#3-数字签名" class="headerlink" title="3.数字签名"></a>3.数字签名</h3><h3 id="4-单向散列函数"><a href="#4-单向散列函数" class="headerlink" title="4.单向散列函数"></a>4.单向散列函数</h3><h3 id="5-证书"><a href="#5-证书" class="headerlink" title="5.证书"></a>5.证书</h3><h3 id="6-压缩"><a href="#6-压缩" class="headerlink" title="6.压缩"></a>6.压缩</h3><h3 id="7-文本数据"><a href="#7-文本数据" class="headerlink" title="7.文本数据"></a>7.文本数据</h3><h3 id="8-大文件的拆分和平和"><a href="#8-大文件的拆分和平和" class="headerlink" title="8.大文件的拆分和平和"></a>8.大文件的拆分和平和</h3><h3 id="9-钥匙串管理"><a href="#9-钥匙串管理" class="headerlink" title="9.钥匙串管理"></a>9.钥匙串管理</h3><h1 id="3-生成秘钥对"><a href="#3-生成秘钥对" class="headerlink" title="3 生成秘钥对"></a>3 生成秘钥对</h1><h1 id="4-加密与解密"><a href="#4-加密与解密" class="headerlink" title="4 加密与解密"></a>4 加密与解密</h1><h1 id="5-生成和验证数字签名"><a href="#5-生成和验证数字签名" class="headerlink" title="5 生成和验证数字签名"></a>5 生成和验证数字签名</h1><h1 id="6-生成数字签名并加密以及解密并验证数字签名"><a href="#6-生成数字签名并加密以及解密并验证数字签名" class="headerlink" title="6 生成数字签名并加密以及解密并验证数字签名"></a>6 生成数字签名并加密以及解密并验证数字签名</h1><h1 id="7-信任网"><a href="#7-信任网" class="headerlink" title="7 信任网"></a>7 信任网</h1><h2 id="7-1-公钥合法性"><a href="#7-1-公钥合法性" class="headerlink" title="7.1 公钥合法性"></a>7.1 公钥合法性</h2><p>在使用 PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换（参 5.7.4节）。<br>第十章介绍的证书就是确认公钥合法性的方法之一。证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。<br>然而，PGP 中却没有使用认证机构，而是采用了一种叫<strong>信任网</strong>（web of trust）的方法。在这种方法中， PGP 用户会<strong>互相对对方的公钥进行数字签名</strong>。<br>信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。<br>下面介绍 PGP 的信任网是如何建立起来的。</p><h3 id="1-场景1：通过自己的数字签名进行确认"><a href="#1-场景1：通过自己的数字签名进行确认" class="headerlink" title="1.场景1：通过自己的数字签名进行确认"></a>1.场景1：通过自己的数字签名进行确认</h3><p>Alice 和 Bob 约会，在告别的时候， Bob 给了 Alice 一张存储卡，并说“这是我的公钥”。<br>Alice 回到家中，从存储卡中取出 Bob 的公钥，并存放到自己所使用的 PGP 的公钥串中（导入公钥）。由于 Alice 确信刚刚导入的公钥确实是属于 Bob 本人的，因此 Alice 对这个公钥加上了自己的数字签名。<br>对 Bob 的公钥加上数字签名，就相当于 Alice 生命“这个公钥属于 Bob 本人（即这个公钥是合法的）”。<br>随后，Alice 收到了来自 Bob 的邮件，由于这封邮件带有 Bob 的数字签名，因此 Alice 想用 PGP 来验证 Bob 的数字签名。 PGP 将执行下面这些操作：  </p><ol><li>为了验证 Bob 的数字签名， PGP 需要从 Alice 的公钥串中寻找 Bob 的公钥。</li><li>Alice 的公钥串中包含 Bob 的公钥，因为前几天约会之后 Alice 导入了 Bob 的公钥。</li><li>PGP 发现 Bob 的公钥带有 Alice 的数字签名。</li><li>为了验证 Alice 的数字签名，PGP 需要从 Alice 的公钥串中寻找 Alice 自己的公钥。</li><li>PGP 使用 Alice 的公钥对 Bob 的公钥上的 Alice 的数字签名进行验证。如果验证成功，则可以确认这的确就是 Bob 的公钥。</li><li>PGP 使用合法的 Bob 的公钥对邮件上附带的 Bob 的数字签名进行验证。</li></ol><h3 id="2-场景2：通过自己完全信任的人的数字签名进行确认"><a href="#2-场景2：通过自己完全信任的人的数字签名进行确认" class="headerlink" title="2.场景2：通过自己完全信任的人的数字签名进行确认"></a>2.场景2：通过自己完全信任的人的数字签名进行确认</h3><p>Alice 有一个叫 Trent 的男朋友。在 Alice 的公钥串中，也包含带有 Alice 的数字签名的 Trent 的公钥。 Alice 非常信任 Trent ，她想：<strong>经过他签名的公钥一定是合法的</strong>。<br>假设 Alice 收到了一封来自 Carrol 的邮件</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-本章概要&quot;&gt;&lt;a href=&quot;#1-本章概要&quot; class=&quot;headerlink&quot; title=&quot;1 本章概要&quot;&gt;&lt;/a&gt;1 本章概要&lt;/h1&gt;&lt;p&gt;本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>十二、随机数——不可预测性的源泉</title>
    <link href="http://www.liwenguang.cn/2017/12/06/graphic2cryptography/12.html/"/>
    <id>http://www.liwenguang.cn/2017/12/06/graphic2cryptography/12.html/</id>
    <published>2017-12-06T15:40:00.000Z</published>
    <updated>2017-12-07T15:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-骡子的锁匠铺"><a href="#1-骡子的锁匠铺" class="headerlink" title="1 骡子的锁匠铺"></a>1 骡子的锁匠铺</h1><p>很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。<br>骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。<br>教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><ul><li>使用随机数的密码技术</li><li>随机数的性质</li><li>伪随机数生成器</li><li>具体的伪随机数生成器</li><li>对伪随机数生成器的攻击</li></ul><h1 id="3-使用随机数的密码技术"><a href="#3-使用随机数的密码技术" class="headerlink" title="3 使用随机数的密码技术"></a>3 使用随机数的密码技术</h1><h2 id="3-1-随机数是干什么的"><a href="#3-1-随机数是干什么的" class="headerlink" title="3.1 随机数是干什么的"></a>3.1 随机数是干什么的</h2><ol><li>生成秘钥：用于对称密码和消息认证码。</li><li>生成密钥对：用于公钥密码和数字签名。</li><li>生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。</li><li>生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。</li><li>生成盐：用于基于口令的密码（PBE）等。</li></ol><p>在这里，请大家记住<strong>为了不让攻击者看穿而使用随机数</strong>这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。</p><h1 id="4-随机数的性质"><a href="#4-随机数的性质" class="headerlink" title="4 随机数的性质"></a>4 随机数的性质</h1><h2 id="4-1-对随机数的性质分类"><a href="#4-1-对随机数的性质分类" class="headerlink" title="4.1 对随机数的性质分类"></a>4.1 对随机数的性质分类</h2><ol><li>随机性：不存在统计学偏差，是完全杂乱的数列。</li><li>不可预测性：不能从过去的数列推测出下一个出现的数。</li><li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。</li></ol><p>为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。||随机性|不可预测性|不可重现性|||:-:|:-:|:-:|:-:|:-:||弱伪随机数|✔️|✘|✘|只具备随机性||强伪随机数|✔️|✔️|✘|具备不可预测性||真随机数|✔️|✔️|✔️|具备不可重现性|</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_1.png" alt=""></p><h2 id="4-2-随机性"><a href="#4-2-随机性" class="headerlink" title="4.2 随机性"></a>4.2 随机性</h2><p>杂乱无章并不代表不会被看穿，因此本书中将只具备随机性的伪随机数称为“弱伪随机数”。</p><h2 id="4-3-不可预测性"><a href="#4-3-不可预测性" class="headerlink" title="4.3 不可预测性"></a>4.3 不可预测性</h2><p>不可预测性（unpredictability），是一种“不可能事先说中”的性质，及不可预测性。即，攻击者在知道过去生成的为随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。</p><h2 id="4-4-不可重现性"><a href="#4-4-不可重现性" class="headerlink" title="4.4 不可重现性"></a>4.4 不可重现性</h2><p>即，无法重现和某一随机数列完全相同的数列的性质。如果除了将随机数列本身保存下来意外，没有其它方法能够重现该数列，则我们就说该随机数列具备不可重现性。<br>要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。</p><h1 id="5-伪随机数生成器"><a href="#5-伪随机数生成器" class="headerlink" title="5 伪随机数生成器"></a>5 伪随机数生成器</h1><p>仅仅靠软件无法生成真随机数，因此要加上一个“伪”。</p><h2 id="5-1-伪随机数生成器的结构"><a href="#5-1-伪随机数生成器的结构" class="headerlink" title="5.1 伪随机数生成器的结构"></a>5.1 伪随机数生成器的结构</h2><p>伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_2.png" alt="">  </p><h3 id="1-伪随机数生成器的内部状态"><a href="#1-伪随机数生成器的内部状态" class="headerlink" title="1.伪随机数生成器的内部状态"></a>1.伪随机数生成器的内部状态</h3><p>伪随机数生成器的内部状态，是指伪随机数生成器所管理的内存中的数值。伪随机数生成器会根据内存中的数值进行计算，并将计算的结果作为伪随机数输出。随后，为了响应下一个伪随机数请求。伪随机数生成器会改变自己的内部状态。</p><h3 id="2-伪随机数生成器的种子"><a href="#2-伪随机数生成器的种子" class="headerlink" title="2.伪随机数生成器的种子"></a>2.伪随机数生成器的种子</h3><p>伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_3.png" alt=""></p><h1 id="6-具体的伪随机数生成器"><a href="#6-具体的伪随机数生成器" class="headerlink" title="6 具体的伪随机数生成器"></a>6 具体的伪随机数生成器</h1><h2 id="6-1-杂乱的方法"><a href="#6-1-杂乱的方法" class="headerlink" title="6.1 杂乱的方法"></a>6.1 杂乱的方法</h2><p>用一个程序员都不懂的算法生成，但是这是错误的，不能用于密码技术。因为，周期太短，使用复杂算法所生成的数列大多数都会具有很短的周期（即短数列的不断重复）。另外则是，无法判断所生成的随机数是否具备不可预测性。</p><h2 id="6-2-线性同余法"><a href="#6-2-线性同余法" class="headerlink" title="6.2 线性同余法"></a>6.2 线性同余法</h2><p>线性同余法（linear congruential method）是一种使用很广泛的伪随机数生成器算法。然而，它并不能用于密码技术。<br>A、C、M 都是常量，且 A 和 C 需要小于 M。接下来，根据种子 R0 计算下一个伪随机数 R1：<br>R1 = （A <em> R0 + C） mod M。<br>当前得到的伪随机数即是下一个伪随机数的种子：<br>Rn+1 = (A </em> Rn + C) mod M。<br>但是这具有周期性，而且可以通过上一个种子得到下一个伪随机数。因此不具备不可预测性，不能将线性同余法用于密码技术。<br>很多伪随机数生成器的库函数都是采用线性同余法编写的。包括 C 语言的库函数 rand。 以及 java 的 java.util.Random 类等。</p><h2 id="6-3-单向散列函数法"><a href="#6-3-单向散列函数法" class="headerlink" title="6.3 单向散列函数法"></a>6.3 单向散列函数法</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_4.png" alt=""><br>攻击者要预测下一个伪随机数，需要知道计数器的当前值，以及，破解单向散列函数的单向性。利用了单向散列函数的单向性。</p><h2 id="6-4-密码法"><a href="#6-4-密码法" class="headerlink" title="6.4 密码法"></a>6.4 密码法</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_5.png" alt=""><br>密码的机密性是支撑伪随机数生成器不可预测性的基础。</p><h1 id="7-对伪随机数生成器的攻击"><a href="#7-对伪随机数生成器的攻击" class="headerlink" title="7 对伪随机数生成器的攻击"></a>7 对伪随机数生成器的攻击</h1><h2 id="7-1-对种子进行攻击"><a href="#7-1-对种子进行攻击" class="headerlink" title="7.1 对种子进行攻击"></a>7.1 对种子进行攻击</h2><h2 id="7-2-对随机数池进行攻击"><a href="#7-2-对随机数池进行攻击" class="headerlink" title="7.2 对随机数池进行攻击"></a>7.2 对随机数池进行攻击</h2><p>一般不会到了需要的时候才当场生成真随机数，而是会事先在一个名为<strong>随机数池</strong>（random pool）的文件中积累随机比特序列。当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。这是不能被攻击所知道的。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>由于密码技术的伪随机数生成器，需要使用单向散列函数和密码等技术来确保不可预测性。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><ol><li>伪随机数的种子需要对攻击者保密。</li><li>线性同余法可以作为用于密码的伪随机数生成器。</li><li>具备随机性的伪随机数生成器不一定具备不可预测性。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-骡子的锁匠铺&quot;&gt;&lt;a href=&quot;#1-骡子的锁匠铺&quot; class=&quot;headerlink&quot; title=&quot;1 骡子的锁匠铺&quot;&gt;&lt;/a&gt;1 骡子的锁匠铺&lt;/h1&gt;&lt;p&gt;很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>去中心化</title>
    <link href="http://www.liwenguang.cn/2017/12/05/talker/decentralization_1.html/"/>
    <id>http://www.liwenguang.cn/2017/12/05/talker/decentralization_1.html/</id>
    <published>2017-12-04T17:06:00.000Z</published>
    <updated>2017-12-04T17:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。</p></blockquote><hr><p>编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。  </p><p>“去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。  </p><p>但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_1.png" alt="">  </p><p>现在再来看看Quora上面有关“<a href="https://www.quora.com/Whats-the-difference-between-distributed-and-decentralized-in-Bitcoin-land" target="_blank" rel="external">分布式和去中心化的区别</a>”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的<a href="https://ethereum.stackexchange.com/questions/7812/question-on-the-terms-distributed-and-decentralised" target="_blank" rel="external">图解</a>，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。</p><h2 id="三种类型的去中心化"><a href="#三种类型的去中心化" class="headerlink" title="三种类型的去中心化"></a>三种类型的去中心化</h2><p>当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是：  </p><ol><li>结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？</li><li>政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？</li><li>逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？</li></ol><p>我们可以把这三个维度用下面这张表来表示：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_2.png" alt="">  </p><p>要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况：  </p><ul><li>传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。</li><li>民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。</li><li>语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。</li><li>BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。</li><li>区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。  </li></ul><p>很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的<a href="http://scuttlebot.io/more/articles/design-challenge-avoid-centralization-and-singletons.html" target="_blank" rel="external">文章</a>）。  </p><p>结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。  </p><p>逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。</p><h2 id="去中心化的三个原因"><a href="#去中心化的三个原因" class="headerlink" title="去中心化的三个原因"></a>去中心化的三个原因</h2><p>接下来的问题就是为什么去中心化会有用？这通常会有几种观点：  </p><ul><li>可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。</li><li><p>抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。</p></li><li><p>抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。</p></li></ul><p>这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到<a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274" target="_blank" rel="external">原文</a>了解进一步的讨论。</p><hr><p>此文转载自：<a href="https://36kr.com/p/5063699.html" target="_blank" rel="external">&lt;去中心化的三个维度_36氪&gt;</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitali
      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.liwenguang.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>十四、SSL/TLS-为了更安全的通信</title>
    <link href="http://www.liwenguang.cn/2017/12/04/graphic2cryptography/14.html/"/>
    <id>http://www.liwenguang.cn/2017/12/04/graphic2cryptography/14.html/</id>
    <published>2017-12-04T15:31:00.000Z</published>
    <updated>2017-12-06T15:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>SSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。</p><h1 id="2-什么是-SSL-TLS"><a href="#2-什么是-SSL-TLS" class="headerlink" title="2 什么是 SSL/TLS"></a>2 什么是 SSL/TLS</h1><h2 id="2-1-客户端与服务器"><a href="#2-1-客户端与服务器" class="headerlink" title="2.1 客户端与服务器"></a>2.1 客户端与服务器</h2><p>将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_1.png" alt=""><br>Alice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。  </p><p>不过，如果直接发送请求的话，信用卡号就很可能被窃听。</p><h2 id="2-2-用-SSL-TLS-承载-HTTP"><a href="#2-2-用-SSL-TLS-承载-HTTP" class="headerlink" title="2.2 用 SSL/TLS 承载 HTTP"></a>2.2 用 SSL/TLS 承载 HTTP</h2><p>当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_2.png" alt=""></p><h2 id="2-3-SSL-TLS-的工作"><a href="#2-3-SSL-TLS-的工作" class="headerlink" title="2.3 SSL/TLS 的工作"></a>2.3 SSL/TLS 的工作</h2><p>进行安全的通信，我们有几个必须要解决的问题：  </p><ol><li>Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。</li><li>Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。</li><li>确认通信对方的 Web 服务器是真正的 Bob 书店。</li></ol><p>在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。<br>要解决这些问题，让我们在密码学家的工具箱中找一找：<br>要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。<br>要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。<br>要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。<br>好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。</p><h2 id="2-4-SSL-TLS-也可以保护其它的协议"><a href="#2-4-SSL-TLS-也可以保护其它的协议" class="headerlink" title="2.4 SSL/TLS 也可以保护其它的协议"></a>2.4 SSL/TLS 也可以保护其它的协议</h2><p>刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_3.png" alt=""></p><h2 id="2-5-密码套件"><a href="#2-5-密码套件" class="headerlink" title="2.5 密码套件"></a>2.5 密码套件</h2><p>SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。<br>尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为<strong>密码套件</strong>（cipher suite）。</p><h2 id="2-6-SSL-与-TLS-的区别"><a href="#2-6-SSL-与-TLS-的区别" class="headerlink" title="2.6 SSL 与 TLS 的区别"></a>2.6 SSL 与 TLS 的区别</h2><p>SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。</p><h1 id="3-使用-SSL-TLS-进行通信"><a href="#3-使用-SSL-TLS-进行通信" class="headerlink" title="3 使用 SSL/TLS 进行通信"></a>3 使用 SSL/TLS 进行通信</h1><p>下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。</p><h2 id="3-1-层次化的协议"><a href="#3-1-层次化的协议" class="headerlink" title="3.1 层次化的协议"></a>3.1 层次化的协议</h2><p>TLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_4.png" alt=""><br>下面简单介绍一下其中各个协议的功能</p><h3 id="1-TLS记录协议"><a href="#1-TLS记录协议" class="headerlink" title="1.TLS记录协议"></a>1.TLS记录协议</h3><p>TLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。<br>TLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。</p><h3 id="2-TLS握手协议"><a href="#2-TLS握手协议" class="headerlink" title="2.TLS握手协议"></a>2.TLS握手协议</h3><p>TLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。</p><h4 id="2-1-握手协议"><a href="#2-1-握手协议" class="headerlink" title="2-1 握手协议"></a>2-1 握手协议</h4><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：<br>客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”<br>服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”<br>在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。</p><h4 id="2-2-密码规格变更协议"><a href="#2-2-密码规格变更协议" class="headerlink" title="2-2 密码规格变更协议"></a>2-2 密码规格变更协议</h4><p><strong>密码规格变更协议</strong>是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。<br>这个协议所发送的消息，大致相当于下面的对话：<br>客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”<br>当协议中途发生错误时，就会通过下面的警告协议传达给对方。</p><h4 id="2-3-警告协议"><a href="#2-3-警告协议" class="headerlink" title="2-3 警告协议"></a>2-3 警告协议</h4><p><strong>警告协议</strong>是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。<br>这个协议所发送的消息，大致相当于下面的对话：<br>服务器：“刚才的消息无法正确解密哦！”<br>如果没有发生错误，则会使用下面的应用数据协议来进行通信。</p><h4 id="2-4-应用数据协议"><a href="#2-4-应用数据协议" class="headerlink" title="2-4 应用数据协议"></a>2-4 应用数据协议</h4><p><strong>应用数据协议</strong>是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。<br>下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。</p><h2 id="3-2-TLS记录协议"><a href="#3-2-TLS记录协议" class="headerlink" title="3.2 TLS记录协议"></a>3.2 TLS记录协议</h2><p><strong>TLS记录协议</strong>负责消息的压缩、加密以及数据的认证，其处理过程如下：  </p><ol><li>消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。</li><li>经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。</li><li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。</li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_5.png" alt=""></p><h2 id="3-3-TLS握手协议"><a href="#3-3-TLS握手协议" class="headerlink" title="3.3 TLS握手协议"></a>3.3 TLS握手协议</h2><h3 id="1-握手协议"><a href="#1-握手协议" class="headerlink" title="1.握手协议"></a>1.握手协议</h3><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。<br>握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。<br>由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_6.png" alt=""><br>下面我们来详细讲解握手协议中所交换的消息。</p><h3 id="2-密码规格变更协议"><a href="#2-密码规格变更协议" class="headerlink" title="2.密码规格变更协议"></a>2.密码规格变更协议</h3><p>TLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。<br>那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。</p><h3 id="3-警告协议"><a href="#3-警告协议" class="headerlink" title="3.警告协议"></a>3.警告协议</h3><p>TLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。</p><h3 id="4-应用数据协议"><a href="#4-应用数据协议" class="headerlink" title="4.应用数据协议"></a>4.应用数据协议</h3><p><strong>应用数据协议</strong>是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。<br>当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。</p><h2 id="3-4-主密码"><a href="#3-4-主密码" class="headerlink" title="3.4 主密码"></a>3.4 主密码</h2><p>主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。<br>主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_7.png" alt=""></p><h2 id="3-5-TLS-中使用的密码技术小结"><a href="#3-5-TLS-中使用的密码技术小结" class="headerlink" title="3.5 TLS 中使用的密码技术小结"></a>3.5 TLS 中使用的密码技术小结</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_8.png" alt=""></p><h1 id="4-对-SSL-TLS-的攻击"><a href="#4-对-SSL-TLS-的攻击" class="headerlink" title="4 对 SSL/TLS 的攻击"></a>4 对 SSL/TLS 的攻击</h1><h2 id="4-1-对各个密码技术的攻击"><a href="#4-1-对各个密码技术的攻击" class="headerlink" title="4.1 对各个密码技术的攻击"></a>4.1 对各个密码技术的攻击</h2><p>针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。<br>然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。</p><h2 id="4-2-对伪随机数生成器的攻击"><a href="#4-2-对伪随机数生成器的攻击" class="headerlink" title="4.2 对伪随机数生成器的攻击"></a>4.2 对伪随机数生成器的攻击</h2><p>只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。</p><h2 id="4-3-利用证书的时间差进行攻击"><a href="#4-3-利用证书的时间差进行攻击" class="headerlink" title="4.3 利用证书的时间差进行攻击"></a>4.3 利用证书的时间差进行攻击</h2><p>SSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。</p><h1 id="5-SSL-TLS-用户的注意事项"><a href="#5-SSL-TLS-用户的注意事项" class="headerlink" title="5 SSL/TLS 用户的注意事项"></a>5 SSL/TLS 用户的注意事项</h1><h2 id="5-1-不要误解证书的含义"><a href="#5-1-不要误解证书的含义" class="headerlink" title="5.1 不要误解证书的含义"></a>5.1 不要误解证书的含义</h2><p>在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是<strong>即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，</strong>因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。<br>此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。<br>为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。</p><h2 id="5-2-密码通信之前的数据时不受保护的"><a href="#5-2-密码通信之前的数据时不受保护的" class="headerlink" title="5.2 密码通信之前的数据时不受保护的"></a>5.2 密码通信之前的数据时不受保护的</h2><p>SSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。</p><h2 id="5-3-密码通信之后的数据时不受保护的"><a href="#5-3-密码通信之后的数据时不受保护的" class="headerlink" title="5.3 密码通信之后的数据时不受保护的"></a>5.3 密码通信之后的数据时不受保护的</h2><p>SSL/TLS 也无法保护通信之后的数据。<br>因此信用卡号<strong>不会再通信过程中被第三方获取</strong>，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。</p><h1 id="6-本章小结"><a href="#6-本章小结" class="headerlink" title="6 本章小结"></a>6 本章小结</h1><p>SSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。</p><h1 id="7-小测验"><a href="#7-小测验" class="headerlink" title="7 小测验"></a>7 小测验</h1><ol><li>使用 SSL/TLS 可以确保通信的机密性。</li><li>在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。</li><li>在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。</li><li>在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。</li><li>使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-本章概要&quot;&gt;&lt;a href=&quot;#1-本章概要&quot; class=&quot;headerlink&quot; title=&quot;1 本章概要&quot;&gt;&lt;/a&gt;1 本章概要&lt;/h1&gt;&lt;p&gt;SSL（Secure Socket Layer）与TLS(Transport Layer Security)
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>十一、秘钥——秘密的精华</title>
    <link href="http://www.liwenguang.cn/2017/11/23/graphic2cryptography/10.html/"/>
    <id>http://www.liwenguang.cn/2017/11/23/graphic2cryptography/10.html/</id>
    <published>2017-11-23T15:42:00.000Z</published>
    <updated>2017-12-04T14:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。</p><h1 id="2-什么是秘钥"><a href="#2-什么是秘钥" class="headerlink" title="2 什么是秘钥"></a>2 什么是秘钥</h1><h2 id="2-1-秘钥就是一个巨大的数字"><a href="#2-1-秘钥就是一个巨大的数字" class="headerlink" title="2.1 秘钥就是一个巨大的数字"></a>2.1 秘钥就是一个巨大的数字</h2><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为<strong>秘钥</strong>（key）的巨大数字。然后，数字本身的带下并不重要，重要的是<strong>秘钥空间的大小</strong>，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由<strong>秘钥长度</strong>决定的。</p><h3 id="1-DES-的秘钥"><a href="#1-DES-的秘钥" class="headerlink" title="1.DES 的秘钥"></a>1.DES 的秘钥</h3><p>对称密码 DES 的秘钥的实质长度为 56 比特。<br>例如，一个 DES 秘钥用二进制可以表示为：<br>01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100<br>用十六进制则可以表示为：<br>51 EC 4B 12 3D 4A A1<br>而用十进制则可以表示为：<br>12309120398102938102983<br>为了显得专业，将统一使用十六进制。</p><h3 id="2-三重-DES-的秘钥"><a href="#2-三重-DES-的秘钥" class="headerlink" title="2.三重 DES 的秘钥"></a>2.三重 DES 的秘钥</h3><p>在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。<br>DES-EDE2 的秘钥实际长度为 112 比特。<br>DES-EDE3 的秘钥实际长度为 168 比特。</p><h3 id="3-AES-的秘钥"><a href="#3-AES-的秘钥" class="headerlink" title="3.AES 的秘钥"></a>3.AES 的秘钥</h3><p>对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。  </p><blockquote><p>实际长度会更长，因为会加一些用于识别通信错误的校验比特。</p></blockquote><h2 id="2-2-秘钥和明文是等价的"><a href="#2-2-秘钥和明文是等价的" class="headerlink" title="2.2 秘钥和明文是等价的"></a>2.2 秘钥和明文是等价的</h2><p>对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，<strong>秘钥和明文是等价的</strong>。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。</p><h2 id="2-3-密码算法与秘钥"><a href="#2-3-密码算法与秘钥" class="headerlink" title="2.3 密码算法与秘钥"></a>2.3 密码算法与秘钥</h2><p>信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。</p><h1 id="3-各种不同的秘钥"><a href="#3-各种不同的秘钥" class="headerlink" title="3 各种不同的秘钥"></a>3 各种不同的秘钥</h1><h2 id="3-1-对称密码的秘钥与公钥密码的秘钥"><a href="#3-1-对称密码的秘钥与公钥密码的秘钥" class="headerlink" title="3.1 对称密码的秘钥与公钥密码的秘钥"></a>3.1 对称密码的秘钥与公钥密码的秘钥</h2><p>在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_1.png" alt=""><br>在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_2.png" alt=""></p><h2 id="3-2-消息认证码的秘钥与数字签名的秘钥"><a href="#3-2-消息认证码的秘钥与数字签名的秘钥" class="headerlink" title="3.2 消息认证码的秘钥与数字签名的秘钥"></a>3.2 消息认证码的秘钥与数字签名的秘钥</h2><p>在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_3.png" alt=""><br>在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_4.png" alt=""></p><h2 id="3-3-用于确保机密性的秘钥与用于认证的秘钥"><a href="#3-3-用于确保机密性的秘钥与用于认证的秘钥" class="headerlink" title="3.3 用于确保机密性的秘钥与用于认证的秘钥"></a>3.3 用于确保机密性的秘钥与用于认证的秘钥</h2><p>对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。  </p><p>相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。</p><h2 id="3-4-会话秘钥与主秘钥"><a href="#3-4-会话秘钥与主秘钥" class="headerlink" title="3.4 会话秘钥与主秘钥"></a>3.4 会话秘钥与主秘钥</h2><p>刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。<br>当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为<strong>会话秘钥</strong>（session key）。<br>虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。<br>相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为<strong>主秘钥</strong>（master key）。</p><h2 id="3-5-用于加密内容的秘钥与用于加密秘钥的秘钥"><a href="#3-5-用于加密内容的秘钥与用于加密秘钥的秘钥" class="headerlink" title="3.5 用于加密内容的秘钥与用于加密秘钥的秘钥"></a>3.5 用于加密内容的秘钥与用于加密秘钥的秘钥</h2><p>一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_5.png" alt="">  </p><p>在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。</p><h1 id="4-秘钥的管理"><a href="#4-秘钥的管理" class="headerlink" title="4 秘钥的管理"></a>4 秘钥的管理</h1><h2 id="4-1-生成秘钥"><a href="#4-1-生成秘钥" class="headerlink" title="4.1 生成秘钥"></a>4.1 生成秘钥</h2><h3 id="1-用随机数生成秘钥"><a href="#1-用随机数生成秘钥" class="headerlink" title="1.用随机数生成秘钥"></a>1.用随机数生成秘钥</h3><h3 id="2-用口令生成秘钥"><a href="#2-用口令生成秘钥" class="headerlink" title="2.用口令生成秘钥"></a>2.用口令生成秘钥</h3><p>即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。</p><h2 id="4-2-配送秘钥"><a href="#4-2-配送秘钥" class="headerlink" title="4.2 配送秘钥"></a>4.2 配送秘钥</h2><p>在第五章介绍，可以采用<strong>事先共享秘钥、使用秘钥分配中心、使用公钥密码</strong>等方法。一会将介绍<strong>Diffie-Hellman秘钥交换</strong>。</p><h2 id="4-3-更新秘钥"><a href="#4-3-更新秘钥" class="headerlink" title="4.3 更新秘钥"></a>4.3 更新秘钥</h2><p>有一种提高通信机密性的技术被称为<strong>秘钥更新</strong>（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。  </p><p>在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是<strong>用当前秘钥的散列值作为下一个秘钥</strong>。<br>这种防止破译过去的通信内容的机制，称为<strong>后向安全</strong>（backward security）。</p><h2 id="4-4-保存秘钥"><a href="#4-4-保存秘钥" class="headerlink" title="4.4 保存秘钥"></a>4.4 保存秘钥</h2><p>由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑<strong>保存秘钥</strong>的问题了。</p><h3 id="1-人类无法记住秘钥"><a href="#1-人类无法记住秘钥" class="headerlink" title="1.人类无法记住秘钥"></a>1.人类无法记住秘钥</h3><p>首先我们必须要理解一个重要的事实，那就是人类是<strong>无法记住具有使用长度的秘钥</strong>的。 </p><h3 id="2-对秘钥进行加密的意义"><a href="#2-对秘钥进行加密的意义" class="headerlink" title="2.对秘钥进行加密的意义"></a>2.对秘钥进行加密的意义</h3><p>例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。</p><h2 id="4-5-作废秘钥"><a href="#4-5-作废秘钥" class="headerlink" title="4.5 作废秘钥"></a>4.5 作废秘钥</h2><p>如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。</p><h1 id="5-Diffie-Hellman秘钥交换"><a href="#5-Diffie-Hellman秘钥交换" class="headerlink" title="5 Diffie-Hellman秘钥交换"></a>5 Diffie-Hellman秘钥交换</h1><h2 id="5-1-什么是-Diffie-Hellman-秘钥交换"><a href="#5-1-什么是-Diffie-Hellman-秘钥交换" class="headerlink" title="5.1 什么是 Diffie-Hellman 秘钥交换"></a>5.1 什么是 Diffie-Hellman 秘钥交换</h2><p>使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。  </p><p>虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。</p><h2 id="5-2-Diffie-Hellman-秘钥交换的步骤"><a href="#5-2-Diffie-Hellman-秘钥交换的步骤" class="headerlink" title="5.2 Diffie-Hellman 秘钥交换的步骤"></a>5.2 Diffie-Hellman 秘钥交换的步骤</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_6.png" alt="">  </p><h3 id="1-Alice-向-Bob-发送两个质数-P-和-G"><a href="#1-Alice-向-Bob-发送两个质数-P-和-G" class="headerlink" title="1.Alice 向 Bob 发送两个质数 P 和 G"></a>1.Alice 向 Bob 发送两个质数 P 和 G</h3><p>P 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为<strong>生成元</strong>。 G 可以是一个较小的数字。 P 和 G 不需要保密。</p><h3 id="2-Alice-生成一个随机数-A"><a href="#2-Alice-生成一个随机数-A" class="headerlink" title="2.Alice 生成一个随机数 A"></a>2.Alice 生成一个随机数 A</h3><p>A 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。</p><h3 id="3-Bob-生成一个随机数-B"><a href="#3-Bob-生成一个随机数-B" class="headerlink" title="3.Bob 生成一个随机数 B"></a>3.Bob 生成一个随机数 B</h3><p>B 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。</p><h3 id="4-Alice-将-G-A-mod-P-这个数发送给-Bob"><a href="#4-Alice-将-G-A-mod-P-这个数发送给-Bob" class="headerlink" title="4.Alice 将 G^A mod P 这个数发送给 Bob"></a>4.Alice 将 G^A mod P 这个数发送给 Bob</h3><p>这个数让 Eve 知道也没关系</p><h3 id="5-Bob-将-G-B-mod-P-这个数发送给-Alice"><a href="#5-Bob-将-G-B-mod-P-这个数发送给-Alice" class="headerlink" title="5.Bob 将 G^B mod P 这个数发送给 Alice"></a>5.Bob 将 G^B mod P 这个数发送给 Alice</h3><p>这个数让 Eve 知道也没关系</p><h3 id="6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P"><a href="#6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P" class="headerlink" title="6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P"></a>6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^B mod P)^A mod P</p><h3 id="7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P"><a href="#7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P" class="headerlink" title="7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P"></a>7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^A mod P)^B mod P</p><h3 id="8-这样-Alice-和-Bob-得到的值就是相同的"><a href="#8-这样-Alice-和-Bob-得到的值就是相同的" class="headerlink" title="8.这样 Alice 和 Bob 得到的值就是相同的"></a>8.这样 Alice 和 Bob 得到的值就是相同的</h3><h2 id="5-3-Eve-能计算出秘钥吗"><a href="#5-3-Eve-能计算出秘钥吗" class="headerlink" title="5.3 Eve 能计算出秘钥吗"></a>5.3 Eve 能计算出秘钥吗</h2><p>这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。</p><h1 id="6-基于口令的密码（PBE）"><a href="#6-基于口令的密码（PBE）" class="headerlink" title="6 基于口令的密码（PBE）"></a>6 基于口令的密码（PBE）</h1><h2 id="6-1-什么是基于口令的密码"><a href="#6-1-什么是基于口令的密码" class="headerlink" title="6.1 什么是基于口令的密码"></a>6.1 什么是基于口令的密码</h2><p>用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。</p><h2 id="6-2-PBE-加密"><a href="#6-2-PBE-加密" class="headerlink" title="6.2 PBE 加密"></a>6.2 PBE 加密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_7.png" alt=""></p><h2 id="6-3-PBE-解密"><a href="#6-3-PBE-解密" class="headerlink" title="6.3 PBE 解密"></a>6.3 PBE 解密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_8.png" alt=""></p><h1 id="7-本章小结"><a href="#7-本章小结" class="headerlink" title="7 本章小结"></a>7 本章小结</h1><p>对秘钥本身做了简单介绍。</p><h1 id="8-小测验"><a href="#8-小测验" class="headerlink" title="8 小测验"></a>8 小测验</h1><ol><li>由于秘钥只是随机的比特序列，因此被别人知道了也没关系。</li><li>私钥是可以公开的。</li><li>在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-本章概要&quot;&gt;&lt;a href=&quot;#1-本章概要&quot; class=&quot;headerlink&quot; title=&quot;1 本章概要&quot;&gt;&lt;/a&gt;1 本章概要&lt;/h1&gt;&lt;p&gt;密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。&lt;/p&gt;
&lt;h1 id=&quot;2-什么是秘钥&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>电影《一个叫欧维的男人决定去死》有感~</title>
    <link href="http://www.liwenguang.cn/2017/11/23/talker/2.html/"/>
    <id>http://www.liwenguang.cn/2017/11/23/talker/2.html/</id>
    <published>2017-11-23T15:11:00.000Z</published>
    <updated>2017-11-23T15:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  </p><p>他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。</p><p>他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。  </p><p>我以为应该是个美好结局。  </p><p>“这才是人生”。 </p><hr><p>life is not easy. So is suicide.</p><blockquote><p>《En Man Som Heter Ove》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  &lt;/p&gt;
&lt;p&gt;他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“
      
    
    </summary>
    
      <category term="闲聊" scheme="http://www.liwenguang.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>十、证书——为公钥加上数字签名</title>
    <link href="http://www.liwenguang.cn/2017/11/22/graphic2cryptography/10.html/"/>
    <id>http://www.liwenguang.cn/2017/11/22/graphic2cryptography/10.html/</id>
    <published>2017-11-22T13:48:00.000Z</published>
    <updated>2017-11-22T13:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。  </p><p>我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。</p><h1 id="2-证书"><a href="#2-证书" class="headerlink" title="2 证书"></a>2 证书</h1><h1 id="2-1-什么是证书"><a href="#2-1-什么是证书" class="headerlink" title="2.1 什么是证书"></a>2.1 什么是证书</h1><p>公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由<strong>认证机构（Certification Authority、Certifying Authority，CA）</strong>施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为<strong>证书</strong>（certificate）。<br>认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。</p><h1 id="2-2-证书的应用场景"><a href="#2-2-证书的应用场景" class="headerlink" title="2.2 证书的应用场景"></a>2.2 证书的应用场景</h1><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_1.png" alt="">  </p><ol><li>Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。</li><li>Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_2.png" alt=""></li><li>认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。</li><li>Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。</li><li>Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。</li><li>Alice 用 Bob 的公钥加密消息并发送给 Bob。</li><li>Bob 用自己的私钥解密密文得到 Alice 的消息。</li></ol><h1 id="3-证书标准规范-X-509"><a href="#3-证书标准规范-X-509" class="headerlink" title="3 证书标准规范 X.509"></a>3 证书标准规范 X.509</h1><ol><li>签名前的证书——签名对象的信息</li><li>数字签名算法——对证书签名时所使用的算法</li><li>数字签名——对证书施加的数字签名</li></ol><h1 id="4-公钥基础设施（PKI）"><a href="#4-公钥基础设施（PKI）" class="headerlink" title="4 公钥基础设施（PKI）"></a>4 公钥基础设施（PKI）</h1><h2 id="4-1-什么是公钥基础设施"><a href="#4-1-什么是公钥基础设施" class="headerlink" title="4.1 什么是公钥基础设施"></a>4.1 什么是公钥基础设施</h2><p><strong>公钥基础设施</strong>（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。</p><h2 id="4-2-PKI-的组成要素"><a href="#4-2-PKI-的组成要素" class="headerlink" title="4.2 PKI 的组成要素"></a>4.2 PKI 的组成要素</h2><ol><li>用户——使用 PKI 的人</li><li>认证机构——颁发证书的人</li><li>仓库——保存证书的数据</li></ol><h2 id="4-3-认证机构的工作"><a href="#4-3-认证机构的工作" class="headerlink" title="4.3 认证机构的工作"></a>4.3 认证机构的工作</h2><ol><li>生成密钥对</li><li>注册证书</li><li>作废证书与 CRL（证书作废清单 Certificate Revocation List）</li></ol><h2 id="4-4-证书的层级结构"><a href="#4-4-证书的层级结构" class="headerlink" title="4.4 证书的层级结构"></a>4.4 证书的层级结构</h2><p>证书颁发：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。验证证书：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。如果连根CA都无法验证说明证书是存在问题的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_3.png" alt=""></p><h1 id="5-对证书的攻击"><a href="#5-对证书的攻击" class="headerlink" title="5. 对证书的攻击"></a>5. 对证书的攻击</h1><h2 id="5-1-在公钥注册之前进行攻击"><a href="#5-1-在公钥注册之前进行攻击" class="headerlink" title="5.1 在公钥注册之前进行攻击"></a>5.1 在公钥注册之前进行攻击</h2><h2 id="5-2-注册相似人名进行攻击"><a href="#5-2-注册相似人名进行攻击" class="headerlink" title="5.2 注册相似人名进行攻击"></a>5.2 注册相似人名进行攻击</h2><h2 id="5-3-窃取认证机构的私钥进行攻击"><a href="#5-3-窃取认证机构的私钥进行攻击" class="headerlink" title="5.3 窃取认证机构的私钥进行攻击"></a>5.3 窃取认证机构的私钥进行攻击</h2><h2 id="5-4-攻击者伪装成认证机构进行攻击"><a href="#5-4-攻击者伪装成认证机构进行攻击" class="headerlink" title="5.4 攻击者伪装成认证机构进行攻击"></a>5.4 攻击者伪装成认证机构进行攻击</h2><h2 id="5-5-钻-CRL-的空子进行攻击"><a href="#5-5-钻-CRL-的空子进行攻击" class="headerlink" title="5.5 钻 CRL 的空子进行攻击"></a>5.5 钻 CRL 的空子进行攻击</h2><p>Mallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。</p><h1 id="6-关于证书的-Q-amp-A"><a href="#6-关于证书的-Q-amp-A" class="headerlink" title="6. 关于证书的 Q&amp;A"></a>6. 关于证书的 Q&amp;A</h1><h2 id="6-1-为什么需要证书"><a href="#6-1-为什么需要证书" class="headerlink" title="6.1 为什么需要证书"></a>6.1 为什么需要证书</h2><p>疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？<br>回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。</p><h2 id="6-2-通过自己的方法进行认证是不是更安全"><a href="#6-2-通过自己的方法进行认证是不是更安全" class="headerlink" title="6.2 通过自己的方法进行认证是不是更安全"></a>6.2 通过自己的方法进行认证是不是更安全</h2><p>疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？<br>回答：靠隐蔽式来保证安全是错误的！</p><h2 id="6-3-为什么要相信认证机构"><a href="#6-3-为什么要相信认证机构" class="headerlink" title="6.3 为什么要相信认证机构"></a>6.3 为什么要相信认证机构</h2><p>？？？</p><h1 id="7-本章小结"><a href="#7-本章小结" class="headerlink" title="7. 本章小结"></a>7. 本章小结</h1><p>从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。<br>无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。</p><h1 id="8-小测验"><a href="#8-小测验" class="headerlink" title="8. 小测验"></a>8. 小测验</h1><ol><li>证书是认证机构将用户的公钥加密后的产物</li><li>要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥</li><li>世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA</li><li>用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构</li><li>用户需要定期从认证机构获取 CRL</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-本章概要&quot;&gt;&lt;a href=&quot;#1-本章概要&quot; class=&quot;headerlink&quot; title=&quot;1 本章概要&quot;&gt;&lt;/a&gt;1 本章概要&lt;/h1&gt;&lt;p&gt;第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>九、数字签名——消息到底是谁写的</title>
    <link href="http://www.liwenguang.cn/2017/11/21/graphic2cryptography/9.html/"/>
    <id>http://www.liwenguang.cn/2017/11/21/graphic2cryptography/9.html/</id>
    <published>2017-11-20T17:07:00.000Z</published>
    <updated>2017-11-22T13:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-羊妈妈的认证"><a href="#1-羊妈妈的认证" class="headerlink" title="1 羊妈妈的认证"></a>1 羊妈妈的认证</h1><p>大灰狼把黑色的爪子伸进门缝，说道：<br>“我是你们的妈妈，快快开门吧！”<br>七只小羊回答道：<br>“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”<br>听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。<br>这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。<br>如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。</p><h1 id="3-数字签名"><a href="#3-数字签名" class="headerlink" title="3 数字签名"></a>3 数字签名</h1><h2 id="3-1-Alice-的借条"><a href="#3-1-Alice-的借条" class="headerlink" title="3.1 Alice 的借条"></a>3.1 Alice 的借条</h2><p>假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：<br>“Bob，我向你借款 100 万元。”————Alice。<br>显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。</p><h2 id="3-2-从消息认证码到数字签名"><a href="#3-2-从消息认证码到数字签名" class="headerlink" title="3.2 从消息认证码到数字签名"></a>3.2 从消息认证码到数字签名</h2><h3 id="1-消息认证码的局限性"><a href="#1-消息认证码的局限性" class="headerlink" title="1. 消息认证码的局限性"></a>1. 消息认证码的局限性</h3><p>第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。</p><h3 id="2-通过数字签名解决问题"><a href="#2-通过数字签名解决问题" class="headerlink" title="2. 通过数字签名解决问题"></a>2. 通过数字签名解决问题</h3><p>假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。<br>实际上，这种看似神奇的技术，早就已经问世了，这就是<strong>数字签名</strong>（digital signature）。</p><h2 id="3-3-签名的生成和验证"><a href="#3-3-签名的生成和验证" class="headerlink" title="3.3 签名的生成和验证"></a>3.3 签名的生成和验证</h2><p>在数字签名技术中，出现了下面两种行为：  </p><ul><li>生成消息签名的行为</li><li>验证消息签名的行为</li></ul><p>生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。<br>验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。  </p><p>Alice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。<strong>数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。</strong>这一点非常重要。此外，<strong>签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。</strong><br>这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，<strong>数字签名</strong>就是通过将公钥密码“反过来用”而实现的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_1.png" alt=""></p><h2 id="3-4-公钥密码与数字签名"><a href="#3-4-公钥密码与数字签名" class="headerlink" title="3.4 公钥密码与数字签名"></a>3.4 公钥密码与数字签名</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_2.png" alt=""><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_3.png" alt=""></p><h1 id="4-数字签名的方法"><a href="#4-数字签名的方法" class="headerlink" title="4 数字签名的方法"></a>4 数字签名的方法</h1><p>我们来介绍两种生成和验证数字签名的方法：  </p><ol><li>直接对消息签名的方法</li><li>对消息的散列值签名的方法</li></ol><p>后者虽然复杂，但实际中我们一般都使用这种方法。</p><h2 id="4-1-直接对消息签名的方法"><a href="#4-1-直接对消息签名的方法" class="headerlink" title="4.1 直接对消息签名的方法"></a>4.1 直接对消息签名的方法</h2><p>发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。<br>Alice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名签名的 Bob 则需要得到 Alice 公钥。过程如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_4.png" alt="">  </p><ol><li>Alice 用自己的私钥对消息进行加密。</li><li>Alice 将消息和签名发送给 Bob。</li><li>Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。</li><li>Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。</li></ol><h2 id="4-2-对消息的散列值签名的方法"><a href="#4-2-对消息的散列值签名的方法" class="headerlink" title="4.2 对消息的散列值签名的方法"></a>4.2 对消息的散列值签名的方法</h2><p>与对消息签名的不同是，这里的消息变成了消息的散列值。流程参考上图。</p><h1 id="5-对数字签名的疑问"><a href="#5-对数字签名的疑问" class="headerlink" title="5 对数字签名的疑问"></a>5 对数字签名的疑问</h1><h2 id="5-1-密文为什么能作为签名使用"><a href="#5-1-密文为什么能作为签名使用" class="headerlink" title="5.1 密文为什么能作为签名使用"></a>5.1 密文为什么能作为签名使用</h2><p>疑问：为什么密文能够具备签名的意义呢？<br>解答：数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表<strong>只有持有该秘钥的人才能够生成的信息</strong>。<br>这样的信息一般称为<strong>认证符号</strong>（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。</p><h2 id="5-2-数字签名不能保证机密性吗"><a href="#5-2-数字签名不能保证机密性吗" class="headerlink" title="5.2 数字签名不能保证机密性吗"></a>5.2 数字签名不能保证机密性吗</h2><p>疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？<br>解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。</p><h2 id="5-3-这种签名可以随意复制吗"><a href="#5-3-这种签名可以随意复制吗" class="headerlink" title="5.3 这种签名可以随意复制吗"></a>5.3 这种签名可以随意复制吗</h2><p>疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？<br>解答：签名重要的是，<strong>特定的签名者与特定的消息绑定在了一起</strong>这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。</p><h2 id="5-4-消息内容会不不会任意修改"><a href="#5-4-消息内容会不不会任意修改" class="headerlink" title="5.4 消息内容会不不会任意修改"></a>5.4 消息内容会不不会任意修改</h2><p>疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？<br>解答：数字签名所要实现的并不是<strong>防止修改</strong>，而是<strong>识别修改</strong>。修改没问题，但验证签名会失败。</p><h2 id="5-5-删除签名也无法“作废合同”吗"><a href="#5-5-删除签名也无法“作废合同”吗" class="headerlink" title="5.5 删除签名也无法“作废合同”吗"></a>5.5 删除签名也无法“作废合同”吗</h2><p>疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？<br>解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。</p><h2 id="5-6-如何防止否认"><a href="#5-6-如何防止否认" class="headerlink" title="5.6 如何防止否认"></a>5.6 如何防止否认</h2><p>严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。</p><h2 id="5-7-数字签名真的能够代替签名吗"><a href="#5-7-数字签名真的能够代替签名吗" class="headerlink" title="5.7 数字签名真的能够代替签名吗"></a>5.7 数字签名真的能够代替签名吗</h2><p>不能代替，而是共存。</p><h1 id="6-数字签名的应用实例"><a href="#6-数字签名的应用实例" class="headerlink" title="6 数字签名的应用实例"></a>6 数字签名的应用实例</h1><h2 id="6-1-安全信息公告"><a href="#6-1-安全信息公告" class="headerlink" title="6.1 安全信息公告"></a>6.1 安全信息公告</h2><p>一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥可以排除有人恶意伪装成该组织来发布假消息的风险。</p><h2 id="6-2-软件下载"><a href="#6-2-软件下载" class="headerlink" title="6.2 软件下载"></a>6.2 软件下载</h2><p>保证网络下载的软件是否被篡改过。</p><h2 id="6-3-公钥证书"><a href="#6-3-公钥证书" class="headerlink" title="6.3 公钥证书"></a>6.3 公钥证书</h2><p>在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是<strong>公钥证书</strong>，将在第十章详解。</p><h2 id="6-4-SSL-TLS"><a href="#6-4-SSL-TLS" class="headerlink" title="6.4 SSL/TLS"></a>6.4 SSL/TLS</h2><p>SSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。</p><h1 id="7-通过-RSA-实现数字签名"><a href="#7-通过-RSA-实现数字签名" class="headerlink" title="7 通过 RSA 实现数字签名"></a>7 通过 RSA 实现数字签名</h1><h2 id="7-1-用-RSA-生成签名"><a href="#7-1-用-RSA-生成签名" class="headerlink" title="7.1 用 RSA 生成签名"></a>7.1 用 RSA 生成签名</h2><h2 id="签名-消息-D-mod-N"><a href="#签名-消息-D-mod-N" class="headerlink" title="签名 = 消息 ^ D mod N"></a>签名 = 消息 ^ D mod N</h2><p>这里所使用的 D 和 N 就是签名者的私钥。</p><h2 id="7-2-用-RSA-验证签名"><a href="#7-2-用-RSA-验证签名" class="headerlink" title="7.2 用 RSA 验证签名"></a>7.2 用 RSA 验证签名</h2><h2 id="由签名求得的消息-签名-E-mod-N"><a href="#由签名求得的消息-签名-E-mod-N" class="headerlink" title="由签名求得的消息 = 签名 ^ E mod N"></a>由签名求得的消息 = 签名 ^ E mod N</h2><p>这里所使用的 E 和 N 就是签名者的公钥。</p><h2 id="7-3-具体实践"><a href="#7-3-具体实践" class="headerlink" title="7.3 具体实践"></a>7.3 具体实践</h2><p>假设密钥对：<br>公钥：E = 5; N = 323;私钥：D = 29; N = 323;</p><h3 id="1-生成签名"><a href="#1-生成签名" class="headerlink" title="1.生成签名"></a>1.生成签名</h3><p>消息^D mod N = 123^29 mod 323 = 157<br>得到签名是 157，向接收者发送的内容为：(123，157)。</p><h3 id="2-验证签名"><a href="#2-验证签名" class="headerlink" title="2.验证签名"></a>2.验证签名</h3><p>签名^E mod N = 157^5 mod 323 = 123<br>得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。</p><h1 id="8-其它的数字签名"><a href="#8-其它的数字签名" class="headerlink" title="8 其它的数字签名"></a>8 其它的数字签名</h1><ol><li>EIGamal 方式：利用了在 mod N 中求离散对数的困难度。</li><li>DSA。</li><li>Rabin 方式：利用了在 mod N 中其平方根的困难度。</li></ol><h1 id="9-对数字签名的攻击"><a href="#9-对数字签名的攻击" class="headerlink" title="9 对数字签名的攻击"></a>9 对数字签名的攻击</h1><h2 id="9-1-中间人攻击"><a href="#9-1-中间人攻击" class="headerlink" title="9.1 中间人攻击"></a>9.1 中间人攻击</h2><h2 id="9-2-对单向散列函数的攻击"><a href="#9-2-对单向散列函数的攻击" class="headerlink" title="9.2 对单向散列函数的攻击"></a>9.2 对单向散列函数的攻击</h2><p>数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。</p><h2 id="9-3-利用数字签名攻击公钥密码"><a href="#9-3-利用数字签名攻击公钥密码" class="headerlink" title="9.3 利用数字签名攻击公钥密码"></a>9.3 利用数字签名攻击公钥密码</h2><p>将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴）<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_5.png" alt=""></p><h1 id="10-各种密码技术的对比"><a href="#10-各种密码技术的对比" class="headerlink" title="10 各种密码技术的对比"></a>10 各种密码技术的对比</h1><h2 id="10-1-消息认证码与数字签名"><a href="#10-1-消息认证码与数字签名" class="headerlink" title="10.1 消息认证码与数字签名"></a>10.1 消息认证码与数字签名</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">对称密码</th><th style="text-align:left">公钥密码</th></tr></thead><tbody><tr><td style="text-align:center">发送者</td><td style="text-align:center">用共享秘钥加密</td><td style="text-align:left">用公钥加密</td></tr><tr><td style="text-align:center">接收者</td><td style="text-align:center">用共享秘钥解密</td><td style="text-align:left">用私钥解密</td></tr><tr><td style="text-align:center">秘钥配送问题</td><td style="text-align:center">存在</td><td style="text-align:left">不存在，但公钥需要另外认证</td></tr><tr><td style="text-align:center">机密性</td><td style="text-align:center">✔️</td><td style="text-align:left">✔️</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">消息认证码</th><th style="text-align:left">数字签名</th></tr></thead><tbody><tr><td style="text-align:center">发送者</td><td style="text-align:center">用共享秘钥计算 MAC 值</td><td style="text-align:left">用私钥生成签名</td></tr><tr><td style="text-align:center">接收者</td><td style="text-align:center">用共享秘钥计算 MAC 值</td><td style="text-align:left">用公钥验证签名</td></tr><tr><td style="text-align:center">秘钥配送问题</td><td style="text-align:center">存在</td><td style="text-align:left">不存在，但公钥需要另外认证</td></tr><tr><td style="text-align:center">完整性</td><td style="text-align:center">✔️</td><td style="text-align:left">✔️</td></tr><tr><td style="text-align:center">认证</td><td style="text-align:center">✔️（仅限通信对象双方）</td><td style="text-align:left">✔️（可适用于任何第三方）</td></tr><tr><td style="text-align:center">防止否认</td><td style="text-align:center">✘</td><td style="text-align:left">✔️</td></tr></tbody></table><h2 id="10-2-混合密码系统与散列值签名"><a href="#10-2-混合密码系统与散列值签名" class="headerlink" title="10.2 混合密码系统与散列值签名"></a>10.2 混合密码系统与散列值签名</h2><p>在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。<br>另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。<br>即：<strong>对称密码的秘钥是机密性的精华</strong>，<strong>单向散列函数的散列值是完整性的精华</strong>。</p><h1 id="11-数字签名无法解决的问题"><a href="#11-数字签名无法解决的问题" class="headerlink" title="11 数字签名无法解决的问题"></a>11 数字签名无法解决的问题</h1><p>用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。<br>然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的<strong>公钥必须属于真正的发送者</strong>。<br>现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。<br>为了能够确认自己得到的公钥是否合法，我们需要使用<strong>证书</strong>。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。   </p><p>但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即<strong>公钥基础设施（Public Key Intrastructure）</strong>，简称 PKI，关于证书和 PKI 将在第十章详解。</p><h1 id="12-本章小结"><a href="#12-本章小结" class="headerlink" title="12 本章小结"></a>12 本章小结</h1><p>本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。<br>通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。</p><h1 id="13-小测验"><a href="#13-小测验" class="headerlink" title="13 小测验"></a>13 小测验</h1><ol><li>要验证数字签名，需要使用签名者的私钥。</li><li>RSA 可以用作数字签名算法。</li><li>使用数字签名可以保护消息的机密性，不用担心被窃听。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-羊妈妈的认证&quot;&gt;&lt;a href=&quot;#1-羊妈妈的认证&quot; class=&quot;headerlink&quot; title=&quot;1 羊妈妈的认证&quot;&gt;&lt;/a&gt;1 羊妈妈的认证&lt;/h1&gt;&lt;p&gt;大灰狼把黑色的爪子伸进门缝，说道：&lt;br&gt;“我是你们的妈妈，快快开门吧！”&lt;br&gt;七只小羊回
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>八、消息认证码</title>
    <link href="http://www.liwenguang.cn/2017/11/19/graphic2cryptography/8.html/"/>
    <id>http://www.liwenguang.cn/2017/11/19/graphic2cryptography/8.html/</id>
    <published>2017-11-19T15:09:00.000Z</published>
    <updated>2017-11-20T17:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。<br>消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。</p><h1 id="2-消息认证码"><a href="#2-消息认证码" class="headerlink" title="2 消息认证码"></a>2 消息认证码</h1><h2 id="2-1-汇款请求是正确的吗"><a href="#2-1-汇款请求是正确的吗" class="headerlink" title="2.1 汇款请求是正确的吗"></a>2.1 汇款请求是正确的吗</h2><p>我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。<br>消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。<br>消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。<br>本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。</p><h2 id="2-2-什么是消息认证码"><a href="#2-2-什么是消息认证码" class="headerlink" title="2.2 什么是消息认证码"></a>2.2 什么是消息认证码</h2><p>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 <strong>MAC</strong>。<br>消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。<br>根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。<br>要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。  </p><p>后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：<strong>消息认证码是一种与秘钥相关联的单向散列函数</strong>。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_1.png" alt=""></p><h2 id="2-3-消息认证码的使用步骤"><a href="#2-3-消息认证码的使用步骤" class="headerlink" title="2.3 消息认证码的使用步骤"></a>2.3 消息认证码的使用步骤</h2><p>以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_2.png" alt="">  </p><ol><li>发送者 Alice 与接收者 Bob 事先共享秘钥。</li><li>发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。</li><li>发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。</li><li>接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥）</li><li>接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。</li><li>如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。</li></ol><h2 id="2-4-消息认证码的秘钥配送问题"><a href="#2-4-消息认证码的秘钥配送问题" class="headerlink" title="2.4 消息认证码的秘钥配送问题"></a>2.4 消息认证码的秘钥配送问题</h2><p>发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。</p><h1 id="3-消息认证码的应用实例"><a href="#3-消息认证码的应用实例" class="headerlink" title="3 消息认证码的应用实例"></a>3 消息认证码的应用实例</h1><h2 id="3-1-SWIFT"><a href="#3-1-SWIFT" class="headerlink" title="3.1 SWIFT"></a>3.1 SWIFT</h2><p>SWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。<br>在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。</p><h2 id="3-2-IPsec"><a href="#3-2-IPsec" class="headerlink" title="3.2 IPsec"></a>3.2 IPsec</h2><p>IPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。</p><h2 id="3-3-SSL-TLS"><a href="#3-3-SSL-TLS" class="headerlink" title="3.3 SSL/TLS"></a>3.3 SSL/TLS</h2><p>SSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。</p><h1 id="4-消息认证码的实现方法"><a href="#4-消息认证码的实现方法" class="headerlink" title="4 消息认证码的实现方法"></a>4 消息认证码的实现方法</h1><h2 id="4-1-使用单向散列函数实现"><a href="#4-1-使用单向散列函数实现" class="headerlink" title="4.1 使用单向散列函数实现"></a>4.1 使用单向散列函数实现</h2><p>使用 SHA-1、MD5 之类的<strong>单向散列函数</strong>可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。</p><h2 id="4-2-使用分组密码实现"><a href="#4-2-使用分组密码实现" class="headerlink" title="4.2 使用分组密码实现"></a>4.2 使用分组密码实现</h2><p>使用 DES、AES 之类的<strong>分组密码</strong>可以实现消息认证码。<br>将分组密码的秘钥作为消息认证码的共享秘钥来使用。</p><h2 id="4-3-其它实现方法"><a href="#4-3-其它实现方法" class="headerlink" title="4.3 其它实现方法"></a>4.3 其它实现方法</h2><p>使用流密码和公钥密码等也可以实现消息认证码。</p><h1 id="5-HMAC-的详细介绍"><a href="#5-HMAC-的详细介绍" class="headerlink" title="5 HMAC 的详细介绍"></a>5 HMAC 的详细介绍</h1><h2 id="5-1-什么是-HMAC"><a href="#5-1-什么是-HMAC" class="headerlink" title="5.1 什么是 HMAC"></a>5.1 什么是 HMAC</h2><p>HMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。<br>HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。<br>使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。</p><h2 id="5-2-HMAC-的步骤"><a href="#5-2-HMAC-的步骤" class="headerlink" title="5.2 HMAC 的步骤"></a>5.2 HMAC 的步骤</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_3.png" alt="">  </p><h3 id="1-秘钥填充"><a href="#1-秘钥填充" class="headerlink" title="1.秘钥填充"></a>1.秘钥填充</h3><p>如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。<br>如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。</p><h3 id="2-填充后的秘钥与-ipad-的-XOR"><a href="#2-填充后的秘钥与-ipad-的-XOR" class="headerlink" title="2.填充后的秘钥与 ipad 的 XOR"></a>2.填充后的秘钥与 ipad 的 XOR</h3><p>将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。<br>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且<strong>和秘钥相关的比特序列</strong>。这里我们将这个比特序列称为 ipadkey。</p><h3 id="3-与消息组合"><a href="#3-与消息组合" class="headerlink" title="3.与消息组合"></a>3.与消息组合</h3><p>随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。</p><h3 id="4-计算散列值"><a href="#4-计算散列值" class="headerlink" title="4.计算散列值"></a>4.计算散列值</h3><p>将第三步的结果输入单向散列函数，并计算出散列值。</p><h3 id="5-填充后的秘钥与-opad-的-XOR"><a href="#5-填充后的秘钥与-opad-的-XOR" class="headerlink" title="5.填充后的秘钥与 opad 的 XOR"></a>5.填充后的秘钥与 opad 的 XOR</h3><p>将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。<br>XOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_4.png" alt=""></p><h3 id="6-与散列值组合"><a href="#6-与散列值组合" class="headerlink" title="6. 与散列值组合"></a>6. 与散列值组合</h3><p>将第四步的散列值拼在 opadkey 后面。</p><h3 id="7-计算散列值"><a href="#7-计算散列值" class="headerlink" title="7.计算散列值"></a>7.计算散列值</h3><p>将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。<br>通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。</p><h1 id="6-对消息认证码的攻击"><a href="#6-对消息认证码的攻击" class="headerlink" title="6 对消息认证码的攻击"></a>6 对消息认证码的攻击</h1><h2 id="6-1-重放攻击"><a href="#6-1-重放攻击" class="headerlink" title="6.1 重放攻击"></a>6.1 重放攻击</h2><p>Mallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。  </p><ol><li>Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。</li><li>Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。</li><li>Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。</li><li>Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。</li><li>Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。</li><li>Mallory 继续重复第四步。</li><li>Bob 银行重复第五步。</li></ol><p>有几种方法可以防御重放攻击。</p><h3 id="1-序号"><a href="#1-序号" class="headerlink" title="1.序号"></a>1.序号</h3><p>约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。</p><h3 id="2-时间戳"><a href="#2-时间戳" class="headerlink" title="2.时间戳"></a>2.时间戳</h3><p>约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。</p><h3 id="3-nonce"><a href="#3-nonce" class="headerlink" title="3.nonce"></a>3.nonce</h3><p>在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_5.png" alt=""></p><h2 id="6-2-密码推测攻击"><a href="#6-2-密码推测攻击" class="headerlink" title="6.2 密码推测攻击"></a>6.2 密码推测攻击</h2><p>和对单向散列函数的攻击一样，对消息认证码也可以进行<strong>暴力破解</strong>以及<strong>生日攻击</strong>（7.6.2节）。<br>对于消息认证码来说，应保证<strong>不能根据 MAC 值推测出通信双方所使用的秘钥</strong>。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。<br>此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。</p><h1 id="7-消息认证码无法解决的问题"><a href="#7-消息认证码无法解决的问题" class="headerlink" title="7 消息认证码无法解决的问题"></a>7 消息认证码无法解决的问题</h1><h2 id="7-1-对第三方证明"><a href="#7-1-对第三方证明" class="headerlink" title="7.1 对第三方证明"></a>7.1 对第三方证明</h2><p>假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。</p><h2 id="7-2-防止否认"><a href="#7-2-防止否认" class="headerlink" title="7.2 防止否认"></a>7.2 防止否认</h2><p>假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。<br>即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法<strong>防止否认</strong>（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。<br>其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。<br>消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。<br>下一章的数字签名可以解决这些问题。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><ol><li>使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。</li><li>使用消息认证码能够识别出篡改行为。</li><li>使用消息认证码需要发送者和接收者之间共享的秘钥。</li><li>使用消息认证码能够防止否认。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-本章概要&quot;&gt;&lt;a href=&quot;#1-本章概要&quot; class=&quot;headerlink&quot; title=&quot;1 本章概要&quot;&gt;&lt;/a&gt;1 本章概要&lt;/h1&gt;&lt;p&gt;使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>七、单向散列函数（获取消息的“指纹”）</title>
    <link href="http://www.liwenguang.cn/2017/11/19/graphic2cryptography/7.html/"/>
    <id>http://www.liwenguang.cn/2017/11/19/graphic2cryptography/7.html/</id>
    <published>2017-11-19T07:16:00.000Z</published>
    <updated>2017-11-19T15:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。<br>本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。<br>我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。</p><h1 id="2-什么是单向散列函数"><a href="#2-什么是单向散列函数" class="headerlink" title="2 什么是单向散列函数"></a>2 什么是单向散列函数</h1><h2 id="2-1-这个文件是不是真的呢"><a href="#2-1-这个文件是不是真的呢" class="headerlink" title="2.1 这个文件是不是真的呢"></a>2.1 这个文件是不是真的呢</h2><p>Alice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。<br>第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：<br>“这个文件和我昨天晚上生成的文件是一样的吗？”<br>Alice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改……在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。  </p><p>也就是说，Alice 需要确定自己的文件的完整性（integrity）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_1.png" alt=""><br>稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。<br>不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_2.png" alt=""><br>这里还存在一个效率问题。如果需需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。<br>我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_3.png" alt=""><br>本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。</p><h2 id="2-2-什么是单向散列函数"><a href="#2-2-什么是单向散列函数" class="headerlink" title="2.2 什么是单向散列函数"></a>2.2 什么是单向散列函数</h2><p>单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_4.png" alt=""><br>这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。<br>散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_5.png" alt=""><br>由于散列值很短，因此很容易处理和使用。  </p><p>回家之前，Alice 用单向散列函数计算文件的散列值：<br>35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5<br>单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~<br>第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。</p><h2 id="2-3-单向散列函数的性质"><a href="#2-3-单向散列函数的性质" class="headerlink" title="2.3 单向散列函数的性质"></a>2.3 单向散列函数的性质</h2><h3 id="1-根据任意长度的消息计算出固定长度的散列值"><a href="#1-根据任意长度的消息计算出固定长度的散列值" class="headerlink" title="1. 根据任意长度的消息计算出固定长度的散列值"></a>1. 根据任意长度的消息计算出固定长度的散列值</h3><h3 id="2-能够快速计算出散列值"><a href="#2-能够快速计算出散列值" class="headerlink" title="2.能够快速计算出散列值"></a>2.能够快速计算出散列值</h3><h3 id="3-消息不同散列值也不同"><a href="#3-消息不同散列值也不同" class="headerlink" title="3.消息不同散列值也不同"></a>3.消息不同散列值也不同</h3><p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为<strong>碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。<br>难以发现碰撞的性质称为<strong>抗碰撞性（collision resistance）</strong>。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。<br>我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。<br>Alice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_6.png" alt=""><br>由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。  </p><p>这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保<strong>要找到和该条消息具有相同散列值的另外一条消息是非常困难的</strong>。这一性质称为<strong>弱抗碰撞性</strong>。单向散列函数都必须具备弱抗碰撞性。  </p><p>和弱抗碰撞性相对的，还有<strong>强抗碰撞性</strong>。所谓强抗碰撞性，是指<strong>要找到散列值相同的两条不同的消息是非常困难的</strong>这一性质。在这里，散列值可以是任意值。  </p><p>密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p><h3 id="4-具备单向性"><a href="#4-具备单向性" class="headerlink" title="4. 具备单向性"></a>4. 具备单向性</h3><h2 id="2-4-关于术语"><a href="#2-4-关于术语" class="headerlink" title="2.4 关于术语"></a>2.4 关于术语</h2><p><strong>单向散列函数</strong>也称为<strong>消息摘要函数（message digest function）</strong>、<strong>哈希函数</strong>或者<strong>杂凑函数</strong>。<br>输入单向散列函数的消息也称为<strong>原像（pre-image）</strong>。<br>单向散列函数输出的<strong>散列值</strong>也称为<strong>消息摘要（message digest）</strong>或者指纹（fingerprint）**。<br>完整性也称为一致性。<br>“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。</p><h1 id="3-单向散列函数的实际应用"><a href="#3-单向散列函数的实际应用" class="headerlink" title="3 单向散列函数的实际应用"></a>3 单向散列函数的实际应用</h1><h2 id="3-1-检测软件是否被篡改"><a href="#3-1-检测软件是否被篡改" class="headerlink" title="3.1 检测软件是否被篡改"></a>3.1 检测软件是否被篡改</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_7.png" alt=""></p><h2 id="3-2-基于口令的加密"><a href="#3-2-基于口令的加密" class="headerlink" title="3.2 基于口令的加密"></a>3.2 基于口令的加密</h2><p>单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。<br>PBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。</p><h2 id="3-3-消息认证码"><a href="#3-3-消息认证码" class="headerlink" title="3.3 消息认证码"></a>3.3 消息认证码</h2><p>使用单向散列函数可以构造消息认证码。<br>消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。<br>消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。</p><h2 id="3-4-数字签名"><a href="#3-4-数字签名" class="headerlink" title="3.4 数字签名"></a>3.4 数字签名</h2><p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。</p><h2 id="3-5-伪随机数生成器"><a href="#3-5-伪随机数生成器" class="headerlink" title="3.5 伪随机数生成器"></a>3.5 伪随机数生成器</h2><p>使用单向散列函数可以构造伪随机数生成器。<br>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。</p><h2 id="3-6-一次性口令"><a href="#3-6-一次性口令" class="headerlink" title="3.6 一次性口令"></a>3.6 一次性口令</h2><p>一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p><h1 id="4-单向散列函数的具体例子"><a href="#4-单向散列函数的具体例子" class="headerlink" title="4 单向散列函数的具体例子"></a>4 单向散列函数的具体例子</h1><h2 id="4-1-MD4、MD5"><a href="#4-1-MD4、MD5" class="headerlink" title="4.1 MD4、MD5"></a>4.1 MD4、MD5</h2><p>MD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。<br>MD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。<br>MD 是消息摘要（Message Digest）的缩写。</p><h2 id="4-2-SHA-1、SHA-256、SHA-384、SHA-512"><a href="#4-2-SHA-1、SHA-256、SHA-384、SHA-512" class="headerlink" title="4.2 SHA-1、SHA-256、SHA-384、SHA-512"></a>4.2 SHA-1、SHA-256、SHA-384、SHA-512</h2><p>SHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。<br>SHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。<br>它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。</p><h2 id="4-3-RIPEMD-160"><a href="#4-3-RIPEMD-160" class="headerlink" title="4.3 RIPEMD-160"></a>4.3 RIPEMD-160</h2><p>RIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。</p><h2 id="4-4-AHS（Advanced-Hash-Standard）与-SHA-3"><a href="#4-4-AHS（Advanced-Hash-Standard）与-SHA-3" class="headerlink" title="4.4 AHS（Advanced Hash Standard）与 SHA-3"></a>4.4 AHS（Advanced Hash Standard）与 SHA-3</h2><p>在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。</p><h1 id="5-单向散列函数-SHA-1"><a href="#5-单向散列函数-SHA-1" class="headerlink" title="5 单向散列函数 SHA-1"></a>5 单向散列函数 SHA-1</h1><p>此章主要讲解其具体算法，有感兴趣者请看原书。</p><h1 id="6-对单向散列函数的攻击"><a href="#6-对单向散列函数的攻击" class="headerlink" title="6 对单向散列函数的攻击"></a>6 对单向散列函数的攻击</h1><h2 id="6-1-暴力破解（攻击故事-1-）"><a href="#6-1-暴力破解（攻击故事-1-）" class="headerlink" title="6.1 暴力破解（攻击故事 1 ）"></a>6.1 暴力破解（攻击故事 1 ）</h2><p>Alice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的：</p><blockquote><p>Alice 要支付的金额为 100 万元。</p></blockquote><p>改成：</p><blockquote><p>Alice 要支付的金额为 1 亿元。</p></blockquote><p>不过，不仅要修改合同内容，还要不能改变散列值。<br>Mallory 可以从文档文件所具有的<strong>冗余性</strong>入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。<br>举个例子，下面的这些句子基本上说的都是一个意思：<br>Alice 要支付的金额为 1 亿元。<br>Alice 要支付的金额为壹亿元。<br>Alice 要支付的金额为 100000000 元。<br>Alice 应支付 1 亿元。<br>作为报酬， Alice 需要支付 1 亿元。<br><br>除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。  </p><p>于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。<br>在这里，Mallory 所进行的攻击就是<strong>暴力攻击</strong>。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种<strong>试图破解单向散列函数的“弱抗碰撞性”的攻击</strong>。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次）</p><h2 id="6-2-生日攻击（攻击故事-2-）"><a href="#6-2-生日攻击（攻击故事-2-）" class="headerlink" title="6.2 生日攻击（攻击故事 2 ）"></a>6.2 生日攻击（攻击故事 2 ）</h2><p>编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100 万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。<br>这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为<strong>生日攻击（birthday attack）</strong>，这是一种<strong>试图破解单向散列函数的“强抗碰撞性”的攻击。</strong><br>这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。</p><h1 id="7-单向散列函数无法解决的问题"><a href="#7-单向散列函数无法解决的问题" class="headerlink" title="7 单向散列函数无法解决的问题"></a>7 单向散列函数无法解决的问题</h1><p>假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，<strong>单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。</strong><br>因此我们还需要进行<strong>认证</strong>，用于认证的技术包括<strong>消息认证码</strong>和<strong>数字签名</strong>。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。<br>认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。<br>以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。<br>但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><ol><li>MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。</li><li>要找出和某条消息具备相同散列值的另一条消息是非常困难的。</li><li>要找出具有相同散列值但互不相同的两条消息是非常困难的。</li><li>SHA-1 的散列值长度为 20字节。</li><li>如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-本章概要&quot;&gt;&lt;a href=&quot;#1-本章概要&quot; class=&quot;headerlink&quot; title=&quot;1 本章概要&quot;&gt;&lt;/a&gt;1 本章概要&lt;/h1&gt;&lt;p&gt;针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>六、混合密码系统</title>
    <link href="http://www.liwenguang.cn/2017/11/18/graphic2cryptography/6.html/"/>
    <id>http://www.liwenguang.cn/2017/11/18/graphic2cryptography/6.html/</id>
    <published>2017-11-17T18:38:00.000Z</published>
    <updated>2017-11-18T09:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-混合动力汽车"><a href="#1-混合动力汽车" class="headerlink" title="1 混合动力汽车"></a>1 混合动力汽车</h1><p>在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。<br>电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。  </p><p>混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>本章将学习由对称密码和公钥密码相结合的混合密码系统。  </p><p>混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。</p><h1 id="3-混合密码系统"><a href="#3-混合密码系统" class="headerlink" title="3 混合密码系统"></a>3 混合密码系统</h1><h1 id="3-1-对称密码和公钥密码"><a href="#3-1-对称密码和公钥密码" class="headerlink" title="3.1 对称密码和公钥密码"></a>3.1 对称密码和公钥密码</h1><p>对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题：  </p><ol><li>公钥密码的处理速度远远低于对称密码</li><li>公钥密码难以抵御中间人攻击  </li></ol><p>本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍</p><h2 id="3-2-混合密码系统"><a href="#3-2-混合密码系统" class="headerlink" title="3.2 混合密码系统"></a>3.2 混合密码系统</h2><ol><li>用对称密码加密信息</li><li>通过伪随机数生成器生成对称密码的会话秘钥</li><li>通过公钥密码加密会话秘钥</li><li>从混合密码系统外部赋予公钥密码加密时使用的秘钥</li></ol><p>混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。<br>即利用了对称密码的解密速度，公钥密码的机密性。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_1.png" alt=""></p><h2 id="3-3-加密"><a href="#3-3-加密" class="headerlink" title="3.3 加密"></a>3.3 加密</h2><p>流程图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_2.png" alt="">  </p><h3 id="1-明文、秘钥、密文"><a href="#1-明文、秘钥、密文" class="headerlink" title="1. 明文、秘钥、密文"></a>1. 明文、秘钥、密文</h3><p>首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。<br>上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和“用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。</p><h3 id="2-加密消息"><a href="#2-加密消息" class="headerlink" title="2. 加密消息"></a>2. 加密消息</h3><p>中间的大虚线方框分成左右两部分。<br>右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。<br>消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。这就是右半部分所进行的处理。</p><h3 id="3-加密会话秘钥"><a href="#3-加密会话秘钥" class="headerlink" title="3. 加密会话秘钥"></a>3. 加密会话秘钥</h3><p>左半部分进行的是会话秘钥的生成和加密操作。<br>会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分，作为对称密码的秘钥使用。<br>接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。  </p><p><strong>会话秘钥是对称密码的秘钥，同时也是公钥密码的明文</strong>。请大家一定要理解会话秘钥的双重性！</p><h3 id="4-组合"><a href="#4-组合" class="headerlink" title="4. 组合"></a>4. 组合</h3><p>如何上面的内容都理解了，剩下的就简单多了。<br>我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。<br>组合之后的数据就是混合密码系统整体的密文。</p><h2 id="3-4-解密"><a href="#3-4-解密" class="headerlink" title="3.4 解密"></a>3.4 解密</h2><p>流程图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_3.png" alt=""></p><h3 id="1-分离"><a href="#1-分离" class="headerlink" title="1. 分离"></a>1. 分离</h3><p>只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。</p><h3 id="2-解密会话秘钥"><a href="#2-解密会话秘钥" class="headerlink" title="2. 解密会话秘钥"></a>2. 解密会话秘钥</h3><p>会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。<br>解密后的会话秘钥将被用作解密消息的秘钥。</p><h3 id="3-解密消息"><a href="#3-解密消息" class="headerlink" title="3. 解密消息"></a>3. 解密消息</h3><p>消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。<br>上述流程正好是“混合密码系统的加密”的逆操作。</p><h2 id="3-5-混合密码系统的具体例子"><a href="#3-5-混合密码系统的具体例子" class="headerlink" title="3.5 混合密码系统的具体例子"></a>3.5 混合密码系统的具体例子</h2><p>混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。<br>著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。</p><h1 id="4-怎样才是高强度的混合密码系统"><a href="#4-怎样才是高强度的混合密码系统" class="headerlink" title="4 怎样才是高强度的混合密码系统"></a>4 怎样才是高强度的混合密码系统</h1><h2 id="4-1-伪随机数生成器"><a href="#4-1-伪随机数生成器" class="headerlink" title="4.1 伪随机数生成器"></a>4.1 伪随机数生成器</h2><p>混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。<br>会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的攻击方法，将在第十二章详解。</p><h2 id="4-2-对称密码"><a href="#4-2-对称密码" class="headerlink" title="4.2 对称密码"></a>4.2 对称密码</h2><p>混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。</p><h2 id="4-3-公钥密码"><a href="#4-3-公钥密码" class="headerlink" title="4.3 公钥密码"></a>4.3 公钥密码</h2><p>混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。</p><h2 id="4-4-秘钥长度的平衡"><a href="#4-4-秘钥长度的平衡" class="headerlink" title="4.4 秘钥长度的平衡"></a>4.4 秘钥长度的平衡</h2><p>对称密码和公钥密码的秘钥长度必须具备同等的强度。<br>然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_4.png" alt=""></p><h1 id="5-密码技术的组合"><a href="#5-密码技术的组合" class="headerlink" title="5 密码技术的组合"></a>5 密码技术的组合</h1><p>本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。<br>例如，第四章中介绍的<strong>分组密码模式</strong>，就是将只能加密固定长度的数据的分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。  </p><p><strong>三重 DES</strong>是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。  </p><p>对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。<br>在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。  </p><p>数字签名，是由单向散列函数和公钥密码组合而成的。<br>证书，是由公钥和数字签名组合而成的。<br>消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。<br>伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。<br>还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。</p><h1 id="6-本章小结"><a href="#6-本章小结" class="headerlink" title="6 本章小结"></a>6 本章小结</h1><p>本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。<br>到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。<br>从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。</p><h1 id="7-小测验"><a href="#7-小测验" class="headerlink" title="7 小测验"></a>7 小测验</h1><ol><li>混合密码系统是用对称密码对消息进行加密的。</li><li>混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。</li><li>由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。</li><li>混合密码系统的解密过程是按照“公钥密码解密”-&gt;“对称密码解密”的顺序来进行处理的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-混合动力汽车&quot;&gt;&lt;a href=&quot;#1-混合动力汽车&quot; class=&quot;headerlink&quot; title=&quot;1 混合动力汽车&quot;&gt;&lt;/a&gt;1 混合动力汽车&lt;/h1&gt;&lt;p&gt;在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>五、公钥密码</title>
    <link href="http://www.liwenguang.cn/2017/11/15/graphic2cryptography/5.html/"/>
    <id>http://www.liwenguang.cn/2017/11/15/graphic2cryptography/5.html/</id>
    <published>2017-11-15T04:38:00.000Z</published>
    <updated>2017-11-17T18:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-投币寄物柜的使用方法"><a href="#1-投币寄物柜的使用方法" class="headerlink" title="1 投币寄物柜的使用方法"></a>1 投币寄物柜的使用方法</h1><p>介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。<br>只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。  </p><p>因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。  </p><p>本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。</p><h1 id="3-密钥配送问题"><a href="#3-密钥配送问题" class="headerlink" title="3 密钥配送问题"></a>3 密钥配送问题</h1><h2 id="3-1-什么是密钥配送问题"><a href="#3-1-什么是密钥配送问题" class="headerlink" title="3.1 什么是密钥配送问题"></a>3.1 什么是密钥配送问题</h2><p>在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是非常危险的。  </p><p>密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种：  </p><ol><li>通过事先共享密钥来解决</li><li>通过密钥分配中心来解决</li><li>通过 Diffie-Hellman 密钥交换来解决</li><li>通过公钥密码来解决</li></ol><h2 id="3-2-通过事先共享密钥来解决"><a href="#3-2-通过事先共享密钥来解决" class="headerlink" title="3.2 通过事先共享密钥来解决"></a>3.2 通过事先共享密钥来解决</h2><p>事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！</p><h1 id="3-3-通过秘钥分配中心来解决"><a href="#3-3-通过秘钥分配中心来解决" class="headerlink" title="3.3 通过秘钥分配中心来解决"></a>3.3 通过秘钥分配中心来解决</h1><p>公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会从入职时从秘钥分配中心的计算机上领取自己的秘钥。<br>这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。  </p><p>那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤：  </p><ol><li>Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求</li><li>秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥</li><li>秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥</li><li>秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice</li><li>秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob</li><li>Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥</li><li>Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob</li><li>Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥</li><li>Bob 用会话秘钥对来自 Alice 的密文进行解密</li><li>Alice 和 Bob 删除会话秘钥  </li></ol><p>以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见：  </p><ol><li>随着员工增加，秘钥分配中心负荷增大</li><li>如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪</li><li>攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重</li></ol><h2 id="3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题"><a href="#3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题" class="headerlink" title="3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题"></a>3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题</h2><p>解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。<br>根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。</p><h2 id="3-5-通过公钥密码来解决秘钥配送问题"><a href="#3-5-通过公钥密码来解决秘钥配送问题" class="headerlink" title="3.5 通过公钥密码来解决秘钥配送问题"></a>3.5 通过公钥密码来解决秘钥配送问题</h2><p>第四种方法，就是公钥密码。  </p><p>在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有解密秘钥的人才能够进行解密。  </p><p>接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。</p><h1 id="4-公钥密码"><a href="#4-公钥密码" class="headerlink" title="4 公钥密码"></a>4 公钥密码</h1><h2 id="4-1-什么是公钥密码"><a href="#4-1-什么是公钥密码" class="headerlink" title="4.1 什么是公钥密码"></a>4.1 什么是公钥密码</h2><p>公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。<br>加密秘钥和解密秘钥的区别：  </p><ol><li>发送者只需要加密秘钥</li><li>接收者只需要解密秘钥</li><li>解密秘钥不可以被窃听者获取</li><li>加密秘钥被窃听者获取也没问题</li></ol><p>也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。  </p><p>公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。</p><h2 id="4-2-公钥密码的历史"><a href="#4-2-公钥密码的历史" class="headerlink" title="4.2 公钥密码的历史"></a>4.2 公钥密码的历史</h2><ol><li>1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。  </li><li>1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。</li><li>1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。</li></ol><h2 id="4-3-公钥通信的流程"><a href="#4-3-公钥通信的流程" class="headerlink" title="4.3 公钥通信的流程"></a>4.3 公钥通信的流程</h2><p>Alice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的：  </p><ol><li>Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。</li><li>Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。</li><li>Alice 用 Bob 的公钥对消息进行加密。</li><li>Alice 将密文发送给 Bob 。密文被 Eve 获得。</li><li>Bob 用自己的私钥对密文进行解密。</li></ol><h2 id="4-4-公钥密码无法解决的问题"><a href="#4-4-公钥密码无法解决的问题" class="headerlink" title="4.4 公钥密码无法解决的问题"></a>4.4 公钥密码无法解决的问题</h2><p>我们需要判断所得到的公钥是否正确合法，这个问题被称为<strong>公钥认证</strong>问题。这个问题随后将通过对中间人攻击的讲解来探讨。<br>同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。</p><h1 id="5-时钟算法"><a href="#5-时钟算法" class="headerlink" title="5 时钟算法"></a>5 时钟算法</h1><p>在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。</p><h2 id="5-1-加法"><a href="#5-1-加法" class="headerlink" title="5.1 加法"></a>5.1 加法</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_1.png" alt=""><br>指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。  </p><p>因此加法就变成了求余数运算，即 mod 运算。</p><h2 id="5-2-减法"><a href="#5-2-减法" class="headerlink" title="5.2 减法"></a>5.2 减法</h2><p>减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 =&gt; x = 6。</p><h2 id="5-3-乘法"><a href="#5-3-乘法" class="headerlink" title="5.3 乘法"></a>5.3 乘法</h2><p>乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 =&gt; -9 + 12 = 3。</p><h2 id="5-4-除法"><a href="#5-4-除法" class="headerlink" title="5.4 除法"></a>5.4 除法</h2><p>除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。</p><h2 id="5-5-乘方"><a href="#5-5-乘方" class="headerlink" title="5.5 乘方"></a>5.5 乘方</h2><p>7^4：7^4 mod 12 = 2401 mod 12 = 1</p><h2 id="5-6-对数"><a href="#5-6-对数" class="headerlink" title="5.6 对数"></a>5.6 对数</h2><p>即乘方的逆运算：7^X = Y ，已知 Y 求 X。<br>在时钟运算中的对数称为离散对数。例如：<br>7^X mod 12 = 8，<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_2.png" alt=""><br>得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。</p><h2 id="5-7-从时钟指针到-RSA"><a href="#5-7-从时钟指针到-RSA" class="headerlink" title="5.7 从时钟指针到 RSA"></a>5.7 从时钟指针到 RSA</h2><p>我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。</p><h1 id="6-RSA"><a href="#6-RSA" class="headerlink" title="6 RSA"></a>6 RSA</h1><h2 id="6-1-什么是-RSA"><a href="#6-1-什么是-RSA" class="headerlink" title="6.1 什么是 RSA"></a>6.1 什么是 RSA</h2><p>RSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。<br>RSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。<br>RSA 在 1983年取得了专利，但现在专利已经过期。</p><h2 id="6-2-RSA-加密"><a href="#6-2-RSA-加密" class="headerlink" title="6.2 RSA 加密"></a>6.2 RSA 加密</h2><p>在 RSA 中，<strong>明文、秘钥和密文都是数字</strong>， RSA 的加密过程可以用下列公式来表示：  </p><h4 id="密文-明文-E-mod-N"><a href="#密文-明文-E-mod-N" class="headerlink" title="密文 = 明文 ^ E mod N"></a>密文 = 明文 ^ E mod N</h4><p>也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。<br>就是这么简单。<br>其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。<br>现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。</p><h2 id="6-3-RSA-解密"><a href="#6-3-RSA-解密" class="headerlink" title="6.3 RSA 解密"></a>6.3 RSA 解密</h2><h4 id="明文-密文-D-mod-N"><a href="#明文-密文-D-mod-N" class="headerlink" title="明文 = 密文 ^ D mod N"></a>明文 = 密文 ^ D mod N</h4><p>也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。  </p><p>RSA 的加密和解密整理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_3.png" alt=""><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_4.png" alt=""></p><h2 id="6-4-生成密钥对"><a href="#6-4-生成密钥对" class="headerlink" title="6.4 生成密钥对"></a>6.4 生成密钥对</h2><p>由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下：  </p><ol><li>求 N</li><li>求 L（中间值）</li><li>求 E</li><li>求 D</li></ol><p>注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。</p><h1 id="7-对-RSA-的攻击"><a href="#7-对-RSA-的攻击" class="headerlink" title="7 对 RSA 的攻击"></a>7 对 RSA 的攻击</h1><p>RSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。<br>破译者知道的信息：密文、E、N。<br>破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。</p><h2 id="7-1-通过密文来求得明文"><a href="#7-1-通过密文来求得明文" class="headerlink" title="7.1 通过密文来求得明文"></a>7.1 通过密文来求得明文</h2><p>密文 = 明文 ^ E mod N<br>如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难，因为人类还没有发现求离散对数的高效算法。</p><h2 id="7-2-通过暴力破解来找出-D"><a href="#7-2-通过暴力破解来找出-D" class="headerlink" title="7.2 通过暴力破解来找出 D"></a>7.2 通过暴力破解来找出 D</h2><p>由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。</p><h2 id="7-3-通过-E-和-N-求出-D"><a href="#7-3-通过-E-和-N-求出-D" class="headerlink" title="7.3 通过 E 和 N 求出 D"></a>7.3 通过 E 和 N 求出 D</h2><p>既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。</p><h2 id="7-4-中间人攻击"><a href="#7-4-中间人攻击" class="headerlink" title="7.4 中间人攻击"></a>7.4 中间人攻击</h2><p>下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。  </p><p>假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。  </p><ol><li>Alice 向 Bob 发送邮件索要公钥</li><li>Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。</li><li>Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。</li><li>Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。</li><li>Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。</li><li>Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。</li><li>Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。</li><li>Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。  </li></ol><p>Mallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！  </p><p>我们用公钥密码解决了密钥配送问题，但是又出现新的问题，<strong>如何判断收到的公钥是否来自于正确的接收者</strong>，即是否来自于 Bob 。解决这个问题成为认证，将在第十章详解。</p><h1 id="8-其它公钥密码"><a href="#8-其它公钥密码" class="headerlink" title="8 其它公钥密码"></a>8 其它公钥密码</h1><p>RSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。这些密码都可以被用于一般的加密和数字签名。</p><h2 id="8-1-EIGamal-方式"><a href="#8-1-EIGamal-方式" class="headerlink" title="8.1 EIGamal 方式"></a>8.1 EIGamal 方式</h2><p>RSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。</p><h2 id="8-2-Rabin-方式"><a href="#8-2-Rabin-方式" class="headerlink" title="8.2 Rabin 方式"></a>8.2 Rabin 方式</h2><p>Rabin 利用了 mod N 求平方根的困难度。</p><h2 id="8-3-椭圆曲线密码"><a href="#8-3-椭圆曲线密码" class="headerlink" title="8.3 椭圆曲线密码"></a>8.3 椭圆曲线密码</h2><p>椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。<br>它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。</p><h1 id="9-关于公钥密码的问答"><a href="#9-关于公钥密码的问答" class="headerlink" title="9 关于公钥密码的问答"></a>9 关于公钥密码的问答</h1><p>主要选择一些容易被误解的点解答疑问。</p><h2 id="9-1-公钥密码的机密性"><a href="#9-1-公钥密码的机密性" class="headerlink" title="9.1 公钥密码的机密性"></a>9.1 公钥密码的机密性</h2><p>公钥密码比对称密码的机密性更高吗？<br>这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。</p><h2 id="9-2-公钥密码与对称密码的密钥长度"><a href="#9-2-公钥密码与对称密码的密钥长度" class="headerlink" title="9.2 公钥密码与对称密码的密钥长度"></a>9.2 公钥密码与对称密码的密钥长度</h2><p>采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？<br>不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_5.png" alt=""></p><h2 id="9-3-对称密码的未来"><a href="#9-3-对称密码的未来" class="headerlink" title="9.3 对称密码的未来"></a>9.3 对称密码的未来</h2><p>因为已经有了公钥密码，今后对称密码会消失吗？<br>不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。</p><h2 id="9-4-RSA-和质数"><a href="#9-4-RSA-和质数" class="headerlink" title="9.4 RSA 和质数"></a>9.4 RSA 和质数</h2><p>随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？<br>512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后：100亿人<em>100亿个</em>31622400秒*100亿年 &lt; 10^39。<br>另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。</p><h2 id="9-5-RSA-与质因数分解"><a href="#9-5-RSA-与质因数分解" class="headerlink" title="9.5 RSA 与质因数分解"></a>9.5 RSA 与质因数分解</h2><p>RSA 的破译与大整数的质因数分解是等价的吗？<br>不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。</p><h2 id="9-6-RSA-的长度"><a href="#9-6-RSA-的长度" class="headerlink" title="9.6 RSA 的长度"></a>9.6 RSA 的长度</h2><p>要抵御质因数分解，N 的长度需要达到多少比特呢？<br>N 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。</p><h1 id="10-本章小结"><a href="#10-本章小结" class="headerlink" title="10 本章小结"></a>10 本章小结</h1><p>本章学习了公钥密码以及其代表性的实现方法——RSA。<br>使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！<br>对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。  </p><p>尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题将在第九章和第十章详解。  </p><p>即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。</p><h1 id="11-小测验"><a href="#11-小测验" class="headerlink" title="11 小测验"></a>11 小测验</h1><ol><li>秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。<br>为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？</li><li>要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。</li><li>公钥密码的私钥需要和加密后的消息一起被发送给接收者。</li><li>一般来说，对称密码的速度比公钥密码要快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-投币寄物柜的使用方法&quot;&gt;&lt;a href=&quot;#1-投币寄物柜的使用方法&quot; class=&quot;headerlink&quot; title=&quot;1 投币寄物柜的使用方法&quot;&gt;&lt;/a&gt;1 投币寄物柜的使用方法&lt;/h1&gt;&lt;p&gt;介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图解密码技术" scheme="http://www.liwenguang.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
