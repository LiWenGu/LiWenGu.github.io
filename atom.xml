<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不坠青云志</title>
  
  <subtitle>严律己，宽待人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.liwenguang.com/"/>
  <updated>2021-07-05T08:00:00.000Z</updated>
  <id>https://blog.liwenguang.com/</id>
  
  <author>
    <name>李文文 | zed</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>暂不更新</title>
    <link href="https://blog.liwenguang.com/2021/07/05/talker/no_update.html/"/>
    <id>https://blog.liwenguang.com/2021/07/05/talker/no_update.html/</id>
    <published>2021-07-05T08:00:00.000Z</published>
    <updated>2021-07-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近组织了同事们一起系统的学习例如像 Kafka、Elasticsearch、JVM、Dubbo、公司整体系统架构、业务架构的俱乐部。因此私人就暂时不更新。俱乐部博客：<a href="https://lie-flat-club.gitee.io/juan/。" target="_blank" rel="noopener">https://lie-flat-club.gitee.io/juan/。</a></p><ol><li>愿景：技术能力拉满，业务能力拉满，公共分享能力拉满。</li><li>落地：每1~2天就分享一次。</li><li>奥利给！</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近组织了同事们一起系统的学习例如像 Kafka、Elasticsearch、JVM、Dubbo、公司整体系统架构、业务架构的俱乐部。因此私人就暂时不更新。俱乐部博客：&lt;a href=&quot;https://lie-flat-club.gitee.io/juan/。&quot; targe
      
    
    </summary>
    
      <category term="闲聊" scheme="https://blog.liwenguang.com/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://blog.liwenguang.com/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>2021/25周总结</title>
    <link href="https://blog.liwenguang.com/2021/06/21/2021/25.html/"/>
    <id>https://blog.liwenguang.com/2021/06/21/2021/25.html/</id>
    <published>2021-06-21T23:54:00.000Z</published>
    <updated>2021-06-21T23:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>周五淋雨，去打羽毛球。接着周末两天下雨，就没去公司学习，在租房堕落了两天。</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/C4636A6A-3A64-471D-BA73-FFC07E1D0FE4_1_105_c.jpeg" alt="风云战国之列国"></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>科目一的理论终于学完，准备在第26周就要报名科目一了。</li><li>画画在B站学习素描。</li><li>作息调整的还可以。</li><li>基本都在弄 SkyWalking 的二开，每次学习都有新的体会。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>科目一！</li><li>画画习惯</li><li>SkyWalking 需要有个总结博客</li><li>作息习惯</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>能回到正轨就好。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;周五淋雨，去打羽毛球。接着周末两天下雨，就没去公司学习，在租房堕落了两天。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2021总结" scheme="https://blog.liwenguang.com/tags/2021%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2021/24周总结</title>
    <link href="https://blog.liwenguang.com/2021/06/15/2021/24.html/"/>
    <id>https://blog.liwenguang.com/2021/06/15/2021/24.html/</id>
    <published>2021-06-15T23:10:00.000Z</published>
    <updated>2021-06-15T23:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>这个端午过的有点丰富。</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210615231526.png" alt="风云战国之列国"></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>上周的端午节放了三天假，自己因为个人感情问题一直留在杭州，第一天放假在公司学习，第二天放假在租房玩耍，第三天放假和同事打乒乓球~</li><li>上周工作日也比较丰富，主要是在做skywalking的适应工作。</li><li>博客重新从语雀回到了个人博客有点不习惯。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>争取能报名科目一，浙江的科目一确实好复杂，还要看理论培训。时间被拉长了。</li><li>晚上12点前睡觉。</li><li>养成好的作息和学习习惯。现在学习主要是在周末公司学习，平常因为工作忙，而且最近 dota2 有 major 比赛，工作日回来后就看视频娱乐了。</li><li>买了平板希望自己能在业余时间学会画画吧，之前画画还是在高中，一直念念不忘想学会画画。</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>希望能更好。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;这个端午过的有点丰富。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2021总结" scheme="https://blog.liwenguang.com/tags/2021%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>skywalking-service-traffic的交互</title>
    <link href="https://blog.liwenguang.com/2021/06/12/tech/apm/skywalking_2_service-traffic.html/"/>
    <id>https://blog.liwenguang.com/2021/06/12/tech/apm/skywalking_2_service-traffic.html/</id>
    <published>2021-06-12T14:40:00.000Z</published>
    <updated>2021-06-12T14:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>此文源于在二开 SkyWalking 时，发现公司搭建的 SkyWalking 当前服务列表有时候会显示不出来已经接入的应用，在排查和解决过程中的总结。<br><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/90ECDCD7-2CE1-4FBD-B7F0-E9979FD42F0B_1_105_c.jpeg" alt="和亲戚孩子拼的机器人"></p><a id="more"></a><h1 id="1-后台界面显示位置"><a href="#1-后台界面显示位置" class="headerlink" title="1. 后台界面显示位置"></a>1. 后台界面显示位置</h1><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210612145841.png" alt="后台服务列表"></p><p>在当前服务的列表栏，会显示 service_traffic 表的数据，在存储层的 service_traffic 数据格式如下:</p><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210612150120.png" alt="存储层服务流量表"></p><p>目前只发现有两个字段有用，一个是 name 字段，一个是 node_type 字段，而 node_type 在枚举 <code>org.apache.skywalking.oap.server.core.analysis.NodeType</code> 中定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NodeType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Normal = 0;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * This node type would be treated as an observed node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Normal(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Database = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Database(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;RPCFramework = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RPCFramework(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Http = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Http(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;MQ = 4;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MQ(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Cache = 5;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Cache(<span class="number">5</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Browser = 6;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * This node type would be treated as an observed node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Browser(<span class="number">6</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;User = 10&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User(<span class="number">10</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Unrecognized = 11&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Unrecognized(<span class="number">11</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在发现有的应用接入 Skywalking 并启动后，但是在 <code>service_traffic</code> 表中没有显示，而相关的信息，例如 jvm 上报信息，以及实例的信息都是可以在数据中查到的。</p><blockquote><p>服务的实例相关信息可以在 <code>instance_traffic</code> 表中查询，其中 <code>service_id</code> 字段是 <code>service_traffic</code> 表的 <code>name</code> 字段的 base64 编码 + “.1”，例如 name 为 a1 的服务，它的 service_id 为：base64(“a1”) + “.1”。这里我也二开改过，原生会在后面加上随机数。</p></blockquote><h1 id="2-client-上传-service-traffic-信息"><a href="#2-client-上传-service-traffic-信息" class="headerlink" title="2. client 上传 service_traffic 信息"></a>2. client 上传 service_traffic 信息</h1><p>目前 client 会在上传 segment 的时候才会顺带将 service_traffic 信息上报，其实这里已经知道为什么我们应用接入 Skywalking，但是没有应用服务的信息，因为虽然产生了 jvm 以及实例机器的相关信息，但是没有产生让 plugin 拦截的 segment 上报导致。</p><p>以 kafka 为例，在客户端上传 segment 的地方，<code>org.apache.skywalking.apm.agent.core.kafka.KafkaTraceSegmentServiceClient</code> 该类负责客户端的 segment 的信息上传。topic 为 <code>skywalking-segment</code>。上报格式为 <code>apm-protocol/apm-network/src/main/proto/language-agent/Tracing.proto:50</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message SegmentObject &#123;</span><br><span class="line">    string traceId = 1;</span><br><span class="line"></span><br><span class="line">    string traceSegmentId = 2;</span><br><span class="line"></span><br><span class="line">    repeated SpanObject spans = 3;</span><br><span class="line"></span><br><span class="line">    // 上传的 appname</span><br><span class="line">    string service = 4;</span><br><span class="line"></span><br><span class="line">    string serviceInstance = 5;</span><br><span class="line"></span><br><span class="line">    bool isSizeLimited = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端批量一个一个的将 segment 上传后，等待 oap 的处理。</p><h1 id="3-oap-接收-segment-信息，并顺带处理-service-traffic-信息"><a href="#3-oap-接收-segment-信息，并顺带处理-service-traffic-信息" class="headerlink" title="3. oap 接收 segment 信息，并顺带处理 service_traffic 信息"></a>3. oap 接收 segment 信息，并顺带处理 service_traffic 信息</h1><p>oap 服务端通过 <code>org.apache.skywalking.oap.server.analyzer.agent.kafka.provider.handler.TraceSegmentHandler</code> 接收来自客户端的 segment 信息。最终会走到 <code>ServiceTrafficDispatcher</code> 分发器类做分发处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTrafficDispatcher</span> <span class="keyword">implements</span> <span class="title">SourceDispatcher</span>&lt;<span class="title">Service</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="keyword">final</span> Service source)</span> </span>&#123;</span><br><span class="line">        ServiceTraffic traffic = <span class="keyword">new</span> ServiceTraffic();</span><br><span class="line">        traffic.setTimeBucket(source.getTimeBucket());</span><br><span class="line">        traffic.setName(source.getName());</span><br><span class="line">        traffic.setNodeType(source.getNodeType());</span><br><span class="line">        MetricsStreamProcessor.getInstance().in(traffic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及两个核心的类，一个是 <code>SourceDispatcher</code>，源数据处理分发器，它的实现类有很多，通过 <code>dispatch</code> 方法的入参 <code>org.apache.skywalking.oap.server.core.source.Service#scope</code> 方法来判断走哪个分发器，具体代码可以在 <code>org.apache.skywalking.oap.server.core.analysis.DispatcherManager</code> 中查看。</p><p>另一个核心的类是 <code>StreamProcessor</code> 流式处理器类，此类一般和 <code>SourceDispatcher</code> 结合使用，例如上面 <code>ServiceTrafficDispatcher</code> 就在获取到源数据后，通过 <code>MetricsStreamProcessor</code> 做流式处理。</p><blockquote><p>这里的流式处理较为复杂，涉及到 dataCarrier，多生产者多消费者，其中多生产者是各种数据通过流式处理塞入 dataCarrier，而多消费者指的是两个：AggregatorConsumer、PersistentConsumer，前者用于 metrics 指标聚合，后者用于将 metrics 指标存库。</p></blockquote><p>在流式处理过程中，会走到 <code>org.apache.skywalking.oap.server.core.analysis.worker.MetricsRemoteWorker</code> 该 metrics 分析方法。该方法用于是否将当前的 metrics 信息传递给其它的 oap 角色。注意：<code>service_traffic</code> 也是 metrics 的一种。通过 <code>service_traffic</code> 表字段 <code>time_bucket</code> 也可以猜测的到，它也有自己的时间桶。</p><h1 id="4-oap-存-service-traffic-入库过程"><a href="#4-oap-存-service-traffic-入库过程" class="headerlink" title="4. oap 存 service_traffic 入库过程"></a>4. oap 存 service_traffic 入库过程</h1><p>当 <code>service_traffic</code> 作为 metrics 的一种存入 datacarrier 后，会被 <code>org.apache.skywalking.oap.server.core.analysis.worker.MetricsPersistentWorker.PersistentConsumer</code> 取出并消费，将一段时间的客户端的 <code>service_triffic</code> 信息聚合，并存入 <code>org.apache.skywalking.oap.server.core.analysis.data.ReadWriteSafeCache</code> 该缓存中，而 <code>org.apache.skywalking.oap.server.core.storage.PersistenceTimer</code> 会通过定时任务，定时的取出 <code>ReadWriteSafeCache</code> 中的 metrics 信息，当然也包括了 <code>service_traffic</code> 信息。最终通过 <code>org.apache.skywalking.oap.server.core.analysis.worker.MetricsPersistentWorker#flushDataToStorage</code> 存入数据库，这里看下该方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法用于所有 metrics 的存库方法，不仅仅是 service_traffic 信息。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">flushDataToStorage</span><span class="params">(List&lt;Metrics&gt; metricsList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    List&lt;PrepareRequest&gt; prepareRequests)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先从数据库中获取该次 metrics 信息，并存入 context 中</span></span><br><span class="line">        loadFromStorage(metricsList);</span><br><span class="line">        <span class="keyword">for</span> (Metrics metrics : metricsList) &#123;</span><br><span class="line">            <span class="comment">// 判断当前 metrics 是否已经在数据库中有了</span></span><br><span class="line">            Metrics cachedMetrics = context.get(metrics);</span><br><span class="line">            <span class="keyword">if</span> (cachedMetrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * If the metrics is not supportUpdate, defined through MetricsExtension#supportUpdate,</span></span><br><span class="line"><span class="comment">                    * then no merge and further process happens.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                <span class="comment">// service_traffic 就是不允许更新的，只允许插入，也就是说</span></span><br><span class="line">                <span class="comment">// 某个应用只有接入过 skywalking，并写入了 service_traffic</span></span><br><span class="line">                <span class="comment">// 那么永远都会有该应用的列表，即便后面卸载了 skywalking</span></span><br><span class="line">                <span class="keyword">if</span> (!supportUpdate) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Merge metrics into cachedMetrics, change only happens inside cachedMetrics.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                <span class="comment">// 将数据库中的 metrics 信息和当前实时获取的 metrics 信息做聚合</span></span><br><span class="line">                cachedMetrics.combine(metrics);</span><br><span class="line">                cachedMetrics.calculate();</span><br><span class="line">                <span class="comment">// instance_traffic 表更新客户端实例信息</span></span><br><span class="line">                prepareRequests.add(metricsDAO.prepareBatchUpdate(model, cachedMetrics));</span><br><span class="line">                nextWorker(cachedMetrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// service_traffic 写入es</span></span><br><span class="line">                metrics.calculate();</span><br><span class="line">                prepareRequests.add(metricsDAO.prepareBatchInsert(model, metrics));</span><br><span class="line">                nextWorker(metrics);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * The `metrics` should be not changed in all above process. Exporter is an async process.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            nextExportWorker.ifPresent(exportEvenWorker -&gt; exportEvenWorker.in(</span><br><span class="line">                <span class="keyword">new</span> ExportEvent(metrics, ExportEvent.EventType.INCREMENT)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(t.getMessage(), t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        metricsList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，oap 就将 <code>service_traffic</code>(metrics 的一种)，获取并存入了库。</p><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>从上面分析可看出，<code>service_traffic</code> 是不大合理的，有以下几点：</p><ol><li>只有插入，没有更新和删除</li><li>只有在客户端 segment 上报时，该信息才会上报。</li></ol><p>因此对该不合理的地方做了二开，一是利用 <code>service_traffic</code> 的 time_bucket 字段，实现更新和删除。二是在客户端注册的地方，触发 <code>service_traffic</code> 的流式处理，而不是在 segment 上报的时候。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;p&gt;此文源于在二开 SkyWalking 时，发现公司搭建的 SkyWalking 当前服务列表有时候会显示不出来已经接入的应用，在排查和解决过程中的总结。&lt;br&gt;&lt;img src=&quot;https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/90ECDCD7-2CE1-4FBD-B7F0-E9979FD42F0B_1_105_c.jpeg&quot; alt=&quot;和亲戚孩子拼的机器人&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="apm" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/apm/"/>
    
    
      <category term="skywalking" scheme="https://blog.liwenguang.com/tags/skywalking/"/>
    
  </entry>
  
  <entry>
    <title>《干法》阅读总结</title>
    <link href="https://blog.liwenguang.com/2021/06/01/readbook/996.html/"/>
    <id>https://blog.liwenguang.com/2021/06/01/readbook/996.html/</id>
    <published>2021-06-01T19:30:00.000Z</published>
    <updated>2021-06-01T19:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/9854420.jpg" alt="背景"></p><a id="more"></a><ol><li>工作是为了：提升心志，磨炼人性。</li><li>工作要注重自省，大智若愚。</li><li>工作要带有明确目标。并不断的更新和树立自己的目标。</li><li>持续的力量。</li><li>一旦奢侈，就会傲慢。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/9854420.jpg&quot; alt=&quot;背景&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="https://blog.liwenguang.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
      <category term="干法" scheme="https://blog.liwenguang.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/%E5%B9%B2%E6%B3%95/"/>
    
    
      <category term="自我管理" scheme="https://blog.liwenguang.com/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>skywalking-profile原理</title>
    <link href="https://blog.liwenguang.com/2021/05/29/tech/apm/skywalking_1_profile.html/"/>
    <id>https://blog.liwenguang.com/2021/05/29/tech/apm/skywalking_1_profile.html/</id>
    <published>2021-05-29T15:52:00.000Z</published>
    <updated>2021-05-29T15:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>此文源于在二开 SkyWalking 时，发现公司搭建的 SkyWalking 性能剖析不能生效，在排查过程中学到了很多，因此记录下来方便对 SkyWalking 的性能剖析功能有更深的理解。</p><a id="more"></a><h1 id="1-最开始的地方：后台创建性能剖析任务"><a href="#1-最开始的地方：后台创建性能剖析任务" class="headerlink" title="1. 最开始的地方：后台创建性能剖析任务"></a>1. 最开始的地方：后台创建性能剖析任务</h1><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210529161727.png" alt="创建性能剖析任务"></p><h2 id="1-1-后台接收-profile-任务创建请求"><a href="#1-1-后台接收-profile-任务创建请求" class="headerlink" title="1.1 后台接收 profile 任务创建请求"></a>1.1 后台接收 profile 任务创建请求</h2><p>当创建任务时，oap 服务会通过内嵌的 org.apache.skywalking.oap.server.library.server.jetty.JettyJsonHandler.doPost 处理。而 GraphQLQueryHandler 是实际处理类，因为 GraphQLQueryHandler 继承自 JettyJsonHandler 类。</p><p>这是 org.apache.skywalking.oap.query.graphql.GraphQLQueryHandler#execute 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 oap 的 http post 请求</span></span><br><span class="line"><span class="comment">     * 以性能剖析任务创建为例，这是 graphql 的定义：server-query-plugin/query-graphql-plugin/resources/query-protocol/profile.graphqls</span></span><br><span class="line"><span class="comment">     * 而真正执行的 java 代码为：org.apache.skywalking.oap.query.graphql.resolver.ProfileMutation#createProfileTask()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request    oap 的后台查询语法有两个参数，一个是 query，包含要执行的类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> variables  还有一个是 variables 参数，包含要执行的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JsonObject <span class="title">execute</span><span class="params">(String request, Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutionInput executionInput = ExecutionInput.newExecutionInput()</span><br><span class="line">                                                          .query(request)</span><br><span class="line">                                                          .variables(variables)</span><br><span class="line">                                                          .build();</span><br><span class="line">            <span class="comment">// 通过 graphQL 语法找到真正执行的类方法，性能剖析的创建处理类为：ProfileMutation#createProfileTask()</span></span><br><span class="line">            ExecutionResult executionResult = graphQL.execute(executionInput);</span><br><span class="line">            LOGGER.debug(<span class="string">"Execution result is &#123;&#125;"</span>, executionResult);</span><br><span class="line">            Object data = executionResult.getData();</span><br><span class="line">            List&lt;GraphQLError&gt; errors = executionResult.getErrors();</span><br><span class="line">            JsonObject jsonObject = <span class="keyword">new</span> JsonObject();</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jsonObject.add(DATA, gson.fromJson(gson.toJson(data), JsonObject.class));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(errors)) &#123;</span><br><span class="line">                JsonArray errorArray = <span class="keyword">new</span> JsonArray();</span><br><span class="line">                errors.forEach(error -&gt; &#123;</span><br><span class="line">                    JsonObject errorJson = <span class="keyword">new</span> JsonObject();</span><br><span class="line">                    errorJson.addProperty(MESSAGE, error.getMessage());</span><br><span class="line">                    errorArray.add(errorJson);</span><br><span class="line">                &#125;);</span><br><span class="line">                jsonObject.add(ERRORS, errorArray);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> jsonObject;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-从-graphqls-定位到具体的执行类"><a href="#1-2-从-graphqls-定位到具体的执行类" class="headerlink" title="1.2 从 graphqls 定位到具体的执行类"></a>1.2 从 graphqls 定位到具体的执行类</h2><p>我们看下 http 的入参：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: <span class="string">"mutation createProfileTask($creationRequest: ProfileTaskCreationRequest) &#123;\n  createTask: createProfileTask(creationRequest: $creationRequest) &#123;\n    id\n    errorReason\n  &#125;\n  &#125;"</span>,</span><br><span class="line">    <span class="attr">"variables"</span>: &#123;</span><br><span class="line">        <span class="attr">"creationRequest"</span>: &#123;</span><br><span class="line">            <span class="attr">"serviceId"</span>: <span class="string">"ZHViYm8tZXhhbXBsZS1jb25zdW1lcg==.1"</span>,</span><br><span class="line">            <span class="attr">"endpointName"</span>: <span class="string">"/api/users"</span>,</span><br><span class="line">            <span class="attr">"startTime"</span>: <span class="number">1622276464546</span>,</span><br><span class="line">            <span class="attr">"duration"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"minDurationThreshold"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"dumpPeriod"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">"maxSamplingCount"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到了要执行的类方法以及参数。<br>接着看</p><p>server-query-plugin/query-graphql-plugin/resources/query-protocol/profile.graphqls 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">extend type Mutation &#123;</span><br><span class="line">    # crate new profile task</span><br><span class="line">    createProfileTask(creationRequest: ProfileTaskCreationRequest): ProfileTaskCreationResult!</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后定位到 ProfileMutation 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * profile mutation GraphQL resolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileMutation</span> <span class="keyword">implements</span> <span class="title">GraphQLMutationResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProfileTaskCreationResult <span class="title">createProfileTask</span><span class="params">(ProfileTaskCreationRequest creationRequest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProfileTaskService().createTask(creationRequest.getServiceId(), creationRequest.getEndpointName() == <span class="keyword">null</span> ? <span class="keyword">null</span> : creationRequest</span><br><span class="line">            .getEndpointName()</span><br><span class="line">            .trim(), creationRequest.getStartTime() == <span class="keyword">null</span> ? -<span class="number">1</span> : creationRequest.getStartTime(), creationRequest.getDuration(), creationRequest</span><br><span class="line">            .getMinDurationThreshold(), creationRequest.getDumpPeriod(), creationRequest.getMaxSamplingCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-profile-task-任务存储"><a href="#1-3-profile-task-任务存储" class="headerlink" title="1.3 profile task 任务存储"></a>1.3 profile task 任务存储</h2><p>最终会将任务存储到 DB 中，以 ES7 存储为例：</p><p>存储的数据结构 ProfileTaskRecord：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ScopeDeclaration</span>(id = PROFILE_TASK, name = <span class="string">"ProfileTask"</span>)</span><br><span class="line"><span class="meta">@Stream</span>(name = ProfileTaskRecord.INDEX_NAME, scopeId = PROFILE_TASK, builder = ProfileTaskRecord.Builder.class, processor = NoneStreamProcessor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileTaskRecord</span> <span class="keyword">extends</span> <span class="title">NoneStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_NAME = <span class="string">"profile_task"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_ID = <span class="string">"service_id"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENDPOINT_NAME = <span class="string">"endpoint_name"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String START_TIME = <span class="string">"start_time"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION = <span class="string">"duration"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MIN_DURATION_THRESHOLD = <span class="string">"min_duration_threshold"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUMP_PERIOD = <span class="string">"dump_period"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_TIME = <span class="string">"create_time"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAX_SAMPLING_COUNT = <span class="string">"max_sampling_count"</span>;</span><br></pre></td></tr></table></figure><p>在 ES 的数据：</p><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210529171849.png" alt="ES中的profile数据"></p><h1 id="2-client-将-profile-数据传输给-oap"><a href="#2-client-将-profile-数据传输给-oap" class="headerlink" title="2. client 将 profile 数据传输给 oap"></a>2. client 将 profile 数据传输给 oap</h1><p>当 oap 服务端创建了 profile task 后，需要让客户端感知，并将对应的 endpoint 的堆栈数据发送给 oap 服务端，以供分析。</p><h2 id="2-1-client-请求-oap-创建的-profile-task"><a href="#2-1-client-请求-oap-创建的-profile-task" class="headerlink" title="2.1 client 请求 oap 创建的 profile task"></a>2.1 client 请求 oap 创建的 profile task</h2><p>agent client 通过 org.apache.skywalking.apm.agent.core.profile.ProfileTaskChannelService 中的定时任务来定时获取后端中的 profile task 列表，如下是 boot 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sender = ServiceManager.INSTANCE.findService(ProfileSnapshotSender.class);</span><br><span class="line">    <span class="comment">// 客户端开启 profile 的开关</span></span><br><span class="line">    <span class="keyword">if</span> (Config.Profile.ACTIVE) &#123;</span><br><span class="line">        <span class="comment">// query task list，定时从 oap 获取要分析的 endpoint 列表</span></span><br><span class="line">        getTaskListFuture = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">            <span class="keyword">new</span> DefaultNamedThreadFactory(<span class="string">"ProfileGetTaskService"</span>)</span><br><span class="line">        ).scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> RunnableWithExceptionProtection(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                t -&gt; LOGGER.error(<span class="string">"Query profile task list failure."</span>, t)</span><br><span class="line">            ), <span class="number">0</span>, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 将客户端收集的分析堆栈信息传输给 oap</span></span><br><span class="line">        sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">            <span class="keyword">new</span> DefaultNamedThreadFactory(<span class="string">"ProfileSendSnapshotService"</span>)</span><br><span class="line">        ).scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> RunnableWithExceptionProtection(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    List&lt;TracingThreadSnapshot&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);</span><br><span class="line">                    snapshotQueue.drainTo(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.isEmpty()) &#123;</span><br><span class="line">                        sender.send(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                t -&gt; LOGGER.error(<span class="string">"Profile segment snapshot upload failure."</span>, t)</span><br><span class="line">            ), <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 oap 服务端获取 profile task 列表的执行逻辑 ProfileTaskChannelService.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == GRPCChannelStatus.CONNECTED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sniffer info</span></span><br><span class="line">            builder.setService(Config.Agent.SERVICE_NAME).setServiceInstance(Config.Agent.INSTANCE_NAME);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// last command create time</span></span><br><span class="line">            builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class)</span><br><span class="line">                                                                .getLastCommandCreateTime());</span><br><span class="line">            <span class="comment">// 主动跟 oap 通信，通过 grpc 查询当前应用需要开启的 profile task 列表</span></span><br><span class="line">            Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">                                                        .getProfileTaskCommands(builder.build());</span><br><span class="line">            <span class="comment">// 获取到任务列表后客户端处理该命令逻辑</span></span><br><span class="line">            ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> StatusRuntimeException)) &#123;</span><br><span class="line">                LOGGER.error(t, <span class="string">"Query profile task from backend fail."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;</span><br><span class="line">            <span class="keyword">if</span> (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">"Backend doesn't support profiling, profiling will be disabled"</span>);</span><br><span class="line">                <span class="keyword">if</span> (getTaskListFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    getTaskListFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// stop snapshot sender</span></span><br><span class="line">                <span class="keyword">if</span> (sendSnapshotFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sendSnapshotFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-oap-响应-client-获取-profile-task-列表的请求"><a href="#2-2-oap-响应-client-获取-profile-task-列表的请求" class="headerlink" title="2.2 oap 响应 client 获取 profile task 列表的请求"></a>2.2 oap 响应 client 获取 profile task 列表的请求</h2><p>而 oap 是在 server-receiver-plugin/skywalking-profile-receiver-plugin 处理客户端的 ProfileTaskCommandQuery 请求，ProfileTaskServiceHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProfileTaskCommands</span><span class="params">(ProfileTaskCommandQuery request, StreamObserver&lt;Commands&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// query profile task list by service id</span></span><br><span class="line">    <span class="keyword">final</span> String serviceId = IDManager.ServiceID.buildId(request.getService(), NodeType.Normal);</span><br><span class="line">    <span class="keyword">final</span> String serviceInstanceId = IDManager.ServiceInstanceID.buildId(serviceId, request.getServiceInstance());</span><br><span class="line">    <span class="comment">// 从缓存中获取该服务的 profile task 列表，该缓存每隔 10s 从存储中更新 profile task</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ProfileTask&gt; profileTaskList = profileTaskCache.getProfileTaskList(serviceId);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(profileTaskList)) &#123;</span><br><span class="line">        responseObserver.onNext(Commands.newBuilder().build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build command list</span></span><br><span class="line">    <span class="keyword">final</span> Commands.Builder commandsBuilder = Commands.newBuilder();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lastCommandTime = request.getLastCommandTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProfileTask profileTask : profileTaskList) &#123;</span><br><span class="line">        <span class="comment">// if command create time less than last command time, means sniffer already have task</span></span><br><span class="line">        <span class="keyword">if</span> (profileTask.getCreateTime() &lt;= lastCommandTime) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// record profile task log</span></span><br><span class="line">        recordProfileTaskLog(profileTask, serviceInstanceId, ProfileTaskLogOperationType.NOTIFIED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add command</span></span><br><span class="line">        commandsBuilder.addCommands(commandService.newProfileTaskCommand(profileTask).serialize().build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseObserver.onNext(commandsBuilder.build());</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-client-开启-profile-task-的相关定时任务"><a href="#2-3-client-开启-profile-task-的相关定时任务" class="headerlink" title="2.3 client 开启 profile task 的相关定时任务"></a>2.3 client 开启 profile task 的相关定时任务</h2><p>此时 client 主动向 oap 请求获取 profile task 列表，当 client 获取到后，需要进步做处理，ProfileTaskCommandExecutor.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(BaseCommand command)</span> <span class="keyword">throws</span> CommandExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProfileTaskCommand profileTaskCommand = (ProfileTaskCommand) command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build profile task</span></span><br><span class="line">    <span class="keyword">final</span> ProfileTask profileTask = <span class="keyword">new</span> ProfileTask();</span><br><span class="line">    profileTask.setTaskId(profileTaskCommand.getTaskId());</span><br><span class="line">    profileTask.setFirstSpanOPName(profileTaskCommand.getEndpointName());</span><br><span class="line">    profileTask.setDuration(profileTaskCommand.getDuration());</span><br><span class="line">    profileTask.setMinDurationThreshold(profileTaskCommand.getMinDurationThreshold());</span><br><span class="line">    profileTask.setThreadDumpPeriod(profileTaskCommand.getDumpPeriod());</span><br><span class="line">    profileTask.setMaxSamplingCount(profileTaskCommand.getMaxSamplingCount());</span><br><span class="line">    profileTask.setStartTime(profileTaskCommand.getStartTime());</span><br><span class="line">    profileTask.setCreateTime(profileTaskCommand.getCreateTime());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send to executor</span></span><br><span class="line">    <span class="comment">// 将该任务列表塞入一个 list 中，该 list</span></span><br><span class="line">    ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).addProfileTask(profileTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端获取到 profile task 后，需要知道什么时候启动，和什么时候停止，ProfileTaskExecutionService.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add profile task from OAP</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProfileTask</span><span class="params">(ProfileTask task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// update last command create time</span></span><br><span class="line">    <span class="keyword">if</span> (task.getCreateTime() &gt; lastCommandCreateTime) &#123;</span><br><span class="line">        lastCommandCreateTime = task.getCreateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check profile task limit</span></span><br><span class="line">    <span class="keyword">final</span> CheckResult dataError = checkProfileTaskSuccess(task);</span><br><span class="line">    <span class="keyword">if</span> (!dataError.isSuccess()) &#123;</span><br><span class="line">        LOGGER.warn(</span><br><span class="line">            <span class="string">"check command error, cannot process this profile task. reason: &#123;&#125;"</span>, dataError.getErrorReason());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add task to list</span></span><br><span class="line">    profileTaskList.add(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedule to start task，计算出该任务还需要多久才能启动，通过定时任务实现</span></span><br><span class="line">    <span class="keyword">long</span> timeToProcessMills = task.getStartTime() - System.currentTimeMillis();</span><br><span class="line">    PROFILE_TASK_SCHEDULE.schedule(() -&gt; processProfileTask(task), timeToProcessMills, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * active the selected profile task to execution task, and start a removal task for it.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">processProfileTask</span><span class="params">(ProfileTask task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make sure prev profile task already stopped</span></span><br><span class="line">    stopCurrentProfileTask(taskExecutionContext.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make stop task schedule and task context，通过上下文保存该 profile task，该上下文也实际在 trace 记录时塞入堆栈信息</span></span><br><span class="line">    <span class="keyword">final</span> ProfileTaskExecutionContext currentStartedTaskContext = <span class="keyword">new</span> ProfileTaskExecutionContext(task);</span><br><span class="line">    taskExecutionContext.set(currentStartedTaskContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start profiling this task，开启 profileing 定时任务，抓取堆栈信息</span></span><br><span class="line">    currentStartedTaskContext.startProfiling(PROFILE_EXECUTOR);</span><br><span class="line">    <span class="comment">// 计算出该 profile task 的停止时间，通过定时任务停止该 profile task</span></span><br><span class="line">    PROFILE_TASK_SCHEDULE.schedule(</span><br><span class="line">        () -&gt; stopCurrentProfileTask(currentStartedTaskContext), task.getDuration(), TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 client 已经开启了 profile task，并通过 oap 的参数，控制了开启时间和持续时间（停止时间）的定时任务，同时也开启了子线程 profile_executor，用于真正的抓取执行中的堆栈信息。也就是 client 开启了三个定时任务，一个用于 profile 的开启，一个用于 profile 的关闭，一个是用于 profile 真正抓取堆栈信息。</p><h1 id="3-client-与-oap-的-profileSnapshot-信息"><a href="#3-client-与-oap-的-profileSnapshot-信息" class="headerlink" title="3 client 与 oap 的 profileSnapshot 信息"></a>3 client 与 oap 的 profileSnapshot 信息</h1><h2 id="3-1-client-profileSnapshot-的生成"><a href="#3-1-client-profileSnapshot-的生成" class="headerlink" title="3.1 client profileSnapshot 的生成"></a>3.1 client profileSnapshot 的生成</h2><p>在 ProfileTaskExecutionService.processProfileTask 方法中会开启 ProfileThread 任务，profileThread 定时任务会抓取堆栈信息并塞入队列。 ProfileThread.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        profiling(taskExecutionContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ignore interrupted</span></span><br><span class="line">        <span class="comment">// means current task has stopped</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e, <span class="string">"Profiling task fail. taskId:&#123;&#125;"</span>, taskExecutionContext.getTask().getTaskId());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// finally stop current profiling task, tell execution service task has stop</span></span><br><span class="line">        profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * start profiling</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">profiling</span><span class="params">(ProfileTaskExecutionContext executionContext)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run loop when current thread still running</span></span><br><span class="line">    <span class="keyword">long</span> currentLoopStartTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        currentLoopStartTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// each all slot</span></span><br><span class="line">        AtomicReferenceArray&lt;ThreadProfiler&gt; profilers = executionContext.threadProfilerSlots();</span><br><span class="line">        <span class="keyword">int</span> profilerCount = profilers.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> slot = <span class="number">0</span>; slot &lt; profilerCount; slot++) &#123;</span><br><span class="line">            ThreadProfiler currentProfiler = profilers.get(slot);</span><br><span class="line">            <span class="keyword">if</span> (currentProfiler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (currentProfiler.profilingStatus().get()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="comment">// check tracing context running time</span></span><br><span class="line">                    currentProfiler.startProfilingIfNeed();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> PROFILING:</span><br><span class="line">                    <span class="comment">// dump stack</span></span><br><span class="line">                    TracingThreadSnapshot snapshot = currentProfiler.buildSnapshot();</span><br><span class="line">                    <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将获取的堆栈信息快照文件，存入 snapshotQueue 队列中，而 ProfileTaskChannelService 中的 ProfileSendSnapshotService</span></span><br><span class="line">                        <span class="comment">// 定时任务会定期将 snapshotQueue 队列通过 ProfileSnapshotSender 任务发送给 oap</span></span><br><span class="line">                        profileTaskChannelService.addProfilingSnapshot(snapshot);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// tell execution context current tracing thread dump failed, stop it</span></span><br><span class="line">                        executionContext.stopTracingProfile(currentProfiler.tracingContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep to next period</span></span><br><span class="line">        <span class="comment">// if out of period, sleep one period</span></span><br><span class="line">        <span class="keyword">long</span> needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();</span><br><span class="line">        needToSleep = needToSleep &gt; <span class="number">0</span> ? needToSleep : maxSleepPeriod;</span><br><span class="line">        Thread.sleep(needToSleep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 profileSnapshot 信息由 client 发送给 oap，有两种方式，当前默认为 grpc 方式：ProfileSnapshotSender.java，也可以用 kafka 方式发送：KafkaProfileSnapshotSender.java</p><h2 id="3-1-oap-获取-client-传输的-profileSnapshot-信息"><a href="#3-1-oap-获取-client-传输的-profileSnapshot-信息" class="headerlink" title="3.1 oap 获取 client 传输的 profileSnapshot 信息"></a>3.1 oap 获取 client 传输的 profileSnapshot 信息</h2><p>grpc 方式获取也是通过 skywalking-profile-receiver-plugin 模块处理，该模块不仅负责 client 获取 profile task，也负责 profileSnapshot 的 grpc 通信，ProfileTaskServiceHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 前文说过，oap 处理 client 获取 profile task 列表的请求处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProfileTaskCommands</span><span class="params">(ProfileTaskCommandQuery request, StreamObserver&lt;Commands&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * oap 接收来自 client 的 profileSnapshot 信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> responseObserver</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamObserver&lt;ThreadSnapshot&gt; <span class="title">collectSnapshot</span><span class="params">(StreamObserver&lt;Commands&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;ThreadSnapshot&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ThreadSnapshot snapshot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">"receive profile segment snapshot"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// build database data</span></span><br><span class="line">            <span class="keyword">final</span> ProfileThreadSnapshotRecord record = <span class="keyword">new</span> ProfileThreadSnapshotRecord();</span><br><span class="line">            record.setTaskId(snapshot.getTaskId());</span><br><span class="line">            record.setSegmentId(snapshot.getTraceSegmentId());</span><br><span class="line">            record.setDumpTime(snapshot.getTime());</span><br><span class="line">            record.setSequence(snapshot.getSequence());</span><br><span class="line">            record.setStackBinary(snapshot.getStack().toByteArray());</span><br><span class="line">            record.setTimeBucket(TimeBucket.getRecordTimeBucket(snapshot.getTime()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// async storage</span></span><br><span class="line">            RecordStreamProcessor.getInstance().in(record);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            LOGGER.error(throwable.getMessage(), throwable);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            responseObserver.onNext(Commands.newBuilder().build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kafka 的 oap 接收profileSnapshot 也是类似处理，只不过换成了从 topic 中获取数据而已。</p><h1 id="4-profileSnapshot-生成与分析"><a href="#4-profileSnapshot-生成与分析" class="headerlink" title="4. profileSnapshot 生成与分析"></a>4. profileSnapshot 生成与分析</h1><h2 id="4-1-client-生成-profileSnapshot"><a href="#4-1-client-生成-profileSnapshot" class="headerlink" title="4.1 client 生成 profileSnapshot"></a>4.1 client 生成 profileSnapshot</h2><p>在每次创建 TracingContext 的时候，也会初始化 profile 当前的堆栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize all fields with default value.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">TracingContext(String firstOPName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.segment = <span class="keyword">new</span> TraceSegment();</span><br><span class="line">    <span class="keyword">this</span>.spanIdGenerator = <span class="number">0</span>;</span><br><span class="line">    isRunningInAsyncMode = <span class="keyword">false</span>;</span><br><span class="line">    createTime = System.currentTimeMillis();</span><br><span class="line">    running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// profiling status</span></span><br><span class="line">    <span class="keyword">if</span> (PROFILE_TASK_EXECUTION_SERVICE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        PROFILE_TASK_EXECUTION_SERVICE = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要 profile，同时尝试初始化当前 segment 的 thread 信息</span></span><br><span class="line">    <span class="keyword">this</span>.profileStatus = PROFILE_TASK_EXECUTION_SERVICE.addProfiling(</span><br><span class="line">        <span class="keyword">this</span>, segment.getTraceSegmentId(), firstOPName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.correlationContext = <span class="keyword">new</span> CorrelationContext();</span><br><span class="line">    <span class="keyword">this</span>.extensionContext = <span class="keyword">new</span> ExtensionContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addProfiling 方法最终会走到 ProfileTaskExecutionContext.attemptProfiling 方法，该方法会将当前线程堆栈信息存储 volatile 变量：profilingSegmentSlots 中，该变量会在 ProfileThread.profiling 方法中通过 executionContext.threadProfilerSlots(); 方式死循环取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * check have available slot to profile and add it</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> is add profile success</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProfileStatusReference <span class="title">attemptProfiling</span><span class="params">(TracingContext tracingContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String traceSegmentId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String firstSpanOPName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check has available slot</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> usingSlotCount = currentProfilingCount.get();</span><br><span class="line">    <span class="keyword">if</span> (usingSlotCount &gt;= Config.Profile.MAX_PARALLEL) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check first operation name matches</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(task.getFirstSpanOPName(), firstSpanOPName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if out limit started profiling count then stop add profiling</span></span><br><span class="line">    <span class="keyword">if</span> (totalStartedProfilingCount.get() &gt; task.getMaxSamplingCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to occupy slot</span></span><br><span class="line">    <span class="keyword">if</span> (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程 Thread.currentThread() 赋值给 ThreadProfiler 的 profilingThread 参数</span></span><br><span class="line">    <span class="comment">// 同时将 threadProfiler 存入 profilingSegmentSlots 中，profilingSegmentSlots 会被 profileThread 取出</span></span><br><span class="line">    <span class="keyword">final</span> ThreadProfiler threadProfiler = <span class="keyword">new</span> ThreadProfiler(</span><br><span class="line">        tracingContext, traceSegmentId, Thread.currentThread(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int</span> slotLength = profilingSegmentSlots.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> slot = <span class="number">0</span>; slot &lt; slotLength; slot++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (profilingSegmentSlots.compareAndSet(slot, <span class="keyword">null</span>, threadProfiler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> threadProfiler.profilingStatus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如当前只有一个 http 请求：</p><ol><li>在 before method 前将该请求堆栈信息初始化并发送给 oap，该信息包含该 traceId 以及 beginTime。</li><li>该请求执行完后，在 after method 后，会将该 trace 发送给 oap。</li><li>oap 后台查询到 profile 的 trace 后，点击执行按钮，会从存储中获取该请求堆栈信息，并通过 traceId 反查到 trace 链路，并通过 beginTime 和 trace 的 time，得到该堆栈的执行时间。注意：后台点击执行时才会主动分析堆栈的执行和相关信息。</li></ol><h2 id="4-2-oap-执行分析堆栈信息"><a href="#4-2-oap-执行分析堆栈信息" class="headerlink" title="4.2 oap 执行分析堆栈信息"></a>4.2 oap 执行分析堆栈信息</h2><p>oap 请求执行堆栈分析参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: <span class="string">"query getProfileAnalyze($segmentId: String!, $timeRanges: [ProfileAnalyzeTimeRange!]!) &#123;\\n  getProfileAnalyze: getProfileAnalyze(segmentId: $segmentId, timeRanges: $timeRanges) &#123;\\n    tip\\n    trees &#123;\\n      elements &#123;\\n        id\\n        parentId\\n        codeSignature\\n        duration\\n        durationChildExcluded\\n        count\\n      &#125;\\n    &#125;\\n  &#125;\\n  &#125;"</span>,</span><br><span class="line">    <span class="attr">"variables"</span>: &#123;</span><br><span class="line">        <span class="attr">"segmentId"</span>: <span class="string">"f26ef21ccee943d1806c12cf54948c00.57.16225422981970000"</span>,</span><br><span class="line">        <span class="attr">"timeRanges"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"start"</span>: <span class="number">1622542298197</span>,</span><br><span class="line">                <span class="attr">"end"</span>: <span class="number">1622542301399</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到 org.apache.skywalking.oap.server.core.profile.analyze.ProfileAnalyzer#analyze() 执行的分析：从 es 取出从 client 获取的 ProfileSnapshot 堆栈信息，映射的实体类为：ProfileThreadSnapshotRecord</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;p&gt;此文源于在二开 SkyWalking 时，发现公司搭建的 SkyWalking 性能剖析不能生效，在排查过程中学到了很多，因此记录下来方便对 SkyWalking 的性能剖析功能有更深的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="apm" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/apm/"/>
    
    
      <category term="skywalking" scheme="https://blog.liwenguang.com/tags/skywalking/"/>
    
  </entry>
  
  <entry>
    <title>2021/21周总结</title>
    <link href="https://blog.liwenguang.com/2021/05/25/2021/21.html/"/>
    <id>https://blog.liwenguang.com/2021/05/25/2021/21.html/</id>
    <published>2021-05-25T16:10:00.000Z</published>
    <updated>2021-05-25T16:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>没有学习的一周</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/p2642871021.webp" alt="御赐小仵作"></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>近一个月没有周总结，用了语雀半年，但是打开太卡了。失去了纪录笔记的初衷，现在重归 vscode 编写文本。源码文本与渲染分离的模式，还是 hexo + github 这种方式更加适合我。</li><li>周六回武汉，侄子过周岁，正好母亲也趁这个时间一起回来碰面。</li><li>一直以工作为主，因为工作上涉及的技术和知识收货很多，比纯看书感触更深。可能这就是工作中的经验吧。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>重启博客计划，回归周计划节奏，将这半年在语雀的笔记迁移至老博客</li><li>滴答清单 + 自有博客搭配</li><li>学车！</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>自己还是喜欢简单的东西，就像 vscode，编写即可，语雀真的卡，我受不了了。</li><li>工作上需要自己自我安排！马上这个季度也快结束了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;没有学习的一周&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2021总结" scheme="https://blog.liwenguang.com/tags/2021%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo泛化调用导致 zookeeper临时节点暴增的BUG</title>
    <link href="https://blog.liwenguang.com/2021/05/14/tech/dubbo/$invoke_zknode_problem.html/"/>
    <id>https://blog.liwenguang.com/2021/05/14/tech/dubbo/$invoke_zknode_problem.html/</id>
    <published>2021-05-14T19:30:00.000Z</published>
    <updated>2021-05-14T19:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>dubbo 2.7.5，最近发现 zk 的 node 越来越多，监控报警半夜给我打电话。后来排查发现是业务方使用泛化调用不规范！<br>但是排查过程学习到了很多。</p><a id="more"></a><h1 id="1-监控"><a href="#1-监控" class="headerlink" title="1. 监控"></a>1. 监控</h1><p>线上 zk 监控主要是监控 zk 的 node 数量，以及机器 cpu memory，报警主要是 zk 的 node 数量报警，到了阈值。</p><h1 id="2-排查"><a href="#2-排查" class="headerlink" title="2. 排查"></a>2. 排查</h1><p>先查看在报警前后的 zk snapshot 文件有什么变化，将 zk 快照文件转译为文本：<br>java -cp ../../zookeeper-3.4.8.jar:../../lib/slf4j-api-1.6.1.jar org.apache.zookeeper.server.SnapshotFormatter snapshot.b0008ebdd &gt; 05141102.txt<br>这样你就得到了两份 snapshot，一份是报警前一段时间，正常的快照 node，一份是报警后的快照 node。</p><h1 id="3-Dubbo-节点规则"><a href="#3-Dubbo-节点规则" class="headerlink" title="3. Dubbo 节点规则"></a>3. Dubbo 节点规则</h1><p>/dubbo/{com.xx.Service}/consumers/consumer%3A%2F%2F{ip.ip.ip.ip}%2Forg.apache.dubbo.rpc.service.GenericService%3Fapplication%3D{app-name}%26category%3Dconsumers%26check%3Dfalse%26dubbo%3D2.0.2%26generic%3Dtrue%26interface%3D{com.xx.Service}%26lazy%3Dfalse%26loadbalance%3Drandom%26pid%3D26879%26release%3D2.7.3.5-ext%26side%3Dconsumer%26sticky%3Dfalse%26timestamp%3D1620959181596<br>/dubbo/服务提供者接口/consumers/泛化接口?timestamp=<br>通过搜索 zk 报警之后的快照文件发现有接近3000个泛化调用统一接口<br>接口查看该 node 的 ephemeralOwner，定位到该业务服务，同时查看线上该业务服务的发布记录，发现该业务服务的线上发布时间和故障报警时间重合：当该服务重启发布的时候，报警消失，猜测应该是因为机器重启，临时泛化节点都下掉。后来定位代码，发现泛化调用后没有显示的调用 .destory() 销毁泛化调用的 node！</p><h1 id="4-解决"><a href="#4-解决" class="headerlink" title="4. 解决"></a>4. 解决</h1><ol><li>泛化调用后，finally 块代码加入 reference.destory() 方法。</li><li>通过内存缓存 GenericService genericService = reference.get() 获得的 GenericService 类。</li><li>不用泛化调用，直接调用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;p&gt;dubbo 2.7.5，最近发现 zk 的 node 越来越多，监控报警半夜给我打电话。后来排查发现是业务方使用泛化调用不规范！&lt;br&gt;但是排查过程学习到了很多。&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="dubbo" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://blog.liwenguang.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>《重来3：跳出疯狂的忙碌》阅读总结</title>
    <link href="https://blog.liwenguang.com/2021/03/17/readbook/crazyAtWork.html/"/>
    <id>https://blog.liwenguang.com/2021/03/17/readbook/crazyAtWork.html/</id>
    <published>2021-03-17T19:25:00.000Z</published>
    <updated>2021-03-17T19:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/s33699293.jpg" alt></p><a id="more"></a><ol><li>时间被各种碎片切割，导致实际工作效率不高<blockquote><p>安排专门的每天或每周答疑时间范围，统一解决</p></blockquote></li><li>公司作为产品，员工作为用户：员工知道公司哪里最快，哪里最慢，哪里的漏洞可以快速修复。但是需要有好的反馈渠道反馈。</li><li>完成比完美好，定好截止日，中间的任务只会根据时间来减少而不会增加，以在截止时间内完成，之后慢慢细节优化</li><li>每个人有发言权，但是决定权只有一个人，其他人需要配置：我不同意你，但是我需要配合你</li><li>组织的领导者不能向员工乱抛想法。<blockquote><p>“分清建议和命令”</p></blockquote></li><li>人之间的信任像电池。打交道时是充电还是耗电。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/s33699293.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="https://blog.liwenguang.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
      <category term="重来3：跳出疯狂的忙碌" scheme="https://blog.liwenguang.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/%E9%87%8D%E6%9D%A53%EF%BC%9A%E8%B7%B3%E5%87%BA%E7%96%AF%E7%8B%82%E7%9A%84%E5%BF%99%E7%A2%8C/"/>
    
    
      <category term="自我管理" scheme="https://blog.liwenguang.com/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2021/01周总结</title>
    <link href="https://blog.liwenguang.com/2021/01/12/2021/01.html/"/>
    <id>https://blog.liwenguang.com/2021/01/12/2021/01.html/</id>
    <published>2021-01-12T10:58:00.000Z</published>
    <updated>2021-01-12T10:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>坐在同事的小电驴经过公司，这就是我的跨年夜。</li></ol><a id="more"></a><p><img src="hhttps://cdn.nlark.com/yuque/0/2021/png/203689/1610419946633-c04489fd-d66d-461e-94ee-f8a64673ddf4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_bGl3ZW5ndWFuZw%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1038" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>《消息队列高手课》看到18/41</li><li>工作进度正常，最后的迁库迁表分库分表+数据迁移+shardingjdbc</li><li>过年元旦和同事玩游戏！</li><li>本来说元旦去公司学习，但是就光顾着玩游戏了。。。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>《消息队列高手课》完结</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>感觉一周多个计划到最后什么都没完成，以后一周就一个计划吧，多了也完不成，拖一个月没什么意义，工作中也是进步总觉的一部分。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;坐在同事的小电驴经过公司，这就是我的跨年夜。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2021总结" scheme="https://blog.liwenguang.com/tags/2021%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020 总结（以后就用语雀了）</title>
    <link href="https://blog.liwenguang.com/2021/01/04/2020/index.html/"/>
    <id>https://blog.liwenguang.com/2021/01/04/2020/index.html/</id>
    <published>2021-01-04T21:40:00.000Z</published>
    <updated>2021-01-04T21:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是2020总结</p><a id="more"></a><h1 id="1-时间线"><a href="#1-时间线" class="headerlink" title="1. 时间线"></a>1. 时间线</h1><p>过年~2020.03.30：在湖北老家隔离远程办公<br>2020.05~2020.06: 看 netty 相关的书籍<br>2020.06.24~2020.06.27: 去青岛<br>2020.08~2020.2020.10: 看视频学习架构方面的知识、看基础相关的书<br>2020.10.01~2020.10.09: 回汉口<br>2020.11~2020.12: Seata、Sentinel 学习</p><p>时间线总结是从我每天的记录总结出来的，中间还有很多小事没记录，大事件都记录下来了，学习上主学 netty、seata、sentinel，其实还有 skywalking 和 rocketmq，不过没实战过以及深入过，就不写下来了。年初的大疫情让我颓废了许久，我自制力是真的差~</p><h1 id="2-生活线"><a href="#2-生活线" class="headerlink" title="2. 生活线"></a>2. 生活线</h1><p>生活上没有什么大的变化，一直在杭州的这家公司，在杭州也生活了快两年了，这里还有以前的同学，有时候还会约出来一起吃饭什么的。和同事关系也相处的挺好，周末一起愉快的扯淡和学习。</p><h1 id="3-工作线"><a href="#3-工作线" class="headerlink" title="3. 工作线"></a>3. 工作线</h1><p>工作上，在公司支付组干了一年半，年末转到中间件，期间工作表现也算正常，按照公司的层次来说，应该算中上吧，不突出，也不差，但是也没那么好，毕竟干久了，各个系统服务组件都比较熟悉，工作上也游刃有余，没什么大的挑战，因此主动换组新的挑战。</p><h1 id="4-2019-flag"><a href="#4-2019-flag" class="headerlink" title="4. 2019 flag"></a>4. 2019 flag</h1><p>现在翻回去，发现 2019 的总结竟然是空的。。。空的，当时可能因为拖延症没写，我一直以为我写了 2019 的总结！现在我才发现当时我没写，只写了大纲，没有内容，当时真的是懒死了。现在回看起17年和18年的总结，真是尴尬的要命，不过还是保留吧，记录过去。</p><h1 id="5-完结"><a href="#5-完结" class="headerlink" title="5. 完结"></a>5. 完结</h1><p>文章以后就用语雀了，本文是 2020 收官文，语雀编辑更加方便点，主要是觉得这个博客内容没啥有营养的，都是没啥价值的文章，以后要输出有价值的文章，涅槃重生！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是2020总结&lt;/p&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="年度总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020/52周总结</title>
    <link href="https://blog.liwenguang.com/2020/12/29/2020/52.html/"/>
    <id>https://blog.liwenguang.com/2020/12/29/2020/52.html/</id>
    <published>2020-12-29T02:04:00.000Z</published>
    <updated>2020-12-29T02:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>周末去找了韩笑，好好玩了一个周末。</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20201229021348.png" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>并发翻译的 33 章终于翻译完咯。</li><li>《消息队列高手课》看到12/41</li><li>工作进度正常，最后的迁库迁表分库分表，难啃我也啃下来。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>《消息队列高手课》完结，因为本周放三天，预计三天在公司看。</li><li>博客迁移老文章就就不做迁移了，自己当时水平菜，没眼看~</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>这是2020年的倒数第二周总结。<br>暴走大事件又回来了~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;周末去找了韩笑，好好玩了一个周末。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020/51周总结</title>
    <link href="https://blog.liwenguang.com/2020/12/24/2020/51.html/"/>
    <id>https://blog.liwenguang.com/2020/12/24/2020/51.html/</id>
    <published>2020-12-24T01:04:00.000Z</published>
    <updated>2020-12-24T01:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>本来不想写这周总结的，但是大晚上睡不着，不写又难受，但是今天都周四（凌晨）了，感觉写上周总结又显得太迟。。最后还是忍不住写了~</li><li>上周颓废的一周，DOTA2 永雾林渊版本更新，忍不住玩了亿把，太好玩了，哈哈~~</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20201224012139.png" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>并发翻译终于最后快翻译完了，还剩最后一章。</li><li>个人知识库使用语雀梳理，感觉我需要将 hexo 的博文都迁移到新的语雀平台，到时候一个平台方便，也不用语雀+hexo发布了。</li><li>消息队列高手课基础课上完。</li><li>工作我有好好做，元旦就转去中间件组了，以后可能会更忙了。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>周末去青岛</li><li>博客迁移</li><li>零零碎碎的文章梳理</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>游戏真好玩。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本来不想写这周总结的，但是大晚上睡不着，不写又难受，但是今天都周四（凌晨）了，感觉写上周总结又显得太迟。。最后还是忍不住写了~&lt;/li&gt;
&lt;li&gt;上周颓废的一周，DOTA2 永雾林渊版本更新，忍不住玩了亿把，太好玩了，哈哈~~&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法与Hash分表键的坑</title>
    <link href="https://blog.liwenguang.com/2020/12/20/tech/mysql/snowflake&amp;hash.html/"/>
    <id>https://blog.liwenguang.com/2020/12/20/tech/mysql/snowflake&amp;hash.html/</id>
    <published>2020-12-20T01:56:00.000Z</published>
    <updated>2020-12-20T01:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/share.jpg" alt></p><a id="more"></a><h1 id="1-雪花算法的位数原理"><a href="#1-雪花算法的位数原理" class="headerlink" title="1 雪花算法的位数原理"></a>1 雪花算法的位数原理</h1><p>雪花算法在 Java 中默认使用 Long，它是 64 位，各个位的含义如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609150636502-3a9e2cf2-2046-4158-9970-8181b6224850.png#align=left&amp;display=inline&amp;height=72&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=72&amp;originWidth=1438&amp;size=0&amp;status=done&amp;style=none&amp;width=1438" alt></p><p>第一位组：0 写死，表示只会生成正数<br>第二位组：41位，存储的时间戳单位位毫秒，实际存储量位：2^41/1000<em>60</em>60<em>24</em>365 = 69，即时间戳最多支持 69 年，一般都是使用 <code>System.currentTimeMillis() - initDate</code> 差值来实现<br>第三位组：10 位，机器数，用于分布式环境下每个机器生成的值都会不一样，默认支持 2^10 = 1024 个节点生成的值不同<br>第四位组：12 位，每节点每毫秒并发数，默认为 2^12 = 4096</p><p>实际业务场景中，会根据线上的业务场景改动某些位数。而且由于雪花是全局递增，因此动态改动也是可以，不过会出现 id 的明显断层。</p><h1 id="2-Hash-分表原理"><a href="#2-Hash-分表原理" class="headerlink" title="2 Hash 分表原理"></a>2 Hash 分表原理</h1><p>在 MySQL 数据量突增的场景，一般都会根据业务特性来使用横切或纵切达到提高性能的目的。这里只讨论横切，也就是是水平分表。大部分都会使用 Hash 分表，也就是简单的 Hash 取模，而分表都是按 2 的次方分，例如如果按 1024 分表，是如何计算的。</p><p>假设目前有1~1024个列，主键从 1~1024递增，那么按 1024 分表的话，每列都会分在独立的一张表，以分表列值分别为 1，2，3，按 1024 分表的计算过程如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &amp; (1024 - 1) = 1</span><br><span class="line">2 &amp; (1024 - 1) = 2</span><br><span class="line">3 &amp; (1024 - 1) = 3</span><br></pre></td></tr></table></figure></p><p>二进制操作的图例如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609173791431-d522379a-5cb1-48f4-b726-64bcac71211d.png#align=left&amp;display=inline&amp;height=376&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=376&amp;originWidth=2616&amp;size=0&amp;status=done&amp;style=none&amp;width=2616" alt></p><p>这里都是分配均匀，三个列均匀的分配到了 3 个表，但是我们可以根据二进制规律得知，如果有一批数，这一批数其后 10 位都是一样的，那么根据 1024 分表就会出现只分在一个表的情况，例如我现在有三个列，其分表键值分别为 1025，2049，3073，如果按 1024 分表的话，这三列就会都分在第一个表，导致数据倾斜，计算过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609174481106-173a914b-265f-4717-a2d1-605cbf7335d3.png#align=left&amp;display=inline&amp;height=400&amp;margin=%5Bobject%20Object%5D&amp;originHeight=400&amp;originWidth=2854&amp;size=0&amp;status=done&amp;style=none&amp;width=2854" alt></p><p>这样我们就知道了根据 hash 分表数据倾斜的数值特征：后 N 位相同的位数越多，数据倾斜的概率越大，具体后几位，根据你分表数来决定，例如例子中是按 2^10 分表，那么 N 则为 10。接着我们看下雪花算法的位数特性，看看会不会有数据倾斜问题</p><h1 id="3-雪花算法的位数特性"><a href="#3-雪花算法的位数特性" class="headerlink" title="3 雪花算法的位数特性"></a>3 雪花算法的位数特性</h1><p>雪花算法后 12 位为“每节点每毫秒并发数”，在线上有 100 个节点运行，而你的 QPS 为 100000，均匀的打到了每台机器，即每台机器的 QPS 为 1000，这样，你的“每节点每毫秒并发数”为 1000/1000 = 1，这样生成的 100000 个雪花算法的后 12 位全都是一样都是 0，此时如果你对雪花算法做 hash，就会出现这 100000 个数据全部在第 1 个表中，造成了严重的数据倾斜问题，只有当分表数大于 2^13 = 8192 时，才会好点，如果你按 2^13 数量分表，则因为后 12 位都是 0，此时会计算到第三组中 10 位的机器数，但是此时你也只能分成两个表，因为只计算了 1 位，如下图示例，表示的就是两个节点，在“每节点每毫秒并发数”为 1 时，按 8192 的分表的过程：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609175735724-2e24b0e8-20ad-4201-b9c8-a11585ce09b6.png#align=left&amp;display=inline&amp;height=498&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=498&amp;originWidth=2408&amp;size=0&amp;status=done&amp;style=none&amp;width=2408" alt></p><p>“每节点每毫秒并发数”为1，即“每节点每秒并发数”为 1000 以下就会出现严重的数据倾斜问题，但是每节点 1000 的 QPS 已经很高，如果此时我们需要用雪花算法生成的值来做分表键，有什么方法呢？有两种：</p><ol><li>改进雪花算法位数特性</li><li>改进 hash 分表算法</li></ol><h1 id="4-雪花算法位数的改进"><a href="#4-雪花算法位数的改进" class="headerlink" title="4 雪花算法位数的改进"></a>4 雪花算法位数的改进</h1><p>既然我们知道按 2次幂的 hash 主要是看低位，那么我只要保证雪花算法生成的值低位不同即可，如果线上机器够多，例如线上有 128 台机器，这时候我们按 128 分表，我们就可以将雪花算法的第三组和第四组调换，这样生成的最后 10 位是机器节点，肯定是不一样的，从而达到了平衡。但是这样要求节点数据量大于分表数。还有一个更好的方法，那就是将第二组的时间戳与第四组调换，这样就算你线上只有一个节点，但是生成的最后 10 位的时间戳也达到了散列的效果。</p><h1 id="5-hash-算法的改进"><a href="#5-hash-算法的改进" class="headerlink" title="5 hash 算法的改进"></a>5 hash 算法的改进</h1><p>这里就涉及到 hash 的“扰乱”，即，hash 不再是简单的取余，而是增加了对原始值的“打散”，减少出现在同一个组的可能，这里参考 HashMap 的 hash 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tableSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SnowflakeIdWorker idWorker = <span class="keyword">new</span> SnowflakeIdWorker(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> id1 = idWorker.nextId();</span><br><span class="line">    System.out.println(<span class="string">"原始雪花算法值id1:"</span> + id1);</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> id2 = idWorker.nextId();</span><br><span class="line">    System.out.println(<span class="string">"原始雪花算法值id2:"</span> + id2);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"table1Index:"</span> + hash(id1) + <span class="string">"\n"</span> + <span class="string">"table2Index:"</span> + hash(id2));</span><br><span class="line">    System.out.println(<span class="string">"table1Index:"</span> + hashC(id1) + <span class="string">"\n"</span> + <span class="string">"table2Index:"</span> + hashC(id2));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * output:</span></span><br><span class="line"><span class="comment">         * 原始雪花算法值id1:793292040770158592</span></span><br><span class="line"><span class="comment">         * 原始雪花算法值id2:793292040774352896</span></span><br><span class="line"><span class="comment">         * ------------------------</span></span><br><span class="line"><span class="comment">         * table1Index:0</span></span><br><span class="line"><span class="comment">         * table2Index:0</span></span><br><span class="line"><span class="comment">         * 扰乱后的雪花算法值:793299744572601664</span></span><br><span class="line"><span class="comment">         * 扰乱后的雪花算法值:793299744568407424</span></span><br><span class="line"><span class="comment">         * table1Index:320</span></span><br><span class="line"><span class="comment">         * table2Index:384</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hash</span> <span class="params">(<span class="keyword">long</span> snowflakeId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> snowflakeId % tableSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hashC</span> <span class="params">(<span class="keyword">long</span> snowflakeId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c = (snowflakeId ^ (snowflakeId &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">    System.out.println(<span class="string">"扰乱后的雪花算法值:"</span> + c);</span><br><span class="line">    <span class="keyword">return</span> c % tableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到通过原生直接简单 hash 取余都是 0，但是通过扰乱后的再取余就不一样了，达到了“扰乱散列”的效果。</p><p>还有一种 hash 改进的方式针对这种最后几位一样，但是前几位不一样的特征值，我们丢弃掉后几位，也就是直接右移几位，这里我们可以将默认的雪花算法右移 12 位，从而直接根据机器节点来取模，或者粗暴的右移 22 位，根据时间戳在取余，效果更好。在雪花算法场景下，这种方式比“扰乱散列”方式更好。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>这是我在分库分表时，踩下的坑，当时某个业务有个列是雪花算法生成的，因为业务都是它来查值，因此我在分表的时候把它设为分表键，前期数据量比较少，没关注，后面量在 900G 的时候，发现 0000 表占了 500G。然后就开始重新建表，重新分库，开始数据平滑迁移到新表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/share.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="mysql" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/mysql/"/>
    
    
      <category term="分布式" scheme="https://blog.liwenguang.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="唯一ID生成算法" scheme="https://blog.liwenguang.com/tags/%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2020/50周总结</title>
    <link href="https://blog.liwenguang.com/2020/12/15/2020/50.html/"/>
    <id>https://blog.liwenguang.com/2020/12/15/2020/50.html/</id>
    <published>2020-12-15T00:33:00.000Z</published>
    <updated>2020-12-15T00:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>梳理个人知识库中，感觉自己掌握的东西很杂，没有个好的目录和学习总结。</li><li>2020年最后一个月，工作最后加把劲！奥利给。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-12-15%E4%B8%80%E7%A7%92%E9%92%9F.jpg" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>Seata PR merged后，给公司的分享，感觉分享完又精进了不少。</li><li>Seata 系列博文也快完了，目前到第九章了。</li><li>并发翻译终于到进行到了第25章了。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>工作好好干！！！</li><li>Seata这周整理完</li><li>并发的翻译到30周</li><li>个人知识库梳理</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>快要到2021了，赶紧完成之前的flag，到时候做个好的年终总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;梳理个人知识库中，感觉自己掌握的东西很杂，没有个好的目录和学习总结。&lt;/li&gt;
&lt;li&gt;2020年最后一个月，工作最后加把劲！奥利给。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020/49周总结</title>
    <link href="https://blog.liwenguang.com/2020/12/08/2020/49.html/"/>
    <id>https://blog.liwenguang.com/2020/12/08/2020/49.html/</id>
    <published>2020-12-08T23:33:00.000Z</published>
    <updated>2020-12-08T23:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>一周的时间比较颓废，不知道咋回事，就心态自然奔溃了，不过还好就持续了一周，但是比之前好就是，虽然比较颓废，但是周六还是仍然和同事在公司研究东西。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-12-08%E5%A4%A7%E7%A7%A6%E5%B8%9D%E5%9B%BD-%E8%A3%82%E5%8F%98.jpg" alt></p><h1 id="1-上两周总结"><a href="#1-上两周总结" class="headerlink" title="1. 上两周总结"></a>1. 上两周总结</h1><ol><li>主要是整理 Seata 博文系列以及准备要分享的 Seata 文档。</li><li>玩电脑游戏玩疯了，不过一周过后就戒了，犯病了。</li><li>书也没看完，也没坚持学习，一直持续的坚持真的难。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>完成工作，因为工作上这是Q4最后一个月，工作上要收收尾准备好年终奖冲刺。</li><li>Seata这周要整理整理完！</li><li>并发的翻译这周末继续！</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>犯病比之前好点了，持续了一周，同时也不落下学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;一周的时间比较颓废，不知道咋回事，就心态自然奔溃了，不过还好就持续了一周，但是比之前好就是，虽然比较颓废，但是周六还是仍然和同事在公司研究东西。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>引用回收问题</title>
    <link href="https://blog.liwenguang.com/2020/11/25/tech/reference_gc.html/"/>
    <id>https://blog.liwenguang.com/2020/11/25/tech/reference_gc.html/</id>
    <published>2020-11-25T01:51:00.000Z</published>
    <updated>2020-11-25T01:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用回收问题"><a href="#引用回收问题" class="headerlink" title="引用回收问题"></a>引用回收问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文由：<a href="https://github.com/Snailclimb/JavaGuide/issues/975" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/975</a> 讨论延伸而来。<br>主要回顾了对栈帧引用局部变量回收问题、FinalizableDelegatedExecutorService 导致的 jdk p4 bug。<br>最后总结了正确的编码风格。</p><a id="more"></a><h2 id="引用基础"><a href="#引用基础" class="headerlink" title="引用基础"></a>引用基础</h2><p>强软弱虚 +FinalReference 参见：</p><ol><li><a href="https://club.perfma.com/article/125010" target="_blank" rel="noopener">https://club.perfma.com/article/125010</a></li><li><a href="https://www.infoq.cn/article/jvm-source-code-analysis-finalreference" target="_blank" rel="noopener">https://www.infoq.cn/article/jvm-source-code-analysis-finalreference</a></li></ol><p>因为我自己对引用，尤其是 referenceQueue 以及 FinalReference 理解不够透彻，怕写的有问题，并且本文也和引用区别的关系不是很大，就直接贴出我看的博文了，讲解的很细致。</p><h2 id="强引用也会被回收"><a href="#强引用也会被回收" class="headerlink" title="强引用也会被回收"></a>强引用也会被回收</h2><p>本小节理论参考自：<a href="https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope" target="_blank" rel="noopener">https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope</a></p><p>你看的没错，我们传统理解的强引用也会被回收。如下示例代码，可能有点复杂，但是它是为了证明在某种情况下，回收对象和是什么引用无关。其中 Entry 是继承自 WeakReference，而其中使用了 <code>super(k)</code>，表明我们将第一个入参作为弱引用传入，<code>value</code> 则不作任何表示，是一个普通变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// baseWeak();</span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car(<span class="number">22000</span>, <span class="string">"sliver"</span>);</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Entry entry = <span class="keyword">new</span> Entry(car, object);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"Object is alive for "</span> + i + <span class="string">" loops - "</span> + entry);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Object is alive for 61441 loops - Entry@490d6c15</span></span><br><span class="line">                <span class="comment">// null,java.lang.Object@7d4793a8</span></span><br><span class="line">                <span class="comment">// Object has been collected.</span></span><br><span class="line">                System.out.println(entry.get() + <span class="string">","</span> + entry.getValue());</span><br><span class="line">                System.out.println(<span class="string">"Object has been collected."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String colour;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, String colour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.colour = colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColour</span><span class="params">(String colour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colour = colour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value associated with this ThreadLocal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(Car k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中大概在 6W 次循环后，<code>car</code> 引用被回收。注意 <code>car</code> 它本身有强引用在局部变量中的： <code>Car car = new Car()</code>，我开始觉得因为它被弱引用了，于是接下来改动 <code>Entry</code>，将 <code>v</code> 入参作为弱引用（记得改泛型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry(Car k, Object v) &#123;</span><br><span class="line">    <span class="keyword">super</span>(v);</span><br><span class="line">    value = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在循环 6W 次左右后仍然出现了和弱引用一样的情况。说明这个回收对强弱引用都执行相同的逻辑。为什么这里的强引用也会回收，这里已经有了解释：<a href="https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope。" target="_blank" rel="noopener">https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope。</a></p><p>我理解为什么强引用会被回收，是因为 JIT 的优化。为什么我们说局部变量（本例中的 <code>car</code> 变量）是强引用，因为它被栈帧引用了，而栈帧是 GCRoots 之一。而这 <code>car</code> 被回收的前提是 GCRoot 不可达，但是栈帧还没被销毁怎么会不可达呢，因为 JIT 在这里会做优化操作：Java 编译器或代码生成器可以选择将不再使用的变量或参数设置为 NULL，以使此类对象的存储可能更快地可回收。</p><blockquote><p>a Java compiler or code generator may choose to set a variable or parameter that will no longer be used to <code>null</code> to cause the storage for such an object to be potentially reclaimable sooner</p><p>来源：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1。后面简称" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1。后面简称</a> jls-12.6.1</p></blockquote><p>在此示例代码中，car 被 JIT 优化设置为 null（当然，它在循环了 6W 次才“学会了”优化）。</p><h2 id="为什么扯到-ThreadLocal"><a href="#为什么扯到-ThreadLocal" class="headerlink" title="为什么扯到 ThreadLocal"></a>为什么扯到 ThreadLocal</h2><p>因为这篇文章是因 <code>ThreadLocal</code> 而起，我们都知道 <code>ThreadLocal</code> 内部使用 <code>ThreadLocalMap</code> + <code>Entry</code> 实现，而 <code>Entry</code> 继承自 <code>WeakReference</code>，而 <code>ThreadLocalMap</code> 将其 <code>value</code> 设置为了弱引用，也就是我们业务设置的值，而 <code>ThreadLocalMap</code> 的 <code>key</code> 则为 <code>ThreadLocal</code> 本身的实例。</p><p>因此这里会产生一个答案，这个答案的问题是：为什么我们建议 ThreadLocal 实例时作为 static，而不是作为一个局部变量。这个问题的答案是：因为局部变量 <code>ThreadLocal</code> 如果操作不当可能会被回收！而 <code>ThreadLocal</code> 风险很高，因为它除了栈帧在业务上很少会有其它引用（当然，你可以在后面使用它的实例方法）。</p><h2 id="还有什么情况会被奇怪的回收"><a href="#还有什么情况会被奇怪的回收" class="headerlink" title="还有什么情况会被奇怪的回收"></a>还有什么情况会被奇怪的回收</h2><p>前面我们通过 <em>jls-12.6.1</em> 知道，编译器可以选择将不再使用的变量设为 null，但是该文档前面还有一句：</p><p>一个可到达对象是可以从任何活动线程在任何潜在的持续计算中访问的任何对象。</p><blockquote><p>A <em>reachable</em> object is any object that can be accessed in any potential continuing computation from any live thread.</p></blockquote><p>关键点在于“任何活动线程”，那如果某个线程被错误的识别出不活跃，那里面的强引用会被回收吗？但是下面其实和活动线程关系不大，倒是和前面的强引用回收问题有关系。</p><h2 id="SingleThreadExecutor-的-GC-回收问题"><a href="#SingleThreadExecutor-的-GC-回收问题" class="headerlink" title="SingleThreadExecutor 的 GC 回收问题"></a>SingleThreadExecutor 的 GC 回收问题</h2><p>本小节中文参考自：<a href="https://segmentfault.com/a/1190000021109130。其中错误代码如下：" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021109130。其中错误代码如下：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadPoolTest threadPoolTest = <span class="keyword">new</span> ThreadPoolTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        Future&lt;String&gt; future = threadPoolTest.submit();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = future.get();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//子线程不停gc，模拟偶发的gc</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.gc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步执行任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关键点，通过Executors.newSingleThreadExecutor创建一个单线程的线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> System.currentTimeMillis() + <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(futureTask);</span><br><span class="line">        <span class="comment">// 如果放开下面的注释就不会有问题，因为 executorService 被检测到是可达对象所以不会被回收进而产生bug</span></span><br><span class="line">        <span class="comment">// System.out.println(executorService.toString());</span></span><br><span class="line">        <span class="keyword">return</span> futureTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文评论道出了真相，描述和 <a href="https://stackoverflow.com/questions/58714980/rejectedexecutionexception-inside-single-executor-service" target="_blank" rel="noopener">stackoverflow</a> 的高赞回答类似：</p><blockquote><p>executeService 已经是 unreachable，被 gc 是正常的。不觉得是什么 bug，代码本身编写的问题。返回的是 FutureTask, 就是对 FutureTask 的引用，抛出的异常是在你提交任务后，还没有执行完的情况下 ExecuteService 被 gc 了，同时被 shutdown（笔者注：executorService.execute(futureTask); 这行代码并不表示 executorService 被 futureTask 引用，也就是说这行代码对于 executorService 的引用关系是没有任何改变的）</p></blockquote><p>这里参见：<a href="https://bugs.openjdk.java.net/browse/JDK-8145304" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8145304</a> 这个 BUG 一直是 OPEN 状态，里面的示例代码非常简单是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Executors.newSingleThreadExecutor().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">"StartUp-1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>PS：这种代码竟然有 bug，虽然 bug 等级是 P4。</p><p>核心在于 newSingleThreadExecutor 返回的是包装类 FinalizableDelegatedExecutorService，该类重写了 <code>finalize()</code> 方法，在回收时调用 <code>shutdown()</code>，但是 JIT 在优化时，对局部引用对象 executorService 也可能会回收（不活跃线程），导致的 JDK bug。</p><p>如何避免这种问题呢？我们可以将该 executeService 设置为静态变量！或者保证在代码方法块中对 executeService 仍然有访问。但是设为静态变量是最为方便直接的方案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>局部变量虽然被栈帧（GCRoot 之一）引用，但它会被 JIT 优化从而被回收</li><li>Executors.newSingleThreadExecutor 有 bug，其 bug 等级是 P4</li><li>JIT 优化会触发意想不到的问题</li><li>静态变量的设计有很多考究的（不要过度用）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引用回收问题&quot;&gt;&lt;a href=&quot;#引用回收问题&quot; class=&quot;headerlink&quot; title=&quot;引用回收问题&quot;&gt;&lt;/a&gt;引用回收问题&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本文由：&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide/issues/975&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Snailclimb/JavaGuide/issues/975&lt;/a&gt; 讨论延伸而来。&lt;br&gt;主要回顾了对栈帧引用局部变量回收问题、FinalizableDelegatedExecutorService 导致的 jdk p4 bug。&lt;br&gt;最后总结了正确的编码风格。&lt;/p&gt;
    
    </summary>
    
      <category term="技术总结" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
      <category term="java拾遗" scheme="https://blog.liwenguang.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/java%E6%8B%BE%E9%81%97/"/>
    
    
      <category term="jdk bug" scheme="https://blog.liwenguang.com/tags/jdk-bug/"/>
    
  </entry>
  
  <entry>
    <title>2020/47周总结</title>
    <link href="https://blog.liwenguang.com/2020/11/23/2020/47.html/"/>
    <id>https://blog.liwenguang.com/2020/11/23/2020/47.html/</id>
    <published>2020-11-23T20:50:00.000Z</published>
    <updated>2020-11-23T20:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>计划的并发文章翻译到第17章完成，等全部翻译完，再自己校验下，再统一上传。</li><li>幂等业务的博文总结更新了，因为后面因为实际场景的需要后来又优化了一版，总结已更新。</li><li>计划的 threadlocal 弱依赖总结博文没写完，这周补上。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-11-23%E9%A3%9E%E5%A4%A9%E5%A4%A7%E7%9B%97.jpg" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>3个计划，完成2个，完成度66%，能接受~</li><li>周日的时候和同学玩游戏玩疯啦，不知道是为啥，估计是犯病了，压抑久了会不自觉的想释放。</li><li>计划的看一本书计划又凉了，这本《七周七并发模型》是看不完了，囧。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>33章的翻译要翻译到25章。</li><li>threadlocal 弱引用的释放博文总结完成。</li><li>看完《hustle》第一季。</li><li>这周不能玩dota2。</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>用滴答清单重新规划了本周本月计划，感觉更加能激励自己干活了。不干完总心里难受。不过自己懒的总会不想干完。真鸡儿难受。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;计划的并发文章翻译到第17章完成，等全部翻译完，再自己校验下，再统一上传。&lt;/li&gt;
&lt;li&gt;幂等业务的博文总结更新了，因为后面因为实际场景的需要后来又优化了一版，总结已更新。&lt;/li&gt;
&lt;li&gt;计划的 threadlocal 弱依赖总结博文没写完，这周补上。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020/46周总结</title>
    <link href="https://blog.liwenguang.com/2020/11/16/2020/46.html/"/>
    <id>https://blog.liwenguang.com/2020/11/16/2020/46.html/</id>
    <published>2020-11-16T00:12:00.000Z</published>
    <updated>2020-11-16T00:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>本周总体还好，但是周末的时候在公司学习的时候有点难专注。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-11-16%E9%A3%8E%E5%B9%B3%E6%B5%AA%E9%9D%99.jpg" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>《七周七并发模型》书没看完，但是开始翻译并发系列的书了，一共33章，目前翻译到第8章，计划是一个月翻译完。</li><li>计划是本个月就把并发系列给从根上弄清楚。</li><li>新买的iphone12mini到了，感觉挺不错，但是又感觉没什么，到时候先下几个软件，但是发现也就那样，可能已经过了对新设备的期望年纪吧。</li><li>本来说好半个月就读书总结，感觉有点夸张，顺延为1个月一个读书总结。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>33章的翻译要翻译到17章，也就是完成一半。</li><li>threadlocal 弱引用的释放博文总结，因为已经现有素材，直接编写即可，来源于issue上的讨论。</li><li>上周的幂等博文需要更新，因为后面业务调整使用了更加合理的方案实现。</li><li>看完《硅谷第六季》</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>滴答清单被我弱化了，我需要番茄工作法的压力，不然工作一会就容易分心。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本周总体还好，但是周末的时候在公司学习的时候有点难专注。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2020/45周总结</title>
    <link href="https://blog.liwenguang.com/2020/11/09/2020/45.html/"/>
    <id>https://blog.liwenguang.com/2020/11/09/2020/45.html/</id>
    <published>2020-11-09T23:54:00.000Z</published>
    <updated>2020-11-09T23:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>第45周又是个小颓废的一周，不过比上周好点。</li></ol><a id="more"></a><p>![][0]</p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>总结了一篇关于幂等与业务的博文。</li><li>本来说要看两周看一本书来着，但是上周没看，这周得要看了，就看《七周七并发模型》吧，这本书是一直给贡献的JavaGuide作者送我自选买的几本书之一，一直在吃灰，这周得看完了。</li><li>果然人还是天性懒惰的，从我脸上的痘痘就知道了，我上周又半夜不睡觉乱想，大早上又起床困难~</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>《七周七并发模型》读完并有读书总结</li><li>一直说给公司内部分享Seata的，文章也写好了，但是感觉一直没给Seata做PR，不好意思分享，这周得需要有个PR，就算是文档也行！</li><li>希望能买个Iphone12，但是又离自己的攒钱计划越来越远了</li><li>继续使用滴答清单规范生活</li><li>继续健身，虽然说公司的健身房已经被很多杂物都占用了，但是没有健身的日子总感觉不够自律，可能健身有助于让自己更加自律？</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>会总不自觉想逛逛论坛，把控不住自己的手。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-背景&quot;&gt;&lt;a href=&quot;#0-背景&quot; class=&quot;headerlink&quot; title=&quot;0. 背景&quot;&gt;&lt;/a&gt;0. 背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;第45周又是个小颓废的一周，不过比上周好点。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="行为总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="周总结" scheme="https://blog.liwenguang.com/categories/%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020总结" scheme="https://blog.liwenguang.com/tags/2020%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
