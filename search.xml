<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[十二、随机数——不可预测性的源泉]]></title>
    <url>%2F2017%2F12%2F06%2Fgraphic2cryptography%2F12.html%2F</url>
    <content type="text"><![CDATA[1 骡子的锁匠铺很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。 2 本章概要 使用随机数的密码技术 随机数的性质 伪随机数生成器 具体的伪随机数生成器 对伪随机数生成器的攻击 3 使用随机数的密码技术3.1 随机数是干什么的 生成秘钥：用于对称密码和消息认证码。 生成密钥对：用于公钥密码和数字签名。 生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。 生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。 生成盐：用于基于口令的密码（PBE）等。 在这里，请大家记住为了不让攻击者看穿而使用随机数这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。 4 随机数的性质4.1 对随机数的性质分类 随机性：不存在统计学偏差，是完全杂乱的数列。 不可预测性：不能从过去的数列推测出下一个出现的数。 不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。 为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。 ||随机性|不可预测性|不可重现性|| |:-:|:-:|:-:|:-:|:-:| |弱伪随机数|✔️|✘|✘|只具备随机性| |强伪随机数|✔️|✔️|✘|具备不可预测性| |真随机数|✔️|✔️|✔️|具备不可重现性| 5 伪随机数生成器6 具体的伪随机数生成器7 对伪随机数生成器的攻击8 本章小结9 小测验]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[去中心化]]></title>
    <url>%2F2017%2F12%2F05%2Ftalker%2Fdecentralization_1.html%2F</url>
    <content type="text"><![CDATA[作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。 编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。 “去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。 但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图： 现在再来看看Quora上面有关“分布式和去中心化的区别”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的图解，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。 三种类型的去中心化当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是： 结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？ 政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？ 逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？ 我们可以把这三个维度用下面这张表来表示： 要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况： 传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。 民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。 语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。 BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。 区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。 很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的文章）。 结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。 逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。 去中心化的三个原因接下来的问题就是为什么去中心化会有用？这通常会有几种观点： 可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。 抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。 抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。 这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到原文了解进一步的讨论。 此文转载自：&lt;去中心化的三个维度_36氪&gt;]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[十四、SSL/TLS-为了更安全的通信]]></title>
    <url>%2F2017%2F12%2F04%2Fgraphic2cryptography%2F14.html%2F</url>
    <content type="text"><![CDATA[1 本章概要SSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。 2 什么是 SSL/TLS2.1 客户端与服务器将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：Alice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。 不过，如果直接发送请求的话，信用卡号就很可能被窃听。 2.2 用 SSL/TLS 承载 HTTP当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。 2.3 SSL/TLS 的工作进行安全的通信，我们有几个必须要解决的问题： Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。 Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。 确认通信对方的 Web 服务器是真正的 Bob 书店。 在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。要解决这些问题，让我们在密码学家的工具箱中找一找：要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。 2.4 SSL/TLS 也可以保护其它的协议刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。 2.5 密码套件SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为密码套件（cipher suite）。 2.6 SSL 与 TLS 的区别SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。 3 使用 SSL/TLS 进行通信下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。 3.1 层次化的协议TLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：下面简单介绍一下其中各个协议的功能 1.TLS记录协议TLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。TLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。 2.TLS握手协议TLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。 2-1 握手协议握手协议是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。 2-2 密码规格变更协议密码规格变更协议是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。这个协议所发送的消息，大致相当于下面的对话：客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”当协议中途发生错误时，就会通过下面的警告协议传达给对方。 2-3 警告协议警告协议是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。这个协议所发送的消息，大致相当于下面的对话：服务器：“刚才的消息无法正确解密哦！”如果没有发生错误，则会使用下面的应用数据协议来进行通信。 2-4 应用数据协议应用数据协议是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。 3.2 TLS记录协议TLS记录协议负责消息的压缩、加密以及数据的认证，其处理过程如下： 消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。 经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。 经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。 3.3 TLS握手协议1.握手协议握手协议是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。下面我们来详细讲解握手协议中所交换的消息。 2.密码规格变更协议TLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。 3.警告协议TLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。 4.应用数据协议应用数据协议是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。 3.4 主密码主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。 3.5 TLS 中使用的密码技术小结 4 对 SSL/TLS 的攻击4.1 对各个密码技术的攻击针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。 4.2 对伪随机数生成器的攻击只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。 4.3 利用证书的时间差进行攻击SSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。 5 SSL/TLS 用户的注意事项5.1 不要误解证书的含义在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。 5.2 密码通信之前的数据时不受保护的SSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。 5.3 密码通信之后的数据时不受保护的SSL/TLS 也无法保护通信之后的数据。因此信用卡号不会再通信过程中被第三方获取，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。 6 本章小结SSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。 7 小测验 使用 SSL/TLS 可以确保通信的机密性。 在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。 在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。 在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。 使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[十一、秘钥——秘密的精华]]></title>
    <url>%2F2017%2F11%2F23%2Fgraphic2cryptography%2F10.html%2F</url>
    <content type="text"><![CDATA[1 本章概要密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。 2 什么是秘钥2.1 秘钥就是一个巨大的数字在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为秘钥（key）的巨大数字。然后，数字本身的带下并不重要，重要的是秘钥空间的大小，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由秘钥长度决定的。 1.DES 的秘钥对称密码 DES 的秘钥的实质长度为 56 比特。例如，一个 DES 秘钥用二进制可以表示为：01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100用十六进制则可以表示为：51 EC 4B 12 3D 4A A1而用十进制则可以表示为：12309120398102938102983为了显得专业，将统一使用十六进制。 2.三重 DES 的秘钥在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。DES-EDE2 的秘钥实际长度为 112 比特。DES-EDE3 的秘钥实际长度为 168 比特。 3.AES 的秘钥对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。 实际长度会更长，因为会加一些用于识别通信错误的校验比特。 2.2 秘钥和明文是等价的对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，秘钥和明文是等价的。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。 2.3 密码算法与秘钥信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。 3 各种不同的秘钥3.1 对称密码的秘钥与公钥密码的秘钥在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。 3.2 消息认证码的秘钥与数字签名的秘钥在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。 3.3 用于确保机密性的秘钥与用于认证的秘钥对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。 相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。 3.4 会话秘钥与主秘钥刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为会话秘钥（session key）。虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为主秘钥（master key）。 3.5 用于加密内容的秘钥与用于加密秘钥的秘钥一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。 在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。 4 秘钥的管理4.1 生成秘钥1.用随机数生成秘钥2.用口令生成秘钥即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。 4.2 配送秘钥在第五章介绍，可以采用事先共享秘钥、使用秘钥分配中心、使用公钥密码等方法。一会将介绍Diffie-Hellman秘钥交换。 4.3 更新秘钥有一种提高通信机密性的技术被称为秘钥更新（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。 在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是用当前秘钥的散列值作为下一个秘钥。这种防止破译过去的通信内容的机制，称为后向安全（backward security）。 4.4 保存秘钥由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑保存秘钥的问题了。 1.人类无法记住秘钥首先我们必须要理解一个重要的事实，那就是人类是无法记住具有使用长度的秘钥的。 2.对秘钥进行加密的意义例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。 4.5 作废秘钥如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。 5 Diffie-Hellman秘钥交换5.1 什么是 Diffie-Hellman 秘钥交换使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。 虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。 5.2 Diffie-Hellman 秘钥交换的步骤 1.Alice 向 Bob 发送两个质数 P 和 GP 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为生成元。 G 可以是一个较小的数字。 P 和 G 不需要保密。 2.Alice 生成一个随机数 AA 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。 3.Bob 生成一个随机数 BB 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。 4.Alice 将 G^A mod P 这个数发送给 Bob这个数让 Eve 知道也没关系 5.Bob 将 G^B mod P 这个数发送给 Alice这个数让 Eve 知道也没关系 6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P这个数就是共享秘钥。 (G^B mod P)^A mod P 7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P这个数就是共享秘钥。 (G^A mod P)^B mod P 8.这样 Alice 和 Bob 得到的值就是相同的5.3 Eve 能计算出秘钥吗这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。 6 基于口令的密码（PBE）6.1 什么是基于口令的密码用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。 6.2 PBE 加密 6.3 PBE 解密 7 本章小结对秘钥本身做了简单介绍。 8 小测验 由于秘钥只是随机的比特序列，因此被别人知道了也没关系。 私钥是可以公开的。 在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[电影《一个叫欧维的男人决定去死》有感~]]></title>
    <url>%2F2017%2F11%2F23%2Ftalker%2F2.html%2F</url>
    <content type="text"><![CDATA[整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。 他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。 他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。 我以为应该是个美好结局。 “这才是人生”。 life is not easy. So is suicide. 《En Man Som Heter Ove》]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[十、证书——为公钥加上数字签名]]></title>
    <url>%2F2017%2F11%2F22%2Fgraphic2cryptography%2F10.html%2F</url>
    <content type="text"><![CDATA[1 本章概要第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。 我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。 2 证书2.1 什么是证书公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由认证机构（Certification Authority、Certifying Authority，CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书（certificate）。认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。 2.2 证书的应用场景 Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。 Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。 认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。 Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。 Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。 Alice 用 Bob 的公钥加密消息并发送给 Bob。 Bob 用自己的私钥解密密文得到 Alice 的消息。 3 证书标准规范 X.509 签名前的证书——签名对象的信息 数字签名算法——对证书签名时所使用的算法 数字签名——对证书施加的数字签名 4 公钥基础设施（PKI）4.1 什么是公钥基础设施公钥基础设施（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。 4.2 PKI 的组成要素 用户——使用 PKI 的人 认证机构——颁发证书的人 仓库——保存证书的数据 4.3 认证机构的工作 生成密钥对 注册证书 作废证书与 CRL（证书作废清单 Certificate Revocation List） 4.4 证书的层级结构证书颁发：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。 验证证书：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。如果连根CA都无法验证说明证书是存在问题的。 5. 对证书的攻击5.1 在公钥注册之前进行攻击5.2 注册相似人名进行攻击5.3 窃取认证机构的私钥进行攻击5.4 攻击者伪装成认证机构进行攻击5.5 钻 CRL 的空子进行攻击Mallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。 6. 关于证书的 Q&amp;A6.1 为什么需要证书疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。 6.2 通过自己的方法进行认证是不是更安全疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？回答：靠隐蔽式来保证安全是错误的！ 6.3 为什么要相信认证机构？？？ 7. 本章小结从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。 8. 小测验 证书是认证机构将用户的公钥加密后的产物 要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥 世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA 用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构 用户需要定期从认证机构获取 CRL]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[九、数字签名——消息到底是谁写的]]></title>
    <url>%2F2017%2F11%2F21%2Fgraphic2cryptography%2F9.html%2F</url>
    <content type="text"><![CDATA[1 羊妈妈的认证大灰狼把黑色的爪子伸进门缝，说道：“我是你们的妈妈，快快开门吧！”七只小羊回答道：“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。 2 本章概要数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。 3 数字签名3.1 Alice 的借条假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：“Bob，我向你借款 100 万元。”————Alice。显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。 3.2 从消息认证码到数字签名1. 消息认证码的局限性第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。 2. 通过数字签名解决问题假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。实际上，这种看似神奇的技术，早就已经问世了，这就是数字签名（digital signature）。 3.3 签名的生成和验证在数字签名技术中，出现了下面两种行为： 生成消息签名的行为 验证消息签名的行为 生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。 Alice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。这一点非常重要。此外，签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，数字签名就是通过将公钥密码“反过来用”而实现的。 3.4 公钥密码与数字签名 4 数字签名的方法我们来介绍两种生成和验证数字签名的方法： 直接对消息签名的方法 对消息的散列值签名的方法 后者虽然复杂，但实际中我们一般都使用这种方法。 4.1 直接对消息签名的方法发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。Alice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名签名的 Bob 则需要得到 Alice 公钥。过程如下： Alice 用自己的私钥对消息进行加密。 Alice 将消息和签名发送给 Bob。 Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。 Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。 4.2 对消息的散列值签名的方法与对消息签名的不同是，这里的消息变成了消息的散列值。流程参考上图。 5 对数字签名的疑问5.1 密文为什么能作为签名使用疑问：为什么密文能够具备签名的意义呢？解答：数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表只有持有该秘钥的人才能够生成的信息。这样的信息一般称为认证符号（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。 5.2 数字签名不能保证机密性吗疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。 5.3 这种签名可以随意复制吗疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？解答：签名重要的是，特定的签名者与特定的消息绑定在了一起这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。 5.4 消息内容会不不会任意修改疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？解答：数字签名所要实现的并不是防止修改，而是识别修改。修改没问题，但验证签名会失败。 5.5 删除签名也无法“作废合同”吗疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。 5.6 如何防止否认严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。 5.7 数字签名真的能够代替签名吗不能代替，而是共存。 6 数字签名的应用实例6.1 安全信息公告一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥可以排除有人恶意伪装成该组织来发布假消息的风险。 6.2 软件下载保证网络下载的软件是否被篡改过。 6.3 公钥证书在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是公钥证书，将在第十章详解。 6.4 SSL/TLSSSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。 7 通过 RSA 实现数字签名7.1 用 RSA 生成签名签名 = 消息 ^ D mod N这里所使用的 D 和 N 就是签名者的私钥。 7.2 用 RSA 验证签名由签名求得的消息 = 签名 ^ E mod N这里所使用的 E 和 N 就是签名者的公钥。 7.3 具体实践假设密钥对：公钥：E = 5; N = 323; 私钥：D = 29; N = 323; 1.生成签名消息^D mod N = 123^29 mod 323 = 157得到签名是 157，向接收者发送的内容为：(123，157)。 2.验证签名签名^E mod N = 157^5 mod 323 = 123得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。 8 其它的数字签名 EIGamal 方式：利用了在 mod N 中求离散对数的困难度。 DSA。 Rabin 方式：利用了在 mod N 中其平方根的困难度。 9 对数字签名的攻击9.1 中间人攻击9.2 对单向散列函数的攻击数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。 9.3 利用数字签名攻击公钥密码将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴） 10 各种密码技术的对比10.1 消息认证码与数字签名 对称密码 公钥密码 发送者 用共享秘钥加密 用公钥加密 接收者 用共享秘钥解密 用私钥解密 秘钥配送问题 存在 不存在，但公钥需要另外认证 机密性 ✔️ ✔️ 消息认证码 数字签名 发送者 用共享秘钥计算 MAC 值 用私钥生成签名 接收者 用共享秘钥计算 MAC 值 用公钥验证签名 秘钥配送问题 存在 不存在，但公钥需要另外认证 完整性 ✔️ ✔️ 认证 ✔️（仅限通信对象双方） ✔️（可适用于任何第三方） 防止否认 ✘ ✔️ 10.2 混合密码系统与散列值签名在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。即：对称密码的秘钥是机密性的精华，单向散列函数的散列值是完整性的精华。 11 数字签名无法解决的问题用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的公钥必须属于真正的发送者。现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。为了能够确认自己得到的公钥是否合法，我们需要使用证书。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。 但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即公钥基础设施（Public Key Intrastructure），简称 PKI，关于证书和 PKI 将在第十章详解。 12 本章小结本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。 13 小测验 要验证数字签名，需要使用签名者的私钥。 RSA 可以用作数字签名算法。 使用数字签名可以保护消息的机密性，不用担心被窃听。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[八、消息认证码]]></title>
    <url>%2F2017%2F11%2F19%2Fgraphic2cryptography%2F8.html%2F</url>
    <content type="text"><![CDATA[1 本章概要使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。 2 消息认证码2.1 汇款请求是正确的吗我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。 2.2 什么是消息认证码消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 MAC。消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。 后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：消息认证码是一种与秘钥相关联的单向散列函数。 2.3 消息认证码的使用步骤以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。 发送者 Alice 与接收者 Bob 事先共享秘钥。 发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。 发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。 接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥） 接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。 如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。 2.4 消息认证码的秘钥配送问题发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。 3 消息认证码的应用实例3.1 SWIFTSWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。 3.2 IPsecIPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。 3.3 SSL/TLSSSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。 4 消息认证码的实现方法4.1 使用单向散列函数实现使用 SHA-1、MD5 之类的单向散列函数可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。 4.2 使用分组密码实现使用 DES、AES 之类的分组密码可以实现消息认证码。将分组密码的秘钥作为消息认证码的共享秘钥来使用。 4.3 其它实现方法使用流密码和公钥密码等也可以实现消息认证码。 5 HMAC 的详细介绍5.1 什么是 HMACHMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。 5.2 HMAC 的步骤 1.秘钥填充如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。 2.填充后的秘钥与 ipad 的 XOR将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。这里我们将这个比特序列称为 ipadkey。 3.与消息组合随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。 4.计算散列值将第三步的结果输入单向散列函数，并计算出散列值。 5.填充后的秘钥与 opad 的 XOR将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。XOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。 6. 与散列值组合将第四步的散列值拼在 opadkey 后面。 7.计算散列值将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。 6 对消息认证码的攻击6.1 重放攻击Mallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。 Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。 Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。 Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。 Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。 Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。 Mallory 继续重复第四步。 Bob 银行重复第五步。 有几种方法可以防御重放攻击。 1.序号约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。 2.时间戳约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。 3.nonce在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。 6.2 密码推测攻击和对单向散列函数的攻击一样，对消息认证码也可以进行暴力破解以及生日攻击（7.6.2节）。对于消息认证码来说，应保证不能根据 MAC 值推测出通信双方所使用的秘钥。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。 7 消息认证码无法解决的问题7.1 对第三方证明假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。 7.2 防止否认假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法防止否认（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。 8 本章小结本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。下一章的数字签名可以解决这些问题。 9 小测验 使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。 使用消息认证码能够识别出篡改行为。 使用消息认证码需要发送者和接收者之间共享的秘钥。 使用消息认证码能够防止否认。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[七、单向散列函数（获取消息的“指纹”）]]></title>
    <url>%2F2017%2F11%2F19%2Fgraphic2cryptography%2F7.html%2F</url>
    <content type="text"><![CDATA[1 本章概要针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。 2 什么是单向散列函数2.1 这个文件是不是真的呢Alice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：“这个文件和我昨天晚上生成的文件是一样的吗？”Alice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改……在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。 也就是说，Alice 需要确定自己的文件的完整性（integrity）。稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？这里还存在一个效率问题。如果需需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。 2.2 什么是单向散列函数单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。由于散列值很短，因此很容易处理和使用。 回家之前，Alice 用单向散列函数计算文件的散列值：35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。 2.3 单向散列函数的性质1. 根据任意长度的消息计算出固定长度的散列值2.能够快速计算出散列值3.消息不同散列值也不同如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为碰撞（collision）。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。难以发现碰撞的性质称为抗碰撞性（collision resistance）。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。Alice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。 这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的。这一性质称为弱抗碰撞性。单向散列函数都必须具备弱抗碰撞性。 和弱抗碰撞性相对的，还有强抗碰撞性。所谓强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的这一性质。在这里，散列值可以是任意值。 密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。 4. 具备单向性2.4 关于术语单向散列函数也称为消息摘要函数（message digest function）、哈希函数或者杂凑函数。输入单向散列函数的消息也称为原像（pre-image）。单向散列函数输出的散列值也称为消息摘要（message digest）或者指纹（fingerprint）**。完整性也称为一致性。“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。 3 单向散列函数的实际应用3.1 检测软件是否被篡改 3.2 基于口令的加密单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。PBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。 3.3 消息认证码使用单向散列函数可以构造消息认证码。消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。 3.4 数字签名数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。 3.5 伪随机数生成器使用单向散列函数可以构造伪随机数生成器。密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。 3.6 一次性口令一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。 4 单向散列函数的具体例子4.1 MD4、MD5MD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。MD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。MD 是消息摘要（Message Digest）的缩写。 4.2 SHA-1、SHA-256、SHA-384、SHA-512SHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。SHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。 4.3 RIPEMD-160RIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。 4.4 AHS（Advanced Hash Standard）与 SHA-3在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。 5 单向散列函数 SHA-1此章主要讲解其具体算法，有感兴趣者请看原书。 6 对单向散列函数的攻击6.1 暴力破解（攻击故事 1 ）Alice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的： Alice 要支付的金额为 100 万元。 改成： Alice 要支付的金额为 1 亿元。 不过，不仅要修改合同内容，还要不能改变散列值。Mallory 可以从文档文件所具有的冗余性入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。举个例子，下面的这些句子基本上说的都是一个意思：Alice 要支付的金额为 1 亿元。Alice 要支付的金额为壹亿元。Alice 要支付的金额为 100000000 元。Alice 应支付 1 亿元。作为报酬， Alice 需要支付 1 亿元。除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。 于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。在这里，Mallory 所进行的攻击就是暴力攻击。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种试图破解单向散列函数的“弱抗碰撞性”的攻击。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次） 6.2 生日攻击（攻击故事 2 ）编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100 万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为生日攻击（birthday attack），这是一种试图破解单向散列函数的“强抗碰撞性”的攻击。这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。 7 单向散列函数无法解决的问题假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。因此我们还需要进行认证，用于认证的技术包括消息认证码和数字签名。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。 8 本章小结本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。 9 小测验 MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。 要找出和某条消息具备相同散列值的另一条消息是非常困难的。 要找出具有相同散列值但互不相同的两条消息是非常困难的。 SHA-1 的散列值长度为 20字节。 如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[六、混合密码系统]]></title>
    <url>%2F2017%2F11%2F18%2Fgraphic2cryptography%2F6.html%2F</url>
    <content type="text"><![CDATA[1 混合动力汽车在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。 当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。 混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。 2 本章概要本章将学习由对称密码和公钥密码相结合的混合密码系统。 混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。 3 混合密码系统3.1 对称密码和公钥密码对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题： 公钥密码的处理速度远远低于对称密码 公钥密码难以抵御中间人攻击 本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍 3.2 混合密码系统 用对称密码加密信息 通过伪随机数生成器生成对称密码的会话秘钥 通过公钥密码加密会话秘钥 从混合密码系统外部赋予公钥密码加密时使用的秘钥 混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。即利用了对称密码的解密速度，公钥密码的机密性。 3.3 加密流程图如下： 1. 明文、秘钥、密文首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和 “用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。 2. 加密消息中间的大虚线方框分成左右两部分。右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。 这就是右半部分所进行的处理。 3. 加密会话秘钥左半部分进行的是会话秘钥的生成和加密操作。会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分， 作为对称密码的秘钥使用。接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。 会话秘钥是对称密码的秘钥，同时也是公钥密码的明文。请大家一定要理解会话秘钥的双重性！ 4. 组合如何上面的内容都理解了，剩下的就简单多了。我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。组合之后的数据就是混合密码系统整体的密文。 3.4 解密流程图如下： 1. 分离只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。 2. 解密会话秘钥会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。解密后的会话秘钥将被用作解密消息的秘钥。 3. 解密消息消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。上述流程正好是“混合密码系统的加密”的逆操作。 3.5 混合密码系统的具体例子混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。 4 怎样才是高强度的混合密码系统4.1 伪随机数生成器混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的 攻击方法，将在第十二章详解。 4.2 对称密码混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。 4.3 公钥密码混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。 4.4 秘钥长度的平衡对称密码和公钥密码的秘钥长度必须具备同等的强度。然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。 5 密码技术的组合本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。例如，第四章中介绍的分组密码模式，就是将只能加密固定长度的数据的分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。 三重 DES是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。 对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。 数字签名，是由单向散列函数和公钥密码组合而成的。证书，是由公钥和数字签名组合而成的。消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。 6 本章小结本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。 7 小测验 混合密码系统是用对称密码对消息进行加密的。 混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。 由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。 混合密码系统的解密过程是按照“公钥密码解密”-&gt;“对称密码解密”的顺序来进行处理的。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五、公钥密码]]></title>
    <url>%2F2017%2F11%2F15%2Fgraphic2cryptography%2F5.html%2F</url>
    <content type="text"><![CDATA[1 投币寄物柜的使用方法介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。 因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。 2 本章概要在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用 公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。 本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。 3 密钥配送问题3.1 什么是密钥配送问题在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是 非常危险的。 密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种： 通过事先共享密钥来解决 通过密钥分配中心来解决 通过 Diffie-Hellman 密钥交换来解决 通过公钥密码来解决 3.2 通过事先共享密钥来解决事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个 公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！ 3.3 通过秘钥分配中心来解决公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会 从入职时从秘钥分配中心的计算机上领取自己的秘钥。这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。 那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤： Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求 秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥 秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥 秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice 秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥 Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥 Bob 用会话秘钥对来自 Alice 的密文进行解密 Alice 和 Bob 删除会话秘钥 以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见： 随着员工增加，秘钥分配中心负荷增大 如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪 攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重 3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。 3.5 通过公钥密码来解决秘钥配送问题第四种方法，就是公钥密码。 在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有 解密秘钥的人才能够进行解密。 接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥 的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。 4 公钥密码4.1 什么是公钥密码公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。加密秘钥和解密秘钥的区别： 发送者只需要加密秘钥 接收者只需要解密秘钥 解密秘钥不可以被窃听者获取 加密秘钥被窃听者获取也没问题 也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。 公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。 4.2 公钥密码的历史 1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。 1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。 1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。 4.3 公钥通信的流程Alice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的： Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。 Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。 Alice 用 Bob 的公钥对消息进行加密。 Alice 将密文发送给 Bob 。密文被 Eve 获得。 Bob 用自己的私钥对密文进行解密。 4.4 公钥密码无法解决的问题我们需要判断所得到的公钥是否正确合法，这个问题被称为公钥认证问题。这个问题随后将通过对中间人攻击的讲解来探讨。同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。 5 时钟算法在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。 5.1 加法指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。 因此加法就变成了求余数运算，即 mod 运算。 5.2 减法减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 =&gt; x = 6。 5.3 乘法乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 =&gt; -9 + 12 = 3。 5.4 除法除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。 5.5 乘方7^4：7^4 mod 12 = 2401 mod 12 = 1 5.6 对数即乘方的逆运算：7^X = Y ，已知 Y 求 X。在时钟运算中的对数称为离散对数。例如：7^X mod 12 = 8，得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。 5.7 从时钟指针到 RSA我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。 6 RSA6.1 什么是 RSARSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。RSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。RSA 在 1983年取得了专利，但现在专利已经过期。 6.2 RSA 加密在 RSA 中，明文、秘钥和密文都是数字， RSA 的加密过程可以用下列公式来表示： 密文 = 明文 ^ E mod N也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。就是这么简单。其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。 6.3 RSA 解密明文 = 密文 ^ D mod N也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。 RSA 的加密和解密整理如下： 6.4 生成密钥对由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下： 求 N 求 L（中间值） 求 E 求 D 注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。 7 对 RSA 的攻击RSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。破译者知道的信息：密文、E、N。破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。 7.1 通过密文来求得明文密文 = 明文 ^ E mod N如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难， 因为人类还没有发现求离散对数的高效算法。 7.2 通过暴力破解来找出 D由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。 7.3 通过 E 和 N 求出 D既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。 7.4 中间人攻击下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。 假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。 Alice 向 Bob 发送邮件索要公钥 Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。 Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。 Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。 Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。 Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。 Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。 Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。 Mallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！ 我们用公钥密码解决了密钥配送问题，但是又出现新的问题，如何判断收到的公钥是否来自于正确的接收者，即是否来自于 Bob 。解决这个问题成为认证， 将在第十章详解。 8 其它公钥密码RSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。 这些密码都可以被用于一般的加密和数字签名。 8.1 EIGamal 方式RSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。 8.2 Rabin 方式Rabin 利用了 mod N 求平方根的困难度。 8.3 椭圆曲线密码椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。 9 关于公钥密码的问答主要选择一些容易被误解的点解答疑问。 9.1 公钥密码的机密性公钥密码比对称密码的机密性更高吗？这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。 9.2 公钥密码与对称密码的密钥长度采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。 9.3 对称密码的未来因为已经有了公钥密码，今后对称密码会消失吗？不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。 根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。 9.4 RSA 和质数随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后： 100亿人100亿个31622400秒*100亿年 &lt; 10^39。另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。 9.5 RSA 与质因数分解RSA 的破译与大整数的质因数分解是等价的吗？不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。 9.6 RSA 的长度要抵御质因数分解，N 的长度需要达到多少比特呢？N 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。 10 本章小结本章学习了公钥密码以及其代表性的实现方法——RSA。使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解 问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。 尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题 将在第九章和第十章详解。 即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码 提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。 11 小测验 秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？ 要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。 公钥密码的私钥需要和加密后的消息一起被发送给接收者。 一般来说，对称密码的速度比公钥密码要快。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[电影《内在美》有感~]]></title>
    <url>%2F2017%2F11%2F15%2Ftalker%2F1.html%2F</url>
    <content type="text"><![CDATA[看完这部电影，不得不说，最后被男主拿出的戒指感动到了~戒指没有不见，它一直在那里。回想女主第一次拒绝结婚的理由让人熟悉而又无奈，这不是我们每个男生都害怕听到的理由吗？ 我还没有准备好 幸好，最后结局有情人终成眷属了。回想起剧情，就像溪水，可能会流的慢，但是总会流到那里。 最后女主结婚的理由才像她自己： 我害怕世人眼光，但更害怕没有你的日子~ 啊~我需要买一个桌子，带音响的那种。 男主默默的制作家具，给人一种非常沉稳优雅的气质，不得不说，这个职业非常非常适合这个角色，在捷克依然孤独的与家居为伴， 这不是真是我们吗？终日与代码为伴，但是我们也要沉稳、也要优雅 优雅的代码千篇一律，给人赏心悦目；肮脏代码各有不同，总会让你感叹，代码还能这么脏？！ code also can be elegant。]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三、对称密码]]></title>
    <url>%2F2017%2F11%2F12%2Fgraphic2cryptography%2F3.html%2F</url>
    <content type="text"><![CDATA[1 炒鸡蛋与对称密码鸡蛋炒好之后就完全分不清原来的蛋黄和蛋白了，使用对称密码进行加密，和炒鸡蛋有着异曲同工之妙。炒鸡蛋搅拌的是鸡蛋，而密文打乱的则是比特序列。 然后，它们最大的不同是，炒鸡蛋无法还原成原来的鸡蛋，但密文却必须能够让接收者正确解密才行。 因此，如果只是随意地搅拌和混合，则不能称之为加密，而必须仔细设计出一种能够还原的混合方式。 2 本章概要学习比特序列运算和 XOR 运算。以及介绍一种称为一次性密码本的密码系统。具体介绍几种对称密码算法，包括 DES、三重DES、AES以及其它一些密码算法。需要注意的是，密码算法有时候会设计开发者的专利和授权等问题，记得先调查一下该算法的专利和授权信息。 3 从文字密码到比特序列密码3.1 编码计算机操作对象并不是文字，而是由 0 和 1 排列而成的比特序列。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。 3.2 XORXOR 的全称是 exclusive or ，中文叫作异或。 1. 一个比特的 XOR0 XOR 0 = 00 XOR 1 = 11 XOR 0 = 11 XOR 1 = 0可以理解为硬币翻转：不翻转 + 不翻转 = 不翻转 不翻转 + 翻转 = 翻转 翻转 + 不翻转 = 翻转 翻转 + 翻转 = 不翻转 2. 比特序列的 XORA XOR B = ABAB XOR B = A这是因为两个相同的数进行 XOR 运算的结果一定为 0 ，因此 A XOR B XOR B = A。这不就和加密、界面的步骤非常相似么，如下： 将明文 A 用密钥 B 进行加密，得到密文 AB。 将密文 AB 用密钥 B 进行解密，得到明文 A。 实际上，只要选择一个合适的 B，仅仅使用 XOR 就可以实现一个高强度的密码。对同一个比特序列进行两次 XOR 之后就会回到最初的状态。我们不妨来看看一副由很多点组成的图像。如果将白色的点作为 0 ，黑色的点作为 1 ， 那么一副黑白图像就可以表示为 0 和 1 的比特序列。我们转呗两幅图像，一幅画是英文字母 D，另一幅是用 0 和 1 交替排列形成的图像（蒙版）， 并进行如下操作：如果所使用的蒙版是完全随机的比特序列，则使用 XOR 就可以将原来的图像掩盖起来。但如果蒙版中的比特序列是可以被推测出来的，那么实质上图像就 没有被真正的掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特 序列就称为随机数。将在第十二章详解。 4 一次性密码本——绝对不会被破译的密码4.1 什么是一次性密码本只要通过暴力破解对密钥空间进行遍历，无论任何密文总有一天都能够被破译。然后，本节中将要介绍的一次性密码本（one-time pad）却是一个例外。 即便用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。 4.2 一次性密码本的加密它的原理是“将明文与一串随机的比特序列进行 XOR 运算”。如果将硬币的正面设为 0 ，反面设为 1 ，则通过不断掷硬币就能够产生这样一串随机的比特序列。下面我们将明文 midnight 这个字符串通过 ASCII 进行编码并产生一串比特序列。 接着，我们掷 64 次硬币产生 64 比特的随机比特序列： 下面我们将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结构也就是一次性密码本的密文。 这样产生的比特序列如果硬要显示在计算上，那么显示结果看上去就像是乱码一样（其实是加密），因此密文通常不会被还原为字符，而是被作为二进制数据来处理。 4.3 一次性密码本的解密用密文和密钥进行 XOR 运算，就可以得到明文：这样显示在计算上就会是正常的文本： midnight。 4.4 一次性密码本是无法破译的为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是， 即便我们能够解密出 midnight 这个字符串，我们也无法判断它是否是正确的明文。 因为在解密过程中，所有的 64 比特的排列组合都会出现，包括像 aaaaaaaa、bbbbbbbb、ZZZZZZZZ 这样的规则字符串，也会包含 midnight、onenight、 mistress 等英文单词，还会包含乱码看不懂的组合。由于明文中又有的可能排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个 密钥才能够正确解密）。 所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文， 因此一次性密码本是无法破译的。 一次性密码本无法破译的这一特性是由香农于 1949 年通过数学方法加以证明的。一次性密码本是无条件安全（unconditionally secure）的， 在理论上是无法破译的（theoretically unbreakable）。 4.5 一次性密码本为什么没有被使用1. 秘钥的配送最大的问题在于秘钥的配送。接受者 Bob 收到了 Alice 发来的密文。 Bob 要想进行解密，就必须使用和 Alice 进行加密时相同的秘钥，因此 Alice 必须将秘钥也发送给 Bob ， 且该秘钥的长度和密文是相等的。但这样就产生了一个矛盾——如果能够有一种方法将秘钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？ 2. 秘钥的保存既然能保存和明文一样长度的秘钥，那么不也就有办法安全保存明文本身了吗？也就是说，从一开始我们根本就不需要密码。也就是说，我们只是将“保护明文” 这一命题替换成了“保护和明文一样的秘钥”而已，问题并没有得到实质性的解决。 3. 秘钥的重用此外，在一次性密码本中是绝对不能重用过去用过的随机比特序列的，一次性密码本中的“一次性”也正是由此而来。这是因为作为秘钥的比特序列一旦泄露， 过去所有的机密通信内容将全部被解密（假设窃听者 Eve 保存了过去所有的通信内容）。 4. 秘钥的同步如果明文是一个大小为 100MB 的文件，则秘钥的大小也一定是 100MB 。而且在通信过程中，发送者和接受者的秘钥的比特序列不允许有任何错位，否则错位 后的比特的所有信息都将无法解密。 5. 秘钥的生成在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。因此，能够使用一次性密码本的，只有那些机密性重过一切，且可以 话费大量财力和人力来生成并配送秘钥的场合。 综上所述，一次性密码本是一种几乎没有实用性的密码。但是，一次性密码本的思路却孕育出了流密码（stream cipher）。流密码使用的不是真正的随机比特序列， 而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。 5 DES5.1 什么是 DESDES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。由于其在 1999 年只用了 22 小时就可破译， 因此除了用它来解密以前的密文以外，现在我们不应该再使用 DES 了。 5.2 加密和解密DES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于 每隔 7 比特 会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。 DES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的算法密码称为分组密码 （block cipher），DES 就是分组密码的一种。 DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为模式（mode），关于模式会在第四章详解。 5.3 DES 的结构（Feistel网络）在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。如下是 Feistel 网络中一轮的计算流程。而 DES 是 一种 16 轮循环的 Feistel 网络。 1. Feistel 网络的加密输入的数据被分为左右两半分别进行处理，中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。 由于子密钥只在一轮中使用，它只是一个局部密钥，因此才成为子密钥。轮函数的作用是根据“右侧”和子密钥一起生成中间密钥，这个中间密钥对“左侧”进行加密，轮函数是该密码系统的核心。一轮的步骤总结如下： 将输入的数据等分位左右两部分 将输入的右侧直接发送到输入的右侧 将输入的右侧发送到轮函数 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列 将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧 这样一来，“右侧”根本就没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调 2. Feistel 网路的解密我们尝试一次下将一轮加密的输出结果用相同的子密钥重新运行一次，结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文 正确地还原为明文。关于这一点，可以从 XOR 的性质（两个相同的数进行 XOR 的结果一定为 0 ）进行思考。 有多个轮的情况下也是一样的。也就是说， Feistel 网络的解密操作只要按照相反的熟悉怒来使用子密钥就可以完成了。下图是三轮加密图：下图是解密示意图： 3. Feistel 网络的性质Feistel 网络的轮数可以任意增加。无论运行多少轮的加密计算，都不会发生无法解密的情况。以及加密时无论使用任何函数作为轮函数都可以正确解密。 最后是加密和解密可以用完全相同的结构来实现。在 Feistel 网络的一轮中，右半部分实际上没有任何处理，这在加密算法中看起来是一种浪费， 但却保证了可解密性。 6 三重 DES现在 DES 已经可以在限时的时间内被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。 6.1 什么是三重 DES三重 DES（triple-DES）是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。 6.2 三重 DES 的加密经过三次 DES 处理CIA能变成最后的密文，由于 DES 秘钥的长度实质上是 56 比特，因此三重 DES 的秘钥长度就是 56 * 3 = 168 比特。从上图中，我们发现，三重 DES 并不是进行三次 DES 加密，而是加密-解密-加密的过程，实际上这是 IBM 公司设计出来的，目的是为了让三重 DES 能够兼容普通的 DES。当三重 DES 所有秘钥都相同的时候就相当于普通的 DES 了。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES 来进行解密。也就是说三重 DES 对 DES 具备向下兼容性。 6.3 三重 DES 的解密解密过程与加密过程顺序相反。 6.4 三重 DES 的现状其处理速度不高，而且在安全性方面也逐渐显现了一些问题，但还被银行等机构使用。 7 AES 的选定过程7.1 什么是 AESAES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码。全世界的企业和密码学家提交了多个对称密码算法 作为 AES 的候选，最终在 2000 年选出了一种名为 Rijndael 的对称密码算法，并将其确定为了 AES。 7.2 AES 的选定过程组织 AES 公开竞选活动的，是美国的一个标准化机构——NIST，参加 AES 竞选的条件是：被选为 AES 的密码算法必须无条件地免费供全世界使用。此外，参与者还必须提交密码算法的详细规格书、以 ANSIC 和 Java 编写的实现代码以及抗密码破译强度的评估等材料。因此，在提交了详细设计和程序代码 完全公开的情况下，就杜绝了隐蔽式安全性（security by obscurity）。 评审者也是参与者，通过发现别人的弱点，实现竞争，最终实现标准化，正是密码算法选定的正确方式。只有由世界最高水平的密码学家共同尝试破译，依然未能 找到弱点，这样才能够证明一种密码算法的强度。 7.3 AES 最终候选算法的确定与 AES 的最终确定 8 Rijndael8.1 什么是 Rijndael由比利时密码学家 Joan Daemon 和 Vincent Rijmen 设计的分组密码算法。 8.2 Rijndael 的加密和解密和 DES 一样， Rijndael 算法也是由多个轮所构成，但是 Rijndael 使用了 SPN 结构，Rijndael 的输入分组为 128 比特，也就是 16字节。 首先，需要逐个字节地对 16 字节地输入数据进行 SubBytes 处理，即将一个 1 字节地值替换成另一个 1 字节地值，可以想象成简单替换密码。SubBytes 之后进行 ShiftRows处理，即将 SubBytes 的输出以字节单位进行打乱处理，这种打乱是有规律的。然后进行 MixColumns 处理，即对 一个 4 字节地值进行比特运算，将其变成另一个 4 字节值，最后与轮秘钥进行 XOR ，进行 AddRoundkey处理。这就是一轮。实际上，在 Rijndael 需要重复进行 10 ~ 14 次计算。![][14]它在一轮使用了 SubBytes、ShiftRows、MixColumns 分别存在反向运算 InvSubBytes、InvShiftRows、InvMixColumns，分别按字节、行、列进行并行计算。 8.3 Rijndael 的破译对 Rijndael 来说，可能会出现以前并不存在的新的攻击方法。它的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公司来表达。 这只是一种假设而已，到现在为止，还没有出现针对 Rijndael 的有效攻击。 8.4 应该使用哪种对称密码呢介绍了 DES、三重 DES、和 AES 等对称密码。那么我们到底用哪种呢？一般来说不应该使用任何任何自制的密码算法，而是应该使用 AES。 9 本章小结本章介绍了对称密码，以及 DES、三重 DES、AES密码算法。 使用一种秘钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的秘钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他 类型的攻击。 然后用对称密码进行通信时，还会出现秘钥的配送问题。为了解决秘钥配送问题，我们需要公钥密码技术，将在第五章详解。本章所介绍的几乎所有的密码算法，都只能讲一个固定长度的分组进行加密。当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。下一章将 探讨对分组密码进行迭代的方法。 10 小测验 一次性密码本的秘钥可以进行压缩变短。 对称密码中，加密的秘钥和解密的秘钥是相等的。 如果秘钥长度为 56 比特，那么用暴力破解找到正确秘钥需要平均尝试约 2^28 次。 三重 DES 的秘钥空间是 DES 秘钥空间的三倍大。 现在 DES 可以在限时的时间内被破译。 AES 标准选定的密码算法叫 Rijndael。 注：秘钥长度为 56 比特，则秘钥空间（秘钥总数）是 2^56，平均时间除以 2 ，为 2^55。压缩算法在于：重复。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二、历史上的密码，写一篇别人看不懂的文章]]></title>
    <url>%2F2017%2F11%2F11%2Fgraphic2cryptography%2F2.html%2F</url>
    <content type="text"><![CDATA[1 本章概要本章将介绍历史上几种著名的密码： 凯撒密码 简单替换密码 Enigma 此外，还介绍两种破译密码的方法： 暴力攻击 频率分析 最后，我们还将思考密码算法与密钥之间的关系。本章所介绍的密码在现在都已经不再适用了，但在寻找密码弱点的方法、破译密码的思路以及密码算法与密钥的关系等方面，这些密码与现在密码技术依然是相通的。 2 凯撒密码2.1 什么是凯撒密码凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的。 2.2 凯撒密码的加密例如，将 yoshiko 这个女性的名字，加密： y -&gt; Bo -&gt; Rs -&gt; Vh -&gt; Ki -&gt; Lk -&gt; No -&gt; R这样，明文 yoshiko 就被加密为了密文BRVKLNR。凯撒密码中，将字母表中的字母平移这个操作就是密码的算法，而平移的字母数量则相当于密钥。 在本例中，密钥为3： 2.3 凯撒密码的解密我们只需要反向平移3个字母就可以解密了：B -&gt; yR -&gt; oV -&gt; sK -&gt; hL -&gt; iN -&gt; kR -&gt; o这样就得到了明文 yoshiko，但是密钥 3 必须由发送者和接受者事先约定好。 2.4 用暴力破解来破译密码通过上面的讲解，我们知道对于发送者用凯撒密码加密过的密文，接受者是能够进行解密的，但是接受者以为的人在看到密文 BRVKLNR ，是否能够进行破译 得到明文呢？在凯撒密码中，密钥就是字母表平移的字数。因此可以按顺序将这 26 种密钥都尝试一遍：BRVKLNR -&gt; 用密钥 0 解密 -&gt; brvklnrBRVKLNR -&gt; 用密钥 1 解密 -&gt; aqujkmqBRVKLNR -&gt; 用密钥 2 解密 -&gt; zptijlpBRVKLNR -&gt; 用密钥 3 解密 -&gt; yoshiko……BRVKLNR -&gt; 用密钥 25 解密 -&gt; cswlmos尝试一遍都，发现当密钥为 3 时，可以解密出有意义的字符串 yoshiko 。这就意味着我们仅仅根据密文就推测除了密钥和明文，这样的密码有什么用呢？ 凯撒密码实在是太脆弱了，无法保护重要的密码。 上面介绍的这种密码破译方法，就是讲所有可能的密钥全部尝试一遍，这种方法称为暴力破解（brute-force attack）。由于这种方法的本质是从所有的密钥 中找出正确的密钥，因此又称为穷举搜索（exhausive search）。 3 简单替换密码3.1 什么是简单替换密码将明文中所使用的字母表替换为另一套字母表的密码，如下图就是一个简单替换密码的对应表： 3.2 简单替换密码的加密按照上图的替换表，对明文 yoshiko 进行加密：y -&gt; Ko -&gt; Bs -&gt; Lh -&gt; Ti -&gt; Jk -&gt; So -&gt; B就得到密文：KBLTJSB。 3.3 简单替换密码的解密需要根据使用的替换表进行解密。 3.4 简单替换密码的密钥空间yoshiko 用凯撒密码（密钥为 3 ）加密后的密文是 BRVKLNR ，二用简单替换密码（密钥为上图）加密后的密文则是 KBLTJSB。单从密文上来看，我们无法 判断出凯撒密码和简单替换密码到底哪一种更难破解。 凯撒密码可以通过暴力破解来破译，但简单替换密码很难通过暴力破解来破译。这是因为简单替换密码中可以使用的密钥数量，比凯撒密码要多得多。 为了确定这一点，我们计算一下简单替换密码中可以使用的密钥总数。一种密码能够使用的“所有密钥的集合”称为密钥空间（keyspace），所有可用密钥的总数就是密钥空间的 大小。密钥空间越大，暴力破解就越困难。 简单替换密码中，明文字母表中的 a 可以对应A，B，C，…，Z 这 26 个字母中的任意一个，b 可以对应除了 a 所对应的字母以为的剩余 25 个字母中的任意一个。 以此类推，我们可以计算出简单替换密码的密钥总数为：26 * 25 * 24 * 23 * … * 1 = 403291461126605635584000000即使美妙能够遍历 10 亿个密钥，也要花费 120 亿年的时间。 3.5 用频率分析来破译密码频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。例如： 首先，我们统一一下这段密文中每个字母出现的频率： 为了找到破译的线索，我们再来看一下英语文章中所使用的字母的频率，一般的英语文章中出现频率最高的字母是 e 。而上图中出现频率最高的两个字母是 I 和 Y， 我们假设它们中的其中一个是 e 。然后将密文中的 Y 全部替换成 e ，替换后的密文如下：英语中出现最多的单词是 the ，因此我们可以寻找一下以 e 结尾的 3 个字母的组合，结果我们发现 MEe 这3个字母的组合是最常出现的，而且 MEe 出现在 密文的开头，因此 MEe 很可能就是 the 。于是，我们再假设 M -&gt; t，E -&gt; h。得到如下图的表：让我们动员自己所有的英文词汇，在上面的文字中继续寻找可能的组合。我们发现中间有一个词 thPee 比较可以，这个词不会就是 three 吧（P -&gt; r）？ 除了高频字母以外，密文中的低频字母 Q 也可以找到一些相关的组合。直到得到最后通顺的明文，有以下结论： 除了高频字母以外，低频字母也能够成为线索。 搞清开头和结尾能够称为线索，搞清单词之间的分隔也能够成为线索。 密文越长越容易破译。 同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）。 破译的速度会越来越快。 4 Enigma4.1 什么是 EnigmaEnigma 是由德国人于 20 世纪初发明的一种能够进行加密与解密操作的机器。Enigma 这个名字在德语里是“谜”的意思。 4.2 用 Enigma 进行加密通信Enigma 是一种由键盘、齿轮、电池和灯泡所组成的机器，通过这一台机器就可以完成加密和解密两种操作。 发送者和接收者各自拥有一台 Enigma。发送者用 Enigma 将明文加密，将生成的密文通过无线电发送给接收者。接收者将接收到的密文用自己的 Enigma 解密。 由于发送者和接收者必须使用相同的密钥才能完成密码通信，因此发送者和接收者会事先收到一份叫国防军密码本的册子。发送者和接收者按照册子指示来设置 Enigma。 4.3 Enigma 的构造Enigma 的构造如下图。它能对字母表中的 26 个字母进行加密和解密操作，这里将字母的数量简化为 4 个： 每当按下 Enigma 上的一个键，就会点亮一个灯泡。而接线板和轮子在每次输入的时候都会变化，这样的组合让 Enigma 看起来像是一个能够动态变化的操作。 4.4 Enigma 的加密在进行通信之前，发送者金和接收者双方都需要持有国防军密码本，国防军密码本中记载了发送者和接收者需要使用的每日密码。 1.设置 Enigma发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。具体来说，就是接线板和转子排列。 2. 加密通信密码接下来，发送者需要想出 3 个字母，并将其加密。这 3 个字母称为通信密码。通信密码的加密也是通过 Enigma 完成的。假设发送者选择的通信密码为 psv，则发送者需要在 Enigma 的键盘上输入两次该通信密码，也就是说需要输入 psvpsv 这 6 个字母。 发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输入全部 6 个字母之后，发送者就记下了它们所对应的密文， 假设密文是 ATCDVT（密文用大写字母来表示）。 3. 重新设置 Enigma接下来，发送者根据通信密码重新设置 Enigma。通信密码中的 3 个字母实际上代表了三个转子的初始位置。每一个转子的上面都印有字母，可以根据字母 来设置转子的初始位置。通信密码 psv 就表示需要将转子 1、2、3 分别转到 p、s、v 所对应的位置。 4. 加密消息接下来，发送者对消息进行加密。发送者将明文逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。例如输入 nacht ，记录下对应的 KXNWP 。 5. 拼接接下来，发送者将“加密后的通信密码” ATCDVT 与 “加密后的消息” KXNWP 进行拼接，将 ATCDVTKXNWP 作为电文通过无线电发出。 上面就是用 Enigma 进行加密的操作步骤，看来还真是挺麻烦的。 4.5 每日密码与通信密码每日密码在这里不是用来加密消息的，而是用来加密通信密码的。也就是说，每日密码是一种用来加密密钥的密钥，这种密钥，一般称为密钥加密密钥（Key Encrypting Key，KEY）。 4.6 避免通信错误在通信密码的加密中，我们需要将通信密码 psv 连续输入两次，即 psvpsv。这是因为接收者可以对通信密码进行校验，避免错误。 4.7 Enigma 的解密 1.分解接收者将接受到的电文分解为两部分，即开头的 6 个字母 ATCDVT 和剩下的字母 KXNWP。 2. 设置 Enigma接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，这一步和发送者进行的操作是相同的。 3. 解密通信密码接下来，接收者将加密后的通信密码 ATCDVT 进行解密。接收者在 Enigma 的键盘上输入 ATCDVT 这 6 个字母，然后将亮起的灯泡对应的字母 psvpsv 记下来。 因为是 psv 重复两次的形式，所以接收者可以判断在通信过程中没有发生错误。 4. 重新设置 Enigma接下来，接收者根据通信密码 psv 重新设置 Enigma。 5. 解密消息接下里，接收者将电文中的剩余部分 KXNWP 逐一输入，将灯泡的结果记下来，得到了 nacht。 4.8 Enigma 的弱点1. 将通信密码连续输入两次并加密这样密码破译者知道密文开头的 6 个字母被解密后的明文一定是 3 个字母重复两次的形式 2. 通信密码是人为选定的有可能使用 aaa、bbb 或者生日，女朋友的名字当做密码。密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。 3. 必须派发国防军密码本如果落到敌人手里，就会带来大麻烦。如果现在所使用的国防军密码本被敌人得到，哪怕只泄漏了一本，也必须重新制作新的密码本并发到全军。 必须配送密钥这个问题，将在第五章详解。 4.9 Enigma 的破译即使得到了 Enigma 的构造，但是由于 Enigma 的设计并不依赖于“隐蔽式安全性”，只要不知道 Enigma的设置（密钥），就无法破译密码。但是， 每日密码在一天之内不会变，即一天内截获的所有通信，都是用同一个密码进行加密的；以及通信密码都会重复两次。以 ATCDVT 为例，即知道第一个字母和 第四个字母，都是由相同的明文加密得到的；另外，由于一个轮子只有26个可能。最终经过了许多密码专家的破译，包括现代计算机之父阿兰图灵，最终破译了这个密码。 5 思考5.1 为什么吗要将密码算法和密钥分开呢我们来列举一下本章介绍过的密码系统的“密码算法”和“密钥”。 密码系统 密码算法 密钥 凯撒密码 将明文中的各个字母按照指定的字母数平移 平移的字母数量 简单替换密码 按照替换表对字母表进行替换 替换表 Enigma（通信密码的加密） 使用Enigma密码机，通过接线板的接线方式、三个转子的顺序、每个转子的旋转位置对字母进行替换 接线板的接线方式、转子的顺序、转子的旋转位置 Enigma（通信电文的加密） 使用接线板的接线方式和三个转子的顺序固定的Enigma密码机，按照每个转子的旋转位置对字母进行替换 每个转子的旋转位置 仔细研究一下每一对密码算法和密钥的组合就会发现，在密码算法中必然存在可变部分，而这些可变部分就相当于密钥。当密码算法和密钥都确定时，加密的方法也就确定了。如果每次加密都必须产生一个新的密码算法，那真是太诡异了。对于已经开发出的一种密码算法，我们总是希望能够重复使用。 将密码算法和密钥分开的意义正在于此。密码算法是需要重复使用的，但在重复使用同一种算法的过程中，该算法被破译的可能性也在逐渐增大。因此， 我们就在密码算法中准备了一些可变部分，并在每次通信时都对这部分进行改变，而这一可变部分就是密钥。 将密码算法和密钥分开考虑，就解决了希望重复使用，但重复使用会增加风险这个难题。 密钥才是秘密的精华。因此，在密码技术中，如何管理密钥是一个重要的课题。这将在第十一章详解。 每个人都可以拥有相同品牌的锁，但每个人都有不同的钥匙。锁的设计师公开的——锁匠都带有详细图的书，而且绝大多数好的设计方案都在公开专利 中进行了描述——但是钥匙是秘密的。 6 本章小结密码系统：凯撒密码、简单替换密码以及 Enigma。密码破译：暴力破解、字母频率分析。 7 小测验 凯撒密码中，如果存在如 c -&gt; C， q -&gt; Q这样，明文中的字母被替换成了相同字母的密文的情况。于是Alice就想：如果替换表中不出现这种被替换 为相同字母的情况，那么密文应该会更难被破译吧？请问 Alice 的想法正确吗？]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一、环游密码世界]]></title>
    <url>%2F2017%2F11%2F10%2Fgraphic2cryptography%2F1.html%2F</url>
    <content type="text"><![CDATA[1 本章概要从整体上了解密码世界的模样。 2 密码2.1 Alice 与 Bob要讲解密码，需要给参与信息交互的人和计算机起几个名字，如下表： 名称 说明 Alice 一般角色 Bob 一般角色 Eve 窃听者，可窃听通信内容 Mallory 主动攻击者，可妨碍正常通信、伪造消息等 Trent 可信的第三方 Victor 验证者 2.2 发送者、接受者和窃听者Alice 向 Bob 发送消息，Alice 作为 Sender，Bob 作为 Receiver，消息作为 Message。在互联网中，消息会经过许多台计算机和通信设备做中转， 在这个过程中，就存在被恶意窃听者（eavesdropper）偷看的可能。作为监听者，我们给它起名为Eve，它可能是人类也有可能是某些程序软件。 2.3 加密与解密Alice 不想让别人看到她传递消息的内容，因为它决定将消息加密（encrypt） 后再发送出去，加密之前的是明文（plaintext），加密之后的消息称为 密文（ciphertext）。 Bob 收到了 Alice 的加密消息后，他需要进行解密（decrypt）之后再查阅，即将密文恢复成明文的过程。这样，窃听者在网络上得到的只是密文。 2.4 破译Eve 得到了密文，试图将密文还原为明文，被称为密码破译（cryptanalysis），简称破译，或者密码分析。 3 对称密码与公钥密码3.1 密码算法用于解决复杂问题的步骤，通常称为算法（algorithm），明文生成密文的步骤，被称为“加密算法”；而解密的步骤被称为“解密算法”，它们两统称为密码算法。 3.2 密钥密码算法中需要密钥（key）。如下： 无论是在加密还是解密时，都需要知道密钥。 3.3 对称密钥与公钥密码根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。 对称密码（symmetric cryptography）是指在加密和解密时使用同一密钥的方式。 公钥密码（public-key cryptography）则是在加密和解密时使用不同密钥的方式，也称非对称密码（asymmetric cryptography）。 3.4 混合密码系统将对称密码和公钥密码结合起来的密码方式。 4 其它密码技术4.1 单向散列函数为了防止下载的软件被篡改，有安全意思的软件发布者会步的散列值。散列值就是用单向散列函数（one-way hash function）计算出来的数值。 单向散列函数所保证的并不是机密性，而是完整性（integrity），即“数据是正牌的而不是伪造的”。第七章，详细讲解。 4.2 消息认证码为了确认消息是否来自所期望的通信对象，可以使用消息认证码（message authentication code）技术，不仅能保证完整性还能提供认证（authentication）机制。 4.3 数字签名验证消息是否被篡改，能够确保完整性、提供认证并防止否认的密码机制。将第九章详解。 4.4 伪随机数生成器伪随机数生成器（Pseudo Random Number Generator，PRNG）是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这么说可能会感到意外， 但实际上随机数确实承担着密钥生成的重要职责。例如在 Web 中进行 SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥 就是基于伪随机数生成的。将在第十二章详解。 5 密码学家的工具箱在以上内容中，已经出现了很多种类的密码技术，其中以下六种发挥尤其重要的作用： 对称密码 公钥密码（非对称密码） 单向散列函数 消息认证码 数字签名 伪随机数生成器 在本书中，将上述六种技术统称为密码学家的工具箱。 6 隐写术与数字水印上面讲过，密码是一种能够让消息内容变得无法解读的技术，即 cryptography。除此之外，还有另外一种技术，它不是让消息内容变得无法解读，而是能够 隐藏消息本身，这种技术称为隐写术（steganography）。例如：我们先准备一段话，很容易看懂的就可以，喜闻乐见的当然更好，欢迎你尝试将另一句话嵌在这段话中，你会发现这其实就是一种隐写术。 这样，就发现这段话还隐藏着另一句话“我很喜欢你”。隐写术在计算机中，用于数字水印技术，它是一种将著作权拥有者及购买者的信息嵌入文本中的技术。但是仅凭数字水印技术时无法对信息进行加密的，因此需要 和其它技术配合使用。 例如，将密码技术和隐写术相结合的方法就很常见。首先，我们将要嵌入的文章进行加密并生成密文，然后再通过隐写术将密文隐藏到图片中。这样一来， 即便有人发现了密文的存在，也无法读取出所嵌入的文章的内容。密码隐藏的是内容，隐写术隐藏的是消息本身。 7 密码与信息安全常识7.1 不要使用保密的密码算法我们不应该制作或使用任何保密的密码算法，而是应该使用那些已经公开的、被公认为强度较高的密码算法，原因如下： 密码算法的秘密早晚会公诸于世。 开发高强度的密码算法是非常困难的。而试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（security by obscurity），这是危险且愚蠢的行为。 7.2 使用低强度的密码比不进行任何加密更危险对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，这通常会导致用户在处理一些机密信息的时候麻痹大意。 7.3 任何密码总会有一天都会被破解无论使用任何密码算法锁生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的 价值之间的权衡就显得非常重要。严格来说，绝对不会被破解的密码其实是存在的，这种算法称为一次性密码本（one-time pad），将在3.4节详解。此外，还有另一种技术被认为有可能早就完美的密码技术，那就是量子密码，将在15.3.1节详解。 7.4 密码只是信息安全的一部分社会工程学（social engineering）。最脆弱的环节并不是密码，而是人类自己。 8 本章小结主要浏览了密码世界中的一些主要技术。 9 小测验下面说法是否正确？ 将明文转换为密文的过程称为加密。 明文是供人类读取的数据，而密文则是供计算机读取的数据。 只要检查邮件发送者（From:）一栏的内容，就能够正确判断邮件是谁发出的。 在对称密码中，加密用的密钥和解密用的密钥是相同的。 公开的密码算法容易遭到坏人的攻击，因此使用自己公司开发的保密的密码算法更加安全。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图解密码技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[八、Java中的并发工具类]]></title>
    <url>%2F2017%2F11%2F07%2Fconcurrent-art%2F8.html%2F</url>
    <content type="text"><![CDATA[1 等待多线程完成的 CountDownLatch例如：解析一个 Excel 里多个 sheet 的数据，如果使用多线程，每个线程解析一个 sheet 里的数据，等到所有的 sheet 都解析完之后，程序提示解析完成。 即，需要主线程等待所有线程完成 sheet 的解析操作，最简单的做法是使用 join() 方法，代码8-1： 12345678910111213141516171819202122232425262728293031public class JoinCountDownLatchTest &#123; public static void main(String[] args) throws Exception &#123; Thread parser1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("parser1 finish"); &#125; &#125;); Thread parser2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("parser2 finish"); &#125; &#125;); parser1.start(); parser2.start(); parser1.join(); parser2.join(); System.out.println("all parser finish"); &#125;&#125; join 用于让当前执行线程等待 join 线程执行结束。其实现原理是不听检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。 CountDownLacth 内部维护一个 int 类型的参数作为计数器，每次执行 countDown() 都会让计数器减1，await()只有当计数器为0的时候，才不会阻塞当前线程： 1234567891011121314151617181920212223242526272829303132public class CountDownLatchTest &#123; static CountDownLatch c = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(1); c.countDown(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(2); c.countDown(); &#125; &#125;).start(); c.await(); System.out.println("3"); &#125; 2 同步屏障 CyclicBarrier2.1 CyclicBarrier 简介字面意思：可循环使用（cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时， 屏障才会开门，所有被屏障拦截的线程才会继续运行。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839public class CyclicBarrierTest2 &#123; static CyclicBarrier c = new CyclicBarrier(2, new A()); public static void main(String[] args) &#123; Thread s = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; c.await(); Thread.sleep(1000); // 设置睡眠，输出：321，如果不设置，可能会是312 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125; &#125;); s.start(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(2); &#125; static class A implements Runnable &#123; @Override public void run() &#123; System.out.println(3); &#125; &#125;&#125; 2.2 CyclicBarrier 的应用场景用于多线程计算数据，最后合并计算结果的场景。例如，用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个账户近一年的每笔银行流水， 现在需要统计用户的日均银行流水，先多线程处理每个 Sheet 的银行流水，都执行完之后，再用 barrierAction 计算线程结果。代码8-5如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.lwg.current_art;import java.util.HashMap;import java.util.Map;import java.util.concurrent.*;public class BankWaterService implements Runnable&#123; /** * 创建 4 个屏障，当运行了 4 个await()后，才会运行第二参数。 */ private CyclicBarrier c = new CyclicBarrier(4, this); /** * 4 个sheet，创建 4 个线程的线程池 */ private Executor executor = Executors.newFixedThreadPool(4); /** * 保存每个线程的结果 */ private Map&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;(); private void count() &#123; for (int i = 0; i &lt; 4; i++) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; sheetBankWaterCount.put(Thread.currentThread().getName(), 1); System.out.println("size:" + sheetBankWaterCount.size()); try &#123; c.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; @Override public void run() &#123; int result = 0; for (Map.Entry&lt;String, Integer&gt; sheet: sheetBankWaterCount.entrySet())&#123; result += sheet.getValue(); &#125; sheetBankWaterCount.put("result", result); System.out.println(result); &#125; public static void main(String[] agrs) &#123; BankWaterService bankWaterService = new BankWaterService(); bankWaterService.count(); &#125;&#125; 2.3 CyclicBarrier 和 CountDownLatch 的区别CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务。 一些 API 用法如下代码8-6： 1234567891011121314151617181920212223242526272829public class CyclicBarrierTest3 &#123; static CyclicBarrier c = new CyclicBarrier(2); public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); thread.interrupt(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; System.out.println(c.isBroken()); e.printStackTrace(); &#125; &#125;&#125; 2.3 控制并发线程数的 SemaphoreSemaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。 把 Semaphore 比作是控制流量的红绿灯。比如xx马路要限制流量，只允许同时有一百辆车在这条路上行驶，其它的都必须在路口等待，所以前一百辆车会看到绿灯， 可以开进这条马路，后面的车会看到红灯，不能驶入xx马路，但是如果前一百辆中有5辆车已经离开了xx马路，那么后面就允许有5辆车驶入xx马路， 即车就是线程，驶入马路就是线程执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞。 2.3.1 应用场景Semaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假设有一个需求，要读取几万个文件的数据，因为都是IO密集型人物， 我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据， 否则会报错无法获取数据库连接。这个时候可以使用 Semaphore 做流量控制，如下代码8-7： 1234567891011121314151617181920212223242526public class SemaphoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; s.acquire(); System.out.println("save data"); s.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 4 线程间交换数据的 ExchangerExchanger 提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。如果第一个线程执行 exchange() 方法，它就会一直等待第二个线程也执行 exchange 方法， 当两个线程都到达同步点时，这时就可以交换数据。 4.1 应用场景 遗传算法：选出两个人作为交配对象，交换两人的数据，并使用交叉规则得出2个交配结果。 校对工作：对两个人工录入的文件进行校对。123456789101112131415161718192021222324252627282930313233public class ExchangerTest &#123; private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;(); private static ExecutorService threadPool = Executors.newFixedThreadPool(2); public static void main(String[] args) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; String A = "银行流水A"; exgr.exchange(A); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; String B = "银行流水B"; String A = exgr.exchange(B); System.out.println("A和B数据是否一致：" + A.equals(B) + ".A录入的是：" + A + ".B录入的是：" + B); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); threadPool.shutdown(); &#125;&#125; 5 本章小结 CountDownLatch-&gt;CyclicBarrier：都是等待某些运行到某个点后，才执行后面的方法，但是 CyclicBarrier提供的 API 更多适合更复杂的场景。 Semaphore：控制并发数，即创建了30个线程，但是并发最多可以设置为10。 Exchanger：线程间交换数据，在同步点处，A线程可以获得B线程的数据。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Java并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四、Java并发编程基础]]></title>
    <url>%2F2017%2F11%2F07%2Fconcurrent-art%2F4.html%2F</url>
    <content type="text"><![CDATA[1 线程简介1.1 什么是线程操作系统运行一个程序时，会为其创建一个进程。而操作系统调度的最小单元是线程，也叫轻量级进程（ Light Weight Process）， 在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。 1234567891011121314151617public class MultiThread&#123; public static void main(String[] args) &#123; ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); for(ThreadInfo threadInfo : threadInfos) &#123; System.out.println(threadInfo.getThreadId() + "," + threadInfo.getThreadName()); &#125; /** 6,Monitor Ctrl-Break 5,Attach Listener 4,Signal Dispatcher 3,Finalizer 2,Reference Handler 1,main */ &#125; &#125; 1.2 为什么要使用多线程1.2.1 更多的处理器核心程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器 核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上， 就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。 1.2.2 更快的响应时间编写一些较为复杂的代码，例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。这么多业务 操作，如何能够让其更快地完成呢？ 1.2.3 更好的编程模型Java 为多线程编程提供了良好、考究并且一致的编程模型，使开发人员更加专注于问题的解决。 1.3 线程优先级现代操作系统基于采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程 调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器 资源的线程属性。 在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法 来修改优先级，默认优先级是 5 ，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞的线程需要设置较高优先级， 而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级。笔者在 JDK 1.8 的 WIN 10 环境： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Priority &#123; private static volatile boolean notStart = true; private static volatile boolean notEnd = true; public static void main(String[] args) throws InterruptedException &#123; List&lt;Job&gt; jobs = new ArrayList(); for (int i = 0; i &lt; 10; i++) &#123; int priority = i &lt; 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY; Job job = new Job(priority); jobs.add(job); Thread thread = new Thread(job, "Thread:" + i); thread.setPriority(priority); thread.start(); &#125; notStart = false; TimeUnit.SECONDS.sleep(2); notEnd = false; for (Job job : jobs) &#123; System.out.println("Job Priority：" + job.priority + ", Count：" + job.jobCount); &#125; &#125; static class Job implements Runnable &#123; private int priority; private long jobCount; public Job(int priority) &#123; this.priority = priority; &#125; @Override public void run() &#123; while (notStart) &#123; Thread.yield(); &#125; while (notEnd) &#123; Thread.yield(); jobCount++; &#125; &#125; &#125;&#125; 输出： 12345678910Job Priority：1, Count：16772Job Priority：1, Count：16761Job Priority：1, Count：16761Job Priority：1, Count：16758Job Priority：1, Count：16757Job Priority：10, Count：756747Job Priority：10, Count：757594Job Priority：10, Count：757263Job Priority：10, Count：759519Job Priority：10, Count：760287 1.4 线程的状态 1.5 Daemon 线程Daemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候， Java 虚拟机将会退出。可以通过调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程。 Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置。 Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行，如下： 12345678910111213141516171819public class Daemon &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new DaemonRunner(), "DaemonRunner"); thread.setDaemon(true); thread.start(); &#125; static class DaemonRunner implements Runnable &#123; @Override public void run() &#123; try &#123; SleepUtils.second(10); &#125; finally &#123; System.out.println("DaemonThread finally run."); &#125; &#125; &#125;&#125; 最终没有任何的输出，mian 线程在启动了线程 DaemonRunner 之后随着 main 方法执行完毕而终止，而此时 Java 虚拟机中已经灭有非 Daemon 线程， 虚拟机需要退出。 Java 虚拟机中的所有 Daemon 线程都需要立即终止，因此 DaemonRunner 立即终止，但是 DaemonRunner 中的 finally 块并没有执行。 2 启动和终止线程2.1 理解中断中断可以理解为线程的一个标识位属性，它标识一个运行中的线程是否被其它线程进行了中断操作。线程通过方法 isInterrupted 来进行判断是否被中断， 也可以调用静态方法 Thread.interrupted() 对当前线程的中断标识位进行复位。下面的例子中，创建了两个线程， SleepThread 和 BusyThread ， 前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Interrupted &#123; public static void main(String[] args) throws InterruptedException &#123; Thread sleepThread = new Thread(new SleepRunner(), "SleepThread"); sleepThread.setDaemon(true); Thread busyThread = new Thread(new BusyRunner(), "BusyThread"); busyThread.setDaemon(true); sleepThread.start(); busyThread.start(); Thread.sleep(5 * 1000); sleepThread.interrupt(); busyThread.interrupt(); System.out.println("SleepThread interrupted is " + sleepThread.isInterrupted()); System.out.println("BusyThread interrupted is " + busyThread.isInterrupted()); Thread.sleep(2 * 1000); System.out.println("SleepThread interrupted is " + sleepThread.isInterrupted()); System.out.println("BusyThread interrupted is " + busyThread.isInterrupted()); // SleepThread interrupted is false // BusyThread interrupted is true Thread.sleep(2 * 1000); &#125; static class SleepRunner implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; static class BusyRunner implements Runnable &#123; @Override public void run() &#123; while (true) &#123; &#125; &#125; &#125;&#125; 线程 SleepThread 其中断标识位被清除了，而一直忙碌运作的线程 BusyThread ，其中断标识位没有被清除。 2.2 安全地终止线程123456789101112131415161718192021222324252627282930313233343536public class Shutdown &#123; public static void main(String[] args) throws InterruptedException &#123; Runner one = new Runner(); Thread countThread = new Thread(one, "countThread"); countThread.start(); Thread.sleep(1 * 1000); countThread.interrupt(); Runner two = new Runner(); countThread = new Thread(two, "CountThread"); countThread.start(); Thread.sleep(1 * 1000); two.cancel(); &#125; private static class Runner implements Runnable &#123; private long i ; private volatile boolean on = true; @Override public void run() &#123; while(on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; i++; &#125; &#125; private void cancel() &#123; on = false; &#125; &#125;&#125; 使用 Thread.interrupted() 或一个 boolean 来进行中断。 3. 线程间通信3.1 volatile 和 synchronized 关键字每个执行的线程拥有一份拷贝，这样做的目的是加速程序的执行，所以程序在执行过程中，一个线程看到的变量并不一定是最新的。 关键字 volatile 就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。 举个例子：定义一个表示程序是否运行的成员变量 boolean on = true ，另一个线程可能执行了关闭动作 on = false ，这里涉及多个线程对变量的访问， 因此需要定义称为 volatile boolean on = true ，这样其他线程对它改变时，所以线程都会感知，因为所有对 on 变量的访问和修改都需要以共享内存 为准。 关键字 synchronized 主要确保多个线程在同一时刻，只能由一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。 使用 javap 工具分析 synchronized 关键字的实现细节，实例4-10： 123456789101112public class Synchronized &#123; public static void main(String[] args) &#123; synchronized (Synchronized.class) &#123; &#125; m(); &#125; public static synchronized void m() &#123; &#125;&#125; javap -v Synchronized.class :同步块的前面和后面分别有 monitorenter 和 monitorexit 指令，而同步方法依靠方法修饰符 ACC_SYNCHRONIZED 来完成。其本质是对一个对象的监视器(monitor)进行获取，这个获取过程是排他的，即同一时刻只有一个线程获取到由 sychronized 所保护对象的监视器。 任意一个对象都拥有自己的监视器，执行方法的线程必须先获取到该对象的监视器，没有获取到的线程将会阻塞在入口处，进入 BLOCKED 状态。 3.2 等待/通知机制一个线程修改了一个对象的值，另一个线程感知到了变化，进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程。前者是生产者，后者就是消费者。 在功能上进行了解耦，“做什么”和“怎么做”。在 Java 实现类似的功能： 简单的方法就是让消费者线程不断地循环检查变量是否符合预期，如下的消费者： 1234while (value != desire) &#123; Thread.sleep(1000); // 防止过快的“无效”尝试&#125;doSomething(); 存在的问题： 难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化。 难以降低开销。如果降低睡眠时间，比如休眠 1 毫秒，这样消费者能更加迅速地发生条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。 可以通过等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在 Object ，方法和描述如下表所示： 方法名称 描述 notyfy() 通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁 notifyAll() 通知所有等待在该对象上的线程 wait() 调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用 wait() 方法后，会释放对象的锁 wait(long) 超时等待一段时间，也就是等待长达 n 毫秒，如果没有通知就超时返回 wait(long, int) 对于超时时间更细粒度的控制，可以达到纳秒 等待/通知机制，是指一个线程A 调用了对象O 的 wait() 方法进入等待状态，而另一个线程B 调用了对象O 的 notify() 或者 notifyAll() 方法， 线程A 收到通知后从对象O 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的 wait() 和 notify()/notifyAll() 的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class WaitNotify &#123; static boolean flag = true; static Object lock = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread waitThread = new Thread(new Wait(), "WaitThread"); waitThread.start(); Thread.sleep(1 * 1000); Thread notifyThread = new Thread(new Notify(), "NotifyThread"); notifyThread.start(); &#125; static class Wait implements Runnable &#123; @Override public void run() &#123; // 加锁，拥有 lock 的 Monitor synchronized (lock) &#123; // 当条件不满足时，继续 wait ，同时释放了 lock 的锁 while (flag) &#123; try &#123; System.out.println("1"); System.out.println(Thread.currentThread() + " flag is true. wait " + new SimpleDateFormat("HH:mm:ss").format(new Date())); lock.wait(); System.out.println("2"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 条件满足时，完成工作 System.out.println(Thread.currentThread() + " flag is false. running " + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; &#125; &#125; static class Notify implements Runnable &#123; @Override public void run() &#123; // 加锁，拥有 lock 的 Monitor synchronized (lock) &#123; // 获取 lock 的锁，然后进行通知，通知时不会释放 lock 的锁 // 直到当前线程释放了 lock 后， WaitThread 才能从 wait 方法中返回 System.out.println(Thread.currentThread() + " hold lock. notify " + new SimpleDateFormat("HH:mm:ss").format(new Date())); lock.notifyAll(); flag = false; try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 再次加锁 synchronized (lock) &#123; System.out.println(Thread.currentThread() + " hold lock again. sleep " + new SimpleDateFormat("HH:mm:ss").format(new Date())); try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 3.3 Thread.join() 的使用如果一个线程A 执行了 thread.join() 语句，即：当前线程A 等待 thread 线程终止之后才从 thread.join() 返回。代码4-13如下： 123456789101112131415161718192021222324252627282930313233343536public class Join &#123; public static void main(String[] args) &#123; Thread previous = Thread.currentThread(); for (int i = 0; i &lt; 10; i++) &#123; // 每个线程拥有前一个线程的引用 Thread thread = new Thread(new Domino(previous), String.valueOf(i)); thread.start(); previous = thread; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " terminate. "); &#125; static class Domino implements Runnable &#123; private Thread thread; public Domino(Thread thread) &#123; this.thread = thread; &#125; @Override public void run() &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " terminate. "); &#125; &#125;&#125; Thread.join() 源码大概是这样的结构： 12345678// 加锁当前线程对象public final synchronized void join() throws InterruptedException &#123; // 条件不满足，继续等待 while(isAlive()) &#123; wait(0); &#125; // 条件符合，方法返回&#125; 逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑。 3.4 ThreadLocal 的使用1234567891011121314151617181920212223public class Profiler &#123; // 第一次调用 get() 方法会进行初始化，每个线程只会执行一次 private static final ThreadLocal&lt;Long&gt; TIME_threadLocal = new ThreadLocal() &#123; @Override protected Object initialValue() &#123; return System.currentTimeMillis(); &#125; &#125;; public static final void begin() &#123; TIME_threadLocal.set(System.currentTimeMillis()); &#125; public static final long end() &#123; return System.currentTimeMillis() - TIME_threadLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; Profiler.begin(); Thread.sleep(1000); System.out.println("Cost: " + Profiler.end() + " mills"); &#125;&#125; 4 线程应用实例4.1 等待超时模式调用一个方法时等待一段时间，如果该方法能够在给定的时间段之内得到结果，那么将结果立即返回，反之，超时返回默认结果。假设超时时间为 T ，那么在 now + T 之后就会超时。 12345678910public synchronized Object get(long t) &#123; long now = System.currentTimeMillis(); long future = now + t; long remaining = t; while (result == null &amp;&amp; remaining &gt; 0) &#123; wait(remaining); remaining = future - System.currentTimeMillis(); &#125; return result;&#125; 4.2 一个简单的数据库连接池示例主干代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ConnectionPool &#123; private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;(); public ConnectionPool(int initialSize) &#123; if (initialSize &gt; 0) &#123; for (int i = 0; i &lt; initialSize; i++) &#123; pool.addLast(ConnectionDriver.createConnection()); &#125; &#125; &#125; public void releaseConnection(Connection connection) &#123; if (connection != null) &#123; synchronized (pool) &#123; pool.addLast(connection); pool.notifyAll(); &#125; &#125; &#125; public Connection fetchConnection(long mills) throws InterruptedException &#123; synchronized (pool) &#123; if (mills &lt;= 0) &#123; while (pool.isEmpty()) &#123; pool.wait(); &#125; return pool.removeFirst(); &#125; else &#123; long future = System.currentTimeMillis() + mills; long remaining = mills; while (pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123; pool.wait(remaining); remaining = future - System.currentTimeMillis(); &#125; Connection result = null; if (!pool.isEmpty()) &#123; result = pool.removeFirst(); &#125; return result; &#125; &#125; &#125;&#125; 4.3 线程池技术主干代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123; private static final int MAX_WORKER_NUMBERS = 10; private static final int DEFAULT_WORKER_NUMBERS = 5; private static final int MIN_WORK_NUMBERS = 1; // 任务列表 private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;&gt;(); // 工作者列表，即保存着所有的消费者列表 private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;()); // 工作线程的数量 private int workerNum = DEFAULT_WORKER_NUMBERS; // 线程编号 private int threadNum = 0; @Override public void execute(Job job) &#123; if (job != null) &#123; synchronized (jobs) &#123; jobs.addLast(job); jobs.notify(); &#125; &#125; &#125; @Override public void shutdown() &#123; for (Worker worker : workers) &#123; worker.shutdown(); &#125; &#125; @Override public void addWorkers(int num) &#123; synchronized (jobs) &#123; if (num + this.workerNum &gt; MAX_WORKER_NUMBERS) &#123; num = MAX_WORKER_NUMBERS - this.workerNum; &#125; initializeWorkers(num); this.workerNum += num; &#125; &#125; /** * 移除工作线程，即移除消费者 */ @Override public void removeWorker(int num) &#123; synchronized (jobs) &#123; if (num &gt;= this.workerNum) &#123; throw new IllegalArgumentException("beyond workNum"); &#125; int count = 0; while (count &lt; num) &#123; Worker worker = workers.get(count); if (workers.remove(worker)) &#123; worker.shutdown(); count++; &#125; &#125; this.workerNum -= count; &#125; &#125; @Override public int getJobSize() &#123; return jobs.size(); &#125; // 初始化工作者 private void initializeWorkers(int num) &#123; for (int i = 0; i &lt; num; i++) &#123; Worker worker = new Worker(); workers.add(worker); Thread thread = new Thread(worker, "ThreadPool-Worker-" + threadNum++); thread.start(); &#125; &#125; // 工作者，即消费者，负责消费任务 class Worker implements Runnable &#123; // 允许外界控制是否停止 private volatile boolean running = true; @Override public void run() &#123; while (running) &#123; Job job = null; synchronized (jobs) &#123; while (jobs.isEmpty()) &#123; try &#123; jobs.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); return; &#125; &#125; // 取出一个Job job = jobs.removeFirst(); &#125; if (job != null) &#123; job.run(); &#125; &#125; &#125; public void shutdown() &#123; running = false; &#125; &#125;&#125; 4.4 小结]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Java并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五、Java中的锁]]></title>
    <url>%2F2017%2F11%2F07%2Fconcurrent-art%2F5.html%2F</url>
    <content type="text"><![CDATA[1 Lock 接口2. 队列同步器队列同步器 AbstractQueueSynchronizer （简称同步器），是用来构建锁或者其它同步组件的基础框架，它使用了一个 int 成员变量表示同步状态， 通过内置的 FIFO 队列完成资源获取线程的排队工作。 2.1 队列同步器的接口与示例同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者， 它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。 锁和同步器很好地隔离了使用者和实现者所需关注的领域。 只有掌握了同步器的工作原理才能更加深入地理解并发包中其它的并发组件，所以下面通过一个独占锁的实例来深入了解一下同步器的工作原理。 独占锁就是在同一时刻只能由一个线程获取到锁，而其它获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁，代码5-2如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Mutex implements Lock&#123; // 静态内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer &#123; // 是否处于占用状态 @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; @Override public boolean tryAcquire(int acquires) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; @Override protected boolean tryRelease(int releases) &#123; if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; private final Sync sync = new Sync(); @Override public void lock() &#123; sync.acquire(1); &#125; @Override public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; sync.release(1); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads()&#123; return sync.hasQueuedThreads(); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override public Condition newCondition() &#123; return sync.newCondition(); &#125;&#125; 2.2 队列同步器的实现分析分析同步器如何完成线程同步的，包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模块方法。 2.2.1 同步队列当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点 （Node） 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时， 会把首节点中的线程唤醒，使其再次尝试获取同步状态。试想，当一个线程成功地获取了同步状态（锁），其它线程将无法获取到同步状态，转而被构造称为节点并加入到同步队列中，而这个加入队列的过程必须要 保证线程安全，因此同步器提供了一个基于 CAS 线程的设置尾节点的方法： compareAndSetTail(Node expect, Node update) ，它需要传递当前“认为” 的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点： 设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证。 2.2.2 独占式同步状态获取与释放通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程 进行中断操作时，线程不会从同步队列中移出，源码如下： 1234public final void acquire(int arg) &#123; if(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 3 重入锁ReenTrantLock，支持重入的锁。 3.1 实现重进入这个特性需要解决两个问题： 线程再次获取锁。锁需要去识别获取锁额线程是否为当前占据锁的线程，如果是，则再次成功获取。 锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放锁后，其它线程能够获取到锁。要求对获取进行计数自增，释放时计数自减。 获取锁源码： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 释放锁源码： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 3.2 公平与非公平获取锁的区别如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。源码如下： 12345678910111213141516171819protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 其中相对于非公平锁的获取，多了一个 hasQueuedPredecessors() 判断，判断是否当前节点是否有前驱节点的判断。 如果有 n 个线程争夺锁。对于公平锁来说，保证了每个线程都可以获取锁，即有 n 次线程切换。而对于非公平锁来说，有可能有的线程能获取多次锁， 有的线程根本获取不到锁，线程切换次数是小于 n 的。因此减去上下文的切换时间，非公平锁的效率更高，所以 ReentrantLock 默认为非公平锁。 4 读写锁在没有读写锁支持的时候（Java5之前），使用 Java 的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并行通知后， 所有等待的读操作才能继续执行（写操作之间依靠 synchronized 关键字进行同步）。 一般来说，读写锁的性能都会比排他锁好（ReentrantLock 也是一种排他锁），因为大多数场景读是多于写的。Java并发包提供读写锁的实现是 ReentrantReadWriteLock。 4.1 读写锁的接口与示例通过缓存示例说明读写锁的使用方式，代码5-16： 12345678910111213141516171819202122232425262728293031323334353637public class Cache &#123; static Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); static Lock r = rwl.readLock(); static Lock w = rwl.writeLock(); public static final Object get(String key) &#123; r.lock(); try &#123; return map.get(key); &#125; finally &#123; r.unlock(); &#125; &#125; public static final Object put(String key, String value) &#123; w.lock(); try &#123; return map.put(key, value); &#125; finally &#123; w.unlock(); &#125; &#125; public static final void clear() &#123; w.lock(); try &#123; map.clear(); &#125; finally &#123; w.unlock(); &#125; &#125;&#125; 使用非线程安全的 HashMap 作为缓存的实现。使用读写锁提升读操作的并发性，并简化了编程方式。 4.2 读写锁的实现分析4.2.1 读写状态的设计读写锁依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态 （一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。 如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。当前图的同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。 假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF（将高16位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1,， 当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。 根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。 4.2.2 写锁的获取与释放写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态，获取锁的源码如下： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); int w = exclusiveCount(c); if (c != 0) &#123; // 存在读锁或者当前获取线程不是已经获取写锁的线程 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); // Reentrant acquire setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true;&#125; 4.2.3 读锁的获取与释放读锁是一个支持重进入的共享锁，能被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。 如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如 getReadHoldCount() 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的综合，而每个线程各自获取读锁的次数只能选择 保存在 ThreadLocal 中，由线程自身维护，这使得获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分： 123456789101112protected final int tryAcquireShared(int unused) &#123; for (;;) &#123; int c = getState(); int nextc = c + (1 &lt;&lt; 16); if (nextc &lt; c) throw new Error("Maximum lock count exceeded"); if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread()) return -1; if (compareAndSetState(c, nextc)) return 1; &#125;&#125; 如果其它线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，成功获取读锁。 4.2.4 锁降级锁降级指的是写锁降级称为读锁。获取写锁-释放写锁-获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指：获取写锁-获取读锁-释放写锁。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Java并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[六、Java并发容器和框架]]></title>
    <url>%2F2017%2F11%2F07%2Fconcurrent-art%2F6.html%2F</url>
    <content type="text"><![CDATA[1 ConcurrentHashMap 的实现原理与使用1.1 为什么要使用 ConcurrentHashMap 线程不安全的 HashMap ，在多线程下 HashMap 的 Entry 链表导致形成环形数据结构， Entry 的 next 节点永远不为空，就会产生死循环获取 Entry 。 效率低下的 HashTable ，使用 synchronized 保证线程安全。 ConcurrentHashMap 的锁分段技术有效提升并发访问率。 HashTable 效率低下是因为所有访问 HashTable 的线程都必须竞争同一把锁，如果容器里 有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程就不会存在锁竞争。 1.2 ConcurrentHashMap 的结构ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁（ReentrantLock）， Segment的结构和 HashMap 结构类似。 1.3 ConcurrentHashMap 的初始化 初始化 segments 数组 初始化 segmentShift 和 segmentMask。用于散列算法的一些值。 初始化每个 segment，包括容量以及负载因子。 1.4 ConcurrentHashMap 的操作1.4.1 get 操作get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。如何保证不加锁？原因在于它的 get 方法里将要使用的共享变量都 定义成 volatile 类型，如用于统计当前 Segment 大小的 count 字段和用于存储值的 HashEntry 的 value 。但只能被单线程写（有一种情况可以被 多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value ，所以不需要加锁。即使两个线程同时修改和获取 volatile 变量， get 操作也能拿到最新的值，这是用 volatile 替换锁的经典应用场景。 1.4.2 put 操作必须加锁。先定位到 Segment ，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对 Segment 里的 HashEntry 数组 进行扩容，第二步定位添加元素的位置，然后将其放在 HashEntry 数组里。 是否需要扩容：插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量，如果超过阈值，则对数组进行扩容。 如何扩容：先创建一个容量是原来容量两倍的数组，然后将原数组里元素进行散列后插入到新的数组里。为了高效， 只会对某个 Segment 进行扩容。 1.4.3 size 操作每个 Segment 的count 是 valatile 变量，但是累加过程中有可能 count 发生变化，最安全的做法是在统计 size 的时候把所有 Segment 的 put、 remove 和 clean 方法全部锁住，但是非常低效。所以 ConcurrentHashMap 的做法是尝试 2 次通过不锁住 Segment 的方式来统计累和，如果 count 发生变化，再采用加锁方式统计。如果判断count 发生变化呢？使用 modCount 变量。 2 ConcurrentLinkedQueue实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。前者可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队 用不同的锁）等方式实现。非阻塞的实现则可以使用循环 CAS 的方式来实现。 2.1 ConcurrentLinkedQueue 的结构由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成。默认情况下 head 节点存储的元素为空， tail 节点等于 head 节点。 2.2 入队列2.2.1 入队列的过程 添加元素1。队列更新 head 节点的 next 节点为元素1节点，又因为 tail 节点默认情况下等于 head 节点，所以它们的 next 节点都指向元素1节点。 添加元素2。队列首先设置元素1节点的 next 节点为元素2节点，然后更新 tail 节点指向元素2节点。 添加元素3。设置 tail 节点的 next 节点为元素3节点。 添加元素4。设置元素3的 next 节点为元素4节点，然后将 tail 节点指向元素4节点。入队主要做两件事：一是将入队节点设置成当前队列尾节点的下一个节点；二是更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成 tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。 在代码中，入队主要做两件事：一是定位出尾节点（通过 tail 的 next 是否为空）；二是使用 CAS 算法将入队队列设置成尾节点的 next 节点，如不成功则重试。 （进行 tail 的 next 判断是否为空时，如果循环两次都不为空，则重新进行队列，因为肯定有别的线程加了尾）。源码如下： 123456789101112131415161718192021222324252627282930313233343536public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 入队前，创建一个入队节点 Node&lt;E&gt; n = new Node&lt;E&gt;(e); retry: // 死循环，入队不成功反复入队。 for (;;) &#123; // 创建一个指向tail节点的引用 Node&lt;E&gt; t = tail; // p用来表示队列的尾节点，默认情况下等于tail节点。 Node&lt;E&gt; p = t; for (int hops = 0; ; hops++) &#123; // 获得p节点的下一个节点。 Node&lt;E&gt; next = succ(p); // next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点 if (next != null) &#123; // 循环了两次及其以上，并且当前节点还是不等于尾节点 if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; &#125; // 如果p是尾节点，则设置p节点的next节点为入队节点。 else if (p.casNext(null, n)) &#123; /*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点， 更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/ if (hops &gt;= HOPS) casTail(t, n); // 更新tail节点，允许失败 return true; &#125; // p有next节点,表示p的next节点是尾节点，则重新设置p节点 else &#123; p = succ(p); &#125; &#125; &#125;&#125; 2.2.2 定位尾节点通过判断 tail 节点和 tail 节点的 next 节点。 2.2.3 HOPS 的设计意图用如下实现是否可行： 1234567891011public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; n = new Node&lt;E&gt;(e); for (;;) &#123; Node&lt;E&gt; t = tail; if (t.casNext(null, n) &amp;&amp; casTail(t, n)) &#123; return true; &#125; &#125;&#125; 让 tail 节点永远作为队列的尾节点，这样实现代码量非常少。但是有个缺点是，每次都要更新 tail 节点为尾节点，而使用 HOPS 常量，进行判断，如果 当 tail 节点和尾节点的距离大于等于常量 HOPS 的值（默认等于1）时才更新 tail 节点，来通过增加对 volatile 变量的读操作来减少对 volatile 变量 的写操作，入队效率提升。 2.3 出队列只有当 head 节点里没有元素时，出队操作才会更新 head 节点。这种做法也是通过 hops 变量来减少使用 CAS 更新 head 节点的消耗，从而提高出队效率。 3 Java 中的阻塞队列3.1 什么是阻塞队列阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。 支持阻塞的插入方法：意思当队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 3.2 Java 里的阻塞队列 类名 描述 ArrayBlockingQueue 一个由数组结构组成的有界阻塞队列 LinkedBlockingQueue 一个由链表结构组成的有界阻塞队列 PriorityBlockingQueue 支持优先级排序的无界阻塞队列 DelayQueue 使用优先级队列实现的无界阻塞队列 SynchronousQueue 不存储元素的阻塞队列 LinkedTransferQueue 由链表结构组成的无界阻塞队列 LinkedBlockingDeque 由链表结构组成的双向阻塞队列 3.3 阻塞队列的实现原理3.3.1 使用通知模式实现即当生产者往满的队列里添加元素时会阻塞住消费者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。 4 Fork/Join 框架4.1 什么是 Fork/Join 框架Fork 就是把一个大任务切分为若干子任务并行的执行， Join 就是合并这些子任务的执行结果。 4.2 工作窃取算法某个线程先把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理，这时候，完成任务的线程去做还有任务的线程的任务。 优点：充分利用线程进行并行计算，减少线程间的竞争。 缺点：如果只有一个任务时，还是会有竞争。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。 4.3 Fork/Join 框架的设计 分割任务：首先我们需要由一个 fork 类来把大任务分割成小任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。 执行任务并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里， 启动一个线程从队列里里拿数据，然后合并这些数据。 Fork/Join 使用两个类来完成以上两件事。 ForkJoinTask：我们要使用 ForkJoin框架，必须首先创建一个 Fork/Join 任务。它提供在任务中执行 fork() 和 join() 操作的机制。通常情况下， 我们只需要继承它的子类，而 Fork/Join 框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务； RecursiveTask：用于有返回结果的任务。 ForkJoinPool：ForkJoinTask 需要通过 ForkJoinPool 来执行：任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。 当一个工作线程的队列里暂时没有任务时，它会随机从其它工作线程的队列的尾部 获取一个任务。 4.4 使用 Fork/Join 框架需求：计算1+2+3+4的结果。如果希望每个子任务最多执行两个数的相加，我们设置分割的阈值是2，由于是4个数字相加，所以fork成两个子任务，一个计算1+2，一个计算3+4，然后再join两个子任务。 由于有结果的任务，因此继承 RecursiveTask。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CountTask extends RecursiveTask&lt;Integer&gt;&#123; private static final int THRESHOLD = 2; // 阈值 private int start; private int end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; boolean canCompute = (end - start) &lt;= THRESHOLD; // 如果任务足够小就计算任务 if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待子任务执行完，并得到其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); // 生成一个计算任务，负责计算1+2+3+4 CountTask task = new CountTask(1, 4); Future&lt;Integer&gt; result = forkJoinPool.submit(task); try &#123; System.out.println(result.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.5 Fork/Join 框架的实现原理ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成， ForkJoinTask 数组负责将存放程序提交给 ForkJoinPool 的任务， 而 ForkJoinWorkerThread 数组负责执行这些任务。 4.5.1 ForkJoinTask 的 fork 方法实现原理使用 push 方法，把当前任务存放在 ForkJoinTask 数组队列中，再调用 ForkJoinPool 的 signalWork() 方法唤醒或创建一个工作线程来异步的执行这个任务， 然后立即返回结果。 123456789101112131415161718192021222324public final ForkJoinTask&lt;V&gt; fork() &#123; Thread t; if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ((ForkJoinWorkerThread)t).workQueue.push(this); else ForkJoinPool.common.externalPush(this); return this;&#125;final void push(ForkJoinTask&lt;?&gt; task) &#123; ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p; int b = base, s = top, n; if ((a = array) != null) &#123; // ignore if queue removed int m = a.length - 1; // fenced write for task visibility U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task); U.putOrderedInt(this, QTOP, s + 1); if ((n = s - b) &lt;= 1) &#123; if ((p = pool) != null) p.signalWork(p.workQueues, this); &#125; else if (n &gt;= m) growArray(); &#125;&#125; 4.5.2 ForkJoinTask 的 join 方法实现原理Join 方法主要用于阻塞当前线程并等待获取结果。调用 doJoin() 方法，通过查看任务状态，如果执行完则直接返回任务状态；如果没执行完， 则从任务数组里取出任务并执行。 12345678910111213141516171819202122 public final V join() &#123; int s; if ((s = doJoin() &amp; DONE_MASK) != NORMAL) reportException(s); return getRawResult();&#125;private void reportException(int s) &#123; if (s == CANCELLED) throw new CancellationException(); if (s == EXCEPTIONAL) rethrow(getThrowableException());&#125;private int doJoin() &#123; int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w; return (s = status) &lt; 0 ? s : ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ? (w = (wt = (ForkJoinWorkerThread)t).workQueue). tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s : wt.pool.awaitJoin(w, this, 0L) : externalAwaitDone();&#125;]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Java并发编程的艺术</category>
      </categories>
  </entry>
</search>
