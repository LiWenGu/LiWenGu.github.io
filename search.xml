<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>暂不更新</title>
      <link href="/2021/07/05/talker/no_update.html/"/>
      <url>/2021/07/05/talker/no_update.html/</url>
      
        <content type="html"><![CDATA[<p>最近组织了同事们一起系统的学习例如像 Kafka、Elasticsearch、JVM、Dubbo、公司整体系统架构、业务架构的俱乐部。因此私人就暂时不更新。俱乐部博客：<a href="https://lie-flat-club.gitee.io/juan/。" target="_blank" rel="noopener">https://lie-flat-club.gitee.io/juan/。</a></p><ol><li>愿景：技术能力拉满，业务能力拉满，公共分享能力拉满。</li><li>落地：每1~2天就分享一次。</li><li>奥利给！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2021/25周总结</title>
      <link href="/2021/06/21/2021/25.html/"/>
      <url>/2021/06/21/2021/25.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>周五淋雨，去打羽毛球。接着周末两天下雨，就没去公司学习，在租房堕落了两天。</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/C4636A6A-3A64-471D-BA73-FFC07E1D0FE4_1_105_c.jpeg" alt="风云战国之列国"></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>科目一的理论终于学完，准备在第26周就要报名科目一了。</li><li>画画在B站学习素描。</li><li>作息调整的还可以。</li><li>基本都在弄 SkyWalking 的二开，每次学习都有新的体会。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>科目一！</li><li>画画习惯</li><li>SkyWalking 需要有个总结博客</li><li>作息习惯</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>能回到正轨就好。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2021/24周总结</title>
      <link href="/2021/06/15/2021/24.html/"/>
      <url>/2021/06/15/2021/24.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>这个端午过的有点丰富。</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210615231526.png" alt="风云战国之列国"></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>上周的端午节放了三天假，自己因为个人感情问题一直留在杭州，第一天放假在公司学习，第二天放假在租房玩耍，第三天放假和同事打乒乓球~</li><li>上周工作日也比较丰富，主要是在做skywalking的适应工作。</li><li>博客重新从语雀回到了个人博客有点不习惯。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>争取能报名科目一，浙江的科目一确实好复杂，还要看理论培训。时间被拉长了。</li><li>晚上12点前睡觉。</li><li>养成好的作息和学习习惯。现在学习主要是在周末公司学习，平常因为工作忙，而且最近 dota2 有 major 比赛，工作日回来后就看视频娱乐了。</li><li>买了平板希望自己能在业余时间学会画画吧，之前画画还是在高中，一直念念不忘想学会画画。</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>希望能更好。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>skywalking-service-traffic的交互</title>
      <link href="/2021/06/12/tech/apm/skywalking_2_service-traffic.html/"/>
      <url>/2021/06/12/tech/apm/skywalking_2_service-traffic.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>此文源于在二开 SkyWalking 时，发现公司搭建的 SkyWalking 当前服务列表有时候会显示不出来已经接入的应用，在排查和解决过程中的总结。<br><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/90ECDCD7-2CE1-4FBD-B7F0-E9979FD42F0B_1_105_c.jpeg" alt="和亲戚孩子拼的机器人"></p><a id="more"></a><h1 id="1-后台界面显示位置"><a href="#1-后台界面显示位置" class="headerlink" title="1. 后台界面显示位置"></a>1. 后台界面显示位置</h1><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210612145841.png" alt="后台服务列表"></p><p>在当前服务的列表栏，会显示 service_traffic 表的数据，在存储层的 service_traffic 数据格式如下:</p><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210612150120.png" alt="存储层服务流量表"></p><p>目前只发现有两个字段有用，一个是 name 字段，一个是 node_type 字段，而 node_type 在枚举 <code>org.apache.skywalking.oap.server.core.analysis.NodeType</code> 中定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NodeType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Normal = 0;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * This node type would be treated as an observed node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Normal(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Database = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Database(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;RPCFramework = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RPCFramework(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Http = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Http(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;MQ = 4;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MQ(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Cache = 5;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Cache(<span class="number">5</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Browser = 6;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * This node type would be treated as an observed node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Browser(<span class="number">6</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;User = 10&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User(<span class="number">10</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Unrecognized = 11&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Unrecognized(<span class="number">11</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在发现有的应用接入 Skywalking 并启动后，但是在 <code>service_traffic</code> 表中没有显示，而相关的信息，例如 jvm 上报信息，以及实例的信息都是可以在数据中查到的。</p><blockquote><p>服务的实例相关信息可以在 <code>instance_traffic</code> 表中查询，其中 <code>service_id</code> 字段是 <code>service_traffic</code> 表的 <code>name</code> 字段的 base64 编码 + “.1”，例如 name 为 a1 的服务，它的 service_id 为：base64(“a1”) + “.1”。这里我也二开改过，原生会在后面加上随机数。</p></blockquote><h1 id="2-client-上传-service-traffic-信息"><a href="#2-client-上传-service-traffic-信息" class="headerlink" title="2. client 上传 service_traffic 信息"></a>2. client 上传 service_traffic 信息</h1><p>目前 client 会在上传 segment 的时候才会顺带将 service_traffic 信息上报，其实这里已经知道为什么我们应用接入 Skywalking，但是没有应用服务的信息，因为虽然产生了 jvm 以及实例机器的相关信息，但是没有产生让 plugin 拦截的 segment 上报导致。</p><p>以 kafka 为例，在客户端上传 segment 的地方，<code>org.apache.skywalking.apm.agent.core.kafka.KafkaTraceSegmentServiceClient</code> 该类负责客户端的 segment 的信息上传。topic 为 <code>skywalking-segment</code>。上报格式为 <code>apm-protocol/apm-network/src/main/proto/language-agent/Tracing.proto:50</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message SegmentObject &#123;</span><br><span class="line">    string traceId = 1;</span><br><span class="line"></span><br><span class="line">    string traceSegmentId = 2;</span><br><span class="line"></span><br><span class="line">    repeated SpanObject spans = 3;</span><br><span class="line"></span><br><span class="line">    // 上传的 appname</span><br><span class="line">    string service = 4;</span><br><span class="line"></span><br><span class="line">    string serviceInstance = 5;</span><br><span class="line"></span><br><span class="line">    bool isSizeLimited = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端批量一个一个的将 segment 上传后，等待 oap 的处理。</p><h1 id="3-oap-接收-segment-信息，并顺带处理-service-traffic-信息"><a href="#3-oap-接收-segment-信息，并顺带处理-service-traffic-信息" class="headerlink" title="3. oap 接收 segment 信息，并顺带处理 service_traffic 信息"></a>3. oap 接收 segment 信息，并顺带处理 service_traffic 信息</h1><p>oap 服务端通过 <code>org.apache.skywalking.oap.server.analyzer.agent.kafka.provider.handler.TraceSegmentHandler</code> 接收来自客户端的 segment 信息。最终会走到 <code>ServiceTrafficDispatcher</code> 分发器类做分发处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTrafficDispatcher</span> <span class="keyword">implements</span> <span class="title">SourceDispatcher</span>&lt;<span class="title">Service</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="keyword">final</span> Service source)</span> </span>&#123;</span><br><span class="line">        ServiceTraffic traffic = <span class="keyword">new</span> ServiceTraffic();</span><br><span class="line">        traffic.setTimeBucket(source.getTimeBucket());</span><br><span class="line">        traffic.setName(source.getName());</span><br><span class="line">        traffic.setNodeType(source.getNodeType());</span><br><span class="line">        MetricsStreamProcessor.getInstance().in(traffic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及两个核心的类，一个是 <code>SourceDispatcher</code>，源数据处理分发器，它的实现类有很多，通过 <code>dispatch</code> 方法的入参 <code>org.apache.skywalking.oap.server.core.source.Service#scope</code> 方法来判断走哪个分发器，具体代码可以在 <code>org.apache.skywalking.oap.server.core.analysis.DispatcherManager</code> 中查看。</p><p>另一个核心的类是 <code>StreamProcessor</code> 流式处理器类，此类一般和 <code>SourceDispatcher</code> 结合使用，例如上面 <code>ServiceTrafficDispatcher</code> 就在获取到源数据后，通过 <code>MetricsStreamProcessor</code> 做流式处理。</p><blockquote><p>这里的流式处理较为复杂，涉及到 dataCarrier，多生产者多消费者，其中多生产者是各种数据通过流式处理塞入 dataCarrier，而多消费者指的是两个：AggregatorConsumer、PersistentConsumer，前者用于 metrics 指标聚合，后者用于将 metrics 指标存库。</p></blockquote><p>在流式处理过程中，会走到 <code>org.apache.skywalking.oap.server.core.analysis.worker.MetricsRemoteWorker</code> 该 metrics 分析方法。该方法用于是否将当前的 metrics 信息传递给其它的 oap 角色。注意：<code>service_traffic</code> 也是 metrics 的一种。通过 <code>service_traffic</code> 表字段 <code>time_bucket</code> 也可以猜测的到，它也有自己的时间桶。</p><h1 id="4-oap-存-service-traffic-入库过程"><a href="#4-oap-存-service-traffic-入库过程" class="headerlink" title="4. oap 存 service_traffic 入库过程"></a>4. oap 存 service_traffic 入库过程</h1><p>当 <code>service_traffic</code> 作为 metrics 的一种存入 datacarrier 后，会被 <code>org.apache.skywalking.oap.server.core.analysis.worker.MetricsPersistentWorker.PersistentConsumer</code> 取出并消费，将一段时间的客户端的 <code>service_triffic</code> 信息聚合，并存入 <code>org.apache.skywalking.oap.server.core.analysis.data.ReadWriteSafeCache</code> 该缓存中，而 <code>org.apache.skywalking.oap.server.core.storage.PersistenceTimer</code> 会通过定时任务，定时的取出 <code>ReadWriteSafeCache</code> 中的 metrics 信息，当然也包括了 <code>service_traffic</code> 信息。最终通过 <code>org.apache.skywalking.oap.server.core.analysis.worker.MetricsPersistentWorker#flushDataToStorage</code> 存入数据库，这里看下该方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法用于所有 metrics 的存库方法，不仅仅是 service_traffic 信息。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">flushDataToStorage</span><span class="params">(List&lt;Metrics&gt; metricsList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    List&lt;PrepareRequest&gt; prepareRequests)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先从数据库中获取该次 metrics 信息，并存入 context 中</span></span><br><span class="line">        loadFromStorage(metricsList);</span><br><span class="line">        <span class="keyword">for</span> (Metrics metrics : metricsList) &#123;</span><br><span class="line">            <span class="comment">// 判断当前 metrics 是否已经在数据库中有了</span></span><br><span class="line">            Metrics cachedMetrics = context.get(metrics);</span><br><span class="line">            <span class="keyword">if</span> (cachedMetrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * If the metrics is not supportUpdate, defined through MetricsExtension#supportUpdate,</span></span><br><span class="line"><span class="comment">                    * then no merge and further process happens.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                <span class="comment">// service_traffic 就是不允许更新的，只允许插入，也就是说</span></span><br><span class="line">                <span class="comment">// 某个应用只有接入过 skywalking，并写入了 service_traffic</span></span><br><span class="line">                <span class="comment">// 那么永远都会有该应用的列表，即便后面卸载了 skywalking</span></span><br><span class="line">                <span class="keyword">if</span> (!supportUpdate) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Merge metrics into cachedMetrics, change only happens inside cachedMetrics.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                <span class="comment">// 将数据库中的 metrics 信息和当前实时获取的 metrics 信息做聚合</span></span><br><span class="line">                cachedMetrics.combine(metrics);</span><br><span class="line">                cachedMetrics.calculate();</span><br><span class="line">                <span class="comment">// instance_traffic 表更新客户端实例信息</span></span><br><span class="line">                prepareRequests.add(metricsDAO.prepareBatchUpdate(model, cachedMetrics));</span><br><span class="line">                nextWorker(cachedMetrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// service_traffic 写入es</span></span><br><span class="line">                metrics.calculate();</span><br><span class="line">                prepareRequests.add(metricsDAO.prepareBatchInsert(model, metrics));</span><br><span class="line">                nextWorker(metrics);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * The `metrics` should be not changed in all above process. Exporter is an async process.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            nextExportWorker.ifPresent(exportEvenWorker -&gt; exportEvenWorker.in(</span><br><span class="line">                <span class="keyword">new</span> ExportEvent(metrics, ExportEvent.EventType.INCREMENT)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(t.getMessage(), t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        metricsList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，oap 就将 <code>service_traffic</code>(metrics 的一种)，获取并存入了库。</p><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>从上面分析可看出，<code>service_traffic</code> 是不大合理的，有以下几点：</p><ol><li>只有插入，没有更新和删除</li><li>只有在客户端 segment 上报时，该信息才会上报。</li></ol><p>因此对该不合理的地方做了二开，一是利用 <code>service_traffic</code> 的 time_bucket 字段，实现更新和删除。二是在客户端注册的地方，触发 <code>service_traffic</code> 的流式处理，而不是在 segment 上报的时候。</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> apm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skywalking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《干法》阅读总结</title>
      <link href="/2021/06/01/readbook/996.html/"/>
      <url>/2021/06/01/readbook/996.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/9854420.jpg" alt="背景"></p><a id="more"></a><ol><li>工作是为了：提升心志，磨炼人性。</li><li>工作要注重自省，大智若愚。</li><li>工作要带有明确目标。并不断的更新和树立自己的目标。</li><li>持续的力量。</li><li>一旦奢侈，就会傲慢。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 干法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>skywalking-profile原理</title>
      <link href="/2021/05/29/tech/apm/skywalking_1_profile.html/"/>
      <url>/2021/05/29/tech/apm/skywalking_1_profile.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>此文源于在二开 SkyWalking 时，发现公司搭建的 SkyWalking 性能剖析不能生效，在排查过程中学到了很多，因此记录下来方便对 SkyWalking 的性能剖析功能有更深的理解。</p><a id="more"></a><h1 id="1-最开始的地方：后台创建性能剖析任务"><a href="#1-最开始的地方：后台创建性能剖析任务" class="headerlink" title="1. 最开始的地方：后台创建性能剖析任务"></a>1. 最开始的地方：后台创建性能剖析任务</h1><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210529161727.png" alt="创建性能剖析任务"></p><h2 id="1-1-后台接收-profile-任务创建请求"><a href="#1-1-后台接收-profile-任务创建请求" class="headerlink" title="1.1 后台接收 profile 任务创建请求"></a>1.1 后台接收 profile 任务创建请求</h2><p>当创建任务时，oap 服务会通过内嵌的 org.apache.skywalking.oap.server.library.server.jetty.JettyJsonHandler.doPost 处理。而 GraphQLQueryHandler 是实际处理类，因为 GraphQLQueryHandler 继承自 JettyJsonHandler 类。</p><p>这是 org.apache.skywalking.oap.query.graphql.GraphQLQueryHandler#execute 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 oap 的 http post 请求</span></span><br><span class="line"><span class="comment">     * 以性能剖析任务创建为例，这是 graphql 的定义：server-query-plugin/query-graphql-plugin/resources/query-protocol/profile.graphqls</span></span><br><span class="line"><span class="comment">     * 而真正执行的 java 代码为：org.apache.skywalking.oap.query.graphql.resolver.ProfileMutation#createProfileTask()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request    oap 的后台查询语法有两个参数，一个是 query，包含要执行的类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> variables  还有一个是 variables 参数，包含要执行的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JsonObject <span class="title">execute</span><span class="params">(String request, Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutionInput executionInput = ExecutionInput.newExecutionInput()</span><br><span class="line">                                                          .query(request)</span><br><span class="line">                                                          .variables(variables)</span><br><span class="line">                                                          .build();</span><br><span class="line">            <span class="comment">// 通过 graphQL 语法找到真正执行的类方法，性能剖析的创建处理类为：ProfileMutation#createProfileTask()</span></span><br><span class="line">            ExecutionResult executionResult = graphQL.execute(executionInput);</span><br><span class="line">            LOGGER.debug(<span class="string">"Execution result is &#123;&#125;"</span>, executionResult);</span><br><span class="line">            Object data = executionResult.getData();</span><br><span class="line">            List&lt;GraphQLError&gt; errors = executionResult.getErrors();</span><br><span class="line">            JsonObject jsonObject = <span class="keyword">new</span> JsonObject();</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jsonObject.add(DATA, gson.fromJson(gson.toJson(data), JsonObject.class));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(errors)) &#123;</span><br><span class="line">                JsonArray errorArray = <span class="keyword">new</span> JsonArray();</span><br><span class="line">                errors.forEach(error -&gt; &#123;</span><br><span class="line">                    JsonObject errorJson = <span class="keyword">new</span> JsonObject();</span><br><span class="line">                    errorJson.addProperty(MESSAGE, error.getMessage());</span><br><span class="line">                    errorArray.add(errorJson);</span><br><span class="line">                &#125;);</span><br><span class="line">                jsonObject.add(ERRORS, errorArray);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> jsonObject;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-从-graphqls-定位到具体的执行类"><a href="#1-2-从-graphqls-定位到具体的执行类" class="headerlink" title="1.2 从 graphqls 定位到具体的执行类"></a>1.2 从 graphqls 定位到具体的执行类</h2><p>我们看下 http 的入参：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: <span class="string">"mutation createProfileTask($creationRequest: ProfileTaskCreationRequest) &#123;\n  createTask: createProfileTask(creationRequest: $creationRequest) &#123;\n    id\n    errorReason\n  &#125;\n  &#125;"</span>,</span><br><span class="line">    <span class="attr">"variables"</span>: &#123;</span><br><span class="line">        <span class="attr">"creationRequest"</span>: &#123;</span><br><span class="line">            <span class="attr">"serviceId"</span>: <span class="string">"ZHViYm8tZXhhbXBsZS1jb25zdW1lcg==.1"</span>,</span><br><span class="line">            <span class="attr">"endpointName"</span>: <span class="string">"/api/users"</span>,</span><br><span class="line">            <span class="attr">"startTime"</span>: <span class="number">1622276464546</span>,</span><br><span class="line">            <span class="attr">"duration"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"minDurationThreshold"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"dumpPeriod"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">"maxSamplingCount"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到了要执行的类方法以及参数。<br>接着看</p><p>server-query-plugin/query-graphql-plugin/resources/query-protocol/profile.graphqls 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">extend type Mutation &#123;</span><br><span class="line">    # crate new profile task</span><br><span class="line">    createProfileTask(creationRequest: ProfileTaskCreationRequest): ProfileTaskCreationResult!</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后定位到 ProfileMutation 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * profile mutation GraphQL resolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileMutation</span> <span class="keyword">implements</span> <span class="title">GraphQLMutationResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProfileTaskCreationResult <span class="title">createProfileTask</span><span class="params">(ProfileTaskCreationRequest creationRequest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProfileTaskService().createTask(creationRequest.getServiceId(), creationRequest.getEndpointName() == <span class="keyword">null</span> ? <span class="keyword">null</span> : creationRequest</span><br><span class="line">            .getEndpointName()</span><br><span class="line">            .trim(), creationRequest.getStartTime() == <span class="keyword">null</span> ? -<span class="number">1</span> : creationRequest.getStartTime(), creationRequest.getDuration(), creationRequest</span><br><span class="line">            .getMinDurationThreshold(), creationRequest.getDumpPeriod(), creationRequest.getMaxSamplingCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-profile-task-任务存储"><a href="#1-3-profile-task-任务存储" class="headerlink" title="1.3 profile task 任务存储"></a>1.3 profile task 任务存储</h2><p>最终会将任务存储到 DB 中，以 ES7 存储为例：</p><p>存储的数据结构 ProfileTaskRecord：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ScopeDeclaration</span>(id = PROFILE_TASK, name = <span class="string">"ProfileTask"</span>)</span><br><span class="line"><span class="meta">@Stream</span>(name = ProfileTaskRecord.INDEX_NAME, scopeId = PROFILE_TASK, builder = ProfileTaskRecord.Builder.class, processor = NoneStreamProcessor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileTaskRecord</span> <span class="keyword">extends</span> <span class="title">NoneStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_NAME = <span class="string">"profile_task"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_ID = <span class="string">"service_id"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENDPOINT_NAME = <span class="string">"endpoint_name"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String START_TIME = <span class="string">"start_time"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION = <span class="string">"duration"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MIN_DURATION_THRESHOLD = <span class="string">"min_duration_threshold"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUMP_PERIOD = <span class="string">"dump_period"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_TIME = <span class="string">"create_time"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAX_SAMPLING_COUNT = <span class="string">"max_sampling_count"</span>;</span><br></pre></td></tr></table></figure><p>在 ES 的数据：</p><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20210529171849.png" alt="ES中的profile数据"></p><h1 id="2-client-将-profile-数据传输给-oap"><a href="#2-client-将-profile-数据传输给-oap" class="headerlink" title="2. client 将 profile 数据传输给 oap"></a>2. client 将 profile 数据传输给 oap</h1><p>当 oap 服务端创建了 profile task 后，需要让客户端感知，并将对应的 endpoint 的堆栈数据发送给 oap 服务端，以供分析。</p><h2 id="2-1-client-请求-oap-创建的-profile-task"><a href="#2-1-client-请求-oap-创建的-profile-task" class="headerlink" title="2.1 client 请求 oap 创建的 profile task"></a>2.1 client 请求 oap 创建的 profile task</h2><p>agent client 通过 org.apache.skywalking.apm.agent.core.profile.ProfileTaskChannelService 中的定时任务来定时获取后端中的 profile task 列表，如下是 boot 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sender = ServiceManager.INSTANCE.findService(ProfileSnapshotSender.class);</span><br><span class="line">    <span class="comment">// 客户端开启 profile 的开关</span></span><br><span class="line">    <span class="keyword">if</span> (Config.Profile.ACTIVE) &#123;</span><br><span class="line">        <span class="comment">// query task list，定时从 oap 获取要分析的 endpoint 列表</span></span><br><span class="line">        getTaskListFuture = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">            <span class="keyword">new</span> DefaultNamedThreadFactory(<span class="string">"ProfileGetTaskService"</span>)</span><br><span class="line">        ).scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> RunnableWithExceptionProtection(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                t -&gt; LOGGER.error(<span class="string">"Query profile task list failure."</span>, t)</span><br><span class="line">            ), <span class="number">0</span>, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 将客户端收集的分析堆栈信息传输给 oap</span></span><br><span class="line">        sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">            <span class="keyword">new</span> DefaultNamedThreadFactory(<span class="string">"ProfileSendSnapshotService"</span>)</span><br><span class="line">        ).scheduleWithFixedDelay(</span><br><span class="line">            <span class="keyword">new</span> RunnableWithExceptionProtection(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    List&lt;TracingThreadSnapshot&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);</span><br><span class="line">                    snapshotQueue.drainTo(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.isEmpty()) &#123;</span><br><span class="line">                        sender.send(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                t -&gt; LOGGER.error(<span class="string">"Profile segment snapshot upload failure."</span>, t)</span><br><span class="line">            ), <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 oap 服务端获取 profile task 列表的执行逻辑 ProfileTaskChannelService.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == GRPCChannelStatus.CONNECTED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sniffer info</span></span><br><span class="line">            builder.setService(Config.Agent.SERVICE_NAME).setServiceInstance(Config.Agent.INSTANCE_NAME);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// last command create time</span></span><br><span class="line">            builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class)</span><br><span class="line">                                                                .getLastCommandCreateTime());</span><br><span class="line">            <span class="comment">// 主动跟 oap 通信，通过 grpc 查询当前应用需要开启的 profile task 列表</span></span><br><span class="line">            Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">                                                        .getProfileTaskCommands(builder.build());</span><br><span class="line">            <span class="comment">// 获取到任务列表后客户端处理该命令逻辑</span></span><br><span class="line">            ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> StatusRuntimeException)) &#123;</span><br><span class="line">                LOGGER.error(t, <span class="string">"Query profile task from backend fail."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;</span><br><span class="line">            <span class="keyword">if</span> (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">"Backend doesn't support profiling, profiling will be disabled"</span>);</span><br><span class="line">                <span class="keyword">if</span> (getTaskListFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    getTaskListFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// stop snapshot sender</span></span><br><span class="line">                <span class="keyword">if</span> (sendSnapshotFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sendSnapshotFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-oap-响应-client-获取-profile-task-列表的请求"><a href="#2-2-oap-响应-client-获取-profile-task-列表的请求" class="headerlink" title="2.2 oap 响应 client 获取 profile task 列表的请求"></a>2.2 oap 响应 client 获取 profile task 列表的请求</h2><p>而 oap 是在 server-receiver-plugin/skywalking-profile-receiver-plugin 处理客户端的 ProfileTaskCommandQuery 请求，ProfileTaskServiceHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProfileTaskCommands</span><span class="params">(ProfileTaskCommandQuery request, StreamObserver&lt;Commands&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// query profile task list by service id</span></span><br><span class="line">    <span class="keyword">final</span> String serviceId = IDManager.ServiceID.buildId(request.getService(), NodeType.Normal);</span><br><span class="line">    <span class="keyword">final</span> String serviceInstanceId = IDManager.ServiceInstanceID.buildId(serviceId, request.getServiceInstance());</span><br><span class="line">    <span class="comment">// 从缓存中获取该服务的 profile task 列表，该缓存每隔 10s 从存储中更新 profile task</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ProfileTask&gt; profileTaskList = profileTaskCache.getProfileTaskList(serviceId);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(profileTaskList)) &#123;</span><br><span class="line">        responseObserver.onNext(Commands.newBuilder().build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build command list</span></span><br><span class="line">    <span class="keyword">final</span> Commands.Builder commandsBuilder = Commands.newBuilder();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lastCommandTime = request.getLastCommandTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProfileTask profileTask : profileTaskList) &#123;</span><br><span class="line">        <span class="comment">// if command create time less than last command time, means sniffer already have task</span></span><br><span class="line">        <span class="keyword">if</span> (profileTask.getCreateTime() &lt;= lastCommandTime) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// record profile task log</span></span><br><span class="line">        recordProfileTaskLog(profileTask, serviceInstanceId, ProfileTaskLogOperationType.NOTIFIED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add command</span></span><br><span class="line">        commandsBuilder.addCommands(commandService.newProfileTaskCommand(profileTask).serialize().build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseObserver.onNext(commandsBuilder.build());</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-client-开启-profile-task-的相关定时任务"><a href="#2-3-client-开启-profile-task-的相关定时任务" class="headerlink" title="2.3 client 开启 profile task 的相关定时任务"></a>2.3 client 开启 profile task 的相关定时任务</h2><p>此时 client 主动向 oap 请求获取 profile task 列表，当 client 获取到后，需要进步做处理，ProfileTaskCommandExecutor.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(BaseCommand command)</span> <span class="keyword">throws</span> CommandExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProfileTaskCommand profileTaskCommand = (ProfileTaskCommand) command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build profile task</span></span><br><span class="line">    <span class="keyword">final</span> ProfileTask profileTask = <span class="keyword">new</span> ProfileTask();</span><br><span class="line">    profileTask.setTaskId(profileTaskCommand.getTaskId());</span><br><span class="line">    profileTask.setFirstSpanOPName(profileTaskCommand.getEndpointName());</span><br><span class="line">    profileTask.setDuration(profileTaskCommand.getDuration());</span><br><span class="line">    profileTask.setMinDurationThreshold(profileTaskCommand.getMinDurationThreshold());</span><br><span class="line">    profileTask.setThreadDumpPeriod(profileTaskCommand.getDumpPeriod());</span><br><span class="line">    profileTask.setMaxSamplingCount(profileTaskCommand.getMaxSamplingCount());</span><br><span class="line">    profileTask.setStartTime(profileTaskCommand.getStartTime());</span><br><span class="line">    profileTask.setCreateTime(profileTaskCommand.getCreateTime());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send to executor</span></span><br><span class="line">    <span class="comment">// 将该任务列表塞入一个 list 中，该 list</span></span><br><span class="line">    ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).addProfileTask(profileTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端获取到 profile task 后，需要知道什么时候启动，和什么时候停止，ProfileTaskExecutionService.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add profile task from OAP</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProfileTask</span><span class="params">(ProfileTask task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// update last command create time</span></span><br><span class="line">    <span class="keyword">if</span> (task.getCreateTime() &gt; lastCommandCreateTime) &#123;</span><br><span class="line">        lastCommandCreateTime = task.getCreateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check profile task limit</span></span><br><span class="line">    <span class="keyword">final</span> CheckResult dataError = checkProfileTaskSuccess(task);</span><br><span class="line">    <span class="keyword">if</span> (!dataError.isSuccess()) &#123;</span><br><span class="line">        LOGGER.warn(</span><br><span class="line">            <span class="string">"check command error, cannot process this profile task. reason: &#123;&#125;"</span>, dataError.getErrorReason());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add task to list</span></span><br><span class="line">    profileTaskList.add(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedule to start task，计算出该任务还需要多久才能启动，通过定时任务实现</span></span><br><span class="line">    <span class="keyword">long</span> timeToProcessMills = task.getStartTime() - System.currentTimeMillis();</span><br><span class="line">    PROFILE_TASK_SCHEDULE.schedule(() -&gt; processProfileTask(task), timeToProcessMills, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * active the selected profile task to execution task, and start a removal task for it.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">processProfileTask</span><span class="params">(ProfileTask task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make sure prev profile task already stopped</span></span><br><span class="line">    stopCurrentProfileTask(taskExecutionContext.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make stop task schedule and task context，通过上下文保存该 profile task，该上下文也实际在 trace 记录时塞入堆栈信息</span></span><br><span class="line">    <span class="keyword">final</span> ProfileTaskExecutionContext currentStartedTaskContext = <span class="keyword">new</span> ProfileTaskExecutionContext(task);</span><br><span class="line">    taskExecutionContext.set(currentStartedTaskContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start profiling this task，开启 profileing 定时任务，抓取堆栈信息</span></span><br><span class="line">    currentStartedTaskContext.startProfiling(PROFILE_EXECUTOR);</span><br><span class="line">    <span class="comment">// 计算出该 profile task 的停止时间，通过定时任务停止该 profile task</span></span><br><span class="line">    PROFILE_TASK_SCHEDULE.schedule(</span><br><span class="line">        () -&gt; stopCurrentProfileTask(currentStartedTaskContext), task.getDuration(), TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 client 已经开启了 profile task，并通过 oap 的参数，控制了开启时间和持续时间（停止时间）的定时任务，同时也开启了子线程 profile_executor，用于真正的抓取执行中的堆栈信息。也就是 client 开启了三个定时任务，一个用于 profile 的开启，一个用于 profile 的关闭，一个是用于 profile 真正抓取堆栈信息。</p><h1 id="3-client-与-oap-的-profileSnapshot-信息"><a href="#3-client-与-oap-的-profileSnapshot-信息" class="headerlink" title="3 client 与 oap 的 profileSnapshot 信息"></a>3 client 与 oap 的 profileSnapshot 信息</h1><h2 id="3-1-client-profileSnapshot-的生成"><a href="#3-1-client-profileSnapshot-的生成" class="headerlink" title="3.1 client profileSnapshot 的生成"></a>3.1 client profileSnapshot 的生成</h2><p>在 ProfileTaskExecutionService.processProfileTask 方法中会开启 ProfileThread 任务，profileThread 定时任务会抓取堆栈信息并塞入队列。 ProfileThread.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        profiling(taskExecutionContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ignore interrupted</span></span><br><span class="line">        <span class="comment">// means current task has stopped</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e, <span class="string">"Profiling task fail. taskId:&#123;&#125;"</span>, taskExecutionContext.getTask().getTaskId());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// finally stop current profiling task, tell execution service task has stop</span></span><br><span class="line">        profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * start profiling</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">profiling</span><span class="params">(ProfileTaskExecutionContext executionContext)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run loop when current thread still running</span></span><br><span class="line">    <span class="keyword">long</span> currentLoopStartTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        currentLoopStartTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// each all slot</span></span><br><span class="line">        AtomicReferenceArray&lt;ThreadProfiler&gt; profilers = executionContext.threadProfilerSlots();</span><br><span class="line">        <span class="keyword">int</span> profilerCount = profilers.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> slot = <span class="number">0</span>; slot &lt; profilerCount; slot++) &#123;</span><br><span class="line">            ThreadProfiler currentProfiler = profilers.get(slot);</span><br><span class="line">            <span class="keyword">if</span> (currentProfiler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (currentProfiler.profilingStatus().get()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="comment">// check tracing context running time</span></span><br><span class="line">                    currentProfiler.startProfilingIfNeed();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> PROFILING:</span><br><span class="line">                    <span class="comment">// dump stack</span></span><br><span class="line">                    TracingThreadSnapshot snapshot = currentProfiler.buildSnapshot();</span><br><span class="line">                    <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将获取的堆栈信息快照文件，存入 snapshotQueue 队列中，而 ProfileTaskChannelService 中的 ProfileSendSnapshotService</span></span><br><span class="line">                        <span class="comment">// 定时任务会定期将 snapshotQueue 队列通过 ProfileSnapshotSender 任务发送给 oap</span></span><br><span class="line">                        profileTaskChannelService.addProfilingSnapshot(snapshot);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// tell execution context current tracing thread dump failed, stop it</span></span><br><span class="line">                        executionContext.stopTracingProfile(currentProfiler.tracingContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep to next period</span></span><br><span class="line">        <span class="comment">// if out of period, sleep one period</span></span><br><span class="line">        <span class="keyword">long</span> needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();</span><br><span class="line">        needToSleep = needToSleep &gt; <span class="number">0</span> ? needToSleep : maxSleepPeriod;</span><br><span class="line">        Thread.sleep(needToSleep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 profileSnapshot 信息由 client 发送给 oap，有两种方式，当前默认为 grpc 方式：ProfileSnapshotSender.java，也可以用 kafka 方式发送：KafkaProfileSnapshotSender.java</p><h2 id="3-1-oap-获取-client-传输的-profileSnapshot-信息"><a href="#3-1-oap-获取-client-传输的-profileSnapshot-信息" class="headerlink" title="3.1 oap 获取 client 传输的 profileSnapshot 信息"></a>3.1 oap 获取 client 传输的 profileSnapshot 信息</h2><p>grpc 方式获取也是通过 skywalking-profile-receiver-plugin 模块处理，该模块不仅负责 client 获取 profile task，也负责 profileSnapshot 的 grpc 通信，ProfileTaskServiceHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 前文说过，oap 处理 client 获取 profile task 列表的请求处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProfileTaskCommands</span><span class="params">(ProfileTaskCommandQuery request, StreamObserver&lt;Commands&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * oap 接收来自 client 的 profileSnapshot 信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> responseObserver</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamObserver&lt;ThreadSnapshot&gt; <span class="title">collectSnapshot</span><span class="params">(StreamObserver&lt;Commands&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;ThreadSnapshot&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ThreadSnapshot snapshot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">"receive profile segment snapshot"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// build database data</span></span><br><span class="line">            <span class="keyword">final</span> ProfileThreadSnapshotRecord record = <span class="keyword">new</span> ProfileThreadSnapshotRecord();</span><br><span class="line">            record.setTaskId(snapshot.getTaskId());</span><br><span class="line">            record.setSegmentId(snapshot.getTraceSegmentId());</span><br><span class="line">            record.setDumpTime(snapshot.getTime());</span><br><span class="line">            record.setSequence(snapshot.getSequence());</span><br><span class="line">            record.setStackBinary(snapshot.getStack().toByteArray());</span><br><span class="line">            record.setTimeBucket(TimeBucket.getRecordTimeBucket(snapshot.getTime()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// async storage</span></span><br><span class="line">            RecordStreamProcessor.getInstance().in(record);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            LOGGER.error(throwable.getMessage(), throwable);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            responseObserver.onNext(Commands.newBuilder().build());</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kafka 的 oap 接收profileSnapshot 也是类似处理，只不过换成了从 topic 中获取数据而已。</p><h1 id="4-profileSnapshot-生成与分析"><a href="#4-profileSnapshot-生成与分析" class="headerlink" title="4. profileSnapshot 生成与分析"></a>4. profileSnapshot 生成与分析</h1><h2 id="4-1-client-生成-profileSnapshot"><a href="#4-1-client-生成-profileSnapshot" class="headerlink" title="4.1 client 生成 profileSnapshot"></a>4.1 client 生成 profileSnapshot</h2><p>在每次创建 TracingContext 的时候，也会初始化 profile 当前的堆栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize all fields with default value.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">TracingContext(String firstOPName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.segment = <span class="keyword">new</span> TraceSegment();</span><br><span class="line">    <span class="keyword">this</span>.spanIdGenerator = <span class="number">0</span>;</span><br><span class="line">    isRunningInAsyncMode = <span class="keyword">false</span>;</span><br><span class="line">    createTime = System.currentTimeMillis();</span><br><span class="line">    running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// profiling status</span></span><br><span class="line">    <span class="keyword">if</span> (PROFILE_TASK_EXECUTION_SERVICE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        PROFILE_TASK_EXECUTION_SERVICE = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要 profile，同时尝试初始化当前 segment 的 thread 信息</span></span><br><span class="line">    <span class="keyword">this</span>.profileStatus = PROFILE_TASK_EXECUTION_SERVICE.addProfiling(</span><br><span class="line">        <span class="keyword">this</span>, segment.getTraceSegmentId(), firstOPName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.correlationContext = <span class="keyword">new</span> CorrelationContext();</span><br><span class="line">    <span class="keyword">this</span>.extensionContext = <span class="keyword">new</span> ExtensionContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addProfiling 方法最终会走到 ProfileTaskExecutionContext.attemptProfiling 方法，该方法会将当前线程堆栈信息存储 volatile 变量：profilingSegmentSlots 中，该变量会在 ProfileThread.profiling 方法中通过 executionContext.threadProfilerSlots(); 方式死循环取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * check have available slot to profile and add it</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> is add profile success</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProfileStatusReference <span class="title">attemptProfiling</span><span class="params">(TracingContext tracingContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String traceSegmentId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String firstSpanOPName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check has available slot</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> usingSlotCount = currentProfilingCount.get();</span><br><span class="line">    <span class="keyword">if</span> (usingSlotCount &gt;= Config.Profile.MAX_PARALLEL) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check first operation name matches</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(task.getFirstSpanOPName(), firstSpanOPName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if out limit started profiling count then stop add profiling</span></span><br><span class="line">    <span class="keyword">if</span> (totalStartedProfilingCount.get() &gt; task.getMaxSamplingCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to occupy slot</span></span><br><span class="line">    <span class="keyword">if</span> (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程 Thread.currentThread() 赋值给 ThreadProfiler 的 profilingThread 参数</span></span><br><span class="line">    <span class="comment">// 同时将 threadProfiler 存入 profilingSegmentSlots 中，profilingSegmentSlots 会被 profileThread 取出</span></span><br><span class="line">    <span class="keyword">final</span> ThreadProfiler threadProfiler = <span class="keyword">new</span> ThreadProfiler(</span><br><span class="line">        tracingContext, traceSegmentId, Thread.currentThread(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int</span> slotLength = profilingSegmentSlots.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> slot = <span class="number">0</span>; slot &lt; slotLength; slot++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (profilingSegmentSlots.compareAndSet(slot, <span class="keyword">null</span>, threadProfiler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> threadProfiler.profilingStatus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ProfileStatusReference.createWithNone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如当前只有一个 http 请求：</p><ol><li>在 before method 前将该请求堆栈信息初始化并发送给 oap，该信息包含该 traceId 以及 beginTime。</li><li>该请求执行完后，在 after method 后，会将该 trace 发送给 oap。</li><li>oap 后台查询到 profile 的 trace 后，点击执行按钮，会从存储中获取该请求堆栈信息，并通过 traceId 反查到 trace 链路，并通过 beginTime 和 trace 的 time，得到该堆栈的执行时间。注意：后台点击执行时才会主动分析堆栈的执行和相关信息。</li></ol><h2 id="4-2-oap-执行分析堆栈信息"><a href="#4-2-oap-执行分析堆栈信息" class="headerlink" title="4.2 oap 执行分析堆栈信息"></a>4.2 oap 执行分析堆栈信息</h2><p>oap 请求执行堆栈分析参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: <span class="string">"query getProfileAnalyze($segmentId: String!, $timeRanges: [ProfileAnalyzeTimeRange!]!) &#123;\\n  getProfileAnalyze: getProfileAnalyze(segmentId: $segmentId, timeRanges: $timeRanges) &#123;\\n    tip\\n    trees &#123;\\n      elements &#123;\\n        id\\n        parentId\\n        codeSignature\\n        duration\\n        durationChildExcluded\\n        count\\n      &#125;\\n    &#125;\\n  &#125;\\n  &#125;"</span>,</span><br><span class="line">    <span class="attr">"variables"</span>: &#123;</span><br><span class="line">        <span class="attr">"segmentId"</span>: <span class="string">"f26ef21ccee943d1806c12cf54948c00.57.16225422981970000"</span>,</span><br><span class="line">        <span class="attr">"timeRanges"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"start"</span>: <span class="number">1622542298197</span>,</span><br><span class="line">                <span class="attr">"end"</span>: <span class="number">1622542301399</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到 org.apache.skywalking.oap.server.core.profile.analyze.ProfileAnalyzer#analyze() 执行的分析：从 es 取出从 client 获取的 ProfileSnapshot 堆栈信息，映射的实体类为：ProfileThreadSnapshotRecord</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> apm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skywalking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2021/21周总结</title>
      <link href="/2021/05/25/2021/21.html/"/>
      <url>/2021/05/25/2021/21.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>没有学习的一周</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/p2642871021.webp" alt="御赐小仵作"></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>近一个月没有周总结，用了语雀半年，但是打开太卡了。失去了纪录笔记的初衷，现在重归 vscode 编写文本。源码文本与渲染分离的模式，还是 hexo + github 这种方式更加适合我。</li><li>周六回武汉，侄子过周岁，正好母亲也趁这个时间一起回来碰面。</li><li>一直以工作为主，因为工作上涉及的技术和知识收货很多，比纯看书感触更深。可能这就是工作中的经验吧。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>重启博客计划，回归周计划节奏，将这半年在语雀的笔记迁移至老博客</li><li>滴答清单 + 自有博客搭配</li><li>学车！</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>自己还是喜欢简单的东西，就像 vscode，编写即可，语雀真的卡，我受不了了。</li><li>工作上需要自己自我安排！马上这个季度也快结束了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo泛化调用导致 zookeeper临时节点暴增的BUG</title>
      <link href="/2021/05/14/tech/dubbo/$invoke_zknode_problem.html/"/>
      <url>/2021/05/14/tech/dubbo/$invoke_zknode_problem.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>dubbo 2.7.5，最近发现 zk 的 node 越来越多，监控报警半夜给我打电话。后来排查发现是业务方使用泛化调用不规范！<br>但是排查过程学习到了很多。</p><a id="more"></a><h1 id="1-监控"><a href="#1-监控" class="headerlink" title="1. 监控"></a>1. 监控</h1><p>线上 zk 监控主要是监控 zk 的 node 数量，以及机器 cpu memory，报警主要是 zk 的 node 数量报警，到了阈值。</p><h1 id="2-排查"><a href="#2-排查" class="headerlink" title="2. 排查"></a>2. 排查</h1><p>先查看在报警前后的 zk snapshot 文件有什么变化，将 zk 快照文件转译为文本：<br>java -cp ../../zookeeper-3.4.8.jar:../../lib/slf4j-api-1.6.1.jar org.apache.zookeeper.server.SnapshotFormatter snapshot.b0008ebdd &gt; 05141102.txt<br>这样你就得到了两份 snapshot，一份是报警前一段时间，正常的快照 node，一份是报警后的快照 node。</p><h1 id="3-Dubbo-节点规则"><a href="#3-Dubbo-节点规则" class="headerlink" title="3. Dubbo 节点规则"></a>3. Dubbo 节点规则</h1><p>/dubbo/{com.xx.Service}/consumers/consumer%3A%2F%2F{ip.ip.ip.ip}%2Forg.apache.dubbo.rpc.service.GenericService%3Fapplication%3D{app-name}%26category%3Dconsumers%26check%3Dfalse%26dubbo%3D2.0.2%26generic%3Dtrue%26interface%3D{com.xx.Service}%26lazy%3Dfalse%26loadbalance%3Drandom%26pid%3D26879%26release%3D2.7.3.5-ext%26side%3Dconsumer%26sticky%3Dfalse%26timestamp%3D1620959181596<br>/dubbo/服务提供者接口/consumers/泛化接口?timestamp=<br>通过搜索 zk 报警之后的快照文件发现有接近3000个泛化调用统一接口<br>接口查看该 node 的 ephemeralOwner，定位到该业务服务，同时查看线上该业务服务的发布记录，发现该业务服务的线上发布时间和故障报警时间重合：当该服务重启发布的时候，报警消失，猜测应该是因为机器重启，临时泛化节点都下掉。后来定位代码，发现泛化调用后没有显示的调用 .destory() 销毁泛化调用的 node！</p><h1 id="4-解决"><a href="#4-解决" class="headerlink" title="4. 解决"></a>4. 解决</h1><ol><li>泛化调用后，finally 块代码加入 reference.destory() 方法。</li><li>通过内存缓存 GenericService genericService = reference.get() 获得的 GenericService 类。</li><li>不用泛化调用，直接调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《重来3：跳出疯狂的忙碌》阅读总结</title>
      <link href="/2021/03/17/readbook/crazyAtWork.html/"/>
      <url>/2021/03/17/readbook/crazyAtWork.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/s33699293.jpg" alt></p><a id="more"></a><ol><li>时间被各种碎片切割，导致实际工作效率不高<blockquote><p>安排专门的每天或每周答疑时间范围，统一解决</p></blockquote></li><li>公司作为产品，员工作为用户：员工知道公司哪里最快，哪里最慢，哪里的漏洞可以快速修复。但是需要有好的反馈渠道反馈。</li><li>完成比完美好，定好截止日，中间的任务只会根据时间来减少而不会增加，以在截止时间内完成，之后慢慢细节优化</li><li>每个人有发言权，但是决定权只有一个人，其他人需要配置：我不同意你，但是我需要配合你</li><li>组织的领导者不能向员工乱抛想法。<blockquote><p>“分清建议和命令”</p></blockquote></li><li>人之间的信任像电池。打交道时是充电还是耗电。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 重来3：跳出疯狂的忙碌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2021/01周总结</title>
      <link href="/2021/01/12/2021/01.html/"/>
      <url>/2021/01/12/2021/01.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>坐在同事的小电驴经过公司，这就是我的跨年夜。</li></ol><a id="more"></a><p><img src="hhttps://cdn.nlark.com/yuque/0/2021/png/203689/1610419946633-c04489fd-d66d-461e-94ee-f8a64673ddf4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_bGl3ZW5ndWFuZw%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1038" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>《消息队列高手课》看到18/41</li><li>工作进度正常，最后的迁库迁表分库分表+数据迁移+shardingjdbc</li><li>过年元旦和同事玩游戏！</li><li>本来说元旦去公司学习，但是就光顾着玩游戏了。。。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>《消息队列高手课》完结</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol><li>感觉一周多个计划到最后什么都没完成，以后一周就一个计划吧，多了也完不成，拖一个月没什么意义，工作中也是进步总觉的一部分。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020 总结（以后就用语雀了）</title>
      <link href="/2021/01/04/2020/index.html/"/>
      <url>/2021/01/04/2020/index.html/</url>
      
        <content type="html"><![CDATA[<p>这是2020总结</p><a id="more"></a><h1 id="1-时间线"><a href="#1-时间线" class="headerlink" title="1. 时间线"></a>1. 时间线</h1><p>过年~2020.03.30：在湖北老家隔离远程办公<br>2020.05~2020.06: 看 netty 相关的书籍<br>2020.06.24~2020.06.27: 去青岛<br>2020.08~2020.2020.10: 看视频学习架构方面的知识、看基础相关的书<br>2020.10.01~2020.10.09: 回汉口<br>2020.11~2020.12: Seata、Sentinel 学习</p><p>时间线总结是从我每天的记录总结出来的，中间还有很多小事没记录，大事件都记录下来了，学习上主学 netty、seata、sentinel，其实还有 skywalking 和 rocketmq，不过没实战过以及深入过，就不写下来了。年初的大疫情让我颓废了许久，我自制力是真的差~</p><h1 id="2-生活线"><a href="#2-生活线" class="headerlink" title="2. 生活线"></a>2. 生活线</h1><p>生活上没有什么大的变化，一直在杭州的这家公司，在杭州也生活了快两年了，这里还有以前的同学，有时候还会约出来一起吃饭什么的。和同事关系也相处的挺好，周末一起愉快的扯淡和学习。</p><h1 id="3-工作线"><a href="#3-工作线" class="headerlink" title="3. 工作线"></a>3. 工作线</h1><p>工作上，在公司支付组干了一年半，年末转到中间件，期间工作表现也算正常，按照公司的层次来说，应该算中上吧，不突出，也不差，但是也没那么好，毕竟干久了，各个系统服务组件都比较熟悉，工作上也游刃有余，没什么大的挑战，因此主动换组新的挑战。</p><h1 id="4-2019-flag"><a href="#4-2019-flag" class="headerlink" title="4. 2019 flag"></a>4. 2019 flag</h1><p>现在翻回去，发现 2019 的总结竟然是空的。。。空的，当时可能因为拖延症没写，我一直以为我写了 2019 的总结！现在我才发现当时我没写，只写了大纲，没有内容，当时真的是懒死了。现在回看起17年和18年的总结，真是尴尬的要命，不过还是保留吧，记录过去。</p><h1 id="5-完结"><a href="#5-完结" class="headerlink" title="5. 完结"></a>5. 完结</h1><p>文章以后就用语雀了，本文是 2020 收官文，语雀编辑更加方便点，主要是觉得这个博客内容没啥有营养的，都是没啥价值的文章，以后要输出有价值的文章，涅槃重生！</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/52周总结</title>
      <link href="/2020/12/29/2020/52.html/"/>
      <url>/2020/12/29/2020/52.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>周末去找了韩笑，好好玩了一个周末。</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20201229021348.png" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>并发翻译的 33 章终于翻译完咯。</li><li>《消息队列高手课》看到12/41</li><li>工作进度正常，最后的迁库迁表分库分表，难啃我也啃下来。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>《消息队列高手课》完结，因为本周放三天，预计三天在公司看。</li><li>博客迁移老文章就就不做迁移了，自己当时水平菜，没眼看~</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>这是2020年的倒数第二周总结。<br>暴走大事件又回来了~</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/51周总结</title>
      <link href="/2020/12/24/2020/51.html/"/>
      <url>/2020/12/24/2020/51.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>本来不想写这周总结的，但是大晚上睡不着，不写又难受，但是今天都周四（凌晨）了，感觉写上周总结又显得太迟。。最后还是忍不住写了~</li><li>上周颓废的一周，DOTA2 永雾林渊版本更新，忍不住玩了亿把，太好玩了，哈哈~~</li></ol><a id="more"></a><p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/20201224012139.png" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>并发翻译终于最后快翻译完了，还剩最后一章。</li><li>个人知识库使用语雀梳理，感觉我需要将 hexo 的博文都迁移到新的语雀平台，到时候一个平台方便，也不用语雀+hexo发布了。</li><li>消息队列高手课基础课上完。</li><li>工作我有好好做，元旦就转去中间件组了，以后可能会更忙了。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>周末去青岛</li><li>博客迁移</li><li>零零碎碎的文章梳理</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>游戏真好玩。</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>雪花算法与Hash分表键的坑</title>
      <link href="/2020/12/20/tech/mysql/snowflake&amp;hash.html/"/>
      <url>/2020/12/20/tech/mysql/snowflake&amp;hash.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://markdownnoteimages.oss-cn-hangzhou.aliyuncs.com/share.jpg" alt></p><a id="more"></a><h1 id="1-雪花算法的位数原理"><a href="#1-雪花算法的位数原理" class="headerlink" title="1 雪花算法的位数原理"></a>1 雪花算法的位数原理</h1><p>雪花算法在 Java 中默认使用 Long，它是 64 位，各个位的含义如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609150636502-3a9e2cf2-2046-4158-9970-8181b6224850.png#align=left&amp;display=inline&amp;height=72&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=72&amp;originWidth=1438&amp;size=0&amp;status=done&amp;style=none&amp;width=1438" alt></p><p>第一位组：0 写死，表示只会生成正数<br>第二位组：41位，存储的时间戳单位位毫秒，实际存储量位：2^41/1000<em>60</em>60<em>24</em>365 = 69，即时间戳最多支持 69 年，一般都是使用 <code>System.currentTimeMillis() - initDate</code> 差值来实现<br>第三位组：10 位，机器数，用于分布式环境下每个机器生成的值都会不一样，默认支持 2^10 = 1024 个节点生成的值不同<br>第四位组：12 位，每节点每毫秒并发数，默认为 2^12 = 4096</p><p>实际业务场景中，会根据线上的业务场景改动某些位数。而且由于雪花是全局递增，因此动态改动也是可以，不过会出现 id 的明显断层。</p><h1 id="2-Hash-分表原理"><a href="#2-Hash-分表原理" class="headerlink" title="2 Hash 分表原理"></a>2 Hash 分表原理</h1><p>在 MySQL 数据量突增的场景，一般都会根据业务特性来使用横切或纵切达到提高性能的目的。这里只讨论横切，也就是是水平分表。大部分都会使用 Hash 分表，也就是简单的 Hash 取模，而分表都是按 2 的次方分，例如如果按 1024 分表，是如何计算的。</p><p>假设目前有1~1024个列，主键从 1~1024递增，那么按 1024 分表的话，每列都会分在独立的一张表，以分表列值分别为 1，2，3，按 1024 分表的计算过程如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &amp; (1024 - 1) = 1</span><br><span class="line">2 &amp; (1024 - 1) = 2</span><br><span class="line">3 &amp; (1024 - 1) = 3</span><br></pre></td></tr></table></figure></p><p>二进制操作的图例如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609173791431-d522379a-5cb1-48f4-b726-64bcac71211d.png#align=left&amp;display=inline&amp;height=376&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=376&amp;originWidth=2616&amp;size=0&amp;status=done&amp;style=none&amp;width=2616" alt></p><p>这里都是分配均匀，三个列均匀的分配到了 3 个表，但是我们可以根据二进制规律得知，如果有一批数，这一批数其后 10 位都是一样的，那么根据 1024 分表就会出现只分在一个表的情况，例如我现在有三个列，其分表键值分别为 1025，2049，3073，如果按 1024 分表的话，这三列就会都分在第一个表，导致数据倾斜，计算过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609174481106-173a914b-265f-4717-a2d1-605cbf7335d3.png#align=left&amp;display=inline&amp;height=400&amp;margin=%5Bobject%20Object%5D&amp;originHeight=400&amp;originWidth=2854&amp;size=0&amp;status=done&amp;style=none&amp;width=2854" alt></p><p>这样我们就知道了根据 hash 分表数据倾斜的数值特征：后 N 位相同的位数越多，数据倾斜的概率越大，具体后几位，根据你分表数来决定，例如例子中是按 2^10 分表，那么 N 则为 10。接着我们看下雪花算法的位数特性，看看会不会有数据倾斜问题</p><h1 id="3-雪花算法的位数特性"><a href="#3-雪花算法的位数特性" class="headerlink" title="3 雪花算法的位数特性"></a>3 雪花算法的位数特性</h1><p>雪花算法后 12 位为“每节点每毫秒并发数”，在线上有 100 个节点运行，而你的 QPS 为 100000，均匀的打到了每台机器，即每台机器的 QPS 为 1000，这样，你的“每节点每毫秒并发数”为 1000/1000 = 1，这样生成的 100000 个雪花算法的后 12 位全都是一样都是 0，此时如果你对雪花算法做 hash，就会出现这 100000 个数据全部在第 1 个表中，造成了严重的数据倾斜问题，只有当分表数大于 2^13 = 8192 时，才会好点，如果你按 2^13 数量分表，则因为后 12 位都是 0，此时会计算到第三组中 10 位的机器数，但是此时你也只能分成两个表，因为只计算了 1 位，如下图示例，表示的就是两个节点，在“每节点每毫秒并发数”为 1 时，按 8192 的分表的过程：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1609175735724-2e24b0e8-20ad-4201-b9c8-a11585ce09b6.png#align=left&amp;display=inline&amp;height=498&amp;margin=%5Bobject%20Object%5D&amp;name=&amp;originHeight=498&amp;originWidth=2408&amp;size=0&amp;status=done&amp;style=none&amp;width=2408" alt></p><p>“每节点每毫秒并发数”为1，即“每节点每秒并发数”为 1000 以下就会出现严重的数据倾斜问题，但是每节点 1000 的 QPS 已经很高，如果此时我们需要用雪花算法生成的值来做分表键，有什么方法呢？有两种：</p><ol><li>改进雪花算法位数特性</li><li>改进 hash 分表算法</li></ol><h1 id="4-雪花算法位数的改进"><a href="#4-雪花算法位数的改进" class="headerlink" title="4 雪花算法位数的改进"></a>4 雪花算法位数的改进</h1><p>既然我们知道按 2次幂的 hash 主要是看低位，那么我只要保证雪花算法生成的值低位不同即可，如果线上机器够多，例如线上有 128 台机器，这时候我们按 128 分表，我们就可以将雪花算法的第三组和第四组调换，这样生成的最后 10 位是机器节点，肯定是不一样的，从而达到了平衡。但是这样要求节点数据量大于分表数。还有一个更好的方法，那就是将第二组的时间戳与第四组调换，这样就算你线上只有一个节点，但是生成的最后 10 位的时间戳也达到了散列的效果。</p><h1 id="5-hash-算法的改进"><a href="#5-hash-算法的改进" class="headerlink" title="5 hash 算法的改进"></a>5 hash 算法的改进</h1><p>这里就涉及到 hash 的“扰乱”，即，hash 不再是简单的取余，而是增加了对原始值的“打散”，减少出现在同一个组的可能，这里参考 HashMap 的 hash 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tableSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SnowflakeIdWorker idWorker = <span class="keyword">new</span> SnowflakeIdWorker(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> id1 = idWorker.nextId();</span><br><span class="line">    System.out.println(<span class="string">"原始雪花算法值id1:"</span> + id1);</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> id2 = idWorker.nextId();</span><br><span class="line">    System.out.println(<span class="string">"原始雪花算法值id2:"</span> + id2);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"table1Index:"</span> + hash(id1) + <span class="string">"\n"</span> + <span class="string">"table2Index:"</span> + hash(id2));</span><br><span class="line">    System.out.println(<span class="string">"table1Index:"</span> + hashC(id1) + <span class="string">"\n"</span> + <span class="string">"table2Index:"</span> + hashC(id2));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * output:</span></span><br><span class="line"><span class="comment">         * 原始雪花算法值id1:793292040770158592</span></span><br><span class="line"><span class="comment">         * 原始雪花算法值id2:793292040774352896</span></span><br><span class="line"><span class="comment">         * ------------------------</span></span><br><span class="line"><span class="comment">         * table1Index:0</span></span><br><span class="line"><span class="comment">         * table2Index:0</span></span><br><span class="line"><span class="comment">         * 扰乱后的雪花算法值:793299744572601664</span></span><br><span class="line"><span class="comment">         * 扰乱后的雪花算法值:793299744568407424</span></span><br><span class="line"><span class="comment">         * table1Index:320</span></span><br><span class="line"><span class="comment">         * table2Index:384</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hash</span> <span class="params">(<span class="keyword">long</span> snowflakeId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> snowflakeId % tableSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hashC</span> <span class="params">(<span class="keyword">long</span> snowflakeId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c = (snowflakeId ^ (snowflakeId &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">    System.out.println(<span class="string">"扰乱后的雪花算法值:"</span> + c);</span><br><span class="line">    <span class="keyword">return</span> c % tableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到通过原生直接简单 hash 取余都是 0，但是通过扰乱后的再取余就不一样了，达到了“扰乱散列”的效果。</p><p>还有一种 hash 改进的方式针对这种最后几位一样，但是前几位不一样的特征值，我们丢弃掉后几位，也就是直接右移几位，这里我们可以将默认的雪花算法右移 12 位，从而直接根据机器节点来取模，或者粗暴的右移 22 位，根据时间戳在取余，效果更好。在雪花算法场景下，这种方式比“扰乱散列”方式更好。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>这是我在分库分表时，踩下的坑，当时某个业务有个列是雪花算法生成的，因为业务都是它来查值，因此我在分表的时候把它设为分表键，前期数据量比较少，没关注，后面量在 900G 的时候，发现 0000 表占了 500G。然后就开始重新建表，重新分库，开始数据平滑迁移到新表。</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 唯一ID生成算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/50周总结</title>
      <link href="/2020/12/15/2020/50.html/"/>
      <url>/2020/12/15/2020/50.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>梳理个人知识库中，感觉自己掌握的东西很杂，没有个好的目录和学习总结。</li><li>2020年最后一个月，工作最后加把劲！奥利给。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-12-15%E4%B8%80%E7%A7%92%E9%92%9F.jpg" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>Seata PR merged后，给公司的分享，感觉分享完又精进了不少。</li><li>Seata 系列博文也快完了，目前到第九章了。</li><li>并发翻译终于到进行到了第25章了。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>工作好好干！！！</li><li>Seata这周整理完</li><li>并发的翻译到30周</li><li>个人知识库梳理</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>快要到2021了，赶紧完成之前的flag，到时候做个好的年终总结。</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/49周总结</title>
      <link href="/2020/12/08/2020/49.html/"/>
      <url>/2020/12/08/2020/49.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>一周的时间比较颓废，不知道咋回事，就心态自然奔溃了，不过还好就持续了一周，但是比之前好就是，虽然比较颓废，但是周六还是仍然和同事在公司研究东西。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-12-08%E5%A4%A7%E7%A7%A6%E5%B8%9D%E5%9B%BD-%E8%A3%82%E5%8F%98.jpg" alt></p><h1 id="1-上两周总结"><a href="#1-上两周总结" class="headerlink" title="1. 上两周总结"></a>1. 上两周总结</h1><ol><li>主要是整理 Seata 博文系列以及准备要分享的 Seata 文档。</li><li>玩电脑游戏玩疯了，不过一周过后就戒了，犯病了。</li><li>书也没看完，也没坚持学习，一直持续的坚持真的难。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>完成工作，因为工作上这是Q4最后一个月，工作上要收收尾准备好年终奖冲刺。</li><li>Seata这周要整理整理完！</li><li>并发的翻译这周末继续！</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>犯病比之前好点了，持续了一周，同时也不落下学习。</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>引用回收问题</title>
      <link href="/2020/11/25/tech/reference_gc.html/"/>
      <url>/2020/11/25/tech/reference_gc.html/</url>
      
        <content type="html"><![CDATA[<h1 id="引用回收问题"><a href="#引用回收问题" class="headerlink" title="引用回收问题"></a>引用回收问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文由：<a href="https://github.com/Snailclimb/JavaGuide/issues/975" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/975</a> 讨论延伸而来。<br>主要回顾了对栈帧引用局部变量回收问题、FinalizableDelegatedExecutorService 导致的 jdk p4 bug。<br>最后总结了正确的编码风格。</p><a id="more"></a><h2 id="引用基础"><a href="#引用基础" class="headerlink" title="引用基础"></a>引用基础</h2><p>强软弱虚 +FinalReference 参见：</p><ol><li><a href="https://club.perfma.com/article/125010" target="_blank" rel="noopener">https://club.perfma.com/article/125010</a></li><li><a href="https://www.infoq.cn/article/jvm-source-code-analysis-finalreference" target="_blank" rel="noopener">https://www.infoq.cn/article/jvm-source-code-analysis-finalreference</a></li></ol><p>因为我自己对引用，尤其是 referenceQueue 以及 FinalReference 理解不够透彻，怕写的有问题，并且本文也和引用区别的关系不是很大，就直接贴出我看的博文了，讲解的很细致。</p><h2 id="强引用也会被回收"><a href="#强引用也会被回收" class="headerlink" title="强引用也会被回收"></a>强引用也会被回收</h2><p>本小节理论参考自：<a href="https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope" target="_blank" rel="noopener">https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope</a></p><p>你看的没错，我们传统理解的强引用也会被回收。如下示例代码，可能有点复杂，但是它是为了证明在某种情况下，回收对象和是什么引用无关。其中 Entry 是继承自 WeakReference，而其中使用了 <code>super(k)</code>，表明我们将第一个入参作为弱引用传入，<code>value</code> 则不作任何表示，是一个普通变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// baseWeak();</span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car(<span class="number">22000</span>, <span class="string">"sliver"</span>);</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Entry entry = <span class="keyword">new</span> Entry(car, object);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"Object is alive for "</span> + i + <span class="string">" loops - "</span> + entry);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Object is alive for 61441 loops - Entry@490d6c15</span></span><br><span class="line">                <span class="comment">// null,java.lang.Object@7d4793a8</span></span><br><span class="line">                <span class="comment">// Object has been collected.</span></span><br><span class="line">                System.out.println(entry.get() + <span class="string">","</span> + entry.getValue());</span><br><span class="line">                System.out.println(<span class="string">"Object has been collected."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String colour;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, String colour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.colour = colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColour</span><span class="params">(String colour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colour = colour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value associated with this ThreadLocal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(Car k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中大概在 6W 次循环后，<code>car</code> 引用被回收。注意 <code>car</code> 它本身有强引用在局部变量中的： <code>Car car = new Car()</code>，我开始觉得因为它被弱引用了，于是接下来改动 <code>Entry</code>，将 <code>v</code> 入参作为弱引用（记得改泛型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry(Car k, Object v) &#123;</span><br><span class="line">    <span class="keyword">super</span>(v);</span><br><span class="line">    value = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在循环 6W 次左右后仍然出现了和弱引用一样的情况。说明这个回收对强弱引用都执行相同的逻辑。为什么这里的强引用也会回收，这里已经有了解释：<a href="https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope。" target="_blank" rel="noopener">https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope。</a></p><p>我理解为什么强引用会被回收，是因为 JIT 的优化。为什么我们说局部变量（本例中的 <code>car</code> 变量）是强引用，因为它被栈帧引用了，而栈帧是 GCRoots 之一。而这 <code>car</code> 被回收的前提是 GCRoot 不可达，但是栈帧还没被销毁怎么会不可达呢，因为 JIT 在这里会做优化操作：Java 编译器或代码生成器可以选择将不再使用的变量或参数设置为 NULL，以使此类对象的存储可能更快地可回收。</p><blockquote><p>a Java compiler or code generator may choose to set a variable or parameter that will no longer be used to <code>null</code> to cause the storage for such an object to be potentially reclaimable sooner</p><p>来源：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1。后面简称" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6.1。后面简称</a> jls-12.6.1</p></blockquote><p>在此示例代码中，car 被 JIT 优化设置为 null（当然，它在循环了 6W 次才“学会了”优化）。</p><h2 id="为什么扯到-ThreadLocal"><a href="#为什么扯到-ThreadLocal" class="headerlink" title="为什么扯到 ThreadLocal"></a>为什么扯到 ThreadLocal</h2><p>因为这篇文章是因 <code>ThreadLocal</code> 而起，我们都知道 <code>ThreadLocal</code> 内部使用 <code>ThreadLocalMap</code> + <code>Entry</code> 实现，而 <code>Entry</code> 继承自 <code>WeakReference</code>，而 <code>ThreadLocalMap</code> 将其 <code>value</code> 设置为了弱引用，也就是我们业务设置的值，而 <code>ThreadLocalMap</code> 的 <code>key</code> 则为 <code>ThreadLocal</code> 本身的实例。</p><p>因此这里会产生一个答案，这个答案的问题是：为什么我们建议 ThreadLocal 实例时作为 static，而不是作为一个局部变量。这个问题的答案是：因为局部变量 <code>ThreadLocal</code> 如果操作不当可能会被回收！而 <code>ThreadLocal</code> 风险很高，因为它除了栈帧在业务上很少会有其它引用（当然，你可以在后面使用它的实例方法）。</p><h2 id="还有什么情况会被奇怪的回收"><a href="#还有什么情况会被奇怪的回收" class="headerlink" title="还有什么情况会被奇怪的回收"></a>还有什么情况会被奇怪的回收</h2><p>前面我们通过 <em>jls-12.6.1</em> 知道，编译器可以选择将不再使用的变量设为 null，但是该文档前面还有一句：</p><p>一个可到达对象是可以从任何活动线程在任何潜在的持续计算中访问的任何对象。</p><blockquote><p>A <em>reachable</em> object is any object that can be accessed in any potential continuing computation from any live thread.</p></blockquote><p>关键点在于“任何活动线程”，那如果某个线程被错误的识别出不活跃，那里面的强引用会被回收吗？但是下面其实和活动线程关系不大，倒是和前面的强引用回收问题有关系。</p><h2 id="SingleThreadExecutor-的-GC-回收问题"><a href="#SingleThreadExecutor-的-GC-回收问题" class="headerlink" title="SingleThreadExecutor 的 GC 回收问题"></a>SingleThreadExecutor 的 GC 回收问题</h2><p>本小节中文参考自：<a href="https://segmentfault.com/a/1190000021109130。其中错误代码如下：" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021109130。其中错误代码如下：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadPoolTest threadPoolTest = <span class="keyword">new</span> ThreadPoolTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        Future&lt;String&gt; future = threadPoolTest.submit();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = future.get();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//子线程不停gc，模拟偶发的gc</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.gc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步执行任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关键点，通过Executors.newSingleThreadExecutor创建一个单线程的线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> System.currentTimeMillis() + <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(futureTask);</span><br><span class="line">        <span class="comment">// 如果放开下面的注释就不会有问题，因为 executorService 被检测到是可达对象所以不会被回收进而产生bug</span></span><br><span class="line">        <span class="comment">// System.out.println(executorService.toString());</span></span><br><span class="line">        <span class="keyword">return</span> futureTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文评论道出了真相，描述和 <a href="https://stackoverflow.com/questions/58714980/rejectedexecutionexception-inside-single-executor-service" target="_blank" rel="noopener">stackoverflow</a> 的高赞回答类似：</p><blockquote><p>executeService 已经是 unreachable，被 gc 是正常的。不觉得是什么 bug，代码本身编写的问题。返回的是 FutureTask, 就是对 FutureTask 的引用，抛出的异常是在你提交任务后，还没有执行完的情况下 ExecuteService 被 gc 了，同时被 shutdown（笔者注：executorService.execute(futureTask); 这行代码并不表示 executorService 被 futureTask 引用，也就是说这行代码对于 executorService 的引用关系是没有任何改变的）</p></blockquote><p>这里参见：<a href="https://bugs.openjdk.java.net/browse/JDK-8145304" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8145304</a> 这个 BUG 一直是 OPEN 状态，里面的示例代码非常简单是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Executors.newSingleThreadExecutor().submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">"StartUp-1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>PS：这种代码竟然有 bug，虽然 bug 等级是 P4。</p><p>核心在于 newSingleThreadExecutor 返回的是包装类 FinalizableDelegatedExecutorService，该类重写了 <code>finalize()</code> 方法，在回收时调用 <code>shutdown()</code>，但是 JIT 在优化时，对局部引用对象 executorService 也可能会回收（不活跃线程），导致的 JDK bug。</p><p>如何避免这种问题呢？我们可以将该 executeService 设置为静态变量！或者保证在代码方法块中对 executeService 仍然有访问。但是设为静态变量是最为方便直接的方案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>局部变量虽然被栈帧（GCRoot 之一）引用，但它会被 JIT 优化从而被回收</li><li>Executors.newSingleThreadExecutor 有 bug，其 bug 等级是 P4</li><li>JIT 优化会触发意想不到的问题</li><li>静态变量的设计有很多考究的（不要过度用）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> java拾遗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/47周总结</title>
      <link href="/2020/11/23/2020/47.html/"/>
      <url>/2020/11/23/2020/47.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>计划的并发文章翻译到第17章完成，等全部翻译完，再自己校验下，再统一上传。</li><li>幂等业务的博文总结更新了，因为后面因为实际场景的需要后来又优化了一版，总结已更新。</li><li>计划的 threadlocal 弱依赖总结博文没写完，这周补上。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-11-23%E9%A3%9E%E5%A4%A9%E5%A4%A7%E7%9B%97.jpg" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>3个计划，完成2个，完成度66%，能接受~</li><li>周日的时候和同学玩游戏玩疯啦，不知道是为啥，估计是犯病了，压抑久了会不自觉的想释放。</li><li>计划的看一本书计划又凉了，这本《七周七并发模型》是看不完了，囧。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>33章的翻译要翻译到25章。</li><li>threadlocal 弱引用的释放博文总结完成。</li><li>看完《hustle》第一季。</li><li>这周不能玩dota2。</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>用滴答清单重新规划了本周本月计划，感觉更加能激励自己干活了。不干完总心里难受。不过自己懒的总会不想干完。真鸡儿难受。</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/46周总结</title>
      <link href="/2020/11/16/2020/46.html/"/>
      <url>/2020/11/16/2020/46.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>本周总体还好，但是周末的时候在公司学习的时候有点难专注。</li></ol><a id="more"></a><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2020-11-16%E9%A3%8E%E5%B9%B3%E6%B5%AA%E9%9D%99.jpg" alt></p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>《七周七并发模型》书没看完，但是开始翻译并发系列的书了，一共33章，目前翻译到第8章，计划是一个月翻译完。</li><li>计划是本个月就把并发系列给从根上弄清楚。</li><li>新买的iphone12mini到了，感觉挺不错，但是又感觉没什么，到时候先下几个软件，但是发现也就那样，可能已经过了对新设备的期望年纪吧。</li><li>本来说好半个月就读书总结，感觉有点夸张，顺延为1个月一个读书总结。</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>33章的翻译要翻译到17章，也就是完成一半。</li><li>threadlocal 弱引用的释放博文总结，因为已经现有素材，直接编写即可，来源于issue上的讨论。</li><li>上周的幂等博文需要更新，因为后面业务调整使用了更加合理的方案实现。</li><li>看完《硅谷第六季》</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>滴答清单被我弱化了，我需要番茄工作法的压力，不然工作一会就容易分心。</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/45周总结</title>
      <link href="/2020/11/09/2020/45.html/"/>
      <url>/2020/11/09/2020/45.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>第45周又是个小颓废的一周，不过比上周好点。</li></ol><a id="more"></a><p>![][0]</p><h1 id="1-上周总结"><a href="#1-上周总结" class="headerlink" title="1. 上周总结"></a>1. 上周总结</h1><ol><li>总结了一篇关于幂等与业务的博文。</li><li>本来说要看两周看一本书来着，但是上周没看，这周得要看了，就看《七周七并发模型》吧，这本书是一直给贡献的JavaGuide作者送我自选买的几本书之一，一直在吃灰，这周得看完了。</li><li>果然人还是天性懒惰的，从我脸上的痘痘就知道了，我上周又半夜不睡觉乱想，大早上又起床困难~</li></ol><h1 id="2-本周计划"><a href="#2-本周计划" class="headerlink" title="2. 本周计划"></a>2. 本周计划</h1><ol><li>《七周七并发模型》读完并有读书总结</li><li>一直说给公司内部分享Seata的，文章也写好了，但是感觉一直没给Seata做PR，不好意思分享，这周得需要有个PR，就算是文档也行！</li><li>希望能买个Iphone12，但是又离自己的攒钱计划越来越远了</li><li>继续使用滴答清单规范生活</li><li>继续健身，虽然说公司的健身房已经被很多杂物都占用了，但是没有健身的日子总感觉不够自律，可能健身有助于让自己更加自律？</li></ol><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>会总不自觉想逛逛论坛，把控不住自己的手。</p>]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从幂等引发的一个思考</title>
      <link href="/2020/11/09/tech/from_idempotent_to_think.html/"/>
      <url>/2020/11/09/tech/from_idempotent_to_think.html/</url>
      
        <content type="html"><![CDATA[<p>记录前段时间做的一个业务中的思考，对技术与业务结合分析做到取舍并最终的需求。</p><a id="more"></a><h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>广告服务现在需要支付服务提供一个实时扣费的接口，用于支撑 CPC 的新业务，即属于 CPC（Cost per Click） 的范畴，整个业务流转链路如下：商家用一定的金额买下某个广告位，搜索服务在拉出商品时根据权重排序，其中有专门的广告位用于展示此类商品。抽象到技术，即支持近实时的扣费，用户每有效点击一次该商品，就扣除商家的账户金额，因为要支持近实时，上层服务不希望使用 MQ 来与支付系统交互，而是想直接使用 RPC 接口调用，也就是广告点击 TPS 和支付服务的 TPS 是一致的（风险）。</p><p>关于这个近实时直接扣费的点，属于业务上的考虑，虽然也跟产品讨论这个“近实时”的点，但是说初期需要近实时，后期可以接收延迟，并且对大小商家需要有不同的延迟处理，以做到性能和业务上的平衡。</p><h1 id="1-业务分析"><a href="#1-业务分析" class="headerlink" title="1. 业务分析"></a>1. 业务分析</h1><p>业务分析后总结如下：</p><ol><li>TPS 广告服务与支付共享，这是不合理的，但是已经和产品以及上下游讨论了这个点，重点在于：可以接受非实时，但是不能都是非实时，即部分用户实时，部分用户非实时。</li><li>业务上支持对于大广告主可以使用保证金这种兜底方案，这种大客户可以接受非实时，也不怕被薅羊毛，因为会扣除保证金。而对于小客户我们初期给他们实时扣费处理，因为这类的用户 TPS 不会很高，因此可以接受这类方案。</li><li>此类扣费需要支持幂等，保证每次点击就算下游服务出现短暂的超时（例如滚动发布时），也需要能通过重试策略来达到数据一致，而不用人工修复数据或强行引入一致性的第三方服务（成本过大）。</li></ol><h1 id="2-实时与非实时"><a href="#2-实时与非实时" class="headerlink" title="2. 实时与非实时"></a>2. 实时与非实时</h1><p>既然业务可接受部分用户实时，部分用户非实时，在于如何区分大客户/小客户，其实从性能上考虑，大客户是很容易造成热点问题，尤其是在广告的热点时间。最开始计划是做纯动态，非人工干扰，即根据对请求的 userId 做收集，同时后台增加一个定时任务按天或按小时做一个统计（这里可以直接用现有大数据的同步库拉数据），来动态计算出大客户/小客户，从而做出不同的业务策略。后来由于时间问题被业务方 pass 了。接着选择了最快且能满足业务方的一个方案，通过业务方后台动态配置 userId，在处理时判断是否属于该配置的 userId 组，来执行大客户或小客户的业务逻辑，这个方案运营人员也能接受，因为大客户也就那么多。这里选用了选择了已有的技术栈 Apollo 动态配置。</p><h2 id="大客户处理"><a href="#大客户处理" class="headerlink" title="大客户处理"></a>大客户处理</h2><p>大客户是最核心的点，可能 TPS 百分之八十都是来自于大客户，甚至在后期占比会越来越高，而且也会涉及到经典的热点数据问题（MySQL 的行锁竞争），因此是主要优化点。</p><h3 id="保证金"><a href="#保证金" class="headerlink" title="保证金"></a>保证金</h3><p>对于大客户，业务方接受使用了保证金兜底，就有个问题，保证金设置多少合适？</p><p>这里我们可以根据系统可接受的最低阈值来计算：线上的接口 TPS 阈值，乘以当前广告位的值再乘以 timeout 来获得，例如线上 TPS 是 10，当前广告位是 1 元/点击，timeout 为 200ms，那么在极端情况下，当用户金额已为 0 时，此时每秒扣客户的保证金为 10*1/0.2=50 元/秒，同时上游服务会对此类异常响应（余额不足）做一系列的广告位下架处理，假如他们能在 1s 内就能完成，那么保证金最低设置为 50 就可以满足该场景了。</p><h3 id="异步优化"><a href="#异步优化" class="headerlink" title="异步优化"></a>异步优化</h3><p>我们已经知道了对于大客户来说，他们是有保证金兜底的，因此我们可以使用异步做扣款，达到近实时。异步我使用了 MQ，至于为什么选用 MQ 不选用进程内子线程就不必多说了，可以参见 MQ 的优点。使用了 MQ 处理扣款我们不用担心余额不足，因为如果走到了 MQ 逻辑，那么它肯定是大客户，肯定是有保证金兜底的。同时为了削峰，我们可以使用了 MQ 的延迟消息，至于这里的延迟消息是否开启延迟多久，也可以通过动态配置或直接在 Apollo 上配置，在高峰时 ，手动设置开启延迟时间，设置延迟时间。但是设置了延迟时间，同时也要同步到设置保证金的场景，因为每延迟 1s，保证金就要增加 50 元。消息重复问题使用幂等接口处理。而消息的丢失就使用可靠消息入日志处理。</p><h2 id="小客户处理"><a href="#小客户处理" class="headerlink" title="小客户处理"></a>小客户处理</h2><p>小客户就不用多说了，小客户的 TPS 与上游服务的 TPS 对齐，不会很高，直接进行数据库的扣除操作。当 TPS 过高时，会晋升为大客户处理逻辑。</p><h1 id="3-幂等支持"><a href="#3-幂等支持" class="headerlink" title="3. 幂等支持"></a>3. 幂等支持</h1><p>系统框架本身没有支持幂等，一是量没到，二是觉得幂等处理会比较复杂，但是这个接口明确是需要做幂等的（大部分开发时间都在做幂等的支持），当前这个业务是一个典型的复杂转账业务，在成功是返回一个值，在失败是返回另一个值，虽然这个返回值在数据库中可以直接查询得到，但是该表的分库分表键设置的不合理，不建议使用查询返回，对 RT 有影响。例如，虽然转账可能是一个非常简单插入更新操作，但是需要返回是否当前余额不够，我们是直接做更新插入（update xx where column &gt; xx 方式）而不是先查。因此最简单支持幂等的方法就是根据请求的唯一参数，来存储第一次的返回值，我们不用考虑返回值从哪来。而我们业务已经约定好的有一个唯一的请求参数，这个唯一的请求参数（主键 ID 或 UUID 或雪花算法）用来判断是否是相同的重复请求。</p><p>对第一次的请求参数 + 第一次的请求响应做（key,value）即可，以后的 N+1 次请求直接 get(key)返回。因此重点在于判断出是否第一次请求。这里我们可以使用数据库的 insert 或 redis 的 setnx 方式。</p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>多了一层存储（key,value）的开销，key 是在本业务中上游服务是支持的，而 value 是下游服务响应的结果，如果 value 响应体过大则存储量会变大的开销。且每次独立的请求都会有此额外开销，因此需要定时/定期的删除，防止膨胀，删除时间需要业务和性能考虑。</p><p>因为存储介质大概率会考虑 Redis/MySQL，这两种在量大的时候都会对性能有一定的影响，而每次每个接口不同的请求都要存储。因此我们需要提现在线上查看该接口可能的峰值，以及业务上可能正常重复请求的情况，这里说的正常重复请求的情况是指， RT 过高或网络抖动导致的 RPC 重复请求。</p><blockquote><p>异常重复请求是指这种情况，例如该接口正常 100ms 处理完成，一般来说我们 timeout 会设置 3 倍（一般性能敏感业务的 timeout 会设置为 99% 的 RT 时间），即 timeout=300ms，但是如果上游出现异常，导致在 100ms 内，接口不断的请求，那么我们只会对第一次请求返回成功，在这 100ms 内的 n+1 次请求都会返回请求频率过快的报错。</p></blockquote><p>其实说到这，幂等框架已经初步形成了。在实际开发中，我们直接使用注解来避免对现有业务做侵入，使用切面来做一系列的判断逻辑。具体代码可以参考：<a href="https://github.com/liuyukuai/dis.git%E2%80%B8" target="_blank" rel="noopener">https://github.com/liuyukuai/dis.git</a>。不过这个项目是在框架做完后发现的，但是核心思想相同，细节做了不同的处理，例如对请求参数的键设置，我使用了设置字段反射获取值，而不是再使用另一个字段注解，优点在于接口上就能直接看到唯一请求参数是什么，而不用进入到具体请求参数体中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scratch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口一眼就能看出，唯一键为三个字段的值。</span></span><br><span class="line">    <span class="meta">@IdempotentReq</span>(&#123;RequestBean.Fields.name, RequestBean.Fields.age, RequestBean.Fields.gender&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">req</span><span class="params">(RequestBean requestBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@FieldNameConstants</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; habits;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Gender &#123;</span><br><span class="line">    MAN,</span><br><span class="line">    WOMAN,</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="期望的优点"><a href="#期望的优点" class="headerlink" title="期望的优点"></a>期望的优点</h2><ol><li>这里所说的期望优点，是希望能从代码层面对业务透明化，即，正常的一个业务服务提供者，它只需要增加一个标识，即可以自动变成幂等接口，这是我们想到达到的</li><li>隐含的期望优点，是指对于某些业务方，能支持存储方式的模块选择，例如我们可以自由选择 Redis/MySQL 作为存储（key,value）的介质，但是对于 MySQL 有个问题：一是表的存储在哪，二是定时删除数据的定时任务。</li><li>其实达到以上两点，那么它就能做到：成为一个幂等通用处理框架。</li></ol><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>最后是抽出了一套通用的幂等方案，支持 redis 和 mysql 存储请求以及响应。和这个框架类似：<a href="https://github.com/liuyukuai/dis" target="_blank" rel="noopener">https://github.com/liuyukuai/dis</a>。</p><p>关于这个业务场景，主要是为平台增收，同时也满足大小客户不同的流量需求。由于需求的特殊和时间问题，在技术设计上做了一定的取舍。（从技术上看，我觉得使用 MQ 交互是最好的，但是他们更加信任 RPC 而不是 MQ~）。当广告的 TPS 到了极高时（当平台流量高后，广告点击也会随之上升），底层服务 TPS 与上游 TPS 对齐，这是不合理的，二是耦合重。最好的方式是通过 MQ 交互，异步回调返回结果，这是一个非常好的优化点，不过目前的方案上线了几个月，目前没出现什么问题。</p><h1 id="5-反馈"><a href="#5-反馈" class="headerlink" title="5. 反馈"></a>5. 反馈</h1><p>这个方案后面又做了优化，起因是在上线大概一周后，周末在家无聊修复一个微信退款数据时想到的。</p><p>微信对超过一个月的订单退款会有频率限制，即对 TPS 限流，但是由于之前业务量没到这个阈值体系，因此编写代码没有考虑线上也一直也没有触发，而且微信官网也没有这个说明（坑），因此代码上没有对这个频率错误做重试处理，而是直接返回了错误，导致数据有问题，业务大概是：读写数据库 A-&gt; 微信退款-&gt; 读写数据库 B。</p><p>导致正常重试是不行的，对于 A 操作不能直接重试，需要重试<strong>查询退款进度</strong>然后做 B 操作。就是这个查询退款进度启发了我。</p><p>同步请求 + 提供查询接口。因为同步请求已经是幂等，但是不可避免 RT 会有抖动，导致重试，而我们超时时间短，极有可能触发上个请求还未完成，下个请求就来了，这时候接口只能返回请求正在处理中，但是对于上游服务是不友好的。最终优化方式为：</p><ol><li>同步请求幂等（我们内部异步）</li><li>去掉重试，减少超时时间</li><li>提供反查接口。</li></ol><p>第二步是去掉了重试，并将超时时间减少，减少异常时不必要的等待时间，因为当 RT 过高极有可能不是程序慢的问题，这时候让上游请求我们的反查接口，来最终得到结果值。</p>]]></content>
      
      
      <categories>
          
          <category> 工作思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂等 </tag>
            
            <tag> 业务思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/44周总结</title>
      <link href="/2020/11/04/2020/44.html/"/>
      <url>/2020/11/04/2020/44.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/43周总结</title>
      <link href="/2020/10/26/2020/43.html/"/>
      <url>/2020/10/26/2020/43.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/41周总结</title>
      <link href="/2020/10/11/2020/41.html/"/>
      <url>/2020/10/11/2020/41.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/40周总结</title>
      <link href="/2020/10/05/2020/40.html/"/>
      <url>/2020/10/05/2020/40.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/39周总结</title>
      <link href="/2020/09/27/2020/39.html/"/>
      <url>/2020/09/27/2020/39.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/38周总结</title>
      <link href="/2020/09/20/2020/38.html/"/>
      <url>/2020/09/20/2020/38.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19hcbYYTGDNqKLn7E/WqMnjtci1E8hXt4fevEsWIuyHvBI+ybXx7vU3Oy/MAZjdotJ49CBfeRqp3KCYcpYAkHoVrYyq8qPFytxzhxFHofRuUlRC9cXKfpWF13pDqpFwiwpajFpc/gA0YnDmHc38+ZldxyAHFT4M6iKAd2kWVKoxasRFEfBR8rCG8eDe1crxyzeSLLmOfwR6tsnXrNaKBILM4osmqY3ZP8WVTx7mKYnN3GDICW7FAjWjY9WMxmTN4Br/18NJrQqPA2P80nndriQGN1hy91V1+YfC6xdgHyslNgDUZaWM4gRam1+5MUtvuTAzY7ipz8sqhdV7fBI+e/V89DpEHHT4sNlORI7wxmjOu/IwWR2CAS4J6vfCuP2C+IJ1pE9rr+cpLilLUfSgDQO00me3BZL1cU5n+68xNrGQjnOT14+OFDGlBjbBuTjUMjnoglczo0uZ0xhppTYSoXqMU4rMzIoK3lQxJ9HXUKpCaC5E+maetqwSNlvp67+blrnDFHRGjU4vnH29gZSa4CUj5OBYQFSfkzeECoJqLqZWH3hzGj0FcLmqSaxg5mXtg0DIvbkYRAtTej8E9OQrQSqnz7Phl0enE+Re7fFo/2rhqXnntosihNfypMbORPPNoiMBAopSwmU7ul7KxFqt85m2BTGl7ShJ6OFKxhdBfrAWl7nDaayP2JT5p53buiF/W6yJLi9gzLb9K7RSzIx4hiA3VpQduVyWl0gOLt5FPhpqrdbXZFraeq/U7fBNtKiYa4LCdBIsoQDYEkGAulihTI2l+Yti8TxI27tRIi0Yf/9joFesXEWJV5v1hYY7XttB91YoLJ7EJKd6JfW+GAnCzOZpHni7uX9pWrpsk7HBEdIy/jmnG26L5acsU8+zRNIb78PiKARMpATr2XXx3D/SpPw+axoCfvj64mrm10WRRELuGZSyymlFRSJXniuUPBsq28TiWRuNKQy+PIF3K//PLASYqYaH4MhQGvZn2I5OIaB3SgJ+dwB46Fnd5I4okbVmPAtmidyTqr9aXhG90U8Efiw2VI8ULMSFQOk0iFc+7Rgr2Nv32USsxQpsTWfEcFCvhIDEZGGBjB9hBuysj2FS1d4mBJ7XHz88SUXZIxWMk9rF7M5dm3R7HL6OEL5U+0ChxzpgUx2nejKI5lKTQ4cxiIhcU2IXGHwdE+6TclmPhmCuCIeYUFJHTMA4vjjRezpU+M8leEbSkefTyZv8FafeiKo7tHQoUgKG+3fwuqQUSR3LOR947QJdUrn2t3RhCflFPGKOyWNLeidaP/6cVDi33N/+toGoaxGbS1jFnAaKhcrm2vHZT+eAUOofFpIJ+k30cVOHHzomUUiPNmT1BgEOJavaAxSCS29r+14eOUjtA25Tsgb6LMwAy7SgN6rPjJXZJKHtU0jOpz+ulxe7agULFjEkerMmD7xTiwv5h9Y6uTDL5GQucyfRbQN43+xi0YWSFt/IrZCxPSXL2oRzMADjOCJabbwtGnF8LIaWLv0hUjEZQI6nGmYRqEd8hL8xI7ykEvX6fd1ctW11Z8OGaeHfvEBHuFbeP5/KKL/S6Ba8hvQbfssdNTCK7Z8PyRwPty0GkMrj46aWG4spkDZFmVbDZHiLNpWleCgOExDHsgPrsnFyG2h7EeniQpctozTbZnE2LzZN+R4wHo5IyeWexKM/hzyxredeF8ermlPArvn0d+1dVo+ZeGQ6Jg/iNey5FmPqDXSIDYL9G0fCkzH/jcpiL9wXBkm4CnkOAWLWnvxx0Xvqkbr8uPLizuIS2nf/enxwT6UAoxj034hD0zJ/W07ZWpoTyt7yIyokAky2mNATU8WL0cJS6p+e9FiwhH9561+Mb9l3F4KkFVYaC4IXEfgZuO2ZLZrxXty1L43aG8ABmhe2aQIKAHzqD+JJYOikqAbrzsSw8OR8yFD1dfDiRNXmj/X8Hsqd0YJpVSiQedqLqvHQGpb+89P/SXFjMO1ogrRoOe0fmIGuIBvzOmiRU1/atV3B/1EEllbrTu4tMTPuDLI3u/mEdZqINkeLR1Eqz/L8UZ8kFM3Mz+/g5mkl37SeOOVITZqSxpISa8EAfWjfp0LkjzhlbyUgLOB0hEKWjOBTY3y9nOfF9tikVLXfKVztkTFHnL259J7c/CD6HU3YKmqsO4CBRlqnmolGJWWV/vY1HkhjoukEmNoRDi6M+dc9H7fnIqTwbszgPOwntRQMBdY8ACT4l+7wPcASdWRPdhkTgF/T0tTys740lqEWzBBX8aW2lYYDUONSzK2hCGnLBkuzCNDzWYDFM/RymHf5B1EW8GGbUpq68jFql+SytIl3lLR6v/8dWs6ezWJidA8LGUlJ5+UV4ni56NjLEbfwazIujl6rCgePyulSMQlaJek9ieqzuCHPd8ogje64iduRN2H/CH3j+sA80j/1iUVPW57PVmR7bu7ja7688WGVhMKDkWe6+AC6xwMujVOe0n9S4x+m52P42XszFPqL4PAOqLwHDJN+Reh9E8+91C366+koMw4I/gWZpjEo09DVGii5Oholz4UIrscWLervTAt0QUxUQ0E/3BLOfYz1ZKggxjy4+hsN/hv5oaWeG6H11jTXTArY8It8exLMrTl0OliY+/Dr2VWgZQhSRyNL+/1q/9gZP/apjEHDCltxsj9juC0WI3wnwdmmCWlfidQ7NvQvo28gi7k/ND4q81NlHovi7zyb3SdQ8M3CQM3kNzfb4ryrQzu94ayXw7EPwKZU5rsZZ69sjqQU6EnUksW8pNGcmjY6OecoijJ8gxNigqNKsE6R2n/4W0sndQErL+lvoqTJZsNlAcj9wdORumptkM4ARMnbSwrKxgCKu6Q+XWIeGbZqf3jcV3vXob0godqsgGG2zkxlHLEv730qMI0orQWKVOPKzmCezo8p9wYfi9p5ifh5cGJzvqPH00l4aoM4faMVmqUhOkAhAxVix25OndlBn3+KB1LpmwciJWJIc0pWPNj9Sc/FlkkV+D/NK3C4VBpJ8XvmL1+HKKQ28VSqm/q+laJUThbr29wUzO0IkgK2M5W/t2dGbTWgSgAoJxsCAf5tZE515qmXO4VbUZalShzx5M8Qkq794EE9OveUBXKyyt6inszhiIXrfflHeIpC6Jo3YfG/2pQ7SJzm1FkzZOPF8Ls4WDKRAOs44QOfVRYM6WMfnxa6FG8AG/q1A1naOpxy8hmto5NEq35Qee05FxQAPDcb7zXEDoXMbDZIH6NPnj/GHwFav+Vtf3AOOxhc3SXc5bfzE0oQK/uy9kgH78RLRp6lI2XntesN5g27w3+Xyv4fRLBd+T0Gp1gjpYVHYEZrxNY4TvGPinxV7iYwmaidoWVDYiGa+gmoXY+tDkPZecwzZVdL+qhCJP7QfzdLnTiAsC6kx5QiyHCa+KX/bols/K3bVRqZuKlzCbehoyG4fvCqG1kR/fHpuJclFGi4Kd2f8gleKYZkVnDBCSifY5KlcXiZD/vyO6bRWkUoLJEY88LV7kAo4H1dhMbjyOOddc4+ljVFJ9gIYN9m+VbSLvKzNP3mYpyXEqM/AG5RnZlyV/LsUmKM3tn7X/zk6ZWj4O6eF8vkhb0tKVjKutlDfCAxYo40u/s2eAYngxH2cUAdNUY58lzwpqt3l0F8V6RABsBN7gL7GwNomGFFkqEQQlP1HWw9TE+gRibhlXp49fMoMEN8tf27MY18hZjsfO/+5327+YsPNE+4vN6OksXM2pcHgXRP0ZY6gUqrJu3df/kFstb42fkOsMPLFOy2/wDSaiFxnkdU4/W4GCO9mCwVV78OkTv0zX+WdddohrBnW1w8loJ9lJW1LQ57SRrH0pk5rbCo2xcrekFlzeQUBiP66zwpY9t99zLrKmdtpuOGO8kyeYaPQBG0eA+2beo4xrRMzUxfc7jfEJ69LWn49La9mFWKSfsEh5iw1aYKLd+8gil+QW/EFrt7oMPJoQEY2nTeRWGRmObturWrHkSp4ZjehJDv7xnG6TgIjGeKD6NHnOnAQ3Oc2UyLhPn+aZAGAEz8iEBaS7H+bcjPPzGZEN+tiB7jtihvDHmsyV1kjoOwExXaNM9d6c4ZU/7NnkLsG59bf9kgARWkExSuA/HtGlBln2ucCS8bOKPzAJv2FoWIwOWCCVXtuc4TpJt6VYx7JVKcDLUE8kIdFIUNsTMylxxRPHkyBepgKF0Xl1bAet9Xt6XULx23Hch2+jrUqEFnKkhPAT3ip2teAmitygR/A2UgF0RM+C72XenLfFlYnREfgw0/zHrc1c7DXLebE22hS3ukVIBVDzyLg5cqG4HakEfOlEm8YnIVDRcvfLEQuXJRnCSghr1HbyIuvtKHhYR7fVmNv4wnVMrUyNxh6yNOJ+O+gg6aRTLdYcf2PsffvRMe+8MhY9Kyu6wDyqkPDRX72xGxj3ed8KMJmmN2N+tlrFrcMpb4HyV7vM3RdDlZlvImcE704Im24DRzjvN/MFNvRWqaps5wuGQWug+pIrNaZJLecW8uaOXkm+oqSjLQotyXseERL2c1rrPFZPOcEHngKRqJ6TRJ1W3LRKH6bTDxKBG1RMSb3AstNXEmkYPMoct/U97FKDswROfGp7GoG51iX5bXoS4Q1+oanuYh0evfd+IyCpGqxbD5AIpdewRT0nPHQQ4FPLbEbkKk3f2HMW4AbaSMzo0KdNoItmE3Z/F/er/b3SYVCRiuMB8/WjUoAGmfOWfdJxgyEvq2srd4/Ui+rsSl+GtTd/co+4SgBkNkqBlNMWt8HKkoi2kMltAP7JUeiGNrSMDYz3t1Z1CNmI5HI0GK</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/37周总结</title>
      <link href="/2020/09/14/2020/37.html/"/>
      <url>/2020/09/14/2020/37.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/36周总结</title>
      <link href="/2020/09/06/2020/36.html/"/>
      <url>/2020/09/06/2020/36.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/35周总结</title>
      <link href="/2020/08/31/2020/35.html/"/>
      <url>/2020/08/31/2020/35.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/34周总结</title>
      <link href="/2020/08/25/2020/34.html/"/>
      <url>/2020/08/25/2020/34.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/33周总结</title>
      <link href="/2020/08/18/2020/33.html/"/>
      <url>/2020/08/18/2020/33.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/32周总结</title>
      <link href="/2020/08/11/2020/32.html/"/>
      <url>/2020/08/11/2020/32.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/31周总结</title>
      <link href="/2020/08/03/2020/31.html/"/>
      <url>/2020/08/03/2020/31.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/30周总结</title>
      <link href="/2020/07/27/2020/30.html/"/>
      <url>/2020/07/27/2020/30.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/29周总结</title>
      <link href="/2020/07/20/2020/29.html/"/>
      <url>/2020/07/20/2020/29.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/28周总结</title>
      <link href="/2020/07/13/2020/28.html/"/>
      <url>/2020/07/13/2020/28.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1/JxYpSRrON+4ns4qJntO7NNgR+WzIzF/bp4tD3fk872ela1Rp9xjxlaHYTMK9GlVo/zTUFsM2hSqe3DS2m69sNq8LEJG91eReRcPniJtxyZDXwFJI578dU/HdDPauv4BYQzpkiEKjaYXp8KS6ExWU/G0fuV9tmDE0hFl0PSzrt6xekrbDStyM/qeDfA6tQUCKEtOuX0uPzltV+bV4O2cEXEsCFi+HtxAGpj9xk4PKT8Uv8iAEV0qwVM2lE0mwTrXoVFcCdqz41u7eDVzM9ZjW2jxc0Kw23HFOK/gXN9irSNgN0Ec3v5ehF7tebbkSkyqVa7Y229GeBt4v4QBZV1XKbsciJ6KbHsRy+srPUHfq+C7f/H1UzUTNle8JyCgfvLk8GwNJbjJtgoJ7yfHoLyxFr6YPcjkG37zCslwK4tOOCPBaFq/+eYCGugJze512y6AgdK4L/BpwKhFWup5krg2dtvzWWPgIMalkhz0Hx779MbawTMQ3neOK+ZYgQFQHCfKZFTuZV0ZWTAldH8LlHnVnFKc/1onPQkeFfFSE4lk4nh8hkIIqKrqg+daJDHV+oDFG1EBO44YkU3zpyFV+qNHQLaWwcYOxscLmmERtVjUtPiwXgkzqlOVglOM99Kd6M+du3ykTWhsZWFKNPkLP6S5QVV3lwRFtSZts9vE38fLYKJc2vxP3IzN4XDA2Hd7hGHL+XAY0WcPwVIuvfRUb5MnVt2/iOmqFsPtSmLX1vz6h+P6kvoDArRp2jemC4cJEdhERd3+DvLnFsSRLSl+b3BNU+90r0nVqKhmZNi8TGq+CiOmxji48aryZsFFJRAzfVRJE4PNdxItLJasq3HYoFjEukQN6LdAQbrp3t8ovKxhnny5zIqqCc9R4+4VKjVAnmmXpeouFeX+mW611BhN5rNbmoO9SyCPPgKZ05K2YBURjEnNlP1ZOB/CZlMOpX0ncFgltmn2OXuSpxUgsMCFEslCE5zi7lNjrVvSnAKp+vH34/2OL/PD/KP2nM4PRErBMLAXhpY88B3aRjqTY56HZDlHKz37tIp3UCb2gwLT9qVHv6V5i3rS3wU21p/xpZf7xL+mMoZ/1SXwRkFduY/E8Ez+YKcn4wuDDQ6WCbTJSj1Gfv3eQUgbt02vMaoFT7So9KijJUCgRgxXHOdrPTLKLRxJa8ZLDxRl2q13bJ9ApYUZ6icJRUVcGWOQCfiwPNZTVyMpCNXOaMJ/iKDqNcRs0xQgRnU2X0MskwW5pHmn5RnDLrsYVrWzVWC3kT6y8TdrJ1Y47yrWo9k5n3EtyAjMTXu+HR7uQLn+NV4YXjYePfl5rPtU8zdT7B2XAR4oUyiCFpyCkccAYnGQaZHe4pMAKIQBh1PD4KqeNOewg/yp51bfq76wTE55O96knfgdzO2YZOBsKps7x2sMR0xhPni5jVNxjqGIAtLjIyLkCpwS+JpfyJDhdG9azZrsnw/moBjxFleLrUgZPYetgiMeoAlxDcYOFBu9dGUxgB9e9lkFFPX6zfdYXSfB/qAS3tno9zwDK2g8wMjnePeSaHfSEJY0P1qrcWEAmKhYYDv+nqFuV6n0VCTEPWK3rhoDTvSVba/QFmGwTCJFDFsmDkNVylgNE+YcOe8ae3ihouoJuN57YbfiRUKTrFsV73VJIkZ3Ekjy2rmI5NSyASnTCXBCItveKwNlIcQVBKQOvRZMLslPALHciWqzw2iqzcKnplcVhd2nPvTCQM1BZXsqXTavbAbZhK0SxAsUK+dYHqpMyIOOinHRNaI229LRdAn2mVAWWWuvWW42tKRZixzUwtgHPtmYfmsqZ7WmYqVENPgzDD3ZLJOdpoPUpCLpd3BIkg+pZVsiuWYAPr4W58njy7AjvRJF5yxBkFIUKznM860wCGgUPu00f80Zbn4Mdepv0jG46JM/FfrEMij3Tfx7Xp++b4g+8khL9vPJRffNgrLo7+uFv/OQWQ9GHcq2kqofilO9yIHbyhT1acK33S88sJxRdidAjazzak1EeJNmGom2uBLEgLHItwTfu0f+DUza+jc/201XWwTRw7zwbRYcCR26nFPkcVQgrDjx8nV+ls/5YDiOn8hjoy1gsigAg7YnwoNMAOcPa8m+EOwZDWhPbFHQTkS9BHYfy7/igiPHtmmg/q2jhJbV7qZGMex0wIcmRTXLLLVmXnjrleEHmgdujjFCj+C0u5mL05iJG3QYMguxbHOdyIHZKRIGvu99b77FvhhGeBndbvMvpATpRh7U7ZnzOCOF3xvUWdFEdGvmF2RQeCLDQW1oas3toGdbf314jx8go+sVjkI2uVZS1YZxPBN4Mhebhp/dwHJWA+B7mtHEYWh1ltyzZXUZ5U18fAcV7zH8rKlYDCld3R0f1wnf8jbbWWGcRWtQ8yROpntzO7xzAQCl9HEUCAylW9n7uhUPMgBbYPCMvVVeifdR6sKjT5R/O0DJalNq3hFyJqkGParoaO6k1hHTtWZm4qzq1/6LgnNAvPXAJw1ingfbgCfCZSGSwkC2pQQIGIwKpG/gOWzJiekfg9x56BGC6S1ZTPkdyvqCNHaH8BTOjQAYC5SFvy31XufGMwF5WWGmqo6iWQ+ZT6NkWgCbbzIAspYz+2UH+UznUrDBr6hQ388+CRzDK9ftIAyuFJ0BzIznNVXHXEZzwr3wWAJrvxJvMbWEKOWR89aN3cT68wi4bhb45bEk8hGN3QPRHdDt/ebSLVMDfVP7my7zSF4tBY1nUYkeZ+J+aZLwbS3/Kq1onLJq7lUEwzfMgT82RGXXWire6D9vok/zuzz1tVt+pFTXFeErX5VRtldNEK1FBXcp0ByWcB/4OJlmCpjQA0SgA4b53LScsQY/mb2cZhQH+F7I4P+2hsc1n2VlsTqALkeKRvzez/vy/d7wJ4aNXkuwu0wufJ+Jn/PRGqqA+nAwD/HA0M3p3U7p7ryGbV9zeSVoXO3sbgbJ2CnBCsUoDYism7KxVG3sF6ZtEaQ/9qkmOrnqmtPP3ikbGp5Oo5A3QFGiv7Tz1yhXoOb2/XDaZgYTrRb5r040otue/nz2C7Aj6vdlD8uu+7sO1d</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/26周总结</title>
      <link href="/2020/06/29/2020/26.html/"/>
      <url>/2020/06/29/2020/26.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/25周总结</title>
      <link href="/2020/06/22/2020/25.html/"/>
      <url>/2020/06/22/2020/25.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/24周总结</title>
      <link href="/2020/06/15/2020/24.html/"/>
      <url>/2020/06/15/2020/24.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/20周总结</title>
      <link href="/2020/05/17/2020/20.html/"/>
      <url>/2020/05/17/2020/20.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/19周总结</title>
      <link href="/2020/05/13/2020/19.html/"/>
      <url>/2020/05/13/2020/19.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/18周总结</title>
      <link href="/2020/05/04/2020/18.html/"/>
      <url>/2020/05/04/2020/18.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+etLwXXNnUAcJtVufUVMgQ8m2v0Q2Y6GRFa97mP0W87nYD3GlABRdBPiuoYdelUrF5j8Cap1Asym18SphBs1psurRe+O2w+QyTBVmMm8rLeBYbwMB2oZk9tkwLRzmAjL2VcbIAx7R7pyg8bNyMCXzoI7VUb/kTZ/5iM/YVjfiDpc98A5RZR5QRk2DItNrfiBQc8YYIevJbRYqz1isBUfGKlpoGlDNPvGi+tgluyKtIM9qUBNrJ1FTFtHjNiEpXvVZRmDNr1I1S7Cvu8AjaK4lPn+X4enkfWPj6MhWl91OMc3vHTrTVZRiGJwG8AODhve3fxSn5gJW4/cy45PLNWu8iZu/S8psjmY0E68A9NRcTGjDoQQwxVrB9oey++xaXQH6HkI7fhMyk+4M3ZeUAyVrfnG+kxEtbUZ2xIIGbHl7imhoj/p6+zmP591ENeZaPNUFjXnsQGFDY30u333jjrREzjhQKVTzYtmelKoP3RUs69iNfSqfLF82FIGdh8ebWRK6QHMVPSDdysa7vAXfOu78sF1DsanqlBCg7wDhIBreM93Mq0cBPeV77hxurCXX3nDWao9PXh6cwV5av1UCl6iDniANC7OQ5I3V8f79IPZilSynsH6E9j0h8LnWPlrHRqQJXcI9AGDG5+PhsoM17tZcou2Z0t8f15VSjsoM5VNQ4ccVQLs5l0kj4AAvZwy6zsjUktYJQz40/4NONi11StqoUhxPV07vW9PxtcQkExY5qpyjzptT5Ro6J2+GFF36TK7HY/T49I9qK6Zf7vKPIT2AOiS5rtOGnws2w160Kz8HynudWcFp6tt5fENlt+UOkcsb0nXFTicWtuySNLt6Jrx6q3eI4DkH7s/u2lYFfEiZ7TqNg6lL7meGNFLs8EG/8+gKEL+iNAUqml3A24oVg0ZxQt4Qgspb98XjZdavRTSuyYPQcxQ4n7D4JY7mzW2Sysii6EVWGXP2kLIsB62PHyZaRwQ1ftaZh41A7zYHMP4XQed6ovV0VvTZ6E6xNpToCynIlKxxB45xd96o77Niue85Qa79VaJ4nNcO5P/VNxP05pIvxaoZlDeKiXyJ46fW1aYfY3IXzbThzGFHZEbOLAqb7VuAiH7Klj7Bo14ZCAlENormnymQ1Du6DbzIjWHCbOBM4t4IL17iGTEAA82C/S9eOpxRSML04rtKm5KJ4GIFGCcKU/O1CwUWTmSvKpfvmKiUF9VJTjxflIk+RrInN7ZQ0AOT70kYOet5VTipF8fOMhL3KqBC5PtDBKGB3TlYNiRh0t2YXHbZmO/FDeFEtN6J9UPHzV0Za6MyEuhlc2kyeEkXaiYqmf6aHL/6126F9ZE3+T/Uw7Fq3PqZ4StdruvJZDCKE9oc/MDnVCJHx7f6ktjoaAWSUYj32vho+lsGacsY8LDhkMIgdcH/qophgbPYls8bJIiiAqZfDFON+6MSUbGih70zjiCWiwwMkSix+nNIoOcMHq+0x8rl4dJv1jAa3zSDvq1/V8LdKbaZliiM5FvcEcNJsWJ1+AJYZEv3LkKxvg5td4uwT3C4q9KvohjXxqGBUytaiKmRPR8VWWLV8XhUguUpFJjLsHZs/yc3YvB6Ini7vI81D3T3lrA69oUNMZxzAfeO+z5GGc4ufYe0+outtRDRHb3LON3wA4ZYIHPmKQ1FJNCLKsmDTateL3n7GMmSNhv9Tcarjm2ZP4j1jn5q7ruLNw/CAAXAMb4yQhnwF2HsG/SFMptitNLes0tltJlOJDGdVUHIbt2gcJkhq6bAuYocrX2tgEvgvzPc2pQ99S9/CB4k6NoDRSHJUUiHYXl6sYBmxbK4InbwKLhEnrDVJJVznv4dCvKO2NxvOmvPjG1NPKvgwsdDFW6Ta36ZHYdPbdpZkueuZbQVy3XcKhVgTGTZxL3okH+HWlIp5EW/gXPeX6H7XJJ4+uPetc0qOt1DYBP4HxY28OaaUs9mYsaOQfOqZo8dnysAYaCYcTOsu25QXqksFMlaVsG2oEwjRtBJO+/ISXgbqu7J7lrUcEL/wJiKpso4CpXuVgW7LYm1gEF4AMBj+XKn2JkM5G5O8C0jC92TIwJhs7gShhbaMkK6/Jrcb06jAU1wOWLZYeHh1a0fxGnw/EvLWDiIT4FFA0D0v4t22MxuXWwO8qGbop45QUOO83Jy+Y9V48iRoz4FZsjr7EKRR2bBXj364UmclBJIIM/QnjLGhjA1zMYRzEuI7wZpCrJJ7G2Ri93vubEaMOVGnm5PrFr9VvlukUJwfQwQUCWQCy1BS9abfDJe1CcjgMIaCHAJ/b/h+5g3alYNJHglkzkwHVFZIPX3RC4SAiqzmsX8mB1E1fWAdqV0hEWoC+OPUIv2gCJtBrWVBQxOCIL0HADtGf28we0DfKZKBAsEqfpTLlwEyy414RBVnyUo2ANNtJRaydKN63gVOxC6aA75WKY+LocLqXiGwy8phodzQwf/6iBwl3Hj8Fyv3/1bY4nlRIYA2EHZb+ar48kBhiNeU155whH6jGIwv+gyxp3QvRmGpGVfh7WSp6ImkoKUShoIOna4BDGnjspaeeFBSHrAIVAK/eAkeszM4yj9zobRkZWMID28hWwzU9b2kmWLstxPjclowmih0oDO80qHxAB8c42MPvQHVoP0aOh1eLc/svlGITQKG5yQaWnBfrb1wq4eUmzoRW25UM+ZwdJ/elpJOx6AvL8qVEL5uMs2gS3hjWhhWV82KsbUJE8RVdLtTQoil/ADATT/2h/xqHlhqqQT2zoLB1u//acW6c5hPHtTwqgJ4JYs/kKDNPX52u/aKH8yqvw0wZjFPWTa35Wejc91Uya/lzrGA9+pEPZDu/BNdcyaVl9OVC9/Sd6EWCaDIaOt4uatWl0OSpToN6729GFgUhcGAOLFl0BkPVAESQdF+SQOHkrLzJ5tdAavXgVKkb91WIq0+0J7V49PRcrQFo1/RC/9sc901CgIZEVwWE8HF+pa0n4AGJyE2Mem9s39dVPV8pE9YouBPP75Cehhq9mj+4TB5K4oaM+G3i91YcuAzdSHtewpL6b1OFIOneCfiW71Xc4UpnM4HEYQLCn2JE8EAt2X4a6bIDPlWxouvgMCFG4KEAl5BPuWxofRDVUOCBlCXtX1UD+32DeskMjIGNkJd5eWsKwa/vldtnZQ2+TUXjqe+t/9AKYS+ay7Wpg+XnmPhrESPoCACfk+N1COTnXfdm9+AbPEBvm75XojnzNvnimfv1hK33Dh6OcIF0B+dLDURbPtU78coml+vsriW5P6gfxDrqFWQxtPkkTb5YSBqce8pgl5kHWTUp406jzC64K12aLTkunTNQLN8UsSaIOsdpEVrncFtRv4xvScq59kil2zCotamfnVB33YNdV/oLyhDxuikw+u9W/dDe1XsC2FIanaN3pmA9/dF4/ZvHMtCWGzFOeky88eRXkASwqA+73B/cc0ouwKZ0UHDg2GawMdNDKfZDe4CCXp4W8YhCeP/QG2Wn3SYriLVFHXzhF+NFohp4j/9uTYS62fdHXXs/5MRMAhsOAOhqjw9nsL4NY0zlSJqRhUAiKjun22khw/zX5Vo0EBs/pyXJHIkHV96zfEj8ZuV6XWFMxLVkn//fB2X+odC7XyQgPnRzGtIKK3sZ7qOMcI5/TXhyeZ+l8FaMgjFTq2EjaS6SKPcBozNwE3Ev/e28XYSRT9/fJtFK061VE38M4SjD6osSDCdpcFxM8gLtuxBsJITLm3tTeDFCxh+jl44Fb1R34PdwlZHm5rv8aYD2Zr+SEwLKkUka3K2+UhWOaRy1P0+7LpdtzYfIe8tR2NH8F29jmUZnjWF2CYcMleF8Rthf9dV8gHFgYFTb29dHUA14M/xPkF3iYRf91rxVyF4CeO4tG7Etx2glj9/P1jYGNg76mHTca8HIJyBO15FRUq4A3w98NBihlLu8tc4oIayCnh/O642U/zxPj2vcE8UBkzsWEs8pyuPMq/L6L82Q9ByX3U5rXynRNIhzOlLuMqMgekfwuDbmO9HiCuP3mP2kH7134Qb3g6Jxy8gbUAIsaKVaKCjkp2tZStc3ssAakfZacRzRU8ua26dtlpEG5jvrF+kkk9ptDSTibF5iESxs9Ejx/n4GqFStPSG5/fQdwGi1yr6zpBpjJMbWGKh7QaInUo/38WrsOH0LYkGoFbztBVGWUdAWWgAeHvLjqwcJEP9hR7/Upe+C9I8qSyJAbe649LzlRBhS3TXjK3h1+WFeY6dnOooIjJdvE3CRgtz4Vij6DEfYWOVK8kQllF4ok2zCjt/dPM40kaT5IOqGA17dwUceyIPMlXtvGptiHppTJOnZluRkwpnzJAC3U9Om6lolweO/DvxeVqyAVJyu1yee596QFGcx6FNmfpTYTlJ0Wy9o7cRCJQyaw47qLrLVHHd/M29Cd5bRIqHY5fqHaE5EEbIn7G8hJ60u6A7G/HdZ1MxZY0fG0SDsmx0MEnOVrafg93QM/A843Lwkv+Edur8WagqiYyXEHqo5MfjWDr8Y4Exd3TWqb2bAPFvQhR7L8/bRBI23kt3OMZPtLwocr0wu41EnV8S5a7OHafVeiiOEEhYpnle9LAXtuVWABg7oeg7a7+ewx7AfFAmdLrzcEjTWpw5caWjI+oxHx7nOrA7sDS63c1IWLvmRLGZpvliouXr6jDwoxzRZabpb7gwzkrwjDLUQ0ArcV52mfWeCRCoRSeGhwL+7bDCzlz7eid7ciVVoSDphM1lX6/iwUCbZvAsYYKaMeQI9L+B6QbQfjkXe+o2D9nIIuwhsDCyFR8eij7HlmdA13TPbdzE3fBz/azwg1OVy1ufB5QgAY54lH+WRGvt9q01imyFB7RT/gfV5aNtO32tKKxIYWgyO/DkLhlPlEX0TPlGcUd1LhBI4GpM8eF0sI4gd6lNCCz/rttdvKK5TZBJ4vwYHxUciBJW3ExZdI3g1Og58eJUeNvdiiSdc61SEvMe/IrdtND/kzGD4M3OLWs2K7mvWzlIfrgtdTyuzOgbgxwkhYQ9XdO6Uevnoy5S+esqMXR4eLlSZ4HPS+ZXWih/Ll8mSMy6ULyA5UsdUnJxjBO0H9UF7bCdcxV+1kR0CMhJa9Lmq2SE1KtQjXGYM30FkIEVgJcyB8B8LUC1SRbjoDho8EbMoNmomwGu+I3fDX6e4hVbiIt3Zd0pREd8sGHw0oNbbQv1ZTE5fHOZqH/IJ/OlXt56ARVTAHuuuSF3oaCLp59nTR/NwcKjnD5Evmhv</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/17周总结</title>
      <link href="/2020/04/27/2020/17.html/"/>
      <url>/2020/04/27/2020/17.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/15周总结</title>
      <link href="/2020/04/13/2020/15.html/"/>
      <url>/2020/04/13/2020/15.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MQ使用心得</title>
      <link href="/2020/03/31/tech/mq_use.html/"/>
      <url>/2020/03/31/tech/mq_use.html/</url>
      
        <content type="html"><![CDATA[<p>MQ使用的总结心得，主要是阿里云的开源版 RocketMQ：ONS。</p><a id="more"></a><h1 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h1><p>消息中间件服务器基于阿里云 ONS（商业版RokcetMQ）<br>消息 SDK 代码基于：<code>ons-client-ext 1.8.4-final</code> 版本</p><h2 id="1-1-名词"><a href="#1-1-名词" class="headerlink" title="1.1 名词"></a>1.1 名词</h2><ol><li>Group：组，代表具有相同角色的生产者组合或消费者组合，称为生产者组或消费者组，例如一个支付系统，里面有10台机器，这10台就是一个组</li><li>Topic：一个 Topic 标识为一类消息类型，比如交易类信息、支付类消息、积分类消息</li><li>Tag：一个 Tag 标识为一类消息中的二级分类，比如交易类信息下的交易创建、交易完成</li></ol><h2 id="1-2-为什么引入消息队列"><a href="#1-2-为什么引入消息队列" class="headerlink" title="1.2 为什么引入消息队列"></a>1.2 为什么引入消息队列</h2><p>主要两个原因：</p><ol><li>解耦：当某个用户支付完某个订单，接着第三方支付成功回调到支付系统，此时，支付系统需要通知到订单系统、以及积分系统。此时用消息中间件将支付系统和其它系统解耦。</li><li>削峰填谷：当某个活动高峰期，大量用户支付，每个用户支付完后积分系统都需要更新每个用户的积分。此时更新用户的积分可以做延迟顺序消息，做到高峰期的流量平滑。</li></ol><h2 id="1-3-使用消息队列需要注意什么"><a href="#1-3-使用消息队列需要注意什么" class="headerlink" title="1.3 使用消息队列需要注意什么"></a>1.3 使用消息队列需要注意什么</h2><ol><li>首先考虑是否真的需要引入消息队列？</li><li>这个业务是使用普通消息、顺序消息还是延迟消息还是事务消息？</li><li><p>该如何正确的选择 Topic 和 Tag？</p><blockquote><p>以天猫交易平台为例，订单消息和支付消息属于不同业务类型的消息，分别创建 Topic_Order 和 Topic_Pay，其中订单消息根据商品品类以不同的 Tag 再进行细分，列如电器类、男装类、女装类、化妆品类等被各个不同的系统所接收。<br>通过合理的使用 Topic 和 Tag，可以让业务结构清晰，更可以提高效率。</p></blockquote></li><li><p>时刻注意订阅关系一致的问题</p><blockquote><p>订阅关系一致指的是同一个消费者 Group ID 下所有 Consumer 实例的处理逻辑必须完全一致。一旦订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。</p></blockquote></li></ol><p>即同一个 Group ID 下的所有机器，订阅的 Topic 和 Tag 必须完全一样<br>注意：</p><ol><li>不要设置错了 Group ID，这样会导致正确的 Group 出现消息不一致</li><li>Topic 或 Tag 不要修改或删除，如果必须要这样，做好消息丢失的可能</li><li>每次对的消息的订阅信息做了操作时，在消息队列控制台查看订阅关系是否一致</li></ol><h1 id="2-启动配置"><a href="#2-启动配置" class="headerlink" title="2. 启动配置"></a>2. 启动配置</h1><p>生产者配置对应表：红色为必填，紫色建议根据业务调整<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/mq_how.png" alt></p><p>消费者线程源码：</p><ol><li>无界队列：理论上消费消息足够多，会出现 OOM，因此建议做限流处理</li><li>ConsumeThreadMin 默认为 20（同时也是最小值），可以根据机器和业务特性进行调整：<br>ConsumeMessageOrderlyService.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.consumeRequestQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line"><span class="keyword">this</span>.consumeExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeThreadMin(),</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeThreadMax(),</span><br><span class="line">    <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">    TimeUnit.MILLISECONDS,</span><br><span class="line">    <span class="keyword">this</span>.consumeRequestQueue,</span><br><span class="line">    <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ConsumeMessageThread_"</span>));</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-使用消息队列时可能碰到的问题"><a href="#3-使用消息队列时可能碰到的问题" class="headerlink" title="3. 使用消息队列时可能碰到的问题"></a>3. 使用消息队列时可能碰到的问题</h1><h2 id="3-1-发送时失败"><a href="#3-1-发送时失败" class="headerlink" title="3.1 发送时失败"></a>3.1 发送时失败</h2><ol><li>如果是异步消息，不做重试（即只会发送一次）</li><li>如果是同步消息，默认重试1次（即一共发送两次）<br>3.实际观察发现，当消息发送失败时，基本都是 broker 集群抖动造成<blockquote><p>发送失败时业务日志如下：<br>com.aliyun.openservices.ons.api.exception.ONSClientException: defaultMQProducer send exception<br>发送失败时ons日志如下（ClientLoggerUtil.getClientLogger可以查看日志位置）：<br>sendKernelImpl exception, resend at once, InvokeID: -8402362259252035824, RT: 1ms, Broker: MessageQueue [topic=MQ_INST_1961444063236731_Bau0j5Gw%TOPIC_TEST, brokerName=hzvip-mp91lzy4w01-01, queueId=7]<br>com.aliyun.openservices.shade.com.alibaba.rocketmq.client.exception.MQClientException: The broker[hzvip-mp91lzy4w01-01] not exist<br>For more information, please visit the url, <a href="http://rocketmq.apache.org/docs/faq" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/faq</a></p></blockquote></li></ol><h2 id="3-2-发送失败的解决方案"><a href="#3-2-发送失败的解决方案" class="headerlink" title="3.2 发送失败的解决方案"></a>3.2 发送失败的解决方案</h2><ol><li>因为发送时，sdk 帮我们封装了异常信息为 ONSClientException，因此我们可以捕获该异常，在 catch 中，保存该发送失败的消息，稍后发送，建议一分钟后再发送，因为在实际线上场景中发现，如果 broker 抖动，在一分钟内消息都是发送失败的（怀疑在类似 zk 协调中心选举）</li><li>实际操作代码可以使用 redis list lpush 存储，接着在 xxl-job 中定时任务中 rpop 拉出发送失败的消息重试<blockquote><p>注意：如果是精确的定时任务发送失败，需要定时任务做延后特殊处理。</p></blockquote></li></ol><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    SendResult sendResult = producer.send(message);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ONSClientException e) &#123;</span><br><span class="line">    log.error(String.format(<span class="string">"Topic为【 %s 】,Tag为【 %s 】，messageKey为【 %s 】的同步消息【%s】发送失败！失败原因是【%s】"</span>, message.getTopic(),</span><br><span class="line">            message.getTag(), message.getKey(), <span class="keyword">new</span> String(message.getBody()), e.getMessage()), e);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发送失败，大概率此时 ons 服务异常，需要放入 redis 一分钟后重新发送：MqSendErrorRetryTask</span></span><br><span class="line">        redisCloudService.pushMessage(RocketMqSendRedisError, JSON.toJSONString(getMqRecord(message)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        log.error(<span class="string">" 失败消息入redis补偿队列失败 "</span> + JSON.toJSONString(getMqRecord(message)) + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>部分源码分析</li></ol><p>发送失败时的重试源码：<br>DefaultMQProducerImpl.sendDefaultImpl<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是异步，就一共发送1次，否则一共发送2两次 retryTimesWhenSendFailed 默认为2，且没有暴露 set 方法</span></span><br><span class="line"><span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line"><span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">    String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">    MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">    <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mq = mqSelected;</span><br><span class="line">        brokersSent[times] = mq.getBrokerName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//Reset topic with namespace during resend.</span></span><br><span class="line">                msg.setTopic(<span class="keyword">this</span>.defaultMQProducer.withNamespace(msg.getTopic()));</span><br><span class="line">            &#125;</span><br><span class="line">            sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">            endTimestamp = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果是 oneway 第一次发送后直接 return，也就是 oneway 也是只发送一次</span></span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> sendResult;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-2-消息重复接收"><a href="#3-2-消息重复接收" class="headerlink" title="3.2 消息重复接收"></a>3.2 消息重复接收</h2><ol><li>虽然 ONS 提供 Exactly-Once 特性来保证消息的最终处理结果写入到数据库有且仅有一次。但是实际中，即时开启了该特性，仍然有极小概率出现重复写入，而且随着分布式机器的增加，几率也会增加（阿里云官方人员也证实确实会这样）。  </li><li>虽然最佳方案是消息接收时业务处理保证幂等，但是业务各式各样，尤其是复杂业务时，很难保证幂等。因此选择另一个和业务无关方案：通过 Redission 锁 + MessageKey 来保证同一个消息内容在某个时间段内仅消费一次。</li><li><p>此方案强依赖 Redis，因此需要保证 Redis 集群的可用性。</p></li><li><p>消息发送时，使用消息内容的 MD5 作为 MessageKey，由于 md5 会出现不同内容极小概率得到相同的 md5，因此额外加上 messageTag（也可以使用其它信息摘要算法）</p></li><li>消息接收时，通过 Redission 分布式锁对其 MessageKey 做锁（可以使用其它分布式锁）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.setKey(messageTag + <span class="string">"_"</span> + DigestUtil.md5Hex(msgContent));</span><br><span class="line">send(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息接收</span></span><br><span class="line"><span class="keyword">boolean</span> tryLockSuc = RedissionLock.tryLock(messageKey, timeout);</span><br><span class="line"><span class="keyword">if</span> (tryLockSuc) &#123;</span><br><span class="line">    <span class="comment">// 成功获得锁，进行业务处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失败，说明该消息内容曾经处理过，此时是重复消息，直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-3-消息消费到一半机器异常宕机"><a href="#3-3-消息消费到一半机器异常宕机" class="headerlink" title="3.3 消息消费到一半机器异常宕机"></a>3.3 消息消费到一半机器异常宕机</h2><ol><li>主要通过 Redis 来保证消息消费的完整性，注意设置 TTL。</li><li><p>枚举表示：-1 表示消息消费异常，1 表示消息正常消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String msgSchedule = redisCloudService.get(messageKey);</span><br><span class="line">msgSchedule = redisCloudService.get(messageKey);</span><br><span class="line"><span class="keyword">if</span> (msgSchedule == <span class="keyword">null</span> || -<span class="number">1</span> == msgSchedule) &#123;</span><br><span class="line">    <span class="comment">// 消息从未消费过，或上次异常消费，此时需要重新消费</span></span><br><span class="line">    <span class="comment">// 根据业务特性，是否需要重新处理或不处理...完</span></span><br><span class="line">    redisCloudService.set(messageKey, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == msgSchedule) &#123;</span><br><span class="line">    <span class="comment">// 消息上次已经消费完成</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于 ons-client sdk 对 consumer 和 producer 没有做优雅关机的设置，需要我们人工 shutdown，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者优雅关机</span></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者优雅关机</span></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>部分源码分析</p></li></ol><p>DefaultMQPushConsumerImpl.shutdown<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 其实感觉没必要加 synchronized，因为在上层调用已经用 CAS 保证了</span><br><span class="line">public synchronized void shutdown() &#123;</span><br><span class="line">    switch (this.serviceState) &#123;</span><br><span class="line">        case CREATE_JUST:</span><br><span class="line">            break;</span><br><span class="line">        // 下掉注册，修改状态为 shutdown，防止继续“拉”消息</span><br><span class="line">        case RUNNING:</span><br><span class="line">            this.consumeMessageService.shutdown();</span><br><span class="line">            this.persistConsumerOffset();</span><br><span class="line">            this.mQClientFactory.unregisterConsumer(this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            this.mQClientFactory.shutdown();</span><br><span class="line">            log.info(&quot;the consumer [&#123;&#125;] shutdown OK&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            this.rebalanceImpl.destroy();</span><br><span class="line">            this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span><br><span class="line">            break;</span><br><span class="line">        case SHUTDOWN_ALREADY:</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DefaultMQProducerImpl.shutdown<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown(final boolean shutdownFactory) &#123;</span><br><span class="line">    switch (this.serviceState) &#123;</span><br><span class="line">        case CREATE_JUST:</span><br><span class="line">            break;</span><br><span class="line">        // 下掉注册，修改状态为 shutdown，防止客户端继续发送消息</span><br><span class="line">        case RUNNING:</span><br><span class="line">            this.mQClientFactory.unregisterProducer(this.defaultMQProducer.getProducerGroup());</span><br><span class="line">            if (shutdownFactory) &#123;</span><br><span class="line">                this.mQClientFactory.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(&quot;the producer [&#123;&#125;] shutdown OK&quot;, this.defaultMQProducer.getProducerGroup());</span><br><span class="line">            this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span><br><span class="line">            break;</span><br><span class="line">        case SHUTDOWN_ALREADY:</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-4-消息丢失"><a href="#3-4-消息丢失" class="headerlink" title="3.4 消息丢失"></a>3.4 消息丢失</h2><p>消息丢失最大的可能就是消息不一致造成的</p><ol><li>消息不一致的原因无非三种：Group ID 设置错误，Topic 设置错误，Tag 设置错误，逐一排查即可</li><li>解决完消息不一致后，定位消息不一致发生的时间段，将消息消费点重置当这个时间段开始，进行消息重新消费</li><li>由于我们使用了【3.2消息重复接收】的方案，因此不会出现已经消费的消息重复消费</li></ol><h1 id="4-更多"><a href="#4-更多" class="headerlink" title="4. 更多"></a>4. 更多</h1><ol><li>在 <code>MQVersion</code> 类中可以看到 <code>CURRENT_VERSION</code> 字段是 4.3.6，猜测 ONS 是基于 RocketMQ 4.3.6 版本，因此可以多了解 RocketMQ 4.3.6 版本。</li><li>推荐书籍《RocketMQ技术内幕》</li><li>B站 RocketMQ 官方视频：<a href="https://space.bilibili.com/271666652?from=search&amp;seid=18398985987289994532" target="_blank" rel="noopener">https://space.bilibili.com/271666652?from=search&amp;seid=18398985987289994532</a></li><li>ONS 作者讲解 ONS 原理视频：<a href="https://v.youku.com/v_show/id_XODY4ODE3OTY0.html?from=s1.8-1-1.2" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XODY4ODE3OTY0.html?from=s1.8-1-1.2</a></li><li>某个读者阅读 RocketMQ 的笔记：<a href="https://github.com/LiWenGu/awesome-rocketmq" target="_blank" rel="noopener">https://github.com/LiWenGu/awesome-rocketmq</a></li></ol><hr><p>本文尽量为提及的每个数据和说法都列出可靠、可考的佐证，但由于作者能力有限，水平有限，难免有所疏漏，欢迎指出并讨论</p>]]></content>
      
      
      <categories>
          
          <category> 工作思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/13周总结</title>
      <link href="/2020/03/31/2020/13.html/"/>
      <url>/2020/03/31/2020/13.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Zookeeper:分布式过程协同技术详解》阅读总结</title>
      <link href="/2020/01/23/zookeeper_distributed_process_coordination/1.html/"/>
      <url>/2020/01/23/zookeeper_distributed_process_coordination/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>公司从 naocs 的注册中心到 zookeeper 注册中心转变，自己也好久没看过 zookeeper 相关了，上次应该看的是《从Paxos到Zookeeper》一书，这次正好趁年假把另一本经典的书《Zookeeper:分布式过程协同技术详解》看下。</p><h1 id="1-总览"><a href="#1-总览" class="headerlink" title="1. 总览"></a>1. 总览</h1><p>一共十章，八章偏入门实战，敲代码和实战理论为主，在 github 上也有相应的源码。第九章是原理讲解，最后一章是配置详解。<br>前八章应该属于入门实战，通过介绍四大节点类型和监听，来实现一个简单的分布式任务协调中心。<br>第九章通过对源码讲解，对关键的“顺序一致性”、“事务”做代码上的了解。<br>最后一章应该属于参数调优，适合运维和部署者，属于优化点。</p><h1 id="2-入门实战"><a href="#2-入门实战" class="headerlink" title="2. 入门实战"></a>2. 入门实战</h1><p>入门实战分布式任务调度中心书中源码地址：<a href="https://github.com/fpj/zookeeper-book-example" target="_blank" rel="noopener">https://github.com/fpj/zookeeper-book-example</a>  </p><p>关键点：  </p><ol><li>临时节点</li><li>临时有序节点</li><li>永久节点</li><li>永久临时节点</li><li>watch 监听</li><li>异步调用</li><li>ACL 权限控制</li><li>watch 羊群效应的避免</li><li>watch 事件类型业务处理</li><li>curator 开源客户端的使用</li></ol><blockquote><p>观察者的横向扩展用于读性能提高。而在选举时的跟随者以及领导者时的 zxid 的 zab 广播协议过程是通过延长领导者选举时间、超过半数来避免脑裂的产生。</p></blockquote><h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h1><p>关键步骤：</p><ol><li>git clone <a href="https://github.com/apache/zookeeper.git" target="_blank" rel="noopener">https://github.com/apache/zookeeper.git</a></li><li>ant eclipse 编译</li><li>idea 导入: file - new - Project From Existing Sources</li><li>zookeeper-jute 项目需要编译得到生成之后的代码: maven clean install</li><li>复制 zookeeper-jute 项目的 target/classed/org 到 zookeeper-server 下</li><li><p>在 zookeeper-server 项目的 org.apache.zookeeper.version 包新建 Info 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MAJOR=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> MINOR=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> MICRO=<span class="number">6</span>;</span><br><span class="line">    String QUALIFIER=<span class="keyword">null</span>;</span><br><span class="line">    String REVISION_HASH=<span class="string">"c11b7e26bc554b8523dc929761dd28808913f091"</span>;</span><br><span class="line">    String BUILD_DATE=<span class="string">"01/19/2020 10:13 GMT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动 server：执行 org.apache.zookeeper.server.quorum.QuorumPeerMain 类并带 JVM 参数：-Dlog4j.configuration=file:/Users/liwenguang/SourceCode/middle/zookeeper/conf/log4j.properties 以及启动参数：conf/zoo_sample.cfg</p></li></ol><blockquote><p>-Dzookeeper.4lw.commands.whitelist=* 用于 telnet 命令查询。</p></blockquote><ol start="8"><li>至此，server 启动完毕</li><li>启动 client：执行 org.apache.zookeeper.ZooKeeperMain，启动参数：-server 127.0.0.1:2181 ls /zookeeper</li></ol><blockquote><ul><li>ls /zookeeper 为命令</li></ul></blockquote><ol start="10"><li>至此 client 启动测试完毕</li></ol><h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h1><p>翻译的好烂！错别字不说，句子翻译的都不通畅！但是真适合入门（第九章除外），第九章适合看了《从Paxos到Zookeeper》之后再看。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Zookeeper:分布式过程协同技术详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/03周总结</title>
      <link href="/2020/01/20/2020/01.html/"/>
      <url>/2020/01/20/2020/01.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK序列化浅析</title>
      <link href="/2020/01/08/tech/jdk_seriazable.html/"/>
      <url>/2020/01/08/tech/jdk_seriazable.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>一直在用 RPC，但是对非常重要的序列化原理一直模糊不懂，尤其是其中的 serialVersionUID 也模糊不清，虽然 Dubbo 已经帮我们使用了经过优化过的 hession2，但是还是想一探究竟，为什么原生的 JDK 序列化就不行呢？原生 JDK 序列化到底是怎么样的。</p><p>主要参考《分布式Java应用》的<strong>4.3序列化/反序列化</strong>章节</p><h1 id="1-序列化之-writeObject"><a href="#1-序列化之-writeObject" class="headerlink" title="1. 序列化之 writeObject"></a>1. 序列化之 writeObject</h1><h2 id="1-1-获取类信息"><a href="#1-1-获取类信息" class="headerlink" title="1.1 获取类信息"></a>1.1 获取类信息</h2><p>序列化时，需要获取到当前序列化对象的类信息，获取类信息主要是调用的 <code>ObjectStreamClass.lookup(cl, true)</code>，ObjectStreamClass 会通过 ConcurrentMap 缓存类信息优化序列化速度：<code>static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs</code>，其中 key 使用了弱引用（在 ThreadLocal 也有使用弱引用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">            Class&lt;?&gt; repCl;</span><br><span class="line">            <span class="comment">// 获取类信息</span></span><br><span class="line">            desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cl = repCl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">            Object rep = replaceObject(obj);</span><br><span class="line">            <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cl = rep.getClass();</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            obj = rep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">        <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">            subs.assign(orig, obj);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remaining cases</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bout.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Caches</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** cache mapping local classes -&gt; descriptors */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;ObjectStreamClass.WeakClassKey,Reference&lt;?&gt;&gt; localDescs =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** cache mapping field group/local desc pairs -&gt; field reflectors */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;ObjectStreamClass.FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** queue for WeakReferences to local classes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =</span><br><span class="line">            <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/** queue for WeakReferences to field reflectors keys */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =</span><br><span class="line">            <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectStreamClass <span class="title">lookup</span><span class="params">(Class&lt;?&gt; cl, <span class="keyword">boolean</span> all)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(all || Serializable.class.isAssignableFrom(cl))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    processQueue(ObjectStreamClass.Caches.localDescsQueue, ObjectStreamClass.Caches.localDescs);</span><br><span class="line">    ObjectStreamClass.WeakClassKey key = <span class="keyword">new</span> ObjectStreamClass.WeakClassKey(cl, ObjectStreamClass.Caches.localDescsQueue);</span><br><span class="line">    Reference&lt;?&gt; ref = ObjectStreamClass.Caches.localDescs.get(key);</span><br><span class="line">    Object entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry = ref.get();</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectStreamClass.EntryFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ObjectStreamClass.EntryFuture newEntry = <span class="keyword">new</span> ObjectStreamClass.EntryFuture();</span><br><span class="line">        Reference&lt;?&gt; newRef = <span class="keyword">new</span> SoftReference&lt;&gt;(newEntry);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ObjectStreamClass.Caches.localDescs.remove(key, ref);</span><br><span class="line">            &#125;</span><br><span class="line">            ref = ObjectStreamClass.Caches.localDescs.putIfAbsent(key, newRef);</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = ref.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ref != <span class="keyword">null</span> &amp;&amp; entry == <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            future = newEntry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> ObjectStreamClass) &#123;  <span class="comment">// check common case first</span></span><br><span class="line">        <span class="keyword">return</span> (ObjectStreamClass) entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> ObjectStreamClass.EntryFuture) &#123;</span><br><span class="line">        future = (ObjectStreamClass.EntryFuture) entry;</span><br><span class="line">        <span class="keyword">if</span> (future.getOwner() == Thread.currentThread()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Handle nested call situation described by 4803747: waiting</span></span><br><span class="line"><span class="comment">             * for future value to be set by a lookup() call further up the</span></span><br><span class="line"><span class="comment">             * stack will result in deadlock, so calculate and set the</span></span><br><span class="line"><span class="comment">             * future value here instead.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            entry = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry = future.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entry = <span class="keyword">new</span> ObjectStreamClass(cl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            entry = th;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (future.set(entry)) &#123;</span><br><span class="line">            ObjectStreamClass.Caches.localDescs.put(key, <span class="keyword">new</span> SoftReference&lt;Object&gt;(entry));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// nested lookup call already set future</span></span><br><span class="line">            entry = future.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ObjectStreamClass) entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected entry: "</span> + entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-初始化-ObjectStreamClass"><a href="#1-2-初始化-ObjectStreamClass" class="headerlink" title="1.2 初始化 ObjectStreamClass"></a>1.2 初始化 ObjectStreamClass</h2><p>此时从缓存获取的为 null，因此需要初始化：<code>new ObjectStreamClass(cl);</code>，该初始化方法会有一系列的判断：</p><ol><li>是否是代理类（JDK动态代理都会继承 Proxy）</li><li>是否为 Enum</li><li>是否为 serializable（通过 native）</li><li>是否为 externalizable</li><li>获取父类信息（父类如果没有实现 Serializable 则必须有空构造方法）</li></ol><p>当为 serializable 类型，继续如下步骤：</p><ol><li>如果为 enum 则生成一个值为 0 的 suid，并将 fields 设置为空的 ObjectStreamFiled 数组。</li><li>如果为 Array 类型，将 fields 设置为空的 ObjectStreamField 数组。</li><li>如果非以上两种类型则获取定义的 serialVersionUID 的值</li><li>最后写入类信息若发现没有 suid，则根据类签名信息（<code>computeDefaultSUID</code>）来生成</li><li>如果类实现了 Externalizable 接口则调用 <code>writeExternal</code>。</li><li>写入流时，直接采用全类名写入。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cl = cl;</span><br><span class="line">    name = cl.getName();</span><br><span class="line">    isProxy = Proxy.isProxyClass(cl);</span><br><span class="line">    isEnum = Enum.class.isAssignableFrom(cl);</span><br><span class="line">    serializable = Serializable.class.isAssignableFrom(cl);</span><br><span class="line">    externalizable = Externalizable.class.isAssignableFrom(cl);</span><br><span class="line">    <span class="comment">// 获取父类信息</span></span><br><span class="line">    Class&lt;?&gt; superCl = cl.getSuperclass();</span><br><span class="line">    superDesc = (superCl != <span class="keyword">null</span>) ? lookup(superCl, <span class="keyword">false</span>) : <span class="keyword">null</span>;</span><br><span class="line">    localDesc = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">                    suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生成 suid</span></span><br><span class="line">                suid = getDeclaredSUID(cl);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fields = getSerialFields(cl);</span><br><span class="line">                    <span class="comment">// 计算Filed空间，引用属性（非基本类型）个数</span></span><br><span class="line">                    computeFieldOffsets();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvalidClassException e) &#123;</span><br><span class="line">                    serializeEx = deserializeEx =</span><br><span class="line">                            <span class="keyword">new</span> ObjectStreamClass.ExceptionInfo(e.classname, e.getMessage());</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">                    cons = getExternalizableConstructor(cl);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cons = getSerializableConstructor(cl);</span><br><span class="line">                    writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;,</span><br><span class="line">                            Void.TYPE);</span><br><span class="line">                    readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;,</span><br><span class="line">                            Void.TYPE);</span><br><span class="line">                    readObjectNoDataMethod = getPrivateMethod(</span><br><span class="line">                            cl, <span class="string">"readObjectNoData"</span>, <span class="keyword">null</span>, Void.TYPE);</span><br><span class="line">                    hasWriteObjectData = (writeObjectMethod != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                domains = getProtectionDomains(cons, cl);</span><br><span class="line">                writeReplaceMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"writeReplace"</span>, <span class="keyword">null</span>, Object.class);</span><br><span class="line">                readResolveMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"readResolve"</span>, <span class="keyword">null</span>, Object.class);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">        fields = NO_FIELDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fieldRefl = getReflector(fields, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidClassException ex) &#123;</span><br><span class="line">        <span class="comment">// field mismatches impossible when matching local fields vs. self</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deserializeEx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">            deserializeEx = <span class="keyword">new</span> ObjectStreamClass.ExceptionInfo(name, <span class="string">"enum type"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cons == <span class="keyword">null</span>) &#123;</span><br><span class="line">            deserializeEx = <span class="keyword">new</span> ObjectStreamClass.ExceptionInfo(name, <span class="string">"no valid constructor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fields[i].getField() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            defaultSerializeEx = <span class="keyword">new</span> ObjectStreamClass.ExceptionInfo(</span><br><span class="line">                    name, <span class="string">"unmatched serializable field(s) declared"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-反序列化之-readObject"><a href="#2-反序列化之-readObject" class="headerlink" title="2. 反序列化之 readObject"></a>2. 反序列化之 readObject</h1><p>在最开始校验：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">short</span> STREAM_MAGIC = (<span class="keyword">short</span>)<span class="number">0xaced</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version number that is written to the stream header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">short</span> STREAM_VERSION = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2020-01-08%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%B4.png" alt></p><ol><li>读取流中类名、suid，是否有 writeObject、是否是 enum 类型，Filed 个数属性等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> java拾遗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020/01周总结</title>
      <link href="/2020/01/06/2020/01.html/"/>
      <url>/2020/01/06/2020/01.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程池浅出</title>
      <link href="/2020/01/02/tech/java_threadpool_learing.html/"/>
      <url>/2020/01/02/tech/java_threadpool_learing.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>线程池一直对其中的线程销毁机制有点模糊，在网上找了很多文章，终于找到：<a href="https://juejin.im/post/5c33400c6fb9a049fe35503b。" target="_blank" rel="noopener">https://juejin.im/post/5c33400c6fb9a049fe35503b。</a><br>该文通过源码入手分析，写的真不错！<br>而本文两个目的：一是能让自己能给别人讲懂任务如何的执行以及讲懂线程如何的销毁。</p><h1 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1. 线程池状态"></a>1. 线程池状态</h1><ol><li>Running：接收新任务，处理队列任务</li><li>SHUTDOWN：不接受新任务，但会处理队列任务</li><li>STOP：不接受新任务，不处理队列任务，会中断所有处理中的任务</li><li>TIDYING：所有任务都被终结，有效线程为0.会触发terminated()方法</li><li>TERMINATED：当terminated()方法执行结束</li></ol><h1 id="2-线程池变量"><a href="#2-线程池变量" class="headerlink" title="2. 线程池变量"></a>2. 线程池变量</h1><ol><li>ctl：AtomicInteger 类型。高3位存储线程池状态，低29位存储当前线程数量。workerCountOf(c) 返回当前线程数量。runStateOf(c) 返回当前线程池状态。</li><li>worker：一个 Worker 代表一个线程。</li><li>workers：HashSet，管理 worker，即管理当前线程池的所有线程。</li><li>allowCoreThreadTimeOut：超时时间 keepAliveTime 是否对核心线程也有效，即核心线程在空闲时是否也要销毁？</li></ol><h1 id="3-线程池方法"><a href="#3-线程池方法" class="headerlink" title="3. 线程池方法"></a>3. 线程池方法</h1><ol><li>submit：将 Runnable 包装为 RunnableFuture，实际会调用 execute。</li><li>execute：<br>工作线程数小于核心线程数时，新建核心线程执行任务。<br>大于核心线程数时，将任务添加进等待队列。<br>队列满时，创建非核心线程执行任务。<br>工作线程数大于最大线程数时，执行拒绝策略。  </li></ol><h1 id="4-任务的执行"><a href="#4-任务的执行" class="headerlink" title="4. 任务的执行"></a>4. 任务的执行</h1><p>每个任务会包装成 Worker 执行，在执行时，先执行 addWorker() 方法，添加入 workers，接着执行 Worker.run。<br>每个 worker 执行都通过死循环调用 getTask() 方法堵塞，这个方法又是通过死循环不断的从队列中取任务执行。</p><h1 id="5-线程的销毁"><a href="#5-线程的销毁" class="headerlink" title="5. 线程的销毁"></a>5. 线程的销毁</h1><p>线程销毁通过 getTask() 方法以及 processWorkerExit() 这两个方法实现，前者通过 queue 的 poll 做定时堵塞，后者通过 workers.remove 来做线程的移除。</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> java拾遗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019 总结</title>
      <link href="/2019/12/31/2019/index.html/"/>
      <url>/2019/12/31/2019/index.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1/Ux20juCLMa6VUrTCmSToZwRlCixBRYd0yat/MbdvBW2O0cnes5/cB0ry12xljv9U4macmjtkviQd0+OXvwKQU9QmyG4AmdacI3KUcBEldoTcM3z5Yz4+7BXItvsScH1+Vh4SplAbZEhaoZhF78E0rsgBds+TPQUXhVcbSKWbLo8OmLzZJUVjYX62Sg3oKURItFTp27zmzcYLLu42QLB/kr78itaMIM/3yigBdW4RaR/A6fi2wC8FUOX5NZkb8yUjAaqv8Tu5M0lY5yVN8MP6+hkDIl4kaG/qQ0RAcFG1Dk9swC+K9NZGfyhRqKeuC4dNaPR4ncddVnCLl2H2NoIb9APb9SG9NOlTfSlFJJL857KlXYKGZWiHrfY9/S4e0pmUJnBJ8+3vsM+d6UgTl2vyRgiNECaEc2y+9kdL1/iYQCVIhoJWAcRv39gcoj93mGJy2kW19DLxNq12doMyxMVXIJkOAcxRffeg+hM2UETAQPGeBAx1iEJ9J+oZ62tg1xOCmFHpzl2F5NS4zRgYNUcekrw3QjYkCihzxwofPD9oUaDjZe3CpxeUyJAe93IU5Qn3AnEHkXyIbzvrbaeyp+acSTzW0pu7gG1e+UCLlW5Sue8ud9TAkU3Y5oDCanR0tugRY/GW0FGJG1XxkB6HwHgvW2HGTkh/oMuXxdqk3D2FsvZCIPljuSi1XUtfPHm/rk/QKr1ZgUJfXZELuqKOQWNR+uJ4Bu5BEuYSUEbhSNO6LNYrkoO8KT2ncg0HYQRDFXERkWcYEHUV4qeDjw6LVDFM6h7DGpkr0OqJ7+EOpUdD8G8acodiaATW8W8yd/DX8JlYH2SEmEUO9TyibG2QHon5M4b1TN3XwYl+nQQL6uMV2tFZo908g/s+O1fcc3E+mlryth1woHfSETt19KZIjNfy3scIQQQOcJub/YRG81Y9OA9joWmBWp50O0w2+jQH5Cq9YSsQJpBXxyARagJBo8SfwoaBStfNx8QNtfcuy5QT3HRE+O2D9mIgKbJJqUe7fsncqeBKHIFYYfHsKB4HAqlFy1HyeTcGEb5jfn+UIc2sfkUGU2XGhWwnrlefmfy1A/ElRMHOd2dk18/0G54eaEF9NmNxThVVaEE3DfCiyNbsC9Pp5GYQJO0ZwF4/U2rQ2B/QQOBQLHoTbrYtQeOQ6SjNpOLEe0LfvSDVvJ3+LXwiIVoSEB3QISH3c7qq5GdbuZPSznwcCVpyt70mSVAfpvrnz7NY2pZHUwPEs+57av2F8Fl0R3C+m3NUpqUWnbnxMdPFEPfhcHwkFkGGgCepp7khs14HlwsJ+NJEv4frHZ0tv3fM0kbZCTqoVcnG0Hm92MuWfulvpIgV8gSGMsTSJ415YKZ4eEbXIDIeI9Z5smA1ck5ntdimSR5wXlIET922GfXVMmmxOFiBDTtxiFq2u4wZWSs5ywataSLzOFmRp9gAlPD1+OETwpT5w0w1Obwq0ida1NCIZlVAUKEgEGMUOjbVXmoWo48O+LN8CU1wDS3taXX1zhgmKbz3T+tiT2v1ggoYzpGZq4B7opQH0Z1vFA1orX623lXqXwFuANDl5oul3GZI7Bnxnf5gpAFxn5sLkqpv3+ngTpJU0JEKE0YUym+6szLVB+U2JD1IhxDa/4jX0qoPWIJgE5TxtJ6fdlrbppHg3LSAlTcWwWt7YFvFQzPHwiKIX9Nyrrk6ur0Odbjs6jzicGlEkrqrYgRahgomDDztUaRLSZCovbCAN2n91UnHvIQDtnZd+wB86wy/WfMcHZh+Lo77ciTN1o4M5WT9dcGsE83xEvsGvMw==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从Synchronized到Lock</title>
      <link href="/2019/12/30/tech/from_Synchronized_to_Lock.html/"/>
      <url>/2019/12/30/tech/from_Synchronized_to_Lock.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>一步一步的复习锁，从 Synchronized 到 AQS，其实还有 volatile，但是它是可见性和原子性的保证，和锁还是有本质区别的，就没有纳入了。</p><h1 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1. Synchronized"></a>1. Synchronized</h1><p>对象头：每个对象都有一个对象头，里面存储了锁类型（是否偏向锁、轻量锁、重量锁）、GC 标记、对象分代年龄等。<br>monitor：ObjectMonitor 对象，也叫监视器，每个对象都有一个对应的监视器，里面包括处于阻塞该对象锁的线程以及处于等待该对象锁的线程（前者是排队获取锁、后者是 wait 方法）。</p><p>每个对象都有对应的一个 monitor，哪个线程获取到 monitor，就得到了该对象的锁。线程实际通过操作对象头来控制对象的锁。是否为重量锁、轻量锁，是通过对象头的标识来确定锁类型，他们可以转换，即从轻量锁转换成重量级锁等。<br>Synchronized 对应两条指令：monitorenter、monitorexit。这两条指令表明某个线程持有某个 monitor，以及释放某个 monitor。<br>其中 wait/notify 表示：将对象当前被持有的锁放入等待队列，因此这个操作是需要提前获取锁，即需要在 Synchronized 代码块内操作。notify 表示唤醒对象被持有的锁。</p><h1 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2. CAS"></a>2. CAS</h1><p>CAS：compare and swap，基于 UnSafe 类来实现，UnSafe 通过指针操作与操作系统交互，最终依赖操作系统的 CAS 指令完成。<br>虽然是无锁技术，但是并不代表性能比有锁技术高，因为当锁竞争严重时，会不断的在循环中 CAS 操作，性能会很低。  </p><blockquote><p>long、double 占用8字节，也就是64比特，而在 32 位操作系统对 64 位的数据读写要分两步。这个没有做试验。</p></blockquote><h1 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h1><p>从 1.7 的 Segment + HashEntry 到 1.8 的 Synchronized + CAS + 红黑树，比之前的分段锁更加细粒，头结点使用的 CAS 插入，冲突失败后使用 Synchronized 获取头结点锁进行后续操作。</p><h1 id="4-AQS"><a href="#4-AQS" class="headerlink" title="4. AQS"></a>4. AQS</h1><p>AQS 核心在于使用的 CAS 来改动 status 状态值，作为是否持有锁，可重入锁等。以及额外包括了等待队列 CLH，该等待队列用于阻塞线程后的排队容器，因此可以设置排队是否公平。而 ReentrantLock 本质就是 AQS 的一个实现。</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> java拾遗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/52周总结</title>
      <link href="/2019/12/30/2019/52.html/"/>
      <url>/2019/12/30/2019/52.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap浅出</title>
      <link href="/2019/12/26/tech/hashmap_easy1.html/"/>
      <url>/2019/12/26/tech/hashmap_easy1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>好久没动脑子去思考 hashmap 的设计了，这次做个简单分析。</p><h1 id="1-hash-优化"><a href="#1-hash-优化" class="headerlink" title="1. hash 优化"></a>1. hash 优化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原hash：1111 1111 1111 1111 1111 1010 0111 1100<br>右移16位：0000 0000 0000 0000 1111 1111 1111 1111<br>异或运算：1111 1111 1111 1111 0000 0101 1000 0011</p><p>在低16位中，让高低16位都参与进行了异或，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置，增加链表长度。</p><h1 id="2-寻址优化"><a href="#2-寻址优化" class="headerlink" title="2. 寻址优化"></a>2. 寻址优化</h1><p>(n - 1) &amp; hash，即 hash 对 n 取模结果一样。<br>高位没有参与与运算。</p><h1 id="3-扩容的寻址"><a href="#3-扩容的寻址" class="headerlink" title="3. 扩容的寻址"></a>3. 扩容的寻址</h1><p>数组长度为 16 时：<br>n-1：0000 0000 0000 0000 0000 0000 0000 1111<br>hash：1111 1111 1111 1111 0000 1111 0000 0101<br>&amp;结果：0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p>n-1：0000 0000 0000 0000 0000 0000 0000 1111<br>hash：1111 1111 1111 1111 0000 1111 0001 0101<br>&amp;结果：0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p>数组长度为 32 时：<br>n-1：0000 0000 0000 0000 0000 0000 0001 1111<br>hash：1111 1111 1111 1111 0000 1111 0000 0101<br>&amp;结果：0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p>n-1：0000 0000 0000 0000 0000 0000 0001 1111<br>hash：1111 1111 1111 1111 0000 1111 0001 0101<br>&amp;结果：0000 0000 0000 0000 0000 0000 0001 0101 = 21（index = 5+16的位置）</p><p>因此，只需要判断结果是否多了一个 bit 的 1，来决定新的 index 是不变，还是等于 index + oldCap</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> java拾遗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/51周总结</title>
      <link href="/2019/12/25/2019/51.html/"/>
      <url>/2019/12/25/2019/51.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/50周总结</title>
      <link href="/2019/12/19/2019/50.html/"/>
      <url>/2019/12/19/2019/50.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对Redis集群与RedLock的理解</title>
      <link href="/2019/12/11/tech/redis_cluster_and_redlock.html/"/>
      <url>/2019/12/11/tech/redis_cluster_and_redlock.html/</url>
      
        <content type="html"><![CDATA[<p>该文为回答该 Issue 的答案：<a href="https://github.com/Snailclimb/JavaGuide/issues/567" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/567</a></p><p>之前研究过一段时间，用的是 Redisson 框架，<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#84-%E7%BA%A2%E9%94%81redlock" target="_blank" rel="noopener">这里是 Redission 实现 Redlock 的官方文档</a> 。以下为个人见解，可能有误</p><h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><ol><li>平时理解的 Redis 的集群模式：<a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">http://www.redis.cn/topics/cluster-tutorial.html</a></li><li>Redlock 多节点：<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">http://redis.cn/topics/distlock.html</a></li></ol><p>重点如下：</p><ol><li><p>集群模式：Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。</p></li><li><p>Redlock：有 N 个 Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。</p><blockquote><p>这里 Redlock 的使用有四个要求，一是需要 N 个 Redis master，二是节点独立、三是不存在主从复制、四是不存在集群协调机制。后三个要求其实就说明了，你要用的这些 master 不能同时存在同一个集群中。</p></blockquote></li></ol><p>以下用图加深理解</p><h1 id="1-两主两从的集群与-Redlock"><a href="#1-两主两从的集群与-Redlock" class="headerlink" title="1. 两主两从的集群与 Redlock"></a>1. 两主两从的集群与 Redlock</h1><p><img src="https://user-images.githubusercontent.com/15909210/69705013-9e963280-112f-11ea-8d4d-2b2762f3fb54.png" alt></p><p>红框代表的是一个标准的 Redis 集群：它是有六个 Redis 节点间共享数据的程序集。  </p><p>对于 Redlock 来说，这个集群中的两个 Master 不是互相独立的，而且是有集群协调机制的。因此它们不符合使用 Redlock 的场景。你会想，那我只连接一个 Master 可以吧，是可以的，但是也不是标准的 Redlock 的，因为不符合 N 个 Redis master 要求。</p><p>综上：如果你只有一个标准的集群，无论里面有多少个 Master，都是不符合 Redlock 的使用场景的，主要在于一个集群内的 Master 间它们不是互相独立的。</p><h1 id="2-两个独立集群下的-Redlock"><a href="#2-两个独立集群下的-Redlock" class="headerlink" title="2. 两个独立集群下的 Redlock"></a>2. 两个独立集群下的 Redlock</h1><p><img src="https://user-images.githubusercontent.com/15909210/69705530-bcb06280-1130-11ea-9a72-d0e40303c59a.png" alt></p><p>红框和蓝框分别代表两个独立的标准的 Redis 集群，它们分别是有三个 Redis 节点间共享数据的程序集。</p><p>对于 Redlock 来说，一共有两个符合要求的 Master，因此是符合 Redlock 的使用场景。这两个 Master 的同步只在自己的集群内和 Slave 同步。但是不允许这两个 Master 跨集群间同步，因为如果跨集群同步了，那么就不符合 Master 互相独立的要求了。</p><h1 id="3-复杂的两个独立集群下的-Redlock"><a href="#3-复杂的两个独立集群下的-Redlock" class="headerlink" title="3. 复杂的两个独立集群下的 Redlock"></a>3. 复杂的两个独立集群下的 Redlock</h1><p><img src="https://user-images.githubusercontent.com/15909210/69706179-1b2a1080-1132-11ea-8a24-705452579a8a.png" alt></p><p>这里每个集群内部有两个 Master，此时对于 Redlock 来说，它只认为有一组 Master（Master1-Master2、Master1-Master22、Master11-Master2、Master11-Master22） 是互相独立的。（前提在于这两个集群之间并不同步）</p><blockquote><p>其实这里说的并不严谨。这里涉及 Redis 集群的哈希槽知识，对于客户端来说，连接 Redis 集群时，连接该集群下的任意一个节点即可，集群会自动给你对 key 做 hash，然后映射到不同的 Master 上，因此对于客户端来说，其实一个集群无论里面有多少个 Master 节点，客户端只会以为有一个节点。</p></blockquote><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol><li>Redlock 所说的多节点，指的是，独立的 Master 节点。但是集群模式下的 Master 它们是归属于同一个集群下的 Master 节点，它们互相是不独立的，所以这不是一回事。</li><li>虽然 Redlock 所说的 Master 间不同步，但是为了高可用，这里每个 Master 节点都会有 Slave，用于冗余容灾，它们各自的 Master-Slave 是同步的。</li></ol><h1 id="5-备注"><a href="#5-备注" class="headerlink" title="5. 备注"></a>5. 备注</h1><p>关于图的连线，是直接连接 Master 还是连接集群，其实这里要说一下 Redis-cluster，客户端连接集群时，选择集群的任意一个节点连接，在集群中会自动转发到对应的 Master 做操作。  </p><hr><p><strong>如果有错误请指正。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/49周总结</title>
      <link href="/2019/12/11/2019/49.html/"/>
      <url>/2019/12/11/2019/49.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/48周总结</title>
      <link href="/2019/12/04/2019/48.html/"/>
      <url>/2019/12/04/2019/48.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19FtujjqUYrd7e6Vda98M0IefNNvzPD8GN8ILZLBnVKdaU8yHmyXyJ46xwALiO+/n/N4Oc5CTfnDw7iEW3cZMJciHb+b58YHrPZ7UklXfCC8A8n3JXiwf3MU6eax5KJeNJagYXMl6jSRICOa2t5Cnj38kprsaYIepIch8INgNyKghuaqauY1PRLoDwQswkrU5r7WvRjWHqT+dJN23VtTvOUpNWW1euut3gx8cj+WDDJQtfZWhorYxQQ/ShXemrJYrvYlUFIxJHwvELcq7vphJx2+odViI1JrvXp888sR0GRXOdXKwBr4lVFAfV2yWwiB4jCdaEAoYPfmKbP2x+Be96m/FXRu81Zn6B4UO51E4gghNEaV/Nz0bxb0tQA23u47VPkuf3ewYmWNZ4oEP1F5ahVOly/PMDFcrxSDphecu0x2ql0IEKW9ne55hwDOccWpTyaB9GvvGCZws5MxiU40rwOHoIoERuHs9bb0Ez6YUMGKu8eNeXSPwzO7eP1B3pHAxZGJ1na1DglJBXC+2QlXEYl1T2YHi09WC/3r3UCc4FTmVh37B5UdSTYOrz2pseEmsspWuMV39XHFyUzOXi/2EsTvPN/ddkVk2oMk5i5O5SmP1VH19XoT+4kv7c3a1WIe1nedm7s6GeDF/lX0vuoMQVoZEmPyAXAwUp8Tw7gu2lzUeAyUvBidG3ZLuVmeGK6FLFb90bef271VIWZdv1NpIXnJ2Rtiotm6TW6bmj/WTPfuGm5X7tWmMxw/CMCijj3T3SmvZxTdVxrZ2Y1xda91iuE6ZSCwEHR2jgvgWTpT9t55Be6PJJ/x3IrPRr0zZCcWM8/ok+GhNEnd6lWd3dF8/QTS6jquAcfy/UO8CL9t7c7MAF7A+jhlfZU+Wf+5Q8kSzG2IFAz//6gjHqId4tCiL0a3KJVbsalGsWCaGi449v0uOlfi+acjfJkEacAR56dG+qXPDII36wEHw2du2ME88syOo9rle8c3zz5039Fa0KgZ/tr/ZEQl4QdcJpp6oeAz64Oc2oji7KGX73vZR58aelWPIdBRgpIVLjRlZXIaKj66KmvOnx3JMn5YfqETR2BoGIbIYHbvoGnQnzeOLjg0innsFq8pOdasz251CwbBTAD9JUxmIOe4P07G8JfH4eYxeU5oucG5imXXH6zuDnSPnglyZ9ejT0goqjE+3rsnCWJAaOXgqmgtgUYJoWf7OVdfPiybTdOvgX+3GM22ZY49cT3m6W/R6KVUezfRHCMlwZwgvrhWXwlgmpS6nPj748w7cSG3wytpxUQJbdbAH2Nvz/shQCngZ1Q7PHAdktC+XoPqmlqLX9ebKTp0hN3MYIiHaHfTggyehXfsEv1wZliH/5Y7YDUimUx7ChkzDXMjBm4vim+upxZk5mH4lMyV4m4VbG7cNBgRtosZsFKW1N0+pe6NDprC3+dSatv4Qejs8swUDVVaasL/fUsk5VYiobS9PvL6OS3ywAKtjDGvwixU8LBgI/B7/86Ecqny+YAzgLzuAIlONoTMOzN+SpKxjmZqsInBcj53rOE6/KFNKgWbRLmH46Qa9b4ZgkADZ4o8aTkyFZnl1Bfv2OTN1rtiP5QqOEMIR/FIJs47j3jZgbteqD3WLqa9lrW0/60YLuxj4S5LxhQVHG55pbnE5iXQiu0mGEiuypw4Zq+G5GkMqI0KAMhAc0nO4EeRZCTSWJDlulsetpAHKGSXo9cp8QjiJZKN83DDMtgPEwHpkmSi7BYcslHweA2LHfYnKHEpzrbVcx4pQtyvPqKDY6pmyZrihYb1kBx3fcc+07mpfuQYS61zfM+0XN4bZR2QzwIBr57IsEWC056BuzlenWuzGEwcQoxIemqVS+qAvG7/TgAX/BQuFvxWrPVsPaDw4VoKtNsAZGOTJ3H1Yh3v3gBUcCJznIySEooHq1o2XlSQ2/H8FOT8skJaLtcLaeXURx1bj/R+6ioGNuxs+rqbug+z5eDyPGJWhlXfqww/D0KIrsX8a/XTkzRTejzPh4+KpoxVLJiEarZcSR9KfX6uc1UZ6988ow8WkHbwAg4MYqtBt9h9cBvx6rrifdgJg5TeDWa5l8w1Oj07jKJInQd+32E0OQKYI0EYljP1XKC7Lf9DyyJBz68xaLwHtk6D1VV/99Z9pw4vS6uji8hW+MmjdLJllo7S1Z+SQ9XGuV3ZAdX34wr01jr9H2JtblA+gkmX0Rc+h+BHwEShykE49XV5COKINuNGDurfsuVpNIAN4ZoN1KUhaq0kXejs/xt1cnwr5D0FfIUiFJNEloOLwP5UA5QXqQubUY3O/B3Z5mUhu+0XmTNTOVGULqPZ4dFt4k0utLLeo2WEAE5Z36nbasgyRuSG2GEZC1mkhUXXcT4pFvHprPbGBs4rj09Vznp2KVHeKhqL5Yk0IpYIZBWoNPXHmyyrDe1Qk80AbwJt54FCfu4uOd+OHEjsxSfvnXiUsI8WiaMn2eRt986VuZPLnj3E2BHaObhyrbSdQzsmeaw3lGr3qwAZltkkaQyKO3uYNi0K9xp4Pel0ZWCMMs+yMOu9AXHuIS7l4666jCtujHRU0VcHTOPpcv/0pIf3Gz5sk9f+eQ7yxSE5IVQRySqc895Ov/hnG8nJin7sx9mv9OkWE6lsv8UnSTSJgfrehTbvBszgBmW3Xy7CUr60+i0dSU77sFqVthoFTivKIMc5pTDEeqvlM6AJ32zv/76M7U+fYJbPplFEo5pBKUOEFr1vwIIU+Ghl8yjAen/ODLgQ4fZlhpjJf6N/BpugAhCJSH0nPbLJ+M3KReygfUzECg3/goqpK1Nk3+7tNPDFiMbI+qW4idaL9HJY7+WZN0VzzuamWBzIW1mSGtdcfM/CVxNPqAw2mBK6eYBUR+XbKjspw2M1ZzsqrA6o+gLvDS7X1Q//JXo9CLDffxJ7unDrTQrJ7SFgDHzrjFgdqcjCAAkTEwgWkw8MK8XlHaFVc4ZhaTd9N/RwZSrznbQj++xNMNCILIKiQ303OHJkkudQClGFWXQPCj1Ri9+FHfofajyPhybPS0nVCnty6Cnucwoh8Nne2KnKpAnApTlErnuyfXtblvv+KkZKWsIRmqWG6pmD5W1YtVDvwcjWvel83qrT1aP1LLP10U9eBDsytWpjB56MhqlJsqndAV8YcA8Lp4+LPAaqnfdgvTTSaC96QlRwY8ZcM/7NVLU29tQ8ZalUJ7sEfRJ6J9pp6qa9+EFp6n31onsZHWA/EBr16eA2ln+aoek1xqcHFyfTVBe+B10W32ZrU3IX4Dg4Rdu8RsAyE4j8RlWTfs1EGmoog7ZA4EAL73/ZT9ThiZg/Hv9JtYnYrsiMDUsBl2TotEp93ksLxlnRbFw+oPsKgxhbV7eJvfPaobY1Juvd2vS/DVZpnA91Z7XDryXuhQmycaLS5qY1RLMrrI7+Ub4YvkEFqFgRjA5El3Q7TOqEQVQZ/bjIc9IaL11qy6IvY5g6he07z7EcppTxxgkF+mxQ+VnjVNuEBpTJKPLLI6n40Z6Pa2BdpfmKisopeFFKfzRUs5yh5kc/JG/kt1mDs4BFEQ/qw5t/CHFQM4sDpKdi3pqn5dLmz5kvmTsMzhOv72K4ZFvWvt3C+tjo/kSiY42mPnbqIjzR5YYQaWnKk+o2+4dvYxXLxPSMFb5VR98bAarXIbtbJQ0jmPlmn6dHlMGigEGPIuNhr4cU9lEQr6KGC8aLVFS1wrUhrbyXTSHQqKUc4K+SbdY50Mj+LR0SC+wRjaJJmTaW0XOApbVQKOVtXLd4jCUmcvDRcXATyInzBnE0Ug2r2Qqt5hA2zvUgOrRpQBF2SSWrArJ4W8gVYBbr4KUwEJXSaf5gXKD75Zf4NEZ6FppUF5N6MxCfx5bFO5e3kR0deT8EtuCP3AOVRRe2c2l/NZRgkue3FTlBQEbiEYuIFWf9yoBMhisJRiClByqwMhaxRpcMmPeX8I7X/cgDtlz1VyCsv3axs4Y8v5gPwhxgEL2M1wP24ZUlrQ9rmdBi1zK4oRc6IugkukFutHYygEqViiZxcDtX7zzkJTkxZbTE28BaNyrYWRV2ImLb6sZCT5KoG2GO6Tdp6+mhoMFlhIfr++ZKxkKI0eL07V0vocJOOvpInGmn9B/CxwdZqbcJjEScY01h18B9YUAIy/8ngCTMP02XGXORQeL2uxTFRxmXes27gMVZz7GCYC23O84uIDASXV4l2E1CY6FtFcthByYVEOeUuVm4p71pB4A+1AcrhK6mflVkNKlhbRCzsd86SFsXu3RPIkfU1OT+h70O83tjHqVMgRQar+dovFv70q/8t0uRBPkTu8AJR0+v7836tVH36Th+tp/LYNjhm+ZkCKi1k028vPgbGsJiF+q3RC7oINKdc+tG8jXYnOT+e/mdPvf4ZwQtOypXPCjhccvA3zoNINRpazdPYPggNl0x/pa1FeW9XVTApeufB91prVpyEA++uvlonGwyckaz3gwWcmT3RVcnvbMFaRI10FYLuSpliBbtvXav4xWsko08ht7FN/lss+8YoAd0XLa40vKWuZLPGBIxHKJtSjhn7/x5HHxfy3kfn1PfvjMpqIAKzHbhSLqQ7QRD6ZiDh5hMGg77ekYSxKUNbi93x8Z2IlPO5gFSdRIgcjpglWM+lHGQNDoxJjfAnVA53WdRHURArJUGp5LSfPNPijWMdwf8S+KOjYYurSK9cewFrvcNlgQgwUX3ggoqVuE6K0qerg4keVHyDQopqr1MPdiakLFXcPQKvBzXZjM7cOKlSAD2RpZo7tRdXC3rpxRDDRXldnSG1eejqlMNzUWT7XEAyd6JH0vGWNacDgxtg++Ap/Jb/JjD4IC43t6IMRliY0qy+HLtTsQ+ndpEgtoghL24M6qJVEmnjcokAaYQqzU5+oskE9/7XFBSXT72rTNrm8STczxBzzaS8lffrXKDcXJeKh1u1qGfYA9if6IgNqcPdN1MUJuUw411AqOTnY1cRr/0yKiBOeGXnCfhXhMWMfY7ozX9VXh1YzDeEc4ZWsnzmsC4mVfXAs6k/Pedu7nA6dOWSSeHZOwptI7Zraq+sB6fBFUJIgt3+ckP90CcdbqksoORU2HWLEZHBr71dGV7+o8c0Om5z4jHM6YpJ1J+SWWCVs1AaMh+Mjd/cmvQkBE07NKznAqIp5wFTRMwfHpGcU0/kwgMge4LWYIfhuxGcM1yXzzz6Mfjoe2osbTlbuCT3VmL1Dv0waGSxVHE4XVibnqiGkXEhBxIhEmhLQNJl4Kkg3pAEm9C00rTH6auc5qdeFG92cQNd0vYVI8zjNbJ66qNI1+z9THgALKmxi7MTcdtgN0iX1TU1S8cPzvuHeSSdw8mrWmscYHJNy3Pxkk5WruNf1pCc9dI8A79Q3aFed3iP7V9A8t/8NdoqYST1kTSg5xqgBta0PDghC6EnQ9ej8F/qDlD6jWxNqzAC2Frzp9PZ894Nd9Na4D+R5gAGrgCmyJB41mXJlL3wet78q0Q8DSFQ8ZhzpcEf2AWRIOa/EH3cRPZfkbqj4qQECmoKza0LixJnPgTT+2Oxkxcqv+5lkSri2qEc9bkwRrdczgyn3z93K4XcvwPJ8+39ScHr9n1oWdHcwPkzD4/lRUZX3P1sXWBHvUVwXaCI1ilr8mpVFlECUD9v1SzXpip7Y7F+MWgkKM4ERLj5hqtAohL3ZBm0M/Q3gN9bTdZugPM//HEki+w//VLaQqyl3+BuLY+DsMtZ3ce7Kc39nBXM8r/q1VCQ2xKyGGHEf4MbhCMkTFG6HH+Z4F0GYg9inWm7IxKx+0q8HPm84e0fpnDcqAO8BhdIvDx4C/lv6Rdi7vXqi/w2r6ZfCvdrKSESJlCcdth3d2afENAYhN5OTGIzbMAVywMd4KEUTXdUunG/MWz+qY+gs4ra9fswavuDxT25hOOm5Qbdj0Qu+UyqSgpBEqoBkeo1oWR52PJbgID7ouHgjx5oMHRmjEawIEiyCawmoAPoVcOj5f4HdlGe/kittdK48pqr5zgD92XNOo8Ur8pV5fiO4p4WuIySuIeNKaLpvw3XV7uWmyNuI2Y2v1OBSYfJbgecS9K3K26sFWak9eXB4I0t8Sx42V9E3zAjcNHSgOC5r9e8xey1yzkpZiiWLfWCB6WJyHNrI+1thbGK9KQUme+iD0gmTHfkkbMjDev/X6bhBu3Wxvr2hWbgJg/xlvGslJnChIKmBJP/3firICW9DX64VfE2ejKe9YW3uQocQIfHWEaG8RcT0hR02q3HTp0P8jM/IZ200LcnRDnlENcW6pD+CgNQ6bAGyzF6XiuN7Av3VyxcZF7mDyoCPhdT0e3l/9lDYUFfGaByx86GbcNoRXsAO8+/rWcsbSheg2oRYYhGV7HP+/6igIxwI6EhvkgV8gIa48nmDSxIn4b2UXbmGV5x/BCpOZRzdvlcAe8NHwWtCh7+8J+m1Rj0JD1kkkmE5c3eT4jXKDmGFmMgfvr3XgZ1CAlmSZqHPIotwv32kL/EO3X2ugWQApMbk9bZRn0nl9tuwAAZbnqOjFjGAl8rH/Caiv9ejBRV69fHJcUmGwH3v1WSrhh4E0IXskBl4kyxxmXlhzWMQbvrP749tmyjQL3neNaJhz9YwiuPWJw4aE8//XQOb+01H+OvZaLPobVqdWt5hVZS4xB4vB1pEKA9lZQRNJ2mBCWOMQag0TrFv4vb6mhKhFu2xmnXHqDZT8qjQ54hbWcunc6Hcv1LGk39jqeDNFnnIJCstuHVPeMrskd8/tT37BwjOROa90f3tZFNsyNWeKYnrtGKsixpm4TRhnYDGXD+AnJFmeLI1GLt/fS/clngIKrpPj0gDWrrYTqp8Ticg5of/HxtqbvR8SRIypapmkmPr623uW/BWdJB+3jNPP7+g9m1KqpB/X65RdzivAl2y7CPcrcwMIuP4hiUT7drZC4/Gk37cXEmKFn/mE23SS+4deb+fWl+xKVcETZ7BZR+zta4HrCtPiEvPCF3RLwrou22bBLTOQaRojfTE/Ci2koO9sKJ7eNFme4KBfDa1iEkU/5eU4ArgcQQEosq1DzZqVvTkOvwWwjx3lZ01YkE+AszYR7duHeY5c5M484DypiARPLuLV3LqKAwsShsnToPeyDahEo5HagVMeMtclNb9Fihgu7RfmhFZCw6UlGPzLp4PKDbxPLpXHb3FtIIzV9otWumXavKWLm890XlqCQJ8K5uEUnOmsamRjJqb9YF1+cuOSR6mMTMIQEIg4zYpjH04ND2A1NtVIe5me7wP+VNOE4SPflmept7N9wAJ4HPV8bhT1gByNwBUlLsVF</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/47周总结</title>
      <link href="/2019/11/27/2019/47.html/"/>
      <url>/2019/11/27/2019/47.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>库存与超卖的小结</title>
      <link href="/2019/11/14/tech/mysql/inventory_system.html/"/>
      <url>/2019/11/14/tech/mysql/inventory_system.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>最近业务同学在双11做优惠券活动相关的时候，出现了超领的情况，本来定的是一百张，最后超领到了三百多张。最后通过修改数据库的查库存语句解决了问题，峰值1W+ QPS 也没有出现问题。<br>本来想自己整理一下关于库存和超卖的博文，但是在收集资料的时候，发现京东已经有一篇质量非常高的文章，索性直接转发过来了。<br>原文地址：<a href="https://www.infoq.cn/article/jingdongdaojia-inventory-system/" target="_blank" rel="noopener">https://www.infoq.cn/article/jingdongdaojia-inventory-system/</a></p><a id="more"></a><hr><p>目前，京东到家库存系统经历两年多的线上考验与技术迭代，现服务着万级商家、十万级店铺的规模，在需求变更与技术演进中，如何做到系统的稳定性与高可用？下面将会给你揭晓答案。</p><h1 id="1-库存系统技术架构"><a href="#1-库存系统技术架构" class="headerlink" title="1. 库存系统技术架构"></a>1. 库存系统技术架构</h1><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-11-14%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96001.jpg" alt="库存系统技术架构图"></p><p>上图如果进行总结下，主要体现出以下几个方面：</p><h2 id="1-1-完善的基础设施"><a href="#1-1-完善的基础设施" class="headerlink" title="1.1 完善的基础设施"></a>1.1 完善的基础设施</h2><p>强大的基础服务平台让应用、JVM、Docker、物理机所有健康指标一目了然，7*24 小时智能监控告警让开发无须一直盯着监控。</p><h2 id="1-2-数据驱动"><a href="#1-2-数据驱动" class="headerlink" title="1.2 数据驱动"></a>1.2 数据驱动</h2><p>数据与业务相辅相成，用数据验证业务需求，迭代业务需求，让业务需求都尽可能的收益最大化，库存系统的开发同学只需要关注业务需求。</p><h2 id="1-3-健全的测试团队"><a href="#1-3-健全的测试团队" class="headerlink" title="1.3 健全的测试团队"></a>1.3 健全的测试团队</h2><p>大版本上线前相应的测试同学会跟进压测，防止上线后潜在的性能瓶颈。</p><h2 id="1-4-库存系统技术架构图解释说明"><a href="#1-4-库存系统技术架构图解释说明" class="headerlink" title="1.4 库存系统技术架构图解释说明"></a>1.4 库存系统技术架构图解释说明</h2><h3 id="1-4-1-Portal"><a href="#1-4-1-Portal" class="headerlink" title="1.4.1 Portal"></a>1.4.1 Portal</h3><p>通过提供商家 PC 端、App 端解决大部分中小商家的日常运营需求，另外提供开放平台满足大中型商家系统对接与数据共享互通的问题。</p><h3 id="1-4-2-Service"><a href="#1-4-2-Service" class="headerlink" title="1.4.2 Service"></a>1.4.2 Service</h3><p>这个板块涵盖了整个库存最核心的 C&amp;B 数据业务。</p><p>1、业务类</p><ul><li>C 正常流程：用户下单 - 商家拣货 - 快递员妥投</li><li>C 异常流程 - 缺货：用户下单 - 商家缺货 - 用户协商 - 调整订单缺货商品 - 商家拣货 - 快递员妥投</li><li>C 异常流程 - 取消：用户下单 - 用户反悔 - 订单取消</li><li>C 异常流程 - 风控：用户下单 - 风控拦截 - 订单锁定 - 客服审核 - 订单取消 / 继续生产</li><li>B 正常流程：商家维护可售库存数量，即时或者定时生效</li></ul><p>2、数据类</p><p>除了业务类需求外，京东到家还提供了大量有商业价值的数据供商家作业务决策，比如：</p><ol><li>商品销量 Top 榜 - 支持分城市分类目筛选</li><li>热销商品库存不足预警 - 商家 App 版本 Push 通知及待办事项中可以醒目识别这部分商品并进行维护</li><li>红黄线自动下架 - 近七日订单量大于 5 单，并且被踩率大于等于 20% 的商品，进行下架操作，每日执行。</li><li>库存交易流水</li></ol><p>3、中间件类</p><p>古人行军打仗，兵马未动，粮草先行，对于系统来说亦是如此，编码未动架构先行，架构的技术选型非常重要，在这里给大家分享京东技术体系上万码农都在使用的几个中间件。</p><ol><li>JSF，类似于 DUBBO, 是一款非常优秀的 RPC 层框架，可以解决应用间的数据通信问题，它最主要的优势是长连接的实现以及高效的序列化组件。</li><li>JMQ，JMQ 是京东自主研发的一款消息中间件系统，具有高可用、数据高可靠等特性。广泛应用于公司内部系统，包括订单、支付、库房、交易等场景。在库存系统中会优先更新 Redis 缓存数据，并发送变更 MQ，供 MySQL 及 ES 异步更新。</li><li>O2OWORKER，早期淘宝开源的一款产品 TBSCHEDULE，不这个只适用于单项目管理，多个系统使用的话权限无法隔离，另外参数配置过于繁琐，结合这两点进行了重构，从而形成了现在的整个京东到家都在使用的任务管理平台。</li></ol><h3 id="1-4-3-DB"><a href="#1-4-3-DB" class="headerlink" title="1.4.3 DB"></a>1.4.3 DB</h3><p>1、MySQL</p><p>京东到家库存系统使用的关系型数据库是 MySQL，低成本、低耦合、轻量级，总之优势多多。</p><p>2、Redis</p><p>丰富的数据结构 &amp; 众多的原子性命令支持，非常适合库存系统进行缓存查询及扣减操作。</p><p>3、ES</p><p>库存系统的数据量非常大，首先 MySQL 数据库通过水平扩容来解决单表数据量过大的问题，水平扩容的规则采取的是按门店维度进行分表（1. 目前京东到家还没有到分库的阶段，2. 按门店维度进行分表数据量会相对均衡一些，所以没有按照商家维度进行划分）。</p><p>那么在商家 PC 端上查询所有商品库存及维护库存时带来了难度，比如查询该商家下所有的商品有多少条，同时处于上架状态的商品有哪些……，为了解决这一难题，引入了 ES，将数据统一存储在 ES 集群中，解决一些涉及到聚合查询的场景。</p><h1 id="2-库存系统数据流转"><a href="#2-库存系统数据流转" class="headerlink" title="2. 库存系统数据流转"></a>2. 库存系统数据流转</h1><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-11-14%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96002.jpg" alt="库存系统数据流转图"></p><p>库存系统数据流转图解释说明：</p><p>库存系统的数据流转，指的都是销售库存的数据流转，在京东到家还有自营类业务板块，即上图中提到的城市仓，由于它涉及到采购入库及盘盈盘亏等问题, 所以会由一套 WMS 系统来支撑。</p><p>京东到家设计初衷就是希望商家下的商品各门店共享，带来的问题就是商家新建一个商品时，需要推送到商家下所有的门店中，即所有的门店均可以看到这个商品。或者商家新建一个门店时，需要将商家下所有的商品均推送到这个新建的门店中，所以这采用了 MQ 技术进行异步化批量处理。</p><p>写到这里，相信对大家对库存系统有了初步的了解，从上图来看功能上其实并不复杂，但是他面临的技术复杂度却是相当高的，比如秒杀品在高并发的情况下如何防止超卖。</p><p>另外库存系统还不是一个纯技术的系统，需要结合用户的行为特点来考虑，比如下文中提到什么时间进行库存的扣减最合适，我们先抛出几个问题和大家一起探讨下，如有不妥之处，欢迎大家拍砖。</p><h2 id="2-1-库存什么时候进行预占-或者扣减-呢"><a href="#2-1-库存什么时候进行预占-或者扣减-呢" class="headerlink" title="2.1 库存什么时候进行预占 (或者扣减) 呢"></a>2.1 库存什么时候进行预占 (或者扣减) 呢</h2><p>商家销售的商品数量是有限的，用户下单后商品会被扣减，我们可以怎么实现呢？</p><p>举个例子： 一件商品有 1000 个库存，现在有 1000 个用户，每个用户计划同时购买 1000 个。</p><ul><li>实现方案 1：如果用户加入购物车时进行库存预占，那么将只能有 1 个用户将 1000 个商品加入购物车。</li><li>实现方案 2：如果用户提交订单时进行库存预占，那么将也只能有 1 个用户将 1000 个商品提单成功，其它的人均提示“库存不足，提单失败”。</li><li>实现方案 3：如果用户提交订单 &amp; 支付成功时进行库存预占，那么这 1000 个人都能生成订单，但是只有 1 个人可以支付成功，其它的订单均会被自动取消。</li></ul><p>京东到家目前采用的是<strong>方案 2</strong>，理由如下：</p><p>用户可能只是暂时加入购物车，并不表示用户最终会提单并支付。</p><p>所以在购物车进行库存校验并预占，会造成其它真正想买的用户不能加入购物车的情况，但是之前加车的用户一直不付款，最终损失的是公司。</p><p>方案 3 会造成生成 1000 个订单，无论是在支付前校验库存还是在支付成功后再检验库存，都会造成用户准备好支付条件后却会出现 99.9% 的系统取消订单的概率，也就是说会给 99.9% 的用户体验到不爽的感觉。</p><p>数据表明用户提交订单不支付的占比是非常小的（相对于加入购物车不购买的行为），目前京东到家给用户预留的最长支付时间是 30 分钟，超过 30 分钟订单自动取消，预占的库存自动释放。</p><p>综上所述，方案 2 也可能由于用户下单预占库存但最终未支付，造成库存 30 分钟后才能被其它用户使用的情况，但是相较于方案 1，方案 3 无疑是折中的最好方案。</p><h2 id="2-2-重复提交订单的问题？"><a href="#2-2-重复提交订单的问题？" class="headerlink" title="2.2 重复提交订单的问题？"></a>2.2 重复提交订单的问题？</h2><p>重复提交订单造成的库存重复扣减的后果是比较严重的。比如商家设置有 1000 件商品，而实际情况可能卖了 900 件就提示用户无货了，给商家造成无形的损失</p><p>可能出现重复提交订单的情况：</p><ol><li>用户善意行为：app 上用户单击“提交订单”按钮后由于后端接口没有返回，用户以为没有操作成功会再次单击“提交订单”按钮</li><li>用户恶意行为：黑客直接刷提单接口，绕过 App 端防重提交功能</li><li>提单系统重试：比如提单系统为了提高系统的可用性，在第一次调用库存系统扣减接口超时后会重试再次提交扣减请求</li></ol><p>好了，既然问题根源缕清楚了，我们一一对症下药</p><ol><li>用户善意行为：App 侧在用户第一次单击“提交订单”按钮后对按钮进行置灰，禁止再次提交订单</li><li>用户恶意行为：采用令牌机制，用户每次进入结算页，提单系统会颁发一个令牌 ID（全局唯一），当用户点击“提交订单”按钮时发起的网络请求中会带上这个令牌 ID, 这个时候提单系统会优先进行令牌 ID 验证，令牌 ID 存在 &amp; 令牌 ID 访问次数 =1 的话才会放行处理后续逻辑，否则直接返回</li><li>提单系统重试：这种情况则需要后端系统（比如库存系统）来保证接口的幂等性，每次调用库存系统时均带上订单号，库存系统会基于订单号增加一个分布式事务锁。</li></ol><p>问题2的解决伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = redis.incr(orderId);</span><br><span class="line">redis.expire(orderId, <span class="number">5</span>, Timeunit.MINUTES);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 添加成功，说明之前没有处理过这个订单号或者5分钟之前处理过了</span></span><br><span class="line">  <span class="keyword">boolean</span> alreadySuccess = alreadySuccessDoOrder(orderProductRequest);</span><br><span class="line">  <span class="keyword">if</span> (!alreadySuccess) &#123;</span><br><span class="line">    doOrder(orderProductRequest);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"操作失败，原因：重复提交"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"操作失败，原因：重复提交"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-库存数据的回滚机制如何做"><a href="#2-3-库存数据的回滚机制如何做" class="headerlink" title="2.3 库存数据的回滚机制如何做?"></a>2.3 库存数据的回滚机制如何做?</h2><p>需要库存回滚的场景也是比较多的，比如：</p><ol><li>用户未支付：用户下单后后悔了</li><li>用户支付后取消：用户下单 &amp; 支付后后悔了</li><li>风控取消：风控识别到异常行为，强制取消订单</li><li>耦合系统故障：比如提交订单时提单系统 T1 同时会调用积分扣减系统 X1、库存扣减系统 X2、优惠券系统 X3，假如 X1、X2 成功后，调用 X3 失败，需要回滚用户积分与商家库存。</li></ol><p>其中场景 1、2、3 比较类似，都会造成订单取消，订单中心取消后会发送 MQ 出来，各个系统保证自己能够正确消费订单取消 MQ 即可。</p><p>而场景 4 订单其实尚未生成，相对来说要复杂些，如上面提到的，提单系统 T1 需要主动发起库存系统 X2、优惠券系统 X3 的回滚请求（入参必须带上订单号），X2、X3 回滚接口需要支持幂等性。</p><p>其实针对场景 4，还存在一种极端情况，如果提单系统 T1 准备回滚时自身也宕机了，那么库存系统 X2、优惠券系统 X3 就必须依靠自己来完成回滚操作了，也就是说具备自我数据健康检查的能力，具体来说怎么实现呢？</p><p>可以利用当前订单号所属的订单尚未生成的特点，可以通过 worker 机制，每次捞取 40 分钟（这里的 40 一定要大于容忍用户的支付时间）前的订单，调用订单中心查询订单的状态，确保不是已取消的，否则进行自我数据的回滚。</p><h2 id="2-4-多人同时购买-1-件商品，如何安全地库存扣减？"><a href="#2-4-多人同时购买-1-件商品，如何安全地库存扣减？" class="headerlink" title="2.4 多人同时购买 1 件商品，如何安全地库存扣减？"></a>2.4 多人同时购买 1 件商品，如何安全地库存扣减？</h2><p>现实中同一件商品可能会出现多人同时购买的情况，我们可以如何做到并发安全呢？</p><p>伪代码片段 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="keyword">long</span> stockNum = getProductStockNum(productId);</span><br><span class="line">  <span class="keyword">if</span> (stockNum &gt; requestBuyNum) &#123;</span><br><span class="line">    String sql = <span class="string">"update stock_main set stockNum = stockNum - "</span> + requestBuyNum + <span class="string">" where productId = "</span> + productId;</span><br><span class="line">    <span class="keyword">int</span> ret = updateSQL(sql);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"扣减成功"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"扣减失败"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码片段 1 的设计思想是所有的请求过来之后首先加锁，强制其串行化处理，可见其效率一定不高。</p><p>伪代码片段 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stockNum = getProductStockNum(productId);</span><br><span class="line"><span class="keyword">if</span> (stockNum &gt; requestBuyNum) &#123;</span><br><span class="line">  String sql = <span class="string">"update stock_main set stockNum = stockNum - "</span> + requestBuyNum + <span class="string">" where productId = "</span> + productId + </span><br><span class="line">               <span class="string">" and stockNum &gt;= "</span> + requestBuyNum;</span><br><span class="line">  <span class="keyword">int</span> ret = updateSQL(sql);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"扣减成功"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"扣减失败"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只是在 where 条件里增加了 <code>and stockNum&gt;=requestBuyNum</code> 即可防止超卖的行为，达到了与上述伪代码 1 的功能。</p><p>如果商品是促销品（比如参与了秒杀的商品）并发扣减的机率会更高，那么数据库的压力会更高，这个时候还可以怎么做呢?</p><p>海量的用户秒杀请求，本质上是一个排序，先到先得。但是如此之多的请求，注定了有些人是抢不到的，可以在进入上述伪代码 Dao 层之前增加一个计数器进行控制，比如有 50% 的流量将直接告诉其抢购失败，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BuyResult <span class="title">buy</span> <span class="params">(User user, <span class="keyword">int</span> productId, <span class="keyword">int</span> productNum)</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">2</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BuyResult(<span class="string">"抢购失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> doBuy(user, productId, productNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外同一个用户，不允许多次抢购同一件商品，我们又该如何做呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doBuy</span><span class="params">(user, productId, productNum)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用户除了第一次进入值为1，其它时候均大于1</span></span><br><span class="line">  <span class="keyword">int</span> tmp = redis.incr(user.getUid() + productId);</span><br><span class="line">  <span class="keyword">if</span> (tmp == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 1小时后 key 自动销毁</span></span><br><span class="line">    redis.expire(user.getUid() + productId, <span class="number">3600</span>);</span><br><span class="line">    <span class="keyword">return</span> doBuy1(user, productId, productNum);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BuyResult(<span class="string">"抢购失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一个用户拥有不同的帐号，来抢购同一件商品，上面的策略就失效了。一些公司在发展早期几乎是没有限制的，很容易就可以注册很多个账号。也即是网络所谓的“僵尸账号”，数量庞大，如果我们使用几万个“僵尸号”混进去抢购，这样就可以大大提升我们中奖的概率，那我们如何应对呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doBuy1</span><span class="params">(user, productId, productNum)</span> </span>&#123;</span><br><span class="line">  String minuteKey = DateTimeUtil.getDateTimeStr(<span class="string">"yyyyMMddHHmm"</span>);</span><br><span class="line">  String minuteIpCount = redis.incr(minuteKey + user.getClientIp());</span><br><span class="line">  <span class="comment">// threshold 为允许每分钟单个 ip 的最大访问次数</span></span><br><span class="line">  <span class="keyword">if</span> (minuteIpCount &gt; threshold) &#123;</span><br><span class="line">    <span class="comment">// 识别到这部分潜在风险用户时，会让这部分用户强制跳转到验证码页面进行校验</span></span><br><span class="line">    <span class="comment">// 校验通过后才能继续抢购商品</span></span><br><span class="line">    <span class="keyword">return</span> getAndSendVerificationCode(user);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doBuy2(user, productId, productNum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-库存系统的核心表结构设计"><a href="#2-5-库存系统的核心表结构设计" class="headerlink" title="2.5 库存系统的核心表结构设计"></a>2.5 库存系统的核心表结构设计</h2><p>下面列出了库存系统的核心表结构，提供出来供大家在工作中能够有所参考：</p><h3 id="2-5-1-库存主表，命名规则：stock-center-00-99-库存主表"><a href="#2-5-1-库存主表，命名规则：stock-center-00-99-库存主表" class="headerlink" title="2.5.1 库存主表，命名规则：stock_center_00~99 库存主表"></a>2.5.1 库存主表，命名规则：stock_center_00~99 库存主表</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-11-14%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96003.jpg" alt></p><h3 id="2-5-2-库存流水表，命名规则：stock-center-flow-00-99-库存流水表"><a href="#2-5-2-库存流水表，命名规则：stock-center-flow-00-99-库存流水表" class="headerlink" title="2.5.2 库存流水表，命名规则：stock_center_flow_00~99 库存流水表"></a>2.5.2 库存流水表，命名规则：stock_center_flow_00~99 库存流水表</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-11-14%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96004.jpg" alt></p><h3 id="2-5-3-库存批量操作日志表，命名规则：batch-upload-log-库存批量操作日志表"><a href="#2-5-3-库存批量操作日志表，命名规则：batch-upload-log-库存批量操作日志表" class="headerlink" title="2.5.3 库存批量操作日志表，命名规则：batch_upload_log 库存批量操作日志表"></a>2.5.3 库存批量操作日志表，命名规则：batch_upload_log 库存批量操作日志表</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-11-14%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96005.jpg" alt></p><h1 id="3-思考"><a href="#3-思考" class="headerlink" title="3 思考"></a>3 思考</h1><ol><li>关键在于库存扣除的核心代码，考虑并发量以及数据库性能，并依赖 Redis 来实现可靠的代码。我在实际中使用的就是通过 SQL 增加 <code>and stockNum&gt;=requestBuyNum</code> 来保证不会库存多扣。  </li><li>但是关于订单取消的逻辑，我们是使用的 30 分钟之后自动取消，接着业务走相关类似的逻辑。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/45周总结</title>
      <link href="/2019/11/11/2019/45.html/"/>
      <url>/2019/11/11/2019/45.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/44周总结</title>
      <link href="/2019/11/05/2019/44.html/"/>
      <url>/2019/11/05/2019/44.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/43周总结</title>
      <link href="/2019/10/27/2019/43.html/"/>
      <url>/2019/10/27/2019/43.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>压测性能总结</title>
      <link href="/2019/10/27/tech/11_performance_sum.html/"/>
      <url>/2019/10/27/tech/11_performance_sum.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>临近双11，公司对所有的接口都使用阿里云的全链路压测工具做压测，比如首页的 TPS 是3000，支付的 TPS 是 60，根据不同的接口做不同的策略。其中数值是根据平时的5倍计算得出的。<br>这篇博文就是使用阿里云的 arms 监控（APM的一种，类似 skywalking，可以查看请求的每个链路）以及 PTS（做压测的一种工具）对两次压测的优化总结。</p><p>待拆解项目机器集群A：48台，配置为4核8G<br>本项目机器集群B：6台，配置为4核8G<br>由于压测时正在在拆解服务中，因此大部分接口在A集群中。<br>A 集群20%的接口通过 RPC 请求到 B，80%的接口通过发送消息跟 B 交互。<br>数据库配置：1写5读，配置较高，只在主库操作。在压测过程中主库 CPU 基本属于较为稳定。<br>ONS：发送、接收消息总 TPS 为 5000，在压测过程中基本还未达到该阈值。总 TPS 稳定在 40（即发、接消息各20）。<br>Redis：4G两节点，不是瓶颈。<br>第三方请求接口主要有：支付的请求下单、通知回调、银行卡四要素验证等。  </p><a id="more"></a><h1 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1. MySQL"></a>1. MySQL</h1><p>使用 MySQL 的主要用途用于存储支付参数、支付结果等信息，主要是短查询和长写入，整个支付下单事务较长。  </p><p>另外由于正在拆解服务，还没有将支付相关的数据库独立出来，因此项目的数据库性能会受到其它项目对数据库的影响，从而影响本项目的性能，这是没法避免的。</p><p>优化第一点是配置最大连接数：  </p><p>查看最大连接数：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-10-28MySQL%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0.png" alt></p><p>根据数据库能支撑的最大连接数，以及连接该数据库一共有几个项目，来设置平均每个项目的连接数，我这边设置从之前的 20 变更为 50。  </p><p>那什么时候才知道是连接数的问题呢？其实当你在发现某个接口，它请求访问数据库的操作一共需要5s，但是你查看数据库的相关语句的时候，发现语句最慢也才耗时 1s，那这时你就需要怀疑是否是因为等待获取连接而耗费很大量的时间。</p><p>第二点是去掉多余的事务：</p><p>你仔细看了整个项目，从业务和技术角度上考虑过项目上是否有多余的事务注解吗？因为我就犯了这个错。  </p><p>原来的某个服务 A 本来是个有更新操作的，优化后，将更新操作放到别处了，因此服务 A 里面只有一个查询，但是我忘记去掉该服务的 Transaction 注解，导致在压测的时候，该服务的响应时间是1分钟，查看链路发现是一个 select 语句就1分钟！当去掉 Transaction 后变成了10ms！</p><h1 id="2-ONS"><a href="#2-ONS" class="headerlink" title="2. ONS"></a>2. ONS</h1><p>ons 是 rocketmq 的商业版，使用基本和 rocketmq 一致。但是我个人觉得没有 rocketmq 好用，我之前公司使用自己搭建的 rocketmq，有问题基本debug，就能大概定位问题。但是 ons 是闭源的，只能提工单到他们的工作人员，等待反馈。不过 ons 适合刚初创企业，没有多余能力去使用 rocketmq。不可否认的是，当业务发展量到了一定程度，使用 rocketmq 是必然的结果！</p><p>优化第一点：消息能否延迟？</p><p>我在控制台观察消息的生产消费量，支付相关的消息平时相对来说不是很多，然后再看压测时候的消息大致是多少，当时在压测的时候消息使用的是普通消息，导致某个时间消息堆积消费很高，CPU飙升，没有达到削峰的功能！后来在分析该业务后，发现该业务可以接受大概30s的延迟，因此使用了随机延迟消息，平摊到 30s 内做处理，达到了削峰填谷的功能，将 CPU 稳定在了 15%，提升很大。</p><blockquote><p>但是这里有个疑问，我之前了解 rocketmq 知道它使用延迟消息是使用延迟级别的队列实现，即：你有几个延迟级别，就需要多少个额外的队列，但是在 ons，我使用的随机延迟消息，理论上ons那就支持了无限的延迟队列，但是这是不可能的，因此它肯定有自己更好的延迟队列实现！</p></blockquote><p>另外也可以参考消息的最佳实践：  </p><p>一个微服务用一个 GroupId，项目内部一级业务类型，使用 Topic 区分。二级业务使用 TAG 区分。例如我这边的支付相关消息使用 Pay_Topic，下面一些比如退款或转账的具体业务使用 TAG 区分，具体的最佳实践参考文档：<a href="https://help.aliyun.com/document_detail/95837.html?spm=a2c4g.11174283.6.624.3a945793jfF9XT" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/95837.html?spm=a2c4g.11174283.6.624.3a945793jfF9XT</a></p><blockquote><p>其中一个插曲，是关于消息负载的问题，由于阿里他们消息负载有问题（他们也承认了，正在优化），因此有经常某台机器负载堆积消息尤其严重，而有的机器又很空闲。他们答应尽快解决，我这边暂时使用 sentinel 做消息的限流。这也侧面验证其实自建消息队列是很有必要的，至少在消息的负载上，我们可以透明化，一是消息到队列的负载，二是队列到消费者的负载，都可以根据业务情况精准控制。</p></blockquote><h1 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3. Redis"></a>3. Redis</h1><p>关于 Redis 我这边并没有使用很多，因为支付基本都是走的主库，需要实时性，当然有部分的支付相关边缘业务，查询较多，才会考虑使用 Redis 缓存，引入 Redis 还是有一定的技术成本，使用不当会弄巧成拙。  </p><p>我在项目中唯一使用 Redis 的地方是用来保证消息消费的幂等性。  </p><p>由于消息发送方是使用的 ons-client 老的版本，有一些BUG，但是 one-client 新的版本和老的版本部门协议又有不同，没法兼容。而发送方项目由于很多项目都做了依赖，改动 one-client 版本成本太大。因此要解决这个 BUG，需要从我自己项目入手。<br>该 BUG 表现为 exactly-once 的状态变更 bug。ons 的 exactly-once 原理如下：消费端建一张消息消费表，并在代码注入使用它的 MQDataSouce，该 datasource 会在消息消费前后做切面，加入了消费状态的变更和判定，例如：消费状态未消费、消费中、消费完成、消费异常等，而状态的变更写入数据库是和业务的数据库属于同一个事务，从而保证了消息的幂等————通过额外一个消费表记录来实现。但是由于有 BUG，这个状态判定有个小问题，因此我在消费业务代码最外层加入了 Redis，它实现了类似的功能，对同一个 MessageKey 记录消费状态，来实现消息的去重。那我为什么不使用数据库表来实现呢？因为方便。唯一的问题是 Redis 挂掉的问题，或者说是不一致问题。但是说实话，Redis 挂掉的几率基本和 MySQL 挂掉几率基本一样，因为我们都是使用的阿里云集群机器。</p><h1 id="4-内部项目接口"><a href="#4-内部项目接口" class="headerlink" title="4. 内部项目接口"></a>4. 内部项目接口</h1><p>我们内部项目间互相调用使用 dubbo 调用，优化基本集中在 dubbo 配置上。<br>第一个是将 threadpool 将 cached 改为 fixed，数量默认为 200，这是参考了 arms 监控中的线程池变化设定的，而且机器性能也好，不过还需要下次压测查看结果，毕竟线程上下文切换也不知道损耗多少。<br>第二个是超时时间，我这边设置为 3000 ms（默认 1000 ms），另外使用了 Redisson 做重复请求的锁，锁 3000 ms，避免多次点击，由于业务正在优化，某些业务还不支持幂等，重复请求会有点问题，基本在 3 秒内支付相关流程事务执行完，状态写入成功，就没什么大问题了。<br>第三个是 loadbalance 策略，修改为 leastactive</p><blockquote><p>另外，因为我们用的 nacos 有个权重配置，不过这个我还没用，如果以后机器性能不均匀可以有个参考优化点。</p></blockquote><h1 id="5-第三方接口"><a href="#5-第三方接口" class="headerlink" title="5. 第三方接口"></a>5. 第三方接口</h1><p>第三方接口慢，没法避免，而且有的付费接口是基于 TPS 购买的，因此必须要使用限流，不然返回都是错误，用 sentinel 的 callback 就很方便。其它类似的限流工具也差不多，根据漏桶算法，做 TPS 判定，也可以选择使用 RT 做限流，我根据情况来选择 TPS 还是 RT 限流。</p><h1 id="6-JVM-优化"><a href="#6-JVM-优化" class="headerlink" title="6. JVM 优化"></a>6. JVM 优化</h1><p>jvm 优化主要是参考的 <a href="https://opts.console.perfma.com/" target="_blank" rel="noopener">https://opts.console.perfma.com/</a> ，原来的参数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xms4096m -Xmx4096m -XX:NewSize=1024m  -XX:MaxNewSize=1024m -XX:PermSize=512M -XX:MaxPermSize=512m</span><br></pre></td></tr></table></figure></p><p>机器 4核8G，现在的参数调整为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xms5440M -Xmx5440M -Xmn1984M -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m</span><br></pre></td></tr></table></figure></p><p>其中主要参考了压测时的堆栈内存变化，其中可以看出 10-22 的变化：</p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-10-28JVM%E5%9B%BE.png" alt></p><h1 id="7-后台任务分离"><a href="#7-后台任务分离" class="headerlink" title="7. 后台任务分离"></a>7. 后台任务分离</h1><p>这个主要是将后台的定时任务全部迁入到一个专门的执行器项目，使用 xxl-job 来控制后台任务的执行，避免定时任务执行时的性能抖动，影响核心接口</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><ol><li>MySQL</li></ol><p>慢SQL：但是我这边基本没有<br>连接数：这个根据阿里云 RDS 的性能和项目数做调整<br>是否有不必要的事务：检查去掉不必要的事务<br>死锁：其实死锁还是有，很难根本解决，只能说减少概率，这个之前也写死锁总结博文，但是因为这个暂时不是性能瓶颈，因为在之后会花时间再解决。</p><ol start="2"><li>消息队列</li></ol><p>消息是否可以接受延迟？如果可以，那么就随机延迟或者几个延迟级别随机选择。<br>机器消费消息是否负载均衡？如果不均衡，那么看是发消息到队列不均衡，还是队列到消费者不均衡。</p><ol start="3"><li>Redis</li></ol><p>能不用缓存就不用缓存，如果性能问题，必须上缓存，那么要考虑缓存一致的问题，其实我在公司经常听到测试说，为什么这边修改但是用户那边还没改动，根本原因是，缓存在设计的时候不合理，乱用，而不考虑手动缓存失效，只能等待一定时间失效，这是不合理的。<br>Redis 不可用我暂时还没碰到，可能是使用量不大，不过性能抖动倒是碰到过，上家用的腾讯云，半夜会超时什么的，这个没办法，是提供商的问题。</p><ol start="4"><li>内部接口</li></ol><p>我们都是用 dubbo 做项目之间的请求</p><p>别人依赖你：别人依赖你的接口服务，那么尽量保证能异步就异步，日志通过 filter 拦截进出口的日志，方便调试。还有一个是关于 apm 的使用，我们使用了 skywalking，因此我加入了全局链路 token，方便跟踪某个请求，这个对定位问题很方便。自己提供的接口服务能加上限流控制就加上，关键时候设置限流有奇效。<br>你依赖别人：考虑当别人项目不可用时，你会发生什么，做异常的解决或者 callback 快速失败策略。还有请求超时时间以及负载策略的针对配置。</p><ol start="5"><li>JVM 优化</li></ol><p>推荐参考 <a href="https://opts.console.perfma.com/" target="_blank" rel="noopener">https://opts.console.perfma.com/</a> 输入自己的机器参数，自动给你生成相关参数，最后在实际中，观察项目的 JVM 堆栈实际情况，来做调整。</p><ol start="6"><li>服务分离</li></ol><p>前后台服务分离：后台定时任务分离独立为一个项目，提供给别人的接口服务独立为一个项目<br>核心业务分离：这个我没有实战，但是如果以后业务量膨胀，我会使用该方法，核心业务不能挂~</p>]]></content>
      
      
      <categories>
          
          <category> 工作思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/42周总结</title>
      <link href="/2019/10/22/2019/42.html/"/>
      <url>/2019/10/22/2019/42.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DUBBO SPI 解析</title>
      <link href="/2019/10/17/tech/dubbo/dubbo_spi.html/"/>
      <url>/2019/10/17/tech/dubbo/dubbo_spi.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>最近因为项目需要，需要基于 Dubbo 增加一个 filter，拦截所有的 RPC 请求，打印出请求的相关信息。<br>我自定义的 Filter 作为提供者拦截器一共有三步：</p><ol><li>写一个自定义类，实现自 Filter 接口</li><li>在 META-INF/dubbo 下增加一个 org.apache.dubbo.rpc.Filter 的文件名，内容为自定义 Filter 的全路径</li><li>自定义 Filter 类上增加一个 @Activate(group = Constants.PROVIDER, order = -999) 注解  </li></ol><p>因此有个疑问，它是如何生效的呢？我在哪个地方让它生效的呢？因此在参考了一些博客和项目后，有了我这篇总结，分析了 Dubbo SPI 的原理以及我还未使用到的 AOP、IOC 特性是如何实现的。  </p><p>reference:  </p><ol><li>[<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html]" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html]</a></li><li>[<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html]" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html]</a></li><li>[<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html]" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html]</a></li><li>[<a href="https://github.com/LiWenGu/iris-java.git]（轻量级微内核插件机制的" target="_blank" rel="noopener">https://github.com/LiWenGu/iris-java.git]（轻量级微内核插件机制的</a> Java RPC 框架）</li></ol><a id="more"></a><p>如果让你实现类似 SPI 功能，你会如何实现？</p><h1 id="1-加载文件反射动态的获得所有扩展相关类"><a href="#1-加载文件反射动态的获得所有扩展相关类" class="headerlink" title="1. 加载文件反射动态的获得所有扩展相关类"></a>1. 加载文件反射动态的获得所有扩展相关类</h1><ol><li>读取名称为接口全路径的文件，文件内容为具体实现类的全路径，将内容全部保存为 Map  </li></ol><p>例如文件名为：<br>com.liwenguang.PayService<br>文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impl1=com.liwenguang.impl.PayServiceImpl1</span><br><span class="line">impl2=com.liwenguang.impl.PayServiceImpl2</span><br></pre></td></tr></table></figure><p>最后映射的 Map 为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    impl1: Class.for("com.liwenguang.impl.PayServiceImpl1")</span><br><span class="line">    impl2: Class.for("com.liwenguang.impl.PayServiceImpl2")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展类和包装类类似，如下源码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extName2Class 普通的扩展类 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name2Attributes 解析的参数 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name2Wrapper wrapper 包装类 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readExtension0</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extName2Class, Map&lt;String, Map&lt;String, String&gt;&gt; name2Attributes, Map&lt;String, Class&lt;? extends T&gt;&gt; name2Wrapper, ClassLoader classLoader, URL url)</span> </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String config = line;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// delete comments 如果为注释</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = config.indexOf(<span class="string">'#'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) config = config.substring(<span class="number">0</span>, ci);</span><br><span class="line">                config = config.trim();</span><br><span class="line">                <span class="keyword">if</span> (config.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String name = <span class="keyword">null</span>;</span><br><span class="line">                    String body = <span class="keyword">null</span>;</span><br><span class="line">                    String attribute = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 例如内容为 impl1=com.leibangzhu.coco.ext1.impl.SimpleExtImpl1</span></span><br><span class="line">                    <span class="comment">// 通过 = 分割为 name 和 body</span></span><br><span class="line">                    <span class="keyword">int</span> i = config.indexOf(<span class="string">'='</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        name = config.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                        body = config.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没有配置文件中没有扩展点名，从实现类的Extension注解上读取。</span></span><br><span class="line">                    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                                <span class="string">"missing extension name, config value: "</span> + config);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 例如内容为 impl1=com.leibangzhu.coco.ext4.impl.WithAttributeExtImpl1(k1=v1,k2,k3=v3,k4=,k5=v5)</span></span><br><span class="line">                    <span class="comment">// 通过 ( 分割获取后面的内容为参数，这里为 map</span></span><br><span class="line">                    <span class="keyword">int</span> j = config.indexOf(<span class="string">"("</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.charAt(config.length() - <span class="number">1</span>) != <span class="string">')'</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                                    <span class="string">"missing ')' of extension attribute!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        body = config.substring(i + <span class="number">1</span>, j).trim();</span><br><span class="line">                        attribute = config.substring(j + <span class="number">1</span>, config.length() - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Class&lt;? extends T&gt; clazz = Class.forName(body, <span class="keyword">true</span>, classLoader).asSubclass(type);</span><br><span class="line">                    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                                type.getName() + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                                + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 例如内容为 *adaptive=com.leibangzhu.coco.ext9.impl.ManualAdaptive</span></span><br><span class="line">                    <span class="comment">// 通过 * 得到该类为动态生成类，但是在此版本还未生效</span></span><br><span class="line">                    <span class="keyword">if</span> (name.startsWith(PREFIX_ADAPTIVE_CLASS)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (adaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            adaptiveClass = clazz;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!adaptiveClass.equals(clazz)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                                    + adaptiveClass.getClass().getName()</span><br><span class="line">                                    + <span class="string">", "</span> + clazz.getClass().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 例如内容为 +wrapper1=com.leibangzhu.coco.ext3.impl.Ext3Wrapper1</span></span><br><span class="line">                        <span class="comment">// 通过 + 得到该类为包装类</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapper = name.startsWith(PREFIX_WRAPPER_CLASS);</span><br><span class="line">                        <span class="keyword">if</span> (isWrapper)</span><br><span class="line">                            name = name.substring(PREFIX_WRAPPER_CLASS.length());</span><br><span class="line"></span><br><span class="line">                        String[] nameList = NAME_SEPARATOR.split(name);</span><br><span class="line">                        <span class="keyword">for</span> (String n : nameList) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!isValidExtName(n)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"name("</span> + n +</span><br><span class="line">                                        <span class="string">") of extension "</span> + type.getName() + <span class="string">"is invalid!"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (isWrapper) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    clazz.getConstructor(type);</span><br><span class="line">                                    name2Wrapper.put(name, clazz);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"wrapper class("</span> + clazz +</span><br><span class="line">                                            <span class="string">") has NO copy constructor!"</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    clazz.getConstructor();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"extension class("</span> + clazz +</span><br><span class="line">                                            <span class="string">") has NO default constructor!"</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (extName2Class.containsKey(n)) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (extName2Class.get(n) != clazz) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> +</span><br><span class="line">                                                type.getName() + <span class="string">" name "</span> + n +</span><br><span class="line">                                                <span class="string">" on "</span> + clazz.getName() + <span class="string">" and "</span> + clazz.getName());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    extName2Class.put(n, clazz);</span><br><span class="line">                                &#125;</span><br><span class="line">                                name2Attributes.put(n, parseExtAttribute(attribute));</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!extClass2Name.containsKey(clazz)) &#123;</span><br><span class="line">                                    extClass2Name.put(clazz, n); <span class="comment">// 实现类到扩展点名的Map中，记录了一个就可以了</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load config line("</span> + line +</span><br><span class="line">                            <span class="string">") of config file("</span> + url + <span class="string">") for extension("</span> + type.getName() +</span><br><span class="line">                            <span class="string">"), cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    logger.warn(<span class="string">""</span>, e);</span><br><span class="line">                    extClassLoadExceptions.put(line, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of while read lines</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                    type.getName() + <span class="string">", class file: "</span> + url + <span class="string">") in "</span> + url, t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="2-wrapper-包装的-IOC-实现"><a href="#2-wrapper-包装的-IOC-实现" class="headerlink" title="2. wrapper 包装的 IOC 实现"></a>2. wrapper 包装的 IOC 实现</h1><p>IOC 的支持：在扩展类初始化时，将其依赖的扩展类动态的使用构造方法/set方法，塞入。最常用的是生成动态类，在执行方法时，根据参数来决定执行哪个实现类的方法<br>源码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name, List&lt;String&gt; wrappers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取需要被包装的扩展类</span></span><br><span class="line">    T instance = getExtension(name);</span><br><span class="line">    <span class="keyword">return</span> createWrapper(instance, wrappers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createWrapper</span><span class="params">(T instance, List&lt;String&gt; wrappers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String name : wrappers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过构造方法对 wrapper 进行初始化</span></span><br><span class="line">            instance = injectExtension(name2Wrapper.get(name).getConstructor(type).newInstance(instance));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to create wrapper("</span> + name + <span class="string">") for extension point "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (pt.isInterface() &amp;&amp; withExtensionAnnotation(pt)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pt.equals(type)) &#123; <span class="comment">// avoid obvious dead loop TODO avoid complex nested loop setting?</span></span><br><span class="line">                            logger.warn(<span class="string">"Ignore self set("</span> + method + <span class="string">") for class("</span> +</span><br><span class="line">                                    instance.getClass() + <span class="string">") when inject."</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取被包装类的动态类，该动态类注解的 Adaptive 方法都被代理了</span></span><br><span class="line">                            Object adaptive = getExtensionLoader(pt).getAdaptiveInstance();</span><br><span class="line">                            method.invoke(instance, adaptive);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            logger.error(<span class="string">"Fail to inject via method "</span> + method.getName()</span><br><span class="line">                                    + <span class="string">" of interface to extension implementation "</span> + instance.getClass() +</span><br><span class="line">                                    <span class="string">" for extension point "</span> + type.getName() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在例子中即可以使用构造方法进行的注入，也支持 set 方法进行注入。但是构造方法由于比较特殊，在 Dubbo 中去除掉了，个人猜测是因为构造方法的循环依赖的问题太难解决了。</p><h1 id="3-根据参数在运行时动态切换实现类"><a href="#3-根据参数在运行时动态切换实现类" class="headerlink" title="3. 根据参数在运行时动态切换实现类"></a>3. 根据参数在运行时动态切换实现类</h1><p>当你的方法上有 @Adaptive 注解，会根据你的参数来动态执行不同实现类的方法<br>原理在于动态代理该方法，在执行的时候，根据参数获取不同实现类名称，进而使用不同实现类执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveInstance</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    <span class="comment">// 找到有 adaptive 的注解方法</span></span><br><span class="line">    checkAndCollectAdaptiveInfo0();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有AdaptiveClass（在扩展点配置文件中声明的类）</span></span><br><span class="line">    <span class="keyword">if</span> (adaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(adaptiveClass.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object p = Proxy.newProxyInstance(ExtensionLoader.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;type&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass().equals(Object.class)) &#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="keyword">if</span> (methodName.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Adaptive Instance for "</span> + type.getName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (methodName.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (methodName.equals(<span class="string">"equals"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span> == args[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"not support method "</span> + method +</span><br><span class="line">                        <span class="string">" of Adaptive Instance for "</span> + type.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!adaptiveMethod2ArgIndex.containsKey(method)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method "</span> + method.getName() +</span><br><span class="line">                        <span class="string">" of interface "</span> + type.getName() + <span class="string">" is not adaptive method!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> confArgIdx = adaptiveMethod2ArgIndex.get(method);</span><br><span class="line">            Object arg = args[confArgIdx];</span><br><span class="line">            NameExtractor nameExtractor = adaptiveMethod2Extractor.get(method);</span><br><span class="line">            <span class="comment">// 根据参数来获取扩展类名称，例如参数为 &#123;"key", "impl1"&#125;，那么扩展类则为 impl1</span></span><br><span class="line">            String extName = nameExtractor.extract(arg);</span><br><span class="line">            <span class="keyword">if</span> (extName == <span class="keyword">null</span>) extName = defaultExtension;</span><br><span class="line">            <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension("</span> + type.getName() +</span><br><span class="line">                        <span class="string">") name from argument("</span> + arg + <span class="string">") use keys("</span> + Arrays.toString(adaptiveMethod2Keys.get(method)) + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(ExtensionLoader.<span class="keyword">this</span>.getExtension(extName), args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.cast(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">extract</span><span class="params">(Object argument)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argument == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"adaptive "</span> + parameterType.getName() +</span><br><span class="line">                <span class="string">" argument == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object sourceObject = argument;</span><br><span class="line">    <span class="comment">// 如果参数是一个包装类，则从该类中的的 get 中获取，参考 ConfigHolder 类 @FromAttribute("config")</span></span><br><span class="line">    <span class="keyword">if</span> (fromAttribute != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sourceObject = fromGetter.invoke(sourceObject);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == sourceObject) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"adaptive "</span> + parameterType.getName() +</span><br><span class="line">                        <span class="string">" argument "</span> + fromGetter.getName() + <span class="string">"() == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get attribute "</span> +</span><br><span class="line">                    fromGetter.getName() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get attribute "</span> +</span><br><span class="line">                    fromGetter.getName() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getFromMap(sourceObject, adaptiveKeys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj   &#123;"simple.ext": "impl1"&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys  根据 key 获取 obj 参数的值作为真正的实现类</span></span><br><span class="line"><span class="comment"> *              该值优先取 Adaptive 注解的 value 字段，再取类名，例如：NoDefaultExt，则取 no.default.ext </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getFromMap</span><span class="params">(Object obj, String[] keys)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) obj;</span><br><span class="line">    <span class="comment">// 优先第一个</span></span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        Object value = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体例子为：当参数为 Map 时，并且被请求执行的方法带有 @Adaptive 注解时，会根据 Map 参数里面的某个 key 的 value，来决定使用哪个实现类的方法，例如 Map 中键值对为 key:impl1 那么执行的就是 impl1 方法。</p><h1 id="4-完整线路"><a href="#4-完整线路" class="headerlink" title="4. 完整线路"></a>4. 完整线路</h1><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-10-17_DUBBO_SPI%E5%8E%9F%E7%90%86.jpg" alt="完整线路"></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/41周总结</title>
      <link href="/2019/10/13/2019/41.html/"/>
      <url>/2019/10/13/2019/41.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/40周总结</title>
      <link href="/2019/10/08/2019/40.html/"/>
      <url>/2019/10/08/2019/40.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/39周总结</title>
      <link href="/2019/10/01/2019/39.html/"/>
      <url>/2019/10/01/2019/39.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/37周总结</title>
      <link href="/2019/09/17/2019/37.html/"/>
      <url>/2019/09/17/2019/37.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/36周总结</title>
      <link href="/2019/09/11/2019/36.html/"/>
      <url>/2019/09/11/2019/36.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅出分布式唯一ID生成器</title>
      <link href="/2019/09/05/tech/unique_id_1.html/"/>
      <url>/2019/09/05/tech/unique_id_1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>近日由于订单量+机器数量增加，导致原来使用时间戳生成唯一订单号的方法行不通了，出现很多主键冲突。<br>并且由于主键冲突导致的事务死锁的几率也随之加大，进而需要补的数据越来越多！因此急需一个全局唯一ID生成方式。<br>但由于现在单体框架还在拆解过程中，新的生成方式需要兼容单体应用（多台集群）<br>最好能用最简单的方式先解决，待以后服务拆解出来后考虑可用性扩展性。</p><a id="more"></a><h1 id="1-调研"><a href="#1-调研" class="headerlink" title="1. 调研"></a>1. 调研</h1><p>大概有以下几个选择，优先级由高到低：</p><ol><li>snowflake</li><li>数据库唯一ID主键约束</li><li>redis 原子递增</li><li>UUID</li><li>leaf</li><li>uid-generator</li></ol><p>优先级 snowflake 主要是有以下理由：</p><ol><li>snowflake 现阶段用一个工具类就能直接上手使用</li><li>现在分库分表也使用了 snowflake，以后可以做统一的唯一ID服务</li><li>很多分布式ID中间件都基于 snowflake，以后也方便扩展，而不会出现<strong>由于算法不同，新算法生成的序列号可能被以前已经生成过</strong></li></ol><h1 id="2-实际使用"><a href="#2-实际使用" class="headerlink" title="2. 实际使用"></a>2. 实际使用</h1><ol><li>开始考虑使用IP的最后一位作为 workid，因为已经和运维确认过，现在线上机器是最后是连号，不会重复，但是因为默认 workid 最大是 32，就没有将 datacenterid 都改为 workid，因为我发现我们 hostname 是带编号的，而且是递增的规律：xxservice001，最后三位是序号，因此直接取最后三位数字，作为 workid。</li></ol><blockquote><p>snowflake 默认使用 <code>1+41+10+12</code> ID组装模式，其中 10 bit 是 datacenter + workid</p></blockquote><h1 id="2-1-时钟回拨问题"><a href="#2-1-时钟回拨问题" class="headerlink" title="2.1 时钟回拨问题"></a>2.1 时钟回拨问题</h1><p>关于时钟回拨，一般解决方法有：</p><ol><li>机器之间定时同步时间</li><li>通过请求其它机器获取平均时间戳对比（Leaf）</li><li>在阈值内不断获取当前时间直到大于上次申请时间</li><li>使用第三方存储号段来解决（我个人倾向号段方案）</li></ol><p>由于正面临拆分，以后会有专门的 id 生成服务，因此现在并没有在单体服务上做时钟回拨的解决，我选择最简单的 hutool 工具引用即可，但是它仍可能有一定几率有时钟回拨。</p><blockquote><p>现阶段运行了两周，还没发现这个错误。</p></blockquote><h1 id="3-其它ID算法简析"><a href="#3-其它ID算法简析" class="headerlink" title="3. 其它ID算法简析"></a>3. 其它ID算法简析</h1><p>稍微系统的学习一下业内的分布式ID生成方案</p><h2 id="3-1-uid-generator"><a href="#3-1-uid-generator" class="headerlink" title="3.1 uid-generator"></a>3.1 uid-generator</h2><p>以中间件的形式提供服务，基于 snowflake 的优化版，使用双 buffer 环（我个人理解为生产者和消费者模式），一个 buffer 生产号段，一个 buffer 消费号段。</p><p>snowflake 各个分配可自定义：</p><ul><li>1bit：第一位不用，用于标志 0 ，表示正数</li><li>28bits：每个机器当前时间，单位秒</li><li>22bits：机器数量</li><li>13bits：每秒的并发数</li></ul><ol><li>默认是秒级并发，常规的 <code>snowflake</code> 算法是基于毫秒级(41 bits)，但是没有必要这么精确，每台机器每秒并发最多8192够用了。</li><li>接着是环形数组，通俗来讲就是生产者和消费者模型，一个不能生产过快，一个不能消费过快。同时该模型又有扩容机制，即生产者到一定量后扩容。生产者每次生产者的数量。由于是周期性填充生产并缓存，因此可以接受短时间内第三方存储服务不可用。</li><li>默认支持通过 mysql 存储机器申请情况，这可以用其它来代替，例如 zk，但是这需要<strong>我依赖的需要高可用</strong></li></ol><blockquote><p>由此可见, 不管如何配置, CachedUidGenerator总能提供600万/s的稳定吞吐量, 只是使用年限会有所减少. 这真的是太棒了<br>[<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md]" target="_blank" rel="noopener">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md]</a></p></blockquote><h2 id="3-2-leaf"><a href="#3-2-leaf" class="headerlink" title="3.2 leaf"></a>3.2 leaf</h2><p>也是以中间件的形式提供服务。</p><blockquote><p>目前Leaf的性能在4C8G的机器上QPS能压测到近5w/s，TP999 1ms，已经能够满足大部分的业务的需求</p></blockquote><p>有两种生产号段方式：<code>Leaf-segment</code>、<code>Leaf-snowflake</code></p><h3 id="3-2-1-Leaf-segment"><a href="#3-2-1-Leaf-segment" class="headerlink" title="3.2.1 Leaf-segment"></a>3.2.1 Leaf-segment</h3><p>基于 mysql 数据库的号段模式，不是每一次都访问数据库，而是在数据库记录哪台机器分配了哪个号段区间。</p><p>在每次消费时，当前机器访问 Leaf 时，Leaf 会得到该机器是否已经发了号段，并判断下一个号段的状态，接着从数据库中更新号段信息，并将号段到载入内存中，防止出现当前号段消费完后，加载下一个号段时的卡顿。</p><p>由此得知可以短暂的容忍 mysql 一段时间内不可用。</p><h3 id="3-2-2-Leaf-snowflake"><a href="#3-2-2-Leaf-snowflake" class="headerlink" title="3.2.2 Leaf-snowflake"></a>3.2.2 Leaf-snowflake</h3><p>标准的 <code>1+41+10+12</code> ID组装模式，默认使用 zk 做 leaf 集群多机房部署以达到高可用，主要是利用临时节点，记录当前正在访问 leaf 的消费端。</p><blockquote><p>解决了时钟回拨问题：3s一次上传 leaf 机器节点当前的时间，并进行 RPC 调用其它机器的时间，得到平均时间后，有个阈值（考虑网络延迟）进而通过判断当前机器时间与平均时间，来解决时钟回拨的问题。</p></blockquote><h2 id="3-3-UUID"><a href="#3-3-UUID" class="headerlink" title="3.3 UUID"></a>3.3 UUID</h2><p>唯一，但是无序，且长度太长，一般来说，数据库存都是 bigint(20) 即 64 bit，对应在 java 中使用 long，也是 64bit，而 uuid 是 128 bit，且是字母数字组合，需要 char(128)，空间浪费很严重</p><h2 id="3-4-redis"><a href="#3-4-redis" class="headerlink" title="3.4 redis"></a>3.4 redis</h2><p>基于 Redis 全局递增，步长设置。<br>使用 lua 脚本结合 snowflake 来实现</p><p>例如有三台业务机器，两台 redis 作为id生成机器：<code>1+41+10+12</code> 模式，其中的 workid 使用 redis 集群中的机器编号，这样就会请求的每个 redis 获取的 redis 都不会重复，但是仍旧有时钟回拨的问题。</p><h2 id="3-5-idx-mysql-id"><a href="#3-5-idx-mysql-id" class="headerlink" title="3.5 idx_mysql_id"></a>3.5 idx_mysql_id</h2><p>基于 mysql 的主键，强依赖mysql，而且性能低，适合前期使用，并发量大时，不仅每次要访问数据库，而且还要做保证数据库的高可用</p><h2 id="3-6-snowflake"><a href="#3-6-snowflake" class="headerlink" title="3.6 snowflake"></a>3.6 snowflake</h2><p>基本上现在主流的都会或多或少参考该算法<br>一共64bit，</p><ol><li>1bit默认为0，表示正数</li><li>41bit作为时间戳毫秒值</li><li>10bit作为工作机器</li><li>12bit作为每个机器每毫秒下最多能支持多少个并发请求生成号</li></ol><p>cn.hutool.core.lang.Snowflake</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间，hutool 内部有个定时任务刷时间</span></span><br><span class="line"><span class="keyword">long</span> timestamp = genTime();</span><br><span class="line"><span class="comment">// 将当前时间与上次申请时间对比，判断是否出现时钟回拨</span></span><br><span class="line"><span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">     <span class="comment">//如果服务器时间有问题(时钟回拨) 报错。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(StrUtil.format(<span class="string">"Clock moved backwards. Refusing to generate id for &#123;&#125;ms"</span>, lastTimestamp - timestamp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 微秒下的并发走这里</span></span><br><span class="line"><span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">    <span class="comment">// 微秒下进行序号 +1，默认最多支持微秒 8192 并发量</span></span><br><span class="line">    sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">        timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 并发数重置</span></span><br><span class="line">    sequence = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重置上一次时间</span></span><br><span class="line">lastTimestamp = timestamp;</span><br></pre></td></tr></table></figure><h1 id="4-个人认为好的解决方案"><a href="#4-个人认为好的解决方案" class="headerlink" title="4. 个人认为好的解决方案"></a>4. 个人认为好的解决方案</h1><h2 id="4-1-号段"><a href="#4-1-号段" class="headerlink" title="4.1 号段"></a>4.1 号段</h2><p>记录请求的机器ip+port（能唯一定位该机器的标识），然后分配号段，例如1000~3000，另一个机器过来请求，分配另一个号段，例如 4000~9000，这样。主要是依赖第三方存储号段分配情况，例如使用数据库，Redis，Zookeeper 都可以。没有</p><h2 id="4-2-算法生成"><a href="#4-2-算法生成" class="headerlink" title="4.2 算法生成"></a>4.2 算法生成</h2><p>就是 snowflake，不同在于根据业务的不同，可以对其中的 bit 做不同的分配，例如毫秒位改为秒位，这样多了三个位可以放给机器位，适合并发量不大，但是机器多的场景，或者机器位给最后的并发请求量位，适合并发量大，机器数量比 1024 少的场景。</p><p>而且这个也可以进化为号段，但是会有很多永远都不会用到的号段，需要有个重复利用的方案。但是这解决了普通号段模式的订单有序性问题。</p><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p>分布是唯一ID系列5篇：[<a href="https://www.cnblogs.com/itqiankun/p/11350857.html]" target="_blank" rel="noopener">https://www.cnblogs.com/itqiankun/p/11350857.html]</a><br>美团分布式ID系列2篇：[<a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html]" target="_blank" rel="noopener">https://tech.meituan.com/2019/03/07/open-source-project-leaf.html]</a><br>多key的预备：[<a href="https://mp.weixin.qq.com/s/PCzRAZa9n4aJwHOX-kAhtA]" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PCzRAZa9n4aJwHOX-kAhtA]</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 唯一ID生成算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/35周总结</title>
      <link href="/2019/09/03/2019/35.html/"/>
      <url>/2019/09/03/2019/35.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/34周总结</title>
      <link href="/2019/08/26/2019/34.html/"/>
      <url>/2019/08/26/2019/34.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>密码技术Go语言实现</title>
      <link href="/2019/08/21/tech/algo_go_1.html/"/>
      <url>/2019/08/21/tech/algo_go_1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-基础"><a href="#0-基础" class="headerlink" title="0. 基础"></a>0. 基础</h1><p>加密三要素：</p><ul><li>明文/密文</li><li>秘钥</li><li>算法</li></ul><p>CBC模式：分组模式的一种</p><blockquote><ol><li>明文经过填充，分块后和秘钥长度相同，接着第一块明文和初始向量进行数学运算后产生第一个密文块 A1  </li><li>A1 与秘钥 XOR 得到第二个密文块 A2  </li><li>上一个密文块和秘钥 XOR 得到当前密文块</li><li>重复第三步，直到将全部明文加密完成 </li></ol></blockquote><h1 id="1-对称密码"><a href="#1-对称密码" class="headerlink" title="1. 对称密码"></a>1. 对称密码</h1><ul><li>明文分组后需要填充，密文解密时需要去掉填充数据  </li><li>使用哪种分组模式（CBC）</li></ul><h2 id="1-1-DES"><a href="#1-1-DES" class="headerlink" title="1.1 DES"></a>1.1 DES</h2><p>DES（Data Encryption Standard，数据加密标准）算法，作为一个标准已经被高级加密标准 AES 取代，所以也被称为 DEA（Data Encryption Algorithm，数据加密算法）  </p><p>其秘钥长度为 56Bit（8 Bit = 1 byte）,每隔 7 Bit 会设置一个用于错误检查的比特位，即一共 <code>56+8=64Bit=8byte</code><br>其算法过程：</p><ul><li>假如明文长度为 64 byte</li><li>将明文分组，每组长度=秘钥的长度，即 8 byte</li><li>将每组数据和秘钥进行位运算</li><li>得到每组的密文长度=明文长度</li><li>如果分组后的长度小于秘钥长度，则进行填充</li></ul><p>其中位运算Go密码框架已经为我们实现了。</p><h2 id="1-2-3DES"><a href="#1-2-3DES" class="headerlink" title="1.2 3DES"></a>1.2 3DES</h2><p>三重数据加密算法（Triple Data Encryption Algorithm，缩写为TDEA，Triple DEA），或称3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解；3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p><p>要求需要3个秘钥，每个秘钥长度为 8 byte，明文分组后每组的数据长度和秘钥长度必须相同，同为 8 byte</p><p>加密过程：</p><ul><li>对分组数据使用 key1 加密得到 A1</li><li>对 A1 使用 key2 解密得到 A2</li><li>对 A2 使用 key3 加密得到最终的密文<br><img src="https://community.cisco.com/legacyfs/online/legacy/9/6/8/112869-des3p1.gif" alt></li></ul><blockquote><p>为什么能兼容 DES 密码算法？<br>假如 key1、2、3都不同：加密三次<br>假如 key1、2、3都相同：使用秘钥 key1 加密一次（和 DES 相同）</p></blockquote><h2 id="1-3-AES"><a href="#1-3-AES" class="headerlink" title="1.3 AES"></a>1.3 AES</h2><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 <code>Rijndael</code> 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 <code>DES</code>。</p><p>要求秘钥长度：16 byte 或 24 byte 或 32 byte<br>明文分组后每组的长度必须和秘钥长度相同<br>在 <code>go</code> 中密码算法框架指定死了秘钥长度为 16 byte  </p><h2 id="1-4-工程实现"><a href="#1-4-工程实现" class="headerlink" title="1.4 工程实现"></a>1.4 工程实现</h2><p>算法核心类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"crypto/aes"</span></span><br><span class="line"><span class="string">"crypto/cipher"</span></span><br><span class="line"><span class="string">"crypto/des"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充最后一个分组的函数</span></span><br><span class="line"><span class="comment">// src - 原始函数</span></span><br><span class="line"><span class="comment">// blockSize - 每个分组的数据长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paddingText</span><span class="params">(src []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 求出最后一个分组要填充多少个字节</span></span><br><span class="line">padding := blockSize - <span class="built_in">len</span>(src)%blockSize</span><br><span class="line"><span class="comment">// 2. 创建新的切片，切片的字节数为 padding，并初始化，每个字节的值为 padding</span></span><br><span class="line">padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line"><span class="comment">// 3. 将创建出的新切片和原始数据进行连接</span></span><br><span class="line">newText := <span class="built_in">append</span>(src, padText...)</span><br><span class="line"><span class="comment">// 4. 返回新的字符串</span></span><br><span class="line"><span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾填充的字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unPaddingText</span><span class="params">(src []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 求出要处理的切片的长度</span></span><br><span class="line"><span class="built_in">len</span> := <span class="built_in">len</span>(src)</span><br><span class="line"><span class="comment">// 2. 取出最后一个字符</span></span><br><span class="line">number := <span class="keyword">int</span>(src[<span class="built_in">len</span><span class="number">-1</span>])</span><br><span class="line"><span class="comment">// 3. 将切片末尾的number个字节删除</span></span><br><span class="line">newText := src[:<span class="built_in">len</span>-number]</span><br><span class="line"><span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 des 加密</span></span><br><span class="line"><span class="comment">// src - 明文</span></span><br><span class="line"><span class="comment">// key - 秘钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encryptoDES</span><span class="params">(src []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 创建并返回一个使用 DES 算法的 cipher.Block 接口</span></span><br><span class="line">block, err := des.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 对最后一个明文分组填充</span></span><br><span class="line">src = paddingText(src, block.BlockSize())</span><br><span class="line"><span class="comment">// 3. 创建一个密码分组为链接模式，底层使用 DES 加密的 BlockMode 接口</span></span><br><span class="line"><span class="comment">// 初始化向量，必须长度和秘钥长度相同</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"aaaabbbb"</span>)</span><br><span class="line">blockMode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line"><span class="comment">// 4. 加密连续的数据块</span></span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">blockMode.CryptBlocks(dst, src)</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 des 解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decryptoDES</span><span class="params">(src []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 创建并返回一个使用 DES 算法的 cipher.Block 接口</span></span><br><span class="line">block, err := des.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 创建一个密码分组为链接模式的，底层使用 DES 解密的 BlockMode 接口</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"aaaabbbb"</span>)</span><br><span class="line">blockMode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line"><span class="comment">// 3. 数据块解密</span></span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">blockMode.CryptBlocks(dst, src)</span><br><span class="line"><span class="comment">// 4. 去掉最后一组的填充数据</span></span><br><span class="line">newText := unPaddingText(dst)</span><br><span class="line"><span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encrypto3DES</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 创建并返回一个使用 3DES 算法的 cipher.Block 接口</span></span><br><span class="line">block, err := des.NewTripleDESCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">src = paddingText(src, block.BlockSize())</span><br><span class="line"><span class="comment">// 初始化向量，必须长度和秘钥长度相同</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"aaaabbbb"</span>)</span><br><span class="line"><span class="comment">// 2. 创建一个密码分组为链接模式的，底层使用 3DES 加密的 BlockMode 接口</span></span><br><span class="line">blockMode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">blockMode.CryptBlocks(dst, src)</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrypto3DES</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 创建并返回一个使用 3DES 算法的 cipher.Block 接口</span></span><br><span class="line">block, err := des.NewTripleDESCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化向量，必须长度和秘钥长度相同</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"aaaabbbb"</span>)</span><br><span class="line"><span class="comment">// 2. 创建一个密码分组为链接模式的，底层使用 3DES 解密的 BlockMode 接口</span></span><br><span class="line">blockMode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">blockMode.CryptBlocks(dst, src)</span><br><span class="line">newText := unPaddingText(dst)</span><br><span class="line"><span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encryptoAES</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 创建并返回一个使用 AES 算法的 cipher.Block 接口</span></span><br><span class="line">block, err := aes.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">src = paddingText(src, block.BlockSize())</span><br><span class="line"><span class="comment">// 初始化向量，必须长度和秘钥长度相同</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"aaaabbbbccccdddd"</span>)</span><br><span class="line">blockMode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">blockMode.CryptBlocks(dst, src)</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decryptoAES</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">block, err := aes.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化向量，必须长度和秘钥长度相同</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"aaaabbbbccccdddd"</span>)</span><br><span class="line">blockMode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">blockMode.CryptBlocks(dst, src)</span><br><span class="line">newText := unPaddingText(dst)</span><br><span class="line"><span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法测试类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDES</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">"我是一个不知道有多长的明文"</span>)</span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"12345678"</span>)</span><br><span class="line">str := encryptoDES(src, key)</span><br><span class="line">fmt.Println(<span class="string">"加密之后的密文："</span> + <span class="keyword">string</span>(str))</span><br><span class="line">str = decryptoDES(str, key)</span><br><span class="line">fmt.Println(<span class="string">"解密之后的明文："</span> + <span class="keyword">string</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test3DES</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">"我是一个不知道有多长的明文"</span>)</span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"12345678abcdefgh87654321"</span>)</span><br><span class="line">str := encrypto3DES(src, key)</span><br><span class="line">fmt.Println(<span class="string">"加密之后的密文："</span> + <span class="keyword">string</span>(str))</span><br><span class="line">str = decrypto3DES(str, key)</span><br><span class="line">fmt.Println(<span class="string">"解密之后的明文："</span> + <span class="keyword">string</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAES</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    src := []<span class="keyword">byte</span>(<span class="string">"我是一个不知道有多长的明文"</span>)</span><br><span class="line">    <span class="comment">// TODO 这里会报错，因为秘钥长度是 17 byte，去掉一个字符就好了</span></span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"1234abcd4321dcbaw"</span>)</span><br><span class="line">str := encryptoAES(src, key)</span><br><span class="line">fmt.Println(<span class="string">"加密之后的密文："</span> + <span class="keyword">string</span>(str))</span><br><span class="line">str = decryptoAES(str, key)</span><br><span class="line">fmt.Println(<span class="string">"解密之后的明文："</span> + <span class="keyword">string</span>(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-非对称密码"><a href="#2-非对称密码" class="headerlink" title="2. 非对称密码"></a>2. 非对称密码</h1><h2 id="2-1-相关知识"><a href="#2-1-相关知识" class="headerlink" title="2.1 相关知识"></a>2.1 相关知识</h2><p>关键在于解决了秘钥的配送问题<br>核心在于 RSA 算法以及 X509标准、Pem 格式文件</p><p>生成私钥：</p><ol><li>使用 rsa 生成私钥</li><li>通过 x509 标准序列化为 ASN.1 的 DER 编码字符串</li><li>将私钥字符串设置到 pem 格式块中</li><li>通过 pem 将设置好的数据进行编码，写入文件中</li></ol><p>生成公钥：</p><ol><li>从私钥对象取出公钥信息</li><li>通过 x509 标准将得到的 rsa 公钥序列化为字符串</li><li>将公钥字符串设置到 pem 格式块中</li><li>通过 pem 将设置好的数据进行编码，写入文件中</li></ol><h2 id="2-2-工程实现"><a href="#2-2-工程实现" class="headerlink" title="2.2 工程实现"></a>2.2 工程实现</h2><p>算法核心类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/rand"</span></span><br><span class="line"><span class="string">"crypto/rsa"</span></span><br><span class="line"><span class="string">"crypto/x509"</span></span><br><span class="line"><span class="string">"encoding/pem"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成非对称秘钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaGenKey</span><span class="params">(bits <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 使用 rsa 的 GenerateKey 方法生成私钥</span></span><br><span class="line">privateKey, err := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 通过 x509 标准将得到的 rsa 私钥序列化为 ASN.1 的 DER 编码字符串</span></span><br><span class="line">privateStream := x509.MarshalPKCS1PrivateKey(privateKey)</span><br><span class="line"><span class="comment">// 3. 将私钥字符串设置到 pem 格式块中</span></span><br><span class="line">block := pem.Block&#123;</span><br><span class="line">Type:    <span class="string">"RSA Private Key"</span>,</span><br><span class="line">Headers: <span class="literal">nil</span>,</span><br><span class="line">Bytes:   privateStream,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 通过 pem 将设置好的数据进行编码，写入文件</span></span><br><span class="line">privateFile, err := os.Create(<span class="string">"private.pem"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">err = pem.Encode(privateFile, &amp;block)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> privateFile.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 从得到的私钥对象中将公钥信息取出</span></span><br><span class="line">pubKey := privateKey.PublicKey</span><br><span class="line"><span class="comment">// 2. 通过 x509 标准将得到的 rsa 公钥序列化为字符串</span></span><br><span class="line">pubStream := x509.MarshalPKCS1PublicKey(&amp;pubKey)</span><br><span class="line"><span class="comment">// 3. 将公钥字符串设置到 pem 格式块中</span></span><br><span class="line">block = pem.Block&#123;</span><br><span class="line">Type:    <span class="string">"RSA Public key"</span>,</span><br><span class="line">Headers: <span class="literal">nil</span>,</span><br><span class="line">Bytes:   pubStream,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 通过 pem 将设置好的数据进行编码，写入文件</span></span><br><span class="line">pubFile, err := os.Create(<span class="string">"public.pem"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">err = pem.Encode(pubFile, &amp;block)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> pubFile.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSAPublicEncrypto</span><span class="params">(src []<span class="keyword">byte</span>, pathName <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 得到公钥文件中的公钥</span></span><br><span class="line">file, err := os.Open(pathName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">info, err := file.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">recevBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">file.Read(recevBuf)</span><br><span class="line"><span class="comment">// 2. 将得到的字符串解码</span></span><br><span class="line">block, _ := pem.Decode(recevBuf)</span><br><span class="line"><span class="comment">// 3. 使用 xx509 将编码之后公钥解析出来</span></span><br><span class="line">pubKey, err := x509.ParsePKCS1PublicKey(block.Bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 使用公钥加密</span></span><br><span class="line">msg, err := rsa.EncryptPKCS1v15(rand.Reader, pubKey, src)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSAPrivateDecrypt</span><span class="params">(src []<span class="keyword">byte</span>, pathName <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 打开私钥文件</span></span><br><span class="line">file, err := os.Open(pathName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 读私钥文件内容</span></span><br><span class="line">info, _ := file.Stat()</span><br><span class="line">recevBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">file.Read(recevBuf)</span><br><span class="line"><span class="comment">// 3. 将得到的字符串解码</span></span><br><span class="line">block, _ := pem.Decode(recevBuf)</span><br><span class="line"><span class="comment">// 4. 通过 x509 还原私钥数据</span></span><br><span class="line">privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">msg, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, src)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRsaGenKey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">RsaGenKey(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">"我是一个明文"</span>)</span><br><span class="line">fmt.Println(<span class="string">"加密前："</span> + <span class="keyword">string</span>(src))</span><br><span class="line">data := RSAPublicEncrypto(src, PublicKeyFile)</span><br><span class="line">fmt.Println(<span class="string">"加密后："</span> + <span class="keyword">string</span>(data))</span><br><span class="line">data = RSAPrivateDecrypt(data, PrivateKeyFile)</span><br><span class="line">fmt.Println(<span class="string">"解密后："</span> + <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-单向散列函数"><a href="#3-单向散列函数" class="headerlink" title="3. 单向散列函数"></a>3. 单向散列函数</h1><h2 id="3-1-相关知识"><a href="#3-1-相关知识" class="headerlink" title="3.1 相关知识"></a>3.1 相关知识</h2><p>根据任意长度的消息计算出固定长度的散列值的一种数学函数  </p><ol><li>能够快速计算出散列值  </li><li>消息不同散列值也不同</li><li>消息长度不影响散列值的长度</li></ol><p>常用的函数有：  </p><ol><li>MD4</li><li>MD5</li><li>SHA-1</li><li>SHA-256</li><li>SHA-512</li></ol><h2 id="3-2-工程实现"><a href="#3-2-工程实现" class="headerlink" title="3.2 工程实现"></a>3.2 工程实现</h2><p>核心类<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/md5"</span></span><br><span class="line"><span class="string">"encoding/hex"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMD5Str_1</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">res := md5.Sum(src)</span><br><span class="line">myres := hex.EncodeToString(res[:])</span><br><span class="line"><span class="keyword">return</span> myres</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMD5Str_2</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">hash := md5.New()</span><br><span class="line"><span class="comment">// io.WriteString(hash, string(src))</span></span><br><span class="line">hash.Write(src)</span><br><span class="line">res := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 散列值格式化</span></span><br><span class="line">myres := hex.EncodeToString(res)</span><br><span class="line"><span class="keyword">return</span> myres</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetMD5Str_1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">str := GetMD5Str_1([]<span class="keyword">byte</span>(<span class="string">"我是一个明文"</span>))</span><br><span class="line"><span class="comment">// e8e0915549a588dca746a1db55c75b35</span></span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetMD5Str_2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">str := GetMD5Str_2([]<span class="keyword">byte</span>(<span class="string">"我是一个明文"</span>))</span><br><span class="line"><span class="comment">// e8e0915549a588dca746a1db55c75b35</span></span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-消息认证码"><a href="#4-消息认证码" class="headerlink" title="4. 消息认证码"></a>4. 消息认证码</h1><h2 id="4-1-相关知识"><a href="#4-1-相关知识" class="headerlink" title="4.1 相关知识"></a>4.1 相关知识</h2><p>全称：message authentication code，简称 MAC  </p><p>它主要是为了解决消息的完整性，即消息在过程中是否被篡改<br>算法过程：基于<strong>秘钥</strong>和<strong>消息摘要（使用单向散列函数）</strong>获得的一个值</p><p>A 发送给 B 消息，B 解码之后发现是乱码，但是不确定是不是 B 发错了还是说 B 本来发的就是乱码，即消息接收的是否是完整的，即消息没有被篡改，消息被改变，但是依然可以解出数据，但是不知道数据是否可靠</p><p>为什么出现消息认证码：  </p><ol><li>验证数据是否被篡改</li><li>验证数据是否完整</li></ol><p>使用场景：<br>IPSec：IP 协议的增强版</p><p>类型：<br>HMAC：使用 hash 算法实现的消息认证码</p><p>消息认证码存在的问题：  </p><ol><li>对第三方证明：A 向 B 发送消息，B 想要向 C 证明这条消息的确是 A 发送的，但是消息认证码无法证明：因为有可能这条消息是 B 自己发的，诬陷 A（这是由于秘钥的对称，A 和 B 都有相同的秘钥，导致的）</li><li>防止否认：A 就算向 B 发送了消息，但只有 B 知道，B 无法跟别人证明这真是 A 发送的而不是 B 自己捏造的，因为 A 可以不承认，并且说：这是 B 发的，跟我无关。即无法防止发送方否认</li><li>无法有效的配送秘钥：因为要保证 A B 都是相同的秘钥</li></ol><h2 id="4-2-工程实现"><a href="#4-2-工程实现" class="headerlink" title="4.2 工程实现"></a>4.2 工程实现</h2><p>核心类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/hmac"</span></span><br><span class="line"><span class="string">"crypto/sha256"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHMAC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">hasher := hmac.New(sha256.New, key)</span><br><span class="line"></span><br><span class="line">mac := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span> mac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyHMAC</span><span class="params">(src, key, mac1 []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">mac2 := GenerateHMAC(src, key)</span><br><span class="line"><span class="keyword">return</span> hmac.Equal(mac1, mac2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGenerateHMAC</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">"我是一个明文的hash值"</span>)</span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"12345678"</span>)</span><br><span class="line">mac1 := GenerateHMAC(src, key)</span><br><span class="line">fmt.Printf(<span class="string">"mac1: %x\n"</span>, mac1)</span><br><span class="line">isEqual := VerifyHMAC(src, key, mac1)</span><br><span class="line">fmt.Println(isEqual)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-数字签名"><a href="#5-数字签名" class="headerlink" title="5. 数字签名"></a>5. 数字签名</h1><h2 id="5-1-相关知识"><a href="#5-1-相关知识" class="headerlink" title="5.1 相关知识"></a>5.1 相关知识</h2><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-08-27%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg" alt></p><p>解决消息认证码的问题：</p><ol><li>无法有效的配送密码-&gt;不需要配送（使用非对称加密）</li><li>无法进行第三方证明-&gt;只要持有公钥，就可以帮助认证</li><li>无法防止发送方否认-&gt;私钥只有发送方持有</li></ol><p>算法过程，为了方便理解，这里将 A 直接指为明文，实际中 A 应该为加密后的密文：</p><ol><li>发送方：根据原文 A 使用摘要算法得到 H1，对 H1 使用私钥进行签名（可以理解为加密）H1 + privateKey = S，将 S 和 A 发送</li><li>接收方：接收到 A 后，使用相同的摘要算法得到 H2。接收到 S 后，使用公钥验签（可以理解为解密）S + privateKey = H1。最后对比 H1 和接收到 H2，是否一致，来完成验签</li></ol><h2 id="5-2-工程实现"><a href="#5-2-工程实现" class="headerlink" title="5.2 工程实现"></a>5.2 工程实现</h2><p>核心类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto"</span></span><br><span class="line"><span class="string">"crypto/rand"</span></span><br><span class="line"><span class="string">"crypto/rsa"</span></span><br><span class="line"><span class="string">"crypto/sha256"</span></span><br><span class="line"><span class="string">"crypto/x509"</span></span><br><span class="line"><span class="string">"encoding/pem"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私钥签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaSignData</span><span class="params">(filename <span class="keyword">string</span>, src []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">info, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block, _ := pem.Decode(info)</span><br><span class="line">derText := block.Bytes</span><br><span class="line">privateKey, err := x509.ParsePKCS1PrivateKey(derText)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 获取原文的 hash 值</span></span><br><span class="line">hash := sha256.Sum256(src)</span><br><span class="line"><span class="comment">// 2. 对原文 hash 值使用私钥进行签名</span></span><br><span class="line">signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> signature</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥认证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaVerifySignature</span><span class="params">(sign []<span class="keyword">byte</span>, src []<span class="keyword">byte</span>, filename <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">info, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">block, _ := pem.Decode(info)</span><br><span class="line">derText := block.Bytes</span><br><span class="line">publicKey, err := x509.ParsePKCS1PublicKey(derText)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 获取原文的 hash 值</span></span><br><span class="line">hash := sha256.Sum256(src)</span><br><span class="line"><span class="comment">// 2. 公钥解密签名</span></span><br><span class="line">err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], sign)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私钥签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRsaSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">"我是一个明文哦"</span>)</span><br><span class="line">signature := RsaSignData(PrivateKeyFile, src)</span><br><span class="line">fmt.Println(<span class="string">"密文："</span> + <span class="keyword">string</span>(signature))</span><br><span class="line">isVerify := RsaVerifySignature(signature, src, PublicKeyFile)</span><br><span class="line"><span class="keyword">if</span> isVerify &#123;</span><br><span class="line">fmt.Println(<span class="string">"验证成功"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"验证失败"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> 其它爱好 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/33周总结</title>
      <link href="/2019/08/18/2019/33.html/"/>
      <url>/2019/08/18/2019/33.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/32周总结</title>
      <link href="/2019/08/11/2019/32.html/"/>
      <url>/2019/08/11/2019/32.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nacos源码2_服务与实例注册源码</title>
      <link href="/2019/08/10/tech/nacos1_service_instance_1.html/"/>
      <url>/2019/08/10/tech/nacos1_service_instance_1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-启动调试-console"><a href="#0-启动调试-console" class="headerlink" title="0. 启动调试 console"></a>0. 启动调试 console</h1><ol><li>加入 VM option：<code>-Dnacos.standalone=true-Dnacos.functionMode=naming</code> </li><li>启动 console 项目，查看 banner<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/Nacos1_naming_1.png" alt></li></ol><h1 id="1-service-与-instance-的逻辑关系"><a href="#1-service-与-instance-的逻辑关系" class="headerlink" title="1. service 与 instance 的逻辑关系"></a>1. service 与 instance 的逻辑关系</h1><p>每个服务可以有多个实例，每个实例又区分为两种实例，一种为临时实例，一种是非临时实例，它们的关系在 ServiceManager 中保存，具体的 service、instance、cluster 类都在 <code>com.alibaba.nacos.api.naming.pojo</code> 包下，对外的接口主要是 service、instance 的 CRUD 操作。其中有个 cluster 的逻辑结构，属于 service 和 instanc 之间，对应的是某个 service 有多少个 instance，就有多少个 cluster</p><h1 id="2-service-的操作"><a href="#2-service-的操作" class="headerlink" title="2. service 的操作"></a>2. service 的操作</h1><p>nacos 本身支持两种协议，一种是 Raft 一种是 Distro<br>而 service 创建操作使用了 Raft 协议 </p><h2 id="2-1-请求的是-Leader-节点时"><a href="#2-1-请求的是-Leader-节点时" class="headerlink" title="2.1 请求的是 Leader 节点时"></a>2.1 请求的是 Leader 节点时</h2><p>先在本节点发布 service change 事件，接着通过 http 发送到其它节点，同步该服务创建操作，如果这个请求超过 5s，就认为该操作失败。里面使用了代理类 consistencyDelegate，除了临时节点，其它类型的一致性操作统一走 Raft 协议，最终会到 RaftCore.signalPublish() 方法，遍历其它注册中心节点，POST 请求 /v1/ns/raft/datum/commit 接口，该接口主要做了如下判断：对比请求节点的 term 是否比自己大，如果请求节点的 term 大于等于自己节点的 term ，就执行该任务，将服务信息同步到本节点</p><h2 id="2-2-请求的是非-Leader-节点时"><a href="#2-2-请求的是非-Leader-节点时" class="headerlink" title="2.2 请求的是非 Leader 节点时"></a>2.2 请求的是非 Leader 节点时</h2><p>如果当前节点是非 leader，直接得到 leader 节点的 url，并请求 /v1/ns/raft/datum/ 接口，将 service 创建事件给 leader 处理。注意，本节点的 term 是没有变的，这种情况下 leader 接收到请求后 term 会增加，并同步到其它节点，其它节点判断 leader 的 term 和自己等于或大于时就执行该操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalPublish</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 注释：步骤1 如果当前不是 leader，直接将该请求给 leader</span></span><br><span class="line">        <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">            JSONObject params = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            params.put(<span class="string">"key"</span>, key);</span><br><span class="line">            params.put(<span class="string">"value"</span>, value);</span><br><span class="line">            Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            parameters.put(<span class="string">"key"</span>, key);</span><br><span class="line"></span><br><span class="line">            raftProxy.proxyPostLarge(getLeader().ip, API_PUB, params.toJSONString(), parameters);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OPERATE_LOCK.lock();</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> Datum datum = <span class="keyword">new</span> Datum();</span><br><span class="line">            datum.key = key;</span><br><span class="line">            datum.value = value;</span><br><span class="line">            <span class="keyword">if</span> (getDatum(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                datum.timestamp.set(<span class="number">1L</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                datum.timestamp.set(getDatum(key).timestamp.incrementAndGet());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            json.put(<span class="string">"datum"</span>, datum);</span><br><span class="line">            json.put(<span class="string">"source"</span>, peers.local());</span><br><span class="line">            <span class="comment">// 注释：本节点发布 service 发布事件</span></span><br><span class="line">            onPublish(datum, peers.local());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String content = JSON.toJSONString(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(peers.majorityCount());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> String server : peers.allServersIncludeMyself()) &#123;</span><br><span class="line">                <span class="comment">// 注释：这里应该是避免特殊情况：步骤1 之前正在选举 leader，在这里之间选举出了 leader</span></span><br><span class="line">                <span class="keyword">if</span> (isLeader(server)) &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> String url = buildURL(server, API_ON_PUB);</span><br><span class="line">                HttpClient.asyncHttpPostLarge(url, Arrays.asList(<span class="string">"key="</span> + key), content, <span class="keyword">new</span> AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">onCompleted</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                            Loggers.RAFT.warn(<span class="string">"[RAFT] failed to publish data to peer, datumId=&#123;&#125;, peer=&#123;&#125;, http code=&#123;&#125;"</span>,</span><br><span class="line">                                datum.key, server, response.getStatusCode());</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> STATE <span class="title">onContentWriteCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> STATE.CONTINUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="comment">// 注释：超时 5s 就算失败，但是其实本节点已经执行了 service 创建事件</span></span><br><span class="line">            <span class="keyword">if</span> (!latch.await(UtilsAndCommons.RAFT_PUBLISH_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="comment">// only majority servers return success can we consider this update success</span></span><br><span class="line">                Loggers.RAFT.error(<span class="string">"data publish failed, caused failed to notify majority, key=&#123;&#125;"</span>, key);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"data publish failed, caused failed to notify majority, key="</span> + key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            Loggers.RAFT.info(<span class="string">"signalPublish cost &#123;&#125; ms, key: &#123;&#125;"</span>, (end - start), key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            OPERATE_LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-instance-的操作"><a href="#3-instance-的操作" class="headerlink" title="3. instance 的操作"></a>3. instance 的操作</h1><p>instance 增加时，如果没有对应的 service，会默认创建该 service，如果已经有了 service ，会直接塞入到该 service 的 instanceList 中，具体细节在 ServiceManager 中进行操作。<br>接着判断增加的 instance 是否临时来使用不同的一致性协议，如果为临时实例，使用 distro 协议，如果非临时实例，使用 raft 协议。distro 协议大致为定时任务广播其它节点+保存内存，其中广播的接口为 /distro/dump。</p><blockquote><p>distro 协议为自制协议，AP</p></blockquote><h1 id="4-代码地址"><a href="#4-代码地址" class="headerlink" title="4. 代码地址"></a>4. 代码地址</h1><p><a href="https://github.com/LiWenGu/nacos.git" target="_blank" rel="noopener">https://github.com/LiWenGu/nacos.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nacos源码3_服务与实例注册源码</title>
      <link href="/2019/08/10/tech/nacos1_service_instance_1.html/"/>
      <url>/2019/08/10/tech/nacos1_service_instance_1.html/</url>
      
        <content type="html"><![CDATA[<p>心跳和选举主要依靠容器启动时的两个定时任务，分别为 HeartBeat 和 MasterElection 两个。这两个定时任务，每 0.5s 执行一次。<br>当一段时间内（15~20s）没有接受到心跳，就会执行 MasterElection 里面的选举请求逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释：master 选举</span></span><br><span class="line">GlobalExecutor.registerMasterElection(<span class="keyword">new</span> MasterElection());</span><br><span class="line"><span class="comment">// 注释：节点间心跳</span></span><br><span class="line">GlobalExecutor.registerHeartbeat(<span class="keyword">new</span> HeartBeat());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterElection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!peers.isReady()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RaftPeer local = peers.local();</span><br><span class="line">            <span class="comment">// 注释：每次递减0.5s，直到小于0.5s，初始是15~20s的范围，这个任务0.5s执行一次，说明选举在没心跳最坏的情况</span></span><br><span class="line">            <span class="comment">// 是15~20s进行一次选举，即发投票。但是心跳任务每次都会重置这个 leaderDueMs 为 15s</span></span><br><span class="line">            local.leaderDueMs -= GlobalExecutor.TICK_PERIOD_MS;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (local.leaderDueMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reset timeout</span></span><br><span class="line">            <span class="comment">// 注释：重置选举时间间隔</span></span><br><span class="line">            local.resetLeaderDue();</span><br><span class="line">            <span class="comment">// 注释：重置心跳时间间隔为5s</span></span><br><span class="line">            local.resetHeartbeatDue();</span><br><span class="line"></span><br><span class="line">            sendVote();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.RAFT.warn(<span class="string">"[RAFT] error while master election &#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeat</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!peers.isReady()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RaftPeer local = peers.local();</span><br><span class="line">            <span class="comment">// 注释：5s以上发一次心跳（初始随机0~5s）</span></span><br><span class="line">            local.heartbeatDueMs -= GlobalExecutor.TICK_PERIOD_MS;</span><br><span class="line">            <span class="keyword">if</span> (local.heartbeatDueMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注释：重置心跳间隔</span></span><br><span class="line">            local.resetHeartbeatDue();</span><br><span class="line">            <span class="comment">// 注释：发送心跳，里面重置了 leaderDueMs 时间，即当心跳一直正常时，不会发起master选举</span></span><br><span class="line">            sendBeat();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.RAFT.warn(<span class="string">"[RAFT] error while sending beat &#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考了更加细节的文章：<br>文章一：心跳的源码细节：<a href="https://www.jianshu.com/p/b0cdaa64688e" target="_blank" rel="noopener">https://www.jianshu.com/p/b0cdaa64688e</a><br>文章二：选举的源码细节：<a href="https://www.jianshu.com/p/5a2d965174ae" target="_blank" rel="noopener">https://www.jianshu.com/p/5a2d965174ae</a>  </p><p>代码地址：<a href="https://github.com/LiWenGu/nacos.git" target="_blank" rel="noopener">https://github.com/LiWenGu/nacos.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nacos源码1_配置管理源码</title>
      <link href="/2019/08/03/tech/nacos1_config1.html/"/>
      <url>/2019/08/03/tech/nacos1_config1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本地编译"><a href="#1-本地编译" class="headerlink" title="1. 本地编译"></a>1. 本地编译</h1><ol><li>fork 源地址：<a href="https://github.com/alibaba/nacos.git" target="_blank" rel="noopener">https://github.com/alibaba/nacos.git</a></li><li>git clone 自己 fork 版本</li><li>现在基于 1.1.3 版本，nacos 项目基于标签做的版本发布，因此直接 git checkout 1.1.3 然后再基于此新建一个分支，用于源码的修改等</li><li>在根目录下运行：mvn clean -Dmaven.test.skip=true，下载相关依赖包，检查环境</li><li><p>运行 console 项目主类，加上 VM options：-Dnacos.standalone=true<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Nacos/536C41DF-52DF-4692-802E-AC3D537A434B.png" alt></p></li><li><p>我们可以在控制台查看 banner 的相关运行信息</p></li></ol><h1 id="2-修改字符分隔符方便调试"><a href="#2-修改字符分隔符方便调试" class="headerlink" title="2. 修改字符分隔符方便调试"></a>2. 修改字符分隔符方便调试</h1><p>因为报文，使用了特殊的字符，不方便 http 测试请求，因此修改 com.alibaba.nacos.config.server.utils 包下的 MD5Util 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORD_SEPARATOR_CHAR = <span class="string">'~'</span></span><br><span class="line">LINE_SEPARATOR_CHAR = <span class="string">'*'</span></span><br></pre></td></tr></table></figure></p><h1 id="3-发布订阅者模式"><a href="#3-发布订阅者模式" class="headerlink" title="3. 发布订阅者模式"></a>3. 发布订阅者模式</h1><p>配置管理的实现，使用了大量的 ScheduledExecutorService 以及事件发布订阅者模式</p><ol><li>事件分发器/发布者：com.alibaba.nacos.config.server.utils.event.EventDispatcher</li><li>两个监听者：<br>AsyncNotifyService 监听 ConfigDataChangeEvent 事件，当配置做更新操作时，进行同步并异步做 http 请求到其它的健康节点<br>LongPollingService 监听 LocalDataChangeEvent 事件，当配置做更新操作时，一是更新 CacheItem（内存级），二是对当前监听的客户端们做响应</li><li>两种事件：<br>ConfigDataChangeEvent：需要节点间同步配置改动的事件<br>LocalDataChangeEvent：本节点配置改动的事件</li></ol><h1 id="4-数据库访问数据"><a href="#4-数据库访问数据" class="headerlink" title="4. 数据库访问数据"></a>4. 数据库访问数据</h1><p>单机版使用 derby 嵌入式数据库，只能由一个进程访问，查看数据需要停止 Nacos 进程才行，稍微麻烦点，不过 idea 支持 derby 数据查看，会方便点：  </p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Nacos/6015F579-FDC6-490D-9D0E-858D9BC2B827.png" alt></p><p>数据库的具体信息，从 LocalDataSourceServiceImpl 可以查看，包括数据存放地址等，这是可以通过全局配置来设置的</p><p>url：/Users/{user.home}/nacos/data/derby-data<br>username：nacos<br>password：空  </p><p>后台 console 的账号和密码根据配置文件可以查看：console/src/main/resources/META-INF/schema.sql，如果想修改，因为还有一个 Role 表，需要改动 role 和 user 表</p><h1 id="5-配置接口"><a href="#5-配置接口" class="headerlink" title="5. 配置接口"></a>5. 配置接口</h1><h2 id="5-1-配置的监听"><a href="#5-1-配置的监听" class="headerlink" title="5.1 配置的监听"></a>5.1 配置的监听</h2><p>客户端监听注册中心的配置，其实本质是根据 groupKey（AppId+groupId+namespace）获取对应的 md5，即配置内容的 md5 进行对比是否有更新。默认等待 30s，即是否在 30s 内有改动。</p><p>配置的改动监听有三种场景：A 表示客户端，B表示注册中心  </p><ol><li>A-&gt;B，其实A的配置很老了，B的配置是最新的，B的监听接口会先根据本节点的 CacheItem 内存的值进行匹配，如果匹配失败，说明A 的值是旧的，会立刻返回给 A groupKey（不是md5或内容），让A去查询最新的配置值（多此一举么~）</li><li>A-&gt;B，其实A的配置就是最新的，B的配置和A的配置一样，那么 A 请求阻塞 30s（默认Long-Pulling-Timeout配置），B的监听接口使用 Servlet 3.0 异步进行 10s 一次的循环，来根据 groupKey 拿配置的md5，进行对比是否改动，如果改动则返回，不改动理论上会等待30s。</li><li>A-&gt;B，属于情况2的变种，就是，在情况2等待30s过程中，B2配置改变了，那么会根据事件分发以及 http 内部节点之间请求，B2会通知B，B最后来通知A，此时A会立刻返回</li></ol><h2 id="5-2-配置的修改"><a href="#5-2-配置的修改" class="headerlink" title="5.2 配置的修改"></a>5.2 配置的修改</h2><p>post/put/update/delete 等情况，这里有两个要注意，一是自己节点的内存更新，和其它节点的通知更新</p><ol><li>自己节点：先存数据库 derby，然后做事件 ConfigDataChangeEvent 的发送，而这个事件会被 AsyncNotifyService 监听到，这个 AsyncNotifyService 会根据节点的健康情况发送给其它的对等节点（B1,B2,B3），这个是通过内部接口 communication 来发送请求的  </li><li>其它节点：得到http请求后，这个communication接口做了两件事，一是 dump：即根据是否是集群模式，如果是集群模式来将配置信息写入到硬盘（TODO：为什么硬盘？不写MYSQL吗？），二是 TaskMgr 0.1s 死轮询关键任务，这个关键任务就包括的事件改动的通知，这个任务内部做了 CacheItem 刷本节点的内存最新值，二是发布 LocalDataChangeEvent 事件给 LongPollingService 监听，其中 LongPollingService 内部会做 DataChangeTask 的任务来让响应 ClientLongPolling.sendResponse() 方法，从而让监听者即时返回  asyncContext.complete()<br>修改会有点绕，因为里面的发布订阅和定时任务太多了</li></ol><h2 id="5-3-配置的删除"><a href="#5-3-配置的删除" class="headerlink" title="5.3 配置的删除"></a>5.3 配置的删除</h2><ol><li>数据库物理删除 </li><li>发布 ConfigDataChangeEvent 事件</li></ol><h2 id="5-4-配置的获取"><a href="#5-4-配置的获取" class="headerlink" title="5.4 配置的获取"></a>5.4 配置的获取</h2><ol><li>直接获取本节点的 CacheItem 值，这个是 concurrenthashmap 类型，存储在内存中</li></ol><h2 id="5-5-配置的整体流程"><a href="#5-5-配置的整体流程" class="headerlink" title="5.5 配置的整体流程"></a>5.5 配置的整体流程</h2><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/Nacos%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt><br><a href="https://github.com/LiWenGu/nacos.git" target="_blank" rel="noopener">https://github.com/LiWenGu/nacos.git</a><br><a href="https://www.processon.com/view/link/5d441f3fe4b0bc1bbedcf559" target="_blank" rel="noopener">https://www.processon.com/view/link/5d441f3fe4b0bc1bbedcf559</a></p><h1 id="6-代码地址"><a href="#6-代码地址" class="headerlink" title="6. 代码地址"></a>6. 代码地址</h1><p><a href="https://github.com/LiWenGu/nacos.git" target="_blank" rel="noopener">https://github.com/LiWenGu/nacos.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/31周总结</title>
      <link href="/2019/08/03/2019/31.html/"/>
      <url>/2019/08/03/2019/31.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/30周总结</title>
      <link href="/2019/07/28/2019/30.html/"/>
      <url>/2019/07/28/2019/30.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+RmPKumJDP/f7BiDNE0Tn/fpVqRDxzx8yZUXftoSy+AlgoGA1aP+Oo4Z8ZpD8vksLBQUvE8FasUDnzNN3QrvcPGcOc6SSwbz1of//iPqRsZRJehp68znS36o25nECkhKRBLkW4Cr1E60HhSiRFoUzZ71Bznx6Vhj9pCF0XVhUoNW6lXwzIhV5ayY+IJwUc3ojwEZF0T7hyBZ7FbWLl1vfmmFl7cuDBavR+9UEg/3a1QSvLmaE6xmQbsdIvQ8wCHWJPkkmb96aGeFjNnOmiWOSoHyjfmrDmZH9wfNWH1Ngxbvu1ioxYlLZW1zvkA5o90yQyARfYQdJUlYR0M0y1dycGSu76Wd7cENq8R1Su9qoKbLXhC6fRPmCpzbPKtVG12GwLp48S5QvGNXlhsy3LPIkWfiAAyVuuXHWuqMCHwFgG0utd1XLhTTDlOeChz6qoNZDJzbkgci32zXL9v6Kj/Oh7+OF7iqm/Rw4ODtIVGB7YoRaMKY8XrSK3k3uh5m2yT2aK84VtTYKz1Xfig0WgUFDi8/DflH8tZgLuuYfAPDvabSFNjQqd2hNfMMYMhsUDcOSxqd5nuIU1aBcDb783PFxJMS5py36i19kFOXSgLfyNc1m/y0DdObfqEoEJQ/QZmh03nLIBq+qPd6E15nEGo0NLuNP1OQXYImgescGOh5KMCXFkm5GdXV9zl43PEwsEth7vgagjcPOqtln2n7tpE8n9BdAA3jNsPqOLf+mO77865wTXXuJ4q74eECVEuCSZMY/TVMQ989lvg4yM7dW0pokgLVhj+wewij+gNWz5Bz+ozH6TUs1AixHHqdY2Qz7Ogr5gTaR4ldE7d59DwpjD2vPFvqvMs4xYtMXRiJcUYeN2oCJBgZ/SJWK1ZwPKD53pnPbdTNZn3GVu1Ci5Nu4D+9VYEkuMHr/EjNlyWNW42ITGk09gnkOBoaPM4WHowB7bO8O9HdOIq1d5ex+TCGJPDXDYwOHOvBYWeA4WPjqxCMRP/JXhcVO301zqFAs0bqCin/4U42pp9/5gxv6SDq6W5ytHYbmUiT7J4Hd9uHzaHHPtbVsiFsgw7OChKu6rFdCUBMITCFwLqTZRGKbH9EPmqEhgv5EFbw9Lmc0wPmO+N9WrdAi1EoEHAzNvJat07lvZnKBI2SXXO5THvKDpceqcY2LPIFTOH2blu0VPDIy/Qul72/YYzsgQIa2xGEoeqIw5wxlXyLvRepaCqlieu6rJQD254yOdY/QKUXdjiE7KMcFBI3A9rYNh+6bfmPpFDnGkf+hsHSbVHZI86UWnbHKm62c0iOjP++udY1LVZ1jm6tKHjNKev6b4kwrMSlpJUmvbDP9+7LpVMcbPCYs0L+zxpc2hPZWnaA9AGsWeC1xFsBRZS7gqWio4LCoQkI31aeue/3CQYkITpYujEmTTbcYH+xe6y4WeaBnXIOMQmkBI9INrWaeTkgnU2h9ryepUSkwtniqgRyBUSYZQnvKcu8aNMGZyBTz/sTVOWaLqk6adDHBjk2q1Q4FehsfsUPZ32yQ9tFeZ/LoVZaQuGG5FSisZ5q3MmJ3teQ/hOwPSQrsjYcrLV7pXhECn6I7Jgb9D7IHx3YdFOImlXWNBZHp96446G3vF9Q/CWPskIarYcHQY1l77iQto+REn8D1BF7DF4njfSMVPnzBsLIajqcygF4djTZhZ8qVuokb5AVcIWmPnJhCB7dOklR4g6E8sAFp2bzzSN96jZo7kAwxIPZXcwTzULSMHlbPtiapRp5YjRn2QwmZ+r/iHtpOM/R6K73n/Og8KCRiO2TOMXr6gwCrZQZ7grbVqw5L/IL48r/6gqSK+mNw4OzwqIOrsKEYkv6Cj2fSFV6ciVLW9D1vBn36cIaYOxtpTJE2K0yNSIe10RuN1gLfuw5nNJp2XEK0kf+bipaYkj1nZJV+T68DnCShRYbZO3rOpoFH9OOX6Oj8W+s152zDVgGP7MrXbfYHjvPcZS7Z1qVCPq2u5bGW5pfoqHCDOKYKDm6Rc22GTIOxl0K6b5g6429tSuKLBDydUGUyTNuhAYtqLD7+vwaKYRYf6mPLzHwH/GJVsXkrxsb+RYkW3Y8CmgzSA1+f59zfoRzf6AM0uPAnFxewJneuPC1A5Ph30iDH968JcVW70JOTEnp+cHBx5WD+1VLueyZE+qKnpkEdDIcK6pyX7L9P0P27337LpsGKw3AgPSafi+0sB5t9Z8uzKiTWa6IUx7EN2CyN1ohe2sHmtPav/NWNlHXgqRvPv2msw0lQKou+wVQvAavdr/9j9fgShijgGoxGexZ00fshUPn+dn6BmxnxwSiSKg4aU5dn56Rex+hbJDrDl9PAenQDImH0nRwd6S9ZvYG0e4Vap8Hfxym3xvQW8vkdIL3sUoTxfzyu3iMLBRnJiJCA7irZSnS73O8rYD63F/NLkh5+3t9NXCVViQkcm92fts4Yt9FBz8L2NUmVwtJpob2p5s4+T42Rv4wRhGMt30lcbYhg+Sq3lPwqwOZevU59rSFgWDLL0rhfLthcO7GCmPdp6dwxeu0Gh5SMnhhtf+PiIcgrwq79NaWPG6PSlyScR1FLFv7eOOLZjXJ/UVMost/JEUmBXdWczw8NgbYajnHcGNJyRrl/AdNZ7S9ui9kvijxoAKXxfhaJrDop4r2rf12XjsgrlaZc9nYsl4sMSTePgXnJGH+tC1gyTWb2h/20d6wKoGPxc27ONrNPDTUPRVgFbrMv9Uavd+T7/Bi4QDsC6wy0OLAl/f2eHiIjZuIQEEFO6VrgPavOQtsDYGSWzi5GnYUa4UcTD/PwEG9opM1EvWy8P7KVCF5FRX6e+uiz2liJTnqxZVffjKUn2NCmUSxI4yS6v3PzIoSBifGALygFwK2/ogMGj2L8GRb+EHMz1XN0VljQtSGhrS4ksuJl+D4uumzaX8pBpV/JUSJgiq4tD2bgMkOa/cTnORxmnDj05L3wS7zgiETo58TbCqLLojXkrp0oahAKAL9IruWYeXGBAomr/9n7VD6MIRAHTTY9gtTx9L63cj+Ak+EYgMUm4p/0eRRqUSlCGN9V0AWpVcNfckNSfHp2cukjczGvZESDFqhFLr80Ftx812/OqjKIzHJZkBMHUoK1JuMwjypI8Nyov2Nf06JV0Z8nl9xWAZXQJw036Jhd7aNF3hoFjVKxSpJrkqctU786bRYk2CX/tVk8BYnJ6Ptb3b+S5IsnBWTm69HzUoY2oHmaCWYTZpKJpE4/Y3/aAc+IOIqHB3mWy38+T77YsGpZDdvuroHLGH8gEy8btIC8Fa1A0uFQoxaHth1UX3jx08sUowv+wiWsjULPbS7dVtp6R6w7IZWnydRnLzRHmejTGs3Fg9d4LNAY8PazFplAmHVu0aaMYnrRqEO4h6XMy+qXChE83cUHG1Ob30z5UUtZoOBdXN8mHwrDdAm9YHq+2u+gnSkF3qKNoPXrqV9HR1kcpAikS98GTC7W0UxyZJ1tCPXUmWXsk+SfJ7Wpjrp5dj06lx9e09hPVFcIq5hSZ7o/b3ZYTCzpTK0Y5WsJzLfJxwWfQ/fAl5huXrsSY/+z81zV6H3gaAPIGyvT3CiHng0uXwYXC3W/gdymeQsr/Eqc+HIdXlXGMPH5JjPHN/1nFnbeV7uH34CnWpjGxfrgYbsDzrZb0F6ZPoz1bYXW13bz/zjQM0sOXOxFNYa6a5Vg341pJWDUKemwTPI06t9iXwiJEoH2kedt/GzS4inRIEG93L5hS/3Hc2xJMzVyBwdGO6b5LpakhlVt19LTtLcBCPwbKw7rLzKAvg2fe6LZr31CMwUR53zBGmqtbNBF8kGNv5Cfg3DGcubYdqTywJfaoa0n2TvobC8vM36xJEaJbB1ibl2kZdHq5LyDNX0A5XjBuw5QACbuljvCIRpGK1MAH4A5xuoyUg4BhjbD3IfKZPsKzs+F66Jo5UmAY8UB8kf1EwiEwgZXwIw/C6bv5DrvO4nCYXJ9oJIXZA7hyM9o1j/BJezx9XBRYjXhtp/0afJ0Xv4lEFIOezR56u1WYFC+w/gJcFBDlWl7zx5wRalhtIxczm2pl29Yr4aGx9P+qqCWcgybFu64Ti8AMYeZm/7FGPjWDXsjAWbGK5xIIeW+QFe7WbmXW0ArtuP/sYVuj8SLP5dNTbOFB6UDVCcZflJRE8ZA3A304tGn3vK7Yfvd3LPSLwaVCqq+6kI6sinK9L7lS5f0Vt+kt5NouHJbVGQg9Sw7QwkjKddwqJru11Vn6Vfh1H6EHybtloDjs0cEAOc0qsDPhZx1gihoVeja5SFAZCeB1Rs71qYYujgaIb5FrH1aKq/p2DwIziR89jxJfmnyJ28v/dtnD/CQdzKXbqZHa1qL8cMmVJpigqPoDNYKipMHosb02FbX+TzH+xnbI/veYhzKTf2jM/lduLDmmT523XHND76ht2J4rc6mO+/hKoH0IiySn+zF1BTwhI0plTtd9jZCNQ/nC7Z8URea5bhI6VjPFRWDS5/1apEGjx8jNR9o4/GYDDP6c6QIeVcNhKr8BYwKBkzZf9UP92T1ZkU7/KvFyt4RVILpnj8jf1YiH6Ex8oaiKMDj16YGrIVpQ/LutS1nn7bM3HiuBo2kQt20GGaPynrzpu6okSwVPTC3V95MgXp6fYMtwcOK3FfGvX+WG/+x9/bcbQkwIiTSyrPs2rWN+8Juc1KaplmwpTNxF57deXlzNejDr64V30+Vm1XUJyvLzD1yx0YAIwwgPis2IO3K8sIal96Ti0J/ZKLDHxng5b7awcI3zyNo/dZjotF04iWZgcWV6GJnVp+Zg9+8BfdhvM+YO5aj5EyX6f9dCSHVCfNssqTt/olRRo5M/Zw3kKPzlhNyHICiP269KFAZM6Bd7wPhLtlZKOumuBszeCRTjivQJa6OTeT4fY+letVgYR+2SPJ6IbedVGcOeTcm6u5WhJ/lmKUKl0UxLlctXqi7M4egRnikepRZhnhf5KCkN9S/kZiqBZtnr/pzHguzbOrjUIOGnfB7/p6RdPHJJfxC7cs/XIfI5HwTxBzmHXoN99Qw1sSFqs74Pv1s68CYcvZnDkzFy+oqdAUEKseU2LKnJUuaI3m9vjLN8EzDKXYi7ohXrtpi9GUSeXsFofHKqzzQz2681DKl629553W/G/9qU3br8bdn9+f5/CjidaSX63xF2GJ7G5dA91gROxC6y2HBvItfH8VX5AVFCd6y2tFlma2KzpNLnT4TfYmXvh1sUYgILZokJ0OxiDwIHdHC+GO5UESmhndCvW7KtSh4f2v60f+QYe2CMOwxnoBzL4qDfRB6Me9WUuNznhdzQ4fB7KrnbTKmv3Bxhvc37RR1BNxfAHOjUXYmLsREZuWFakDN5kWN7fKVI2hE7QO8T8GPn8j8q+jDMK38O6jbajvchRK3R7XiktVCVK3pMxXNe+BTF59Kt8Kccp/9Dt4KIPd1s87cWoFHS6tYuERKnMDuFgxZh3HdV5cVpQ8Ulv9MDSUVbLwUtLkg0ho+pY2hsUcAsQnlrO5uJ5uPY3gVvFA+lDWQ3DZ6IW8rbq6jf2aoaIdDyFaNUvXWOoFt/34CarjQ+II3oJTEuLKbpYLLdfGHY6z7WtqNNrBYqTrPIZ16Pyhp7pOIivmUodw2SWLlUBWACURfSmGf2Ad/eteUVgOQO9JBdHQgUROnE3/pr1Z/dpnCA2nlkTFAQ8J8jgXMH3CIqOH5LiE82oOXaZAjFLQU5ga5vzDolGZMkYuoA0P88S+u0j/VFb9QS3TT77eSGX/x3lXKAEjQ77d/lig+Ix3IEz9WrVzPGhtB48tWzreGJDil6po5WOo3+sGLQoz9ij2A/rPERVgWeU3zghAmB7M62AC3punov3iCmIuiYJiaYyMFvijMkfZFSgoW9kd9tB3XxtFHDKJv2sXLkA275bTWkqSC19dvY4mlu54Cm0Fbm/FzOC02OWUMV9Q7gVfzWAi70LwyqB2oiTndg2sXQZY0X0inYpbEOybXkje5GSVvi3svJ4XTpccvU2MYcaC3poKrtnvAdt7zMd9Bwy93fQVsYcLY+5yPdkJHF+/vETtw1HCGyss5M4qzOoZPmrUCJTgtGYcbMwJHT1QyaTECJK6b001sMgTqwvko2uMPRiiwV3E1AkmdLXBKuf6Doxjvx+M4QYWjrjSSsA/YyZgQ/MJ7jXwHPfSWUAl5P71EopUwbXo89ywwyxiVXU+mLYN1Z2auA2tT2nKPfHQ4iMWS1Xk3ZQqUo+MjillJoH4cCC6cM/0UcpPXl2wY+7LRpOXQFiFiFj5VYr/0d7SYX/iwhkLaiw9JCPVIUgvHuT9V36ubnp0Mbbco5N7ET+SYXBnhsYzrIJ+OVBnhRmR/lY75XK9YNJLcBt2KDhxu4cOduhhO4eKetscERk2Cyhsp8gy9jwVcS2gv7bsfqJvPibNcSZ3NbLnXMtl7kCkdzKSi0gqM6yMNgz/dDE7XxYlQLfExPe9qI33mUp8pzws/3M5VpVlf4sy/ChRqWA0AmOk66POcCWRjxLz3+HZrU4KfySsybNku8+Nm9a+PLfQ92+0w92+fxhLaQ2wocA+KnLCgxXcZwtlqgfNYsyDpLhPvEPDVvEJJz6RrHCHMZI/tdWLXyBmSatFs7wE4LxPOXc9fLHW9b7er283fY1LHq8q2xXZ/vDmX98l8HS6QUXaygJwZvSgeSUIzo8Ch8XftXy26DyckM8T5nP4yWEgSAbzz+04MN3tCxehH7uVdDL+lPwXTH777aigvUtEx6Ao9SqAuu9TDNdeB5xkokCj1fsMN09FOxe6geCScgUm2PIq87bFpS6xWTqvGkfHEf0GkldB/8ukULSO2sIPHCfHIfyJBWtQSg8NNlTfe7lp2y2Dic0tkfitcCXPT0YZCwpTzRawRmcoWAu9LAry3Ha4TjcA+4ewkWdqTRaS44673mweu9cagNKthMRF1HwJFOAGgKOTm1c7Y/+I7Xa8bnhSspu8eQalcFuDzPS0aRkQIy9Afljmc/dAcCoEv9+7JO1OGi+yose8zIkYyA87rOARz8tIi7xm8KNOlSvj3HpdQrYCiAx/nrigrNKVGc8O1kM4RbonRJPDzwzS/X1mS1UiZMcWu8FVVutnmDkfJamFM0ml23b7V4opHgK+N/gCkhgVc+7IGYCUblIsL418qRPu5QYrxP1iopXt5SBuC1X1/pTFLdayqdKWuNhMIT8Li+PrgwCAtkDNnAbfy6SUlL5zKpKM2qEmTye3GqemoAkMCCUHnufz5r8SiIAMfdEveTHZ9LFoUYeUdomfQ0/wHrlgmECnWxRb4YGVT7VC0ELh+B23zx22rE6NC0ed/ZTAEhjnUmxgtT2W+zt+QR2q7m4WhXwsCs7I+H9FJFJ2AwVoiJWTzv+cAfg/Dkg/NPl93vPKZRR/1fv3ma5zrq4ZPrGBksJ2X92VnDQ3bsvWPtxR6OFK6ZQXT9ZQtlnwMqybMT9/L4yY8T2CopQ8trQT81ZLZpxbBlD87zGMdPz2jPeCLuy77kQg==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/25周总结</title>
      <link href="/2019/06/24/2019/25.html/"/>
      <url>/2019/06/24/2019/25.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/24周总结</title>
      <link href="/2019/06/22/2019/24.html/"/>
      <url>/2019/06/22/2019/24.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/23周总结</title>
      <link href="/2019/06/13/2019/23.html/"/>
      <url>/2019/06/13/2019/23.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/22周总结</title>
      <link href="/2019/06/02/2019/22.html/"/>
      <url>/2019/06/02/2019/22.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>page_limit_stream性能对比</title>
      <link href="/2019/06/02/prac/sum/page_limit_stream.html/"/>
      <url>/2019/06/02/prac/sum/page_limit_stream.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2019-05-26%E7%95%AA%E8%8C%84%E9%9D%A2.jpg" alt></p><a id="more"></a><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>当导出数据量很大时，分页查询会影响内存和数据库连接池，并且速度随着分页 offset 变大而变慢，因此需要优化</p><h1 id="2-三种方法对比"><a href="#2-三种方法对比" class="headerlink" title="2 三种方法对比"></a>2 三种方法对比</h1><p>主要参考：<br>1: <a href="https://ifrenzyc.github.io/2017/11/16/mysql-streaming/" target="_blank" rel="noopener">https://ifrenzyc.github.io/2017/11/16/mysql-streaming/</a><br>2: <a href="http://knes1.github.io/blog/2015/2015-10-19-streaming-mysql-results-using-java8-streams-and-spring-data.html" target="_blank" rel="noopener">http://knes1.github.io/blog/2015/2015-10-19-streaming-mysql-results-using-java8-streams-and-spring-data.html</a><br>测试 jvm 配置： -Xms512m -Xmx512m<br>测试数据量：60W 无查询条件</p><h2 id="2-1-原生分页写法"><a href="#2-1-原生分页写法" class="headerlink" title="2.1 原生分页写法"></a>2.1 原生分页写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table limit pageNo, pageSize</span><br></pre></td></tr></table></figure><p>内存：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/limit_jmm.png" alt><br>时间耗时：三次测试导出，基本在200s~210s之间</p><h2 id="2-2-优化之后的游标导出"><a href="#2-2-优化之后的游标导出" class="headerlink" title="2.2 优化之后的游标导出"></a>2.2 优化之后的游标导出</h2><p>注意：因为使用的主键索引查询范围，因为不支持排序，但是可以导出后让运营在 Excel 中手动排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次查询后，将最大的 id 传入下次作为条件</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; $&#123;<span class="keyword">id</span>&#125; <span class="keyword">limit</span> pageSize</span><br></pre></td></tr></table></figure><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/offset_jmm.png" alt><br>时间耗时：三次测试导出，基本在15s左右</p><h2 id="2-3-使用-stream"><a href="#2-3-使用-stream" class="headerlink" title="2.3 使用 stream"></a>2.3 使用 stream</h2><p>这是 mysql 本身支持的特性，使用流式处理数据  </p><p>jpa 语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Stream&lt;Dao&gt; <span class="title">streamAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">streamAll.forEach(</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/stream_jmm.png" alt><br>时间耗时：三次测试导出，基本在13s左右</p><h1 id="3-最终选择"><a href="#3-最终选择" class="headerlink" title="3 最终选择"></a>3 最终选择</h1><p>选择第二种，因为 stream 的缺点在于长事务，虽然是只读，不会有锁但是属于长连接，而且该 SQL 属于慢查询，在 DBA 就过不去。<br>而第二种更加容易接受和理解，虽然苦了运营~</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/21周总结</title>
      <link href="/2019/05/26/2019/21.html/"/>
      <url>/2019/05/26/2019/21.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/19周总结</title>
      <link href="/2019/05/14/2019/19.html/"/>
      <url>/2019/05/14/2019/19.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka解析</title>
      <link href="/2019/05/07/tech/Kafka_jiexi.html/"/>
      <url>/2019/05/07/tech/Kafka_jiexi.html/</url>
      
        <content type="html"><![CDATA[<p>![][0]</p><a id="more"></a><h1 id="1-kafka-入门"><a href="#1-kafka-入门" class="headerlink" title="1 kafka 入门"></a>1 kafka 入门</h1><p>消息系统：作为消息系统的队列模式（点对点模式）和发布-订阅模式<br>存储系统：同步阻塞发发送消息，等待消息完全地复制到多个节点，才认为这条消息发送成功<br>流处理系统：提供实时的流式数据处理能力：处理乱序、迟来的数据、重新处理输入数据、窗口和状态操作等</p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_1.png" alt></p><p>四种核心 API：生产者、消费者、连接器、流处理<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_2.jpg" alt></p><h2 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h2><h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1"></a>1.2.1</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_3.png" alt></p><p>每个主题（Topic）有多个分区（partition），每个消息入根据不同的 Topic 均匀的分散在其中的分区中，其中入分区的每个消息都带有一个自增的偏移量，分区通过偏移量（offset）来标识消费/写进度  </p><p>通过消费相同分区的消息，来保证有序性</p><h3 id="1-2-2-消费模型"><a href="#1-2-2-消费模型" class="headerlink" title="1.2.2 消费模型"></a>1.2.2 消费模型</h3><p>推模型：由消息中心 Broker 推送消息到消费者，缺点在于，Broker 需要记录消息已发送/已消费/未消费状态值<br>拉模型：由消费者自己从消息中心 Broker 拉消息，这也是 kafka 选择的模式</p><p>kafka 保存所有消息，无论是否消费。这样消费者可以根据偏移量重复消费之前的消息，或者跳着消费，缺点在于磁盘占用空间大，需要合理的设置消息清理时间，kafka 两天清理一次</p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_4.png" alt></p><h3 id="1-2-3-分布式模型"><a href="#1-2-3-分布式模型" class="headerlink" title="1.2.3 分布式模型"></a>1.2.3 分布式模型</h3><p>消息中心，即 Broker 作为服务端，而生产者和消费者作为客户端<br>Broker 主节点用于处理客户端们的消息读写，而 Broker 副节点用于消息的冗余，即为最小单位 partition 分区保证完整性，而采用分布式存储，主副节点支持故障转移  </p><p>消费者组支持纵向扩展，增加某个 Topic 消息吞吐量  </p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_5.png" alt></p><h2 id="1-3-Kafka-的设计与实现"><a href="#1-3-Kafka-的设计与实现" class="headerlink" title="1.3 Kafka 的设计与实现"></a>1.3 Kafka 的设计与实现</h2><h3 id="1-3-1-文件系统的持久化与数据传输效率"><a href="#1-3-1-文件系统的持久化与数据传输效率" class="headerlink" title="1.3.1 文件系统的持久化与数据传输效率"></a>1.3.1 文件系统的持久化与数据传输效率</h3><p>预读：提前将一个比较大的磁盘块读入内存<br>后写：将很多小的逻辑写操作合并起来组合成一个大的物理写操作<br>磁盘缓存：将主内存剩余的所有空闲内存空间作为磁盘缓存，用于磁盘读写操作前的缓存<br>因此，在某些情况下，磁盘顺序读写比随机内存读写快  </p><p>正常写入磁盘都是，先用应用程序写入内存，然后刷新到磁盘。但是 kafka 先存入磁盘缓存，然后刷新到磁盘（这不一样么，磁盘缓存在某种角度来说也是内存。。。）<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_6.png" alt>  </p><p>传统数据复制方案：操作系统将数据从磁盘读到内核空间的页面缓存-&gt;应用程序将数据从内核空间读到用户空间的缓存区-&gt;应用程序将数据从用户空间写回内核空间的 socket 缓存区-&gt;操作系统将数据从 socket 缓存区复制到王卡卡接口，通过网络发送出去    </p><p>kafka 的零拷贝方案：操作系统将数据从磁盘读到内核空间的页面缓存区-&gt;操作系统将数据直接通过网卡接口通过网络发送出去  </p><p>10 个消费者情况下，传统方案，需要 10 * 4 = 40 次<br>零拷贝方案需要 10 + 1 = 11 次，其中的 1 次为从磁盘到内核空间的页面缓存</p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_7.png" alt></p><h3 id="1-3-2-生产者与消费者"><a href="#1-3-2-生产者与消费者" class="headerlink" title="1.3.2 生产者与消费者"></a>1.3.2 生产者与消费者</h3><p>生产者采用一种”在100ms内消息大小达到64字节要立即发送，如果在100ms时还没达到64字节，也要把已经收集的消息发送出去“，通过这种缓存机制，降低延迟以换取吞吐量  </p><p>消费者记录分区消费状态，好处在于消费者可以重新消费之前的消费。而消费状态是通过消费进度检查点文件实现，即在这个点之前的消息都已经被消费<br>消费者拉模型的缺点在于，如果消息中心（Broker）没有消息，而消费者还是继续处于一种轮询阻塞的方式请求。解决方法在于：消费者请求 Broker 时，通过消费者设置的”最低消费字节数“来判断 Broker 消息是否足够，从而是否立即返回或继续阻塞</p><h3 id="1-3-3-副本机制和容错处理"><a href="#1-3-3-副本机制和容错处理" class="headerlink" title="1.3.3 副本机制和容错处理"></a>1.3.3 副本机制和容错处理</h3><p>每个 partition 在同一个节点上，可能为主，也有可能为从</p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Kafka%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1_8.png" alt></p><p>为了避免数据热点问题（主数据全在一个机器上），尽量保证每个节点作为不同 partition 的主或从</p><p>副节点与主节点通信方式和客户端与主节点通信类似，只不过副节点将消息持久化，而客户端是将消息消费<br>副节点正在同步中（in-sync）状态：1. 副节点与 zk 连接。2. 消息复制进度不能落后太多</p><p>如何保证消息被消费者看到后，消息是真实存在磁盘中的：生产者发送消息提交到主节点，只有当副节点从主节点复制完消息后，该消息才会被消费者可见，这就是消息提交机制</p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/18周总结</title>
      <link href="/2019/05/06/2019/18.html/"/>
      <url>/2019/05/06/2019/18.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/17周总结</title>
      <link href="/2019/05/03/2019/17.html/"/>
      <url>/2019/05/03/2019/17.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ解析</title>
      <link href="/2019/04/24/tech/RocketMQ_jiexi.html/"/>
      <url>/2019/04/24/tech/RocketMQ_jiexi.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2019-04-25%E6%B2%A1%E5%BE%97%E9%80%89.png" alt></p><a id="more"></a><h1 id="1-单机版消息中心"><a href="#1-单机版消息中心" class="headerlink" title="1 单机版消息中心"></a>1 单机版消息中心</h1><p>一个消息中心，最基本的需要支持多生产者、多消费者，例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际中会有 nameserver 服务来找到 broker 具体位置以及 broker 主从信息</span></span><br><span class="line">        Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">        Producer producer1 = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer1.connectBroker(broker);</span><br><span class="line">        Producer producer2 = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer2.connectBroker(broker);</span><br><span class="line"></span><br><span class="line">        Consumer consumer1 = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer1.connectBroker(broker);</span><br><span class="line">        Consumer consumer2 = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer2.connectBroker(broker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            producer1.asyncSendMsg(<span class="string">"producer1 send msg"</span> + i);</span><br><span class="line">            producer2.asyncSendMsg(<span class="string">"producer2 send msg"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"broker has msg:"</span> + broker.getAllMagByDisk());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"consumer1 consume msg："</span> + consumer1.syncPullMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"consumer2 consume msg："</span> + consumer2.syncPullMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Broker broker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectBroker</span><span class="params">(Broker broker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.broker = broker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncSendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (broker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"please connect broker first"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            broker.sendMsg(msg);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Broker broker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectBroker</span><span class="params">(Broker broker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.broker = broker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">syncPullMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> broker.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 RocketMQ 中 MessageQueue，默认情况下 1 个 Topic 包含 4 个 MessageQueue</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> LinkedBlockingQueue(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际发送消息到 broker 服务器使用 Netty 发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messageQueue.put(msg);</span><br><span class="line">            <span class="comment">// 实际会同步或异步落盘，异步落盘使用的定时任务定时扫描落盘</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> messageQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAllMagByDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"\n"</span>);</span><br><span class="line">        messageQueue.iterator().forEachRemaining((msg) -&gt; &#123;</span><br><span class="line">            sb.append(msg + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>没有实现真正执行消息存储落盘</li><li>没有实现 NameServer 去作为注册中心，因为单机版在同一个 JVM 中  </li><li>使用 LinkedBlockingQueue 作为消息队列，注意，参数是无限大，在真正 RocketMQ 也是如此是无限大，理论上内存数据抛弃的问题，但是会有内存泄漏问题（阿里巴巴开发手册也因为这个问题，建议我们使用自制线程池）  </li><li>没有使用多个队列（即多个 LinkedBlockingQueue）来模拟顺序消息，RocketMQ 的顺序消息是通过生产者和消费者同时使用同一个 MessageQueue 来实现</li><li>没有使用 MappedByteBuffer 来实现文件映射从而使消息数据落盘非常的快（实际 RocketMQ 使用的是 FileChannel+DirectBuffer）</li></ol><h1 id="2-分布式消息中心"><a href="#2-分布式消息中心" class="headerlink" title="2 分布式消息中心"></a>2 分布式消息中心</h1><h2 id="2-1-问题与解决"><a href="#2-1-问题与解决" class="headerlink" title="2.1 问题与解决"></a>2.1 问题与解决</h2><h3 id="2-1-1-消息丢失的问题"><a href="#2-1-1-消息丢失的问题" class="headerlink" title="2.1.1 消息丢失的问题"></a>2.1.1 消息丢失的问题</h3><ol><li>当你系统需要保证百分百消息不丢失，你可以使用生产者每发送一个消息，Broker 同步返回一个消息发送成功的反馈消息</li><li>即每发送一个消息，同步落盘后才返回生产者消息发送成功，这样只要生产者得到了消息发送生成的返回，事后除了硬盘损坏，都可以保证不会消息丢失</li><li>但是这同时引入了一个问题，同步落盘怎么才能快？</li></ol><h3 id="2-1-2-同步落盘怎么才能快"><a href="#2-1-2-同步落盘怎么才能快" class="headerlink" title="2.1.2 同步落盘怎么才能快"></a>2.1.2 同步落盘怎么才能快</h3><ol><li>使用 FileChannel + DirectBuffer 池，使用堆外内存，加快内存拷贝  </li><li>使用数据和索引分离，当消息需要写入时，使用 commitlog 文件顺序写，当需要定位某个消息时，查询index 文件来定位，从而减少文件IO随机读写的性能损耗</li></ol><h3 id="2-1-3-消息堆积的问题"><a href="#2-1-3-消息堆积的问题" class="headerlink" title="2.1.3 消息堆积的问题"></a>2.1.3 消息堆积的问题</h3><ol><li>后台定时任务每隔72小时，删除旧的没有使用过的消息信息  </li><li>根据不同的业务实现不同的丢弃任务，具体参考线程池的 AbortPolicy，例如FIFO/LRU等（RocketMQ没有此策略）  </li><li>消息定时转移，或者对某些重要的 TAG 型（支付型）消息真正落库</li></ol><h3 id="2-1-4-定时消息的实现"><a href="#2-1-4-定时消息的实现" class="headerlink" title="2.1.4 定时消息的实现"></a>2.1.4 定时消息的实现</h3><ol><li>实际 RocketMQ 没有实现任意精度的定时消息，它只支持某些特定的时间精度的定时消息</li><li>实现定时消息的原理是：创建特定时间精度的 MessageQueue，例如生产者需要定时1s之后被消费者消费，你只需要将此消息发送到特定的 Topic，例如：MessageQueue-1 表示这个 MessageQueue 里面的消息都会延迟一秒被消费，然后 Broker 会在 1s 后发送到消费者消费此消息，使用 newSingleThreadScheduledExecutor 实现</li></ol><h3 id="2-1-5-顺序消息的实现"><a href="#2-1-5-顺序消息的实现" class="headerlink" title="2.1.5 顺序消息的实现"></a>2.1.5 顺序消息的实现</h3><p>与定时消息同原理，生产者生产消息时指定特定的 MessageQueue ，消费者消费消息时，消费特定的 MessageQueue，其实单机版的消息中心在一个 MessageQueue 就天然支持了顺序消息（真棒！）</p><h3 id="2-1-6-分布式消息的实现"><a href="#2-1-6-分布式消息的实现" class="headerlink" title="2.1.6 分布式消息的实现"></a>2.1.6 分布式消息的实现</h3><ol><li>需要前置知识：2PC  </li><li>RocketMQ4.3 起支持，原理为2PC，即两阶段提交，prepared-&gt;commit/rollback</li><li>生产者发送事务消息，假设该事务消息 Topic 为 Topic1-Trans，Broker 得到后首先更改该消息的 Topic 为 Topic1-Prepared，该 Topic1-Prepared 对消费者不可见。然后定时回调生产者的本地事务A执行状态，根据本地事务A执行状态，来是否将该消息修改为 Topic1-Commit 或 Topic1-Rollback，消费者就可以正常找到该事务消息或者不执行等</li></ol><blockquote><p>注意，就算是事务消息最后回滚了也不会物理删除，只会逻辑删除该消息</p></blockquote><h3 id="2-1-7-消息的-push-实现"><a href="#2-1-7-消息的-push-实现" class="headerlink" title="2.1.7 消息的 push 实现"></a>2.1.7 消息的 push 实现</h3><ol><li>注意，RocketMQ 已经说了自己会有低延迟问题，其中就包括这个消息的 push 延迟问题</li><li>因为这并不是真正的将消息主动的推送到消费者，而是 Broker 定时任务每5s将消息推送到消费者</li></ol><h3 id="2-1-8-消息重复发送的避免"><a href="#2-1-8-消息重复发送的避免" class="headerlink" title="2.1.8 消息重复发送的避免"></a>2.1.8 消息重复发送的避免</h3><ol><li>RocketMQ 会出现消息重复发送的问题，因为在网络延迟的情况下，这种问题不可避免的发生，如果非要实现消息不可重复发送，那基本太难，因为网络环境无法预知，还会使程序复杂度加大，因此默认允许消息重复发送</li><li>RocketMQ 让使用者在消费者端去解决该问题，即需要消费者端在消费消息时支持幂等性的去消费消息</li><li>最简单的解决方案是每条消费记录有个消费状态字段，根据这个消费状态字段来是否消费或者使用一个集中式的表，来存储所有消息的消费状态，从而避免重复消费</li><li>具体实现可以查询关于消息幂等消费的解决方案</li></ol><h3 id="2-1-9-广播消费与集群消费"><a href="#2-1-9-广播消费与集群消费" class="headerlink" title="2.1.9 广播消费与集群消费"></a>2.1.9 广播消费与集群消费</h3><ol><li>消息消费区别：广播消费，订阅该 Topic 的消息者们都会消费<strong>每个</strong>消息。集群消费，订阅该 Topic 的消息者们只会有一个去消费<strong>某个</strong>消息</li><li>消息落盘区别：具体表现在消息消费进度的保存上。广播消费，由于每个消费者都独立的去消费每个消息，因此每个消费者各自保存自己的消息消费进度。而集群消费下，订阅了某个 Topic，而旗下又有多个 MessageQueue，每个消费者都可能会去消费不同的 MessageQueue，因此总体的消费进度保存在 Broker 上集中的管理</li></ol><h3 id="2-1-10-RocketMQ-不使用-ZooKeeper-作为注册中心的原因，以及自制的-NameServer-优缺点？"><a href="#2-1-10-RocketMQ-不使用-ZooKeeper-作为注册中心的原因，以及自制的-NameServer-优缺点？" class="headerlink" title="2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？"></a>2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？</h3><ol><li>ZooKeeper 作为支持顺序一致性的中间件，在某些情况下，它为了满足一致性，会丢失一定时间内的可用性，RocketMQ 需要注册中心只是为了发现组件地址，在某些情况下，RocketMQ 的注册中心可以出现数据不一致性，这同时也是 NameServer 的缺点，因为 NameServer 集群间互不通信，它们之间的注册信息可能会不一致</li><li>另外，当有新的服务器加入时，NameServer 并不会立马通知到 Produer，而是由 Produer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息（这种情况是通过 Producer 发送消息时，负载均衡解决）</li></ol><h3 id="2-1-11-其它"><a href="#2-1-11-其它" class="headerlink" title="2.1.11 其它"></a>2.1.11 其它</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/RocketMQ%E6%B5%81%E7%A8%8B.png" alt></p><p>加分项咯 </p><ol><li>包括组件通信间使用 Netty 的自定义协议</li><li>消息重试负载均衡策略（具体参考 Dubbo 负载均衡策略）</li><li>消息过滤器（Producer 发送消息到 Broker，Broker 存储消息信息，Consumer 消费时请求 Broker 端从磁盘文件查询消息文件时就使用过滤服务器进行过滤）  </li><li>Broker 同步双写和异步双写中 Master 和 Slave 的交互</li></ol><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ol><li>《RocketMQ技术内幕》：<a href="https://blog.csdn.net/prestigeding/article/details/85233529" target="_blank" rel="noopener">https://blog.csdn.net/prestigeding/article/details/85233529</a></li><li>关于 RocketMQ 对 MappedByteBuffer 的一点优化：<a href="https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/</a></li><li>阿里中间件团队博客-十分钟入门RocketMQ：<a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="noopener">http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/</a></li><li>分布式事务的种类以及 RocketMQ 支持的分布式消息：<a href="https://www.infoq.cn/article/2018/08/rocketmq-4.3-release" target="_blank" rel="noopener">https://www.infoq.cn/article/2018/08/rocketmq-4.3-release</a></li><li>滴滴出行基于RocketMQ构建企业级消息队列服务的实践：<a href="https://yq.aliyun.com/articles/664608" target="_blank" rel="noopener">https://yq.aliyun.com/articles/664608</a></li><li>基于《RocketMQ技术内幕》源码注释：<a href="https://github.com/LiWenGu/awesome-rocketmq" target="_blank" rel="noopener">https://github.com/LiWenGu/awesome-rocketmq</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> rocketmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/16周总结</title>
      <link href="/2019/04/23/2019/16.html/"/>
      <url>/2019/04/23/2019/16.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/15周总结</title>
      <link href="/2019/04/18/2019/15.html/"/>
      <url>/2019/04/18/2019/15.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/14周总结</title>
      <link href="/2019/04/11/2019/14.html/"/>
      <url>/2019/04/11/2019/14.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/13周总结</title>
      <link href="/2019/04/03/2019/13.html/"/>
      <url>/2019/04/03/2019/13.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/12周总结</title>
      <link href="/2019/03/26/2019/12.html/"/>
      <url>/2019/03/26/2019/12.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/11周总结</title>
      <link href="/2019/03/19/2019/11.html/"/>
      <url>/2019/03/19/2019/11.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/10周总结</title>
      <link href="/2019/03/12/2019/10.html/"/>
      <url>/2019/03/12/2019/10.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/09周总结</title>
      <link href="/2019/03/05/2019/09.html/"/>
      <url>/2019/03/05/2019/09.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/08周总结</title>
      <link href="/2019/02/25/2019/08.html/"/>
      <url>/2019/02/25/2019/08.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS中的TLS</title>
      <link href="/2019/02/22/tech/https_tls.html/"/>
      <url>/2019/02/22/tech/https_tls.html/</url>
      
        <content type="html"><![CDATA[<p>关于 HTTPS 中的 SSL/TLS<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/2019-02-15%E5%B0%8F%E7%86%8A.jpg" alt></p><a id="more"></a><hr><h1 id="0-SSL-与-TLS"><a href="#0-SSL-与-TLS" class="headerlink" title="0 SSL 与 TLS"></a>0 SSL 与 TLS</h1><p>SSL：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本<br>TLS：（Transport Layer Security）传输层安全性协议，是 IETF 在 SSL3.0 的基础上设计的协议<br>以下全部使用 TLS 来表示</p><h1 id="1-从网络协议的角度理解-HTTPS"><a href="#1-从网络协议的角度理解-HTTPS" class="headerlink" title="1 从网络协议的角度理解 HTTPS"></a>1 从网络协议的角度理解 HTTPS</h1><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/%E4%B8%83%E5%B1%82.png" alt="此图并不准确"><br>HTTP：HyperText Transfer Protocol 超文本传输协议<br>HTTPS：Hypertext Transfer Protocol Secure 超文本传输安全协议<br>HTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 HTTPS = HTTP + TLS</p><h1 id="2-从密码学的角度理解-HTTPS"><a href="#2-从密码学的角度理解-HTTPS" class="headerlink" title="2 从密码学的角度理解 HTTPS"></a>2 从密码学的角度理解 HTTPS</h1><p>HTTPS 使用 TLS 保证安全，这里的“安全”分两部分，一是传输内容加密、二是服务端的身份认证</p><h2 id="2-1-TLS-工作流程"><a href="#2-1-TLS-工作流程" class="headerlink" title="2.1 TLS 工作流程"></a>2.1 TLS 工作流程</h2><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/tls%E6%B5%81%E7%A8%8B.png" alt="此图并不准确"><br>此为服务端单向认证，还有客户端/服务端双向认证，流程类似，只不过客户端也有自己的证书，并发送给服务器进行验证</p><h2 id="2-2-密码基础"><a href="#2-2-密码基础" class="headerlink" title="2.2 密码基础"></a>2.2 密码基础</h2><h3 id="2-2-1-伪随机数生成器"><a href="#2-2-1-伪随机数生成器" class="headerlink" title="2.2.1 伪随机数生成器"></a>2.2.1 伪随机数生成器</h3><p>为什么叫伪随机数，因为没有真正意义上的随机数，具体可以参考 Random/TheadLocalRandom<br>它的作用在于生成对称密码的秘钥、用于公钥密码生成秘钥对</p><h3 id="2-2-2-消息认证码"><a href="#2-2-2-消息认证码" class="headerlink" title="2.2.2 消息认证码"></a>2.2.2 消息认证码</h3><p>用于验证消息的完整性与消息的认证，其中消息的认证指“消息来自正确的发送者”<br>注意：用于验证和认证，而不是加密<br>client：消息 + 共享秘钥 = 消息认证码，发送给 server 消息 + 消息认证码<br>server：消息认证码 + 共享秘钥 = 消息1，对比消息1 与收到的消息，实现认证<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%E8%BF%87%E7%A8%8B.png" alt>  </p><ol><li>发送者与接收者事先共享秘钥（秘钥配送问题，可以使用公钥密码解决）</li><li>发送者根据发送消息计算 MAC 值</li><li>发送者发送消息和 MAC 值  </li><li>接收者根据接收到的消息计算 MAC 值</li><li>接收者根据自己计算的 MAC 值与收到的 MAC 对比</li><li>如果对比成功，说明消息完整，并来自与正确的发送者</li></ol><h3 id="2-2-3-数字签名"><a href="#2-2-3-数字签名" class="headerlink" title="2.2.3 数字签名"></a>2.2.3 数字签名</h3><p>消息认证码无法防止否认，因为共享秘钥被 client、server 两端拥有，server 可以伪造 client 发送给自己的消息（自己给自己发送消息），为了解决这个问题，我们需要它们有各自的秘钥不被第二个知晓（这样也解决了共享秘钥的配送问题）  </p><blockquote><p>你可以简单理解为数字签名使用的是非对称密码对消息计算后获取的一个值，消息认证码是使用对称密码对消息计算后获取的一个值，并且它们都<strong>不是为了加密</strong></p></blockquote><p>使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是数字签名，表明我承认该消息来自自己<br>client：消息hash + 私钥 = 签名，发送签名 + 消息<br>server：签名 + 公钥 = 消息hash1，根据接收的消息计算出消息hash对比消息hash1<br>注意：私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B.png" alt>  </p><blockquote><p>可以简单理解单向散列函数类似 md5 获取摘要的过程</p></blockquote><h3 id="2-2-4-公钥密码"><a href="#2-2-4-公钥密码" class="headerlink" title="2.2.4 公钥密码"></a>2.2.4 公钥密码</h3><p>公钥密码也叫非对称密码，由公钥和私钥组成，它是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管<br>它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文<br>client：明文 + 公钥 = 密文<br>server：密文 + 私钥 = 明文<br>注意：公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容   </p><h3 id="2-2-5-证书"><a href="#2-2-5-证书" class="headerlink" title="2.2.5 证书"></a>2.2.5 证书</h3><p>证书：全称公钥证书（Public-Key Certificate, PKC）,里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, <strong>CA</strong>）施加数字签名，表明，某个认证机构认定该公钥的确属于此人  </p><blockquote><p>想象这个场景：你想在支付宝页面交易，你需要支付宝的公钥进行加密通信，于是你从百度上搜索关键字“支付宝公钥”，你获得了支什宝的公钥，这个时候，支什宝通过中间人攻击，让你访问到了他们支什宝的页面，最后你在这个支什宝页面完美的使用了支什宝的公钥完成了与支什宝的交易（谷歌浏览器还会在）<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/dns%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt>   </p></blockquote><p>在上面的场景中，你可以简单的理解支付宝证书就是由支付宝的公钥，和给支付宝颁发证书的企业的数字签名组成<br>任何人都可以给自己或别人的公钥添加自己的数字签名，表明：我拿我的尊严担保，我的公钥/别人的公钥是真的，至于信不信那是另一回事了</p><h3 id="2-2-6-密码小结"><a href="#2-2-6-密码小结" class="headerlink" title="2.2.6 密码小结"></a>2.2.6 密码小结</h3><p>消息认证码：确认消息的完整、并对消息的来源认证，共享秘钥+消息的散列值（理解为 MD5）<br>数字签名=对消息的散列值签名，和公钥密码类似，也有一组秘钥，但是是反着用，即使用私钥加密，公钥解密<br>公钥密码（非对称密码）：秘钥的配送问题，公钥密码=加密秘钥（公钥）+解密秘钥（私钥）<br>证书=公钥密码中的公钥+数字签名，证明此公钥是确实属于此人</p><h2 id="2-3-TLS-使用的密码技术"><a href="#2-3-TLS-使用的密码技术" class="headerlink" title="2.3 TLS 使用的密码技术"></a>2.3 TLS 使用的密码技术</h2><p>TLS 内部分为：TLS握手协议、TLS记录协议，对加密工作做了细致的分工，但是总整体上，我们可以认为它们至少使用到了如下技术：</p><ol><li>伪随机数生成器：秘钥生成随机性，更难被猜测</li><li>对称密码：对称密码使用的秘钥就是由伪随机数生成，相较于非对称密码，效率更高</li><li>消息认证码：保证消息信息的完整性、以及验证消息信息的来源</li><li>公钥密码：证书技术使用的就是公钥密码</li><li>数字签名：验证证书由真实的 CA 颁发 </li><li>证书：解决公钥的真实归属问题，降低中间人攻击概率   </li></ol><h2 id="2-4-TLS-总结"><a href="#2-4-TLS-总结" class="headerlink" title="2.4 TLS 总结"></a>2.4 TLS 总结</h2><p>TLS 是一系列密码工具的框架，作为框架，它也是非常的灵活，体现在每个工具套件它都可以替换，即：客户端与服务端之间协商密码套件，从而更难的被攻破，例如使用不同方式的对称密码，或者公钥密码、数字签名生成方式、单向散列函数技术的替换等</p><h1 id="3-RSA-公钥秘钥算法简单示例"><a href="#3-RSA-公钥秘钥算法简单示例" class="headerlink" title="3 RSA 公钥秘钥算法简单示例"></a>3 RSA 公钥秘钥算法简单示例</h1><p>RSA 是一种公钥密码算法<br>加密算法：密文 = (明文^E) mod N，其中公钥为{E,N}，即”求明文的E次方的对 N 的余数“<br>解密算法：明文 = (密文^D) mod N，其中秘钥为{D,N}，即”求密文的D次方的对 N 的余数“<br>例：公钥为{5,323}，私钥为{29,323}，明文为 300，我们来模拟加密和解密过程：<br>加密：密文 = 123 ^ 5 mod 323 = 225<br>解密：明文 = 225 ^ 29 mod 323 = [[(225 ^ 5) mod 323] <em> [(225 ^ 5) mod 323] </em> [(225 ^ 5) mod 323] <em> [(225 ^ 5) mod 323] </em> [(225 ^ 5) mod 323] <em> [(225 ^ 4) mod 323]] mod 323 = (4 </em> 4 <em> 4 </em> 4 <em> 4 </em> 290) mod 323 = 123</p><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><p>SSL加密发生在哪里：<a href="https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place" target="_blank" rel="noopener">https://security.stackexchange.com/questions/19681/where-does-ssl-encryption-take-place</a><br>TLS工作流程：<a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener">https://blog.csdn.net/ustccw/article/details/76691248</a><br>《图解密码技术》：<a href="https://book.douban.com/subject/26822106/" target="_blank" rel="noopener">https://book.douban.com/subject/26822106/</a> 豆瓣评分 9.5</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> 其它爱好 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/07周总结</title>
      <link href="/2019/02/19/2019/07.html/"/>
      <url>/2019/02/19/2019/07.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/06周总结</title>
      <link href="/2019/02/12/2019/06.html/"/>
      <url>/2019/02/12/2019/06.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+qb3Srtp2/UBaYqqm2Us8dMtk6+m5hJWlOpMnj3HeAyk7oNvcGT4Ex7Wqz1p1Gw2d6yQYyawrUmdGO2tpVnqKAtTAwtgt0/7S12UaEJO34oGKR+aOg/gl53waGoUq/MHl6PSMkD30Re0GcuLgFmnE4aQNNdzUO0TaXvIUkndtgFF9Ke7uTBT0hzqnC1oemxZU2gIUAvSqN+qOb7xwLNBDtE5jSO4sVls5UVQqV4JkBECY5uwzM3R8rKAbo2RCgRCIuabEpWrgZLCpxGsx+slfluG9OC5VCpcr7bQk4tE31AKky0UGP20HHjCz3wP/4BcY8eAj4uQQ5V8HJILysbafJ+l1I47UYveHywO1MsKpJcR1IpbKxfF0kkFv11o4C5UyjKmhlLNbnWZ0FzT0T4GI8O0eDWQp1KK5FUcWBXiJSaKobdoN6VJzRZjT5424WGntEjl8rxYwXXVXv0/3GFC0JTwYwqlIA9WyY3ql9lOQidXskLO1zho/Qxrsbp+cFWi6gjh1vhUIY8k4usCaLNtucqaZ1E1dTwUO34G9Xi4ai+p4XmiAPJy/wIWvhsYWoKLAIorJLitWnaOfhXGMXp5bU9ADvQthHYkcLw8NR8drrYFhtX9i4TCxxYEjALio3EBevO0SunfFlY1+oyDE2K+iWt9Q8hdbQXMp8ibl4kQKWi0zqOnVTggcexfiWmuksdAJfT2DJa6TC6a+f1x+F2tOhILQKVHiwbI/X5Vbw6rDgfXAOBPMJz62u32GkD4T/r2n7/wTEBtHNCCVywA8cldk8QQR+UQ1xTfUEhYk60v0Ocm/a7OZGflkuY6t3+PZGu6AxEkZw7iqj34q4d1aY2zP3mmiSII2BdxuOKi6sMVpGhaPNGlIf9tBQ0NYWPqd/2YpCQCyucL0s8zPfhxV4wJeqABNVKIKCGNBJDYKj+pA2haEDjIsU65o53e/jemD0n3bSuJ/2tX0KMW3t+F4HqI7eTzP8pzBgyUlghrDdnNS7VuSPEOaGrQZoU7tR+/vioLlCkvA1K8JANJ4ais5fLCby8QHB1MTLlpgJEZHPSagL5ruS4HC5mt5oYWSFjUpOIT8CzDMDWjL4DdaH4xpzKfiNQkQcLAvRP+oGU03aCcF4634BHpBpPZePFgMIxHDzuOxQhAlKWGXLSzpEtBCxPrXwSqrhIZ4sOkrD2TSNetH1KIVOpKK8uu5k3pThh8jGnwXAm7+js9bhefIW9GVTYhPuqktjf3bq28DrNe2PxclP+A2yvvjDVVTqUayCey5LMmtpd7SBt/nRrh3X64sOBQ9AJ5C1e0u5j5iN0uvJwYVl3rPsSaWUX8sjsUmw5dwIuyxtoEYmuZPjqjyqFjuBAKRi7Y/9F3oTAKOSIPu2fyxBlW0p+iq9I4Z9PMIi7q4fiUoxSpM59SeX75nY3YzqmILYqX1RpMmJfzq8Bp/og+7D1Msyc5sb9jXhZk6CWzjvzzhh/EFQimsxiqJ8VtkKR5pg6Y3i2Q6en410nKgQuYcuWOvEZrHRsYEs3uF9Pu/SO1Rn+lq+exkmJV6rOhAZX/vRgMy/WsQwbXaD1roDomrODWr0Aq6jmFPXzMfGwU5j6/Qnj4kfE6S5lhUcIfTbJPIBYywO7jhuS9lnIU9T22IlgFna9fau4MTZsCoVOzQjTNb4Zp7F7ytHthwekmvT4108bzo01Gt0KU2/FsgA8Wu/me9WviXYg+9HR8IVcCc5DbWXMo74jxl3iaAFq8p5AKH918IDa5eNb+wq4Ku7uqlQT2UUCt6AT/6/nR9iJ3iE9GRTsIZUJyLp87PFaGHQKhki+dzwQq8oKwABGHShRWfxqi1GdG80/gxsLUeGamGaRL9wWudiejbgsNxIvwMhW082PQCL3QZ6MRiXo+dTavi7IZXZENrLCL5DYtUtY5gDSfmDMUtPPaSMUyvyKAvE2ZQDDkYPP5b2KN9Vm+dRj2Rr0x/UWo67DWOrsnQpcLNH4Yhb4bC+uaSjemPRDyT3z1gnZhr7iKHqrMiWnyoeeFsyZG2ckvuw3riXQia59B6VaStIEALW7jtZKu1i6LiNQ8+9KVNjc8llHti8vBZlzDrVmpooFBtftZczHLhCfBcibVrf018X0i0s2U1Qva2z8pDM4U+TCvqxwuYCRLfUCUWbdP+pgAzmSRH+tU7QNxjIXqZcp89OTUOe4FezjZKzJtmRE5d/EF/EOPEnNBkA77i8aDErVq3FP/wCHWf8dusiAj+1SPQ6qotXD0QNnGBsIzV1NY9IUQEc/2QPfACqnZQi+hLslq0gRDw0B1NUueMpOmtVZR8U3hnhpviUaVF8k5/GEDMIB9BPxv+jJiqbMO5hafIyiA1+5FsvRfvA2SpY3VWYWp4khnPBtKIzWxxYVaNVxXVTqGTuAZldFNrWW1CU2bZ1Hr3wywZr/F3SgqecmtG8KjMJS+MgtdqjAHjvPJ5fwyXKUJ4NXuD9rAhRCHGXrraBKlkAZnMjhyT8R++ViYt+yHgZWML2HHGWrLsg/m/dp5PlX+kowYsHpyRupGbabyEMxrTkIinhi6I+nqBI9xD3scAJ9j3LIr8rdNjtk0tJehFUyPVtkxnFFLXHekFDsTQHh0UerPqTBfNXk6dPcASm6eRrnBhm7gynljnuQGBm2UtqidEAcX5og1fda46a8kGNmdOlH1mRwgwZVnm+VZ907d+ERXLBqytLUBO1Nd4qUxE8MocYtOtQ7WjS7MGPtJFM9G4UT3hTdjxL9w3ZEKHrEUJfHRbXCs2IOIbc93uVk7+cQxuI5l/tC1cVrAmXaU4YuAqWPuxHXvRe+FxpmbVcifaWbaRcUwnZ6xCvtz9+Dcif2yyuQzH1cVd/eomPK8onHGEVoQXu89jEu4p+jLCAq7tZwrU/dX5xyP2eQp6quGtZ8j/WOMY/+1On9XUfoqmw1BNbGgQtXZAN62ict5EBWFEac6uTb6ve2jwafJ90aCVXsuv9GZQfglwdqYoKBIZXisipAg2QG4HoHrnyAIGdGx0YiD1sI/IVJMovTahPezy08HQKRf+jCvfKTi48N/wrw9YmskAkoXk6zYRPcQD6AY51yUr3/4/eqiBs+GqyUQamxasqIien0wCHpGb7UMC2q856Ak537A3eU7SxA/rUKdpkjnmUmAqCvai25yRkCiMMP3bFd6VfmaNK8Vn8shiLSQfOh2lg4fQKe/2gK6ARcGY6a4MkOQdWUk29swejLpkGyfy5G3wRDgVNVGkzXWAw5MKFyadTa8zwlYn5Dlci5aARF9hTr32G/oc62C2TLl8cND+ZsdTusSSOe2TC9gbIN1QQLb/VWoNjW2xDvziLlZQHYgfbtUPIguN1IertFhQH+jexIhxF7As5aAej6YKDoZ1lMIfJUKV+qRBvn7WpefWSCi0hDbcicvMd9UmXhKPZHnTWCm5GN5mDu8t4m9LVDbnoC+SkvvhawJKaxuQ/fDuZvANztsmdQuO68o6fzfLMzSLYLDFKMmmI6kfbx19OkGvJWlEnBiv46fT9Oa9IPMXSHTqaFtVf+lpXEGU6j1K9aLkP7P8aLQoQUSebJ40qek+MosGnfJL8lvxSJINrZ8221O0xTR3Iaq8qVHY92ZtGxZpN/PkmiCla/iRs6k0ClhXjBVdMJAq76udbXPRQfm6V538EDdY9i40rZkyySkvVDgbH27bJylc9ReYy9okplseAqloav1Xg4HfEDFYgd0HYVQp3nB0LoT7pkKsxKVk0AYzxSAcUFmE+VJOt/c0OZqXMas/QCtVTRINSX9XIDC8uCFMQXAjw4curgag+j52C4eDmCSef0w0KqzK5HlHUMvU/bP4u0A/4oJAYr7aWAL2adpWaMajbTgNeWZX0fBAoWAx3/PBtuJrfPD7n/3VqZkCN5ei8/0E3vgRlgD1/BCe3ItBdSymj6v2fH/ouKFXnhAL43zVumEerV30fkeIesmCAr25ivleCBhEq+eTqMCwuRGPaiYOjHU5M/uJlxPUyo31DmoXlcQSqK7u0wLojmQQ0DUvWbpCyeAeVK7+8N+bZIigKtoNGJIgdoWmub54Q7FeRxMBQW+Brsa72RNQrwqaVOXIfFoyCC2JweIKyv2+YhZ22PQ52JwLrn/z6iKUNOW9oyRcbdITCCI0fBQnLYMcR/cP5v2FqSKre2ASBnPEbcLf3EMq7mctV0OSHqUNnJlo9fsNoTxTB5wsnV8lQ0ewhlM/2UBokvdeG1beEultvJm06/Y9PfMTOkP2ucuE1hHRp2Ombyx6H1DVn4dCfxMM302yKGy61+fIiCO3b6hlZGqp2pG/orrT5DQeYDiQ5JD1xboT9DZPx2mloxOqaZShw6e9qibmoPANkK9zR81qqtznCO5sVzag2KQYjAxxWojVQV/oF5Db0vLfgk8vmD8/rKTZCW3hIndbIFQUZdV2C1vQoG1J+PAz5VYo7cUozVEyc6PGXagHWyfNEub1+LBvVwYL+u1BzE3Jtd9DFuD5L3FlHBN0RU7m2aLeBmFsciW9tKDhRzjfYOqHKMSuGmVYnrIvfEycppw9sgR3GD9iHMEV9DP7PNrLS/wsdKRI3wl6JJ/cNTZOlb+uX2zujKVXVA2fusZ2CG72XKH5InssFaPkl5Mnq1wzQ4wbJJgJhoYOuiU2ZuJhDfTGaNfsfy+ATWky2+ku5TND7wf221/d1j1LO/IWJ40wQDV+3CLB+LLFs8LjNuhS+HDR+nBEoAIbXqNMq4obvoMFd3PkVbxYdXrMFUZYJBuMCAzLMF/sQvZpY9fKZ3c3Pro0EtDzOqf4zd0WsSFg0dA1Ajv5t1EfcL6k7lrwODAFIbYlTf3IVzzMbnXj71vDncPIgq1Ojp+PavO8axYe1NHZIEv9u3zEmzOrlUdDzsIim5zSVJZRWBCr1nzoWurI+vDEvmu8qdPoTFhPgIf7G0qICxl5qJVUMUrgAy3UE9f6EYmjuk3Pwz//hbN+YlDoCawRZuuD6UAmxZ81VulHAIL5xYScrlCM7L91XlR7kOc0pi4Egi5ebUtW6lNhvO174mGEo9EjQ2PRiVz0o6FMMro0QT6IXTuwri8oB/g8sOOkFLs3rc3AKreYhoc3Qfh4xoy4rOgHa0ZZFRbyaU4I+1HfUWTX3OHdY7PdlzNmdpnMdd6dOY9ulTUDT24Han+tJhFJ74X0kKt0hyLqvA1Jq1FilSug1FFPDdRn2PUumwpYke5B8ifzudCxgspRSaflDYilEnkZHA1/8abLwBACFdGCYqOgq6mZse/K00lVVkq7X2lhg5PE80QY1WPHqmgQsBi9eaCsk0sfHxbF+64yWW7FnNkO8Cp3saUFbZablurA8gJB5rNmmcS4aLy8Psh7OjBa9wJ7od4BwBCK/E3KWWpLP06QvgeOjrCAAJYDdW/+gjm5fQbgctMSHEhbeY6otSdEHL7SdJehT0Eo0pvnzKZ/KTXfjOxgiX49Ta7faKlH/MvJuHdIwJsUkXgNUDRpG92G4vCJh0qMVSS4lLhr08hfpQh7gMdMfThuezPkfDDUOQbqX/vJlQtAuic6GYBsQVZuFlfixdB+nMPj0h5gl7mguoXXxR5OActl/TuN9CTHSC0ZHjfi0FPXVY9uDur7giVJ6rKHoI0yQafNcsl+Pg4ianQlzomLVmDRqtlesnHB5baQK/jC4T7JQKHs2ZNiAKI+HkfMjUmrAcpRABKIRKRsdDw/mg2NVNRGzm93jC0SgSKEoDp+eHtZMKAyUhECB0jOBdZbMqHC9pqi/pPfS3N2mHjzDZ6GTMZYBfusNT++BCJeO1/mgzmi2owzwiSo/K9k78rNxwWIh//nO36pZGndVHaAOxhS+Iah3DE9GmRTgKslj5KOmjOW9klxrvSZOVssZofNUDlhiQFFczZ3p55n8PJwL/py+mx5FIQ7ep8j5enb0BpNnMgkNJfX+9hwYA07nkRCLJPpmThVWk+t3nFNa4RoBjJW8NwkVbNgXQvVT5OFusLiJKb5bygOhcnb5nKYouh2lyhd+9QAewzxdtBmfMITF5q5TjX+PAnK4lJ4eCz7AdxwXxfjtJ4HZw5BDexPYhMWqcqyXOg0r/72Qm4mpzuJPpTaGRSf9oNtTvO4CqmAvZ7xAODY2PiQ3R9IW2TEr3iXOQnFWrW04kYSdY0vhFvrZMjTVg6vDoS4nhyICfgYgrmUBF5uzwDiqsPNBPOhyuvLEdP7qlCRrxfYWtD9JyspqhXmZ07Gmj+j/1c38WScp3aDNzGt+8Yw40QhWKvBxxNaTK8utikHyx7CZOYNsOKe15Rz66/xK/evCLd/wCOd/w3CVrZmEjncIUQ+IzaJMb7WsG06R7TpedGhRjtv232NgXmT0Mpmojs3TiMyvcmW9lSy8fiUeFaXzgVfg0dsTzsceuOWgWJmJZVtAscBKeP6XLtwWd58K09px7JdrCxjU/dTVsD/ITdme5nJQdNPlib7u0dW9y0qnkVKJjXAzksc4fgHgUrBYp82zLz9w65iFbwffvdMtjo2HtNjCmeCYLLeW+XVWK2AB56GNkG03O0PeuOEvoBrUlCddHpVUDtlHEzu9bB+9nZxUtTe4HxmHFl04BzhBW//xOwGHbBv5u+ydV8tjP0q8FkjoKKjb1taA5UCIBRihBue0D8W9F0cXxRKCB7urtpBytJM/ZFqEnANwt+mc0BHiTQ3a6TU8yVKksiiEAsZ9vPUjbwvHCj6rzrO/gGQSy3Pin+1T0YvKZTS/yJbVwh3T4uoatGEnk+u3bQcfsgtTHbPbIXkY3QhlF5Ap4s8OKcNJ6hlV+XdI+i4M9MbdjI+OUHhdkoKQ3zAi8npAgTcgygzNISCNSb3h41qogE9sgdFfbpZh0J7vVQW2GxKHE6c//9wpCIEQD/3bk8Ctb4amvCi22i4iRq2kaEi6+ZO6fMXN8CdY+A1wD6RWhKW7Y78zOO3msGeGV7G6vC60TVBdm4tQ/1iynKtXXJwBddfuS4bbmxCCIgle6T4nivVuZkY7MobiPkv646S2W4cYEDcPUUgj2kjnl9pAGgNb0Gt9Gn5JkFKHYmOJisdtRmF4QW2rVRhesyh+B9OXXKMlAoJGBnlYDseoWkPpaAYdkidVmcPWPtQRvX4PhETUF5muItnj3Q==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/04周总结</title>
      <link href="/2019/01/29/2019/04.html/"/>
      <url>/2019/01/29/2019/04.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/03周总结</title>
      <link href="/2019/01/21/2019/03.html/"/>
      <url>/2019/01/21/2019/03.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019/02周总结</title>
      <link href="/2019/01/13/2019/02.html/"/>
      <url>/2019/01/13/2019/02.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 周总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈 ConcurrentHashMap 1.7 和 1.8 的不同实现</title>
      <link href="/2018/12/24/reprint_jvm/concurrenthashmap.html/"/>
      <url>/2018/12/24/reprint_jvm/concurrenthashmap.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2014-04-27%E5%AD%A6%E6%A0%A1%E6%93%8D%E5%9C%BA%E5%80%92%E5%BD%B11.jpg" alt><br>在多线程环境下，使用 <code>HashMap</code> 进行 <code>put</code> 操作时由于有 <code>resize</code> 存在，因此会有死锁隐患，为了避免这种bug的隐患，强烈建议使用 <code>ConcurrentHashMap</code> 代替 <code>HashMap</code>，为了对更深入的了解，本文将对 <code>JDK1.7</code> 和 <code>JDK1.8</code> 的不同实现进行分析</p><a id="more"></a><h1 id="1-JDK1-7"><a href="#1-JDK1-7" class="headerlink" title="1 JDK1.7"></a>1 JDK1.7</h1><h2 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h2><p>jdk1.7中采用 <code>Segment</code> + <code>HashEntry</code> 的方式进行实现，结构如下：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/%E8%BD%AC%E8%BD%BD/ConcurrentHashMap1.png" alt></p><ol><li><code>ConcurrentHashMap</code> 初始化时，计算出 <code>Segment</code> 数组的大小 <code>ssize</code> 和每个 <code>Segment</code> 中 <code>HashEntry</code> 数组的大小 <code>cap</code> ，并初始化 <code>Segment</code> 数组的第一个元素；其中 <code>ssize</code> 大小为2的幂次方，默认为 16，cap大小也是 2的幂次方，最小值为 2，最终结果根据根据初始化容量 <code>initialCapacity</code> 进行计算，计算过程如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>其中 <code>Segment</code> 在实现上继承了 <code>ReentrantLock</code> ，这样就自带了可重入锁的功能。</p><h2 id="1-2-put-实现"><a href="#1-2-put-实现" class="headerlink" title="1.2 put 实现"></a>1.2 put 实现</h2><p>当执行 <code>put</code> 方法插入数据时，根据 <code>key</code> 的 <code>hash</code> 值，在 <code>Segment</code> 数组中找到相应的位置，如果相应位置的 <code>Segment</code> 还未初始化，则通过 <code>CAS</code> 进行赋值，接着执行<code>Segment</code> 对象的 <code>put</code> 方法通过加锁机制插入数据，实现如下：<br>场景：线程A和线程B同时执行相同 <code>Segment</code> 对象的 <code>put</code> 方法  </p><ol><li>线程 A 执行 <code>tryLock()</code> 方法成功获取锁，则把 <code>HashEntry</code> 对象插入到相应的位置；</li><li>线程 B 获取锁失败，则执行 <code>scanAndLockForPut()</code> 方法，在 <code>scanAndLockForPut</code> 方法中，会通过重复执行 <code>tryLock()</code> 方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行 <code>tryLock()</code> 方法的次数超过上限时，则执行 <code>lock()</code> 方法挂起线程B；<br>3、当线程 A 执行完插入操作时，会通过 <code>unlock()</code> 方法释放锁，接着唤醒线程B继续执行；</li></ol><h2 id="1-3-size-实现"><a href="#1-3-size-实现" class="headerlink" title="1.3 size 实现"></a>1.3 size 实现</h2><p>因为 <code>ConcurrentHashMap</code> 是可以并发插入数据的，所以在准确计算元素时存在一定的难度，一般的思路是统计每个 <code>Segment</code> 对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的，因为在计算后面几个 <code>Segment</code> 的元素个数时，已经计算过的 <code>Segment</code> 同时可能有数据的插入或则删除，在1.7的实现中，采用了如下方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        overflow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum += seg.modCount;</span><br><span class="line">                <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                    overflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == last)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        last = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先采用不加锁的方式，连续计算元素的个数，最多计算 <strong>3</strong> 次：  </p><ol><li>如果前后两次计算结果相同，则说明计算出来的元素个数是准确的</li><li>如果前后两次计算结果都不同，则给每个 <code>Segment</code> 进行加锁，再计算一次元素的个数</li></ol><h1 id="2-JDK1-8"><a href="#2-JDK1-8" class="headerlink" title="2 JDK1.8"></a>2 JDK1.8</h1><h2 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h2><p>1.8中放弃了 <code>Segment</code> 臃肿的设计，取而代之的是采用 <code>Node</code> + <code>CAS</code> + <code>Synchronized</code> 来保证并发安全进行实现，结构如下：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/%E8%BD%AC%E8%BD%BD/ConcurrentHashMap2.png" alt><br>只有在执行第一次 <code>put</code> 方法时才会调用 <code>initTable()</code> 初始化 <code>Node</code> 数组，实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-put-实现"><a href="#2-2-put-实现" class="headerlink" title="2.2 put 实现"></a>2.2 put 实现</h2><p>当执行 <code>put</code> 方法插入数据时，根据 <code>key</code> 的 <code>hash</code> 值，在 <code>Node</code> 数组中找到相应的位置，实现如下：  </p><ol><li><p>如果相应位置的 <code>Node</code> 还未初始化，则通过 <code>CAS</code> 插入相应的数据:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果相应位置的 <code>Node</code> 不为空，且当前该节点不处于移动状态，则对该节点加 <code>synchronized</code> 锁，如果该节点的 <code>hash</code> 不小于0，则遍历链表更新节点或插入新节点:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果该节点是 <code>TreeBin</code> 类型的节点，说明是红黑树结构，则通过 <code>putTreeVal</code> 方法往红黑树中插入节点:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>binCount</code> 不为0，说明 <code>put</code> 操作对数据产生了影响，如果当前链表的个数达到 8 个，则通过 <code>treeifyBin</code> 方法转化为红黑树，如果 <code>oldVal</code> 不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果插入的是一个新节点，则执行 <code>addCount()</code> 方法尝试更新元素个数 <code>baseCount</code></p></li></ol><h2 id="2-3-size-实现"><a href="#2-3-size-实现" class="headerlink" title="2.3 size 实现"></a>2.3 size 实现</h2><p>1.8 中使用一个 <code>volatile</code> 类型的变量 <code>baseCount</code> 记录元素的个数，当插入新数据或则删除数据时，会通过 <code>addCount()</code> 方法更新 <code>baseCount</code> ，实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">    !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">    CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">        !(uncontended =</span><br><span class="line">          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">        fullAddCount(x, uncontended);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    s = sumCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>初始化时 <code>counterCells</code> 为空，在并发量很高时，如果存在两个线程同时执行 <code>CAS</code> 修改 <code>baseCount</code> 值，则失败的线程会继续执行方法体中的逻辑，使用 <code>CounterCell</code> 记录元素个数的变化</li><li><p>如果 <code>CounterCell</code> 数组 <code>counterCells</code> 为空，调用 <code>fullAddCount()</code> 方法进行初始化，并插入对应的记录数，通过 <code>CAS</code> 设置 <code>cellsBusy</code> 字段，只有设置成功的线程才能初始化 <code>CounterCell</code> 数组，实现如下:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">         U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">        <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">            CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">            rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">            counterCells = rs;</span><br><span class="line">            init = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (init)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果通过 <code>CAS</code> 设置 <code>cellsBusy</code> 字段失败的话，则继续尝试通过 <code>CAS</code> 修改 <code>baseCount</code> 字段，如果修改 <code>baseCount</code> 字段成功的话，就退出循环，否则继续循环插入 <code>CounterCell</code> 对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li></ol><p>所以在 1.8 中的 <code>size</code> 实现比 1.7 简单多，因为元素个数保存 <code>baseCount</code> 中，部分元素的变化个数保存在 <code>CounterCell</code> 数组中，实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过累加 <code>baseCount</code> 和 <code>CounterCell</code> 数组中的数量，即可得到元素的总个数  </p><p><strong>上文转载自：[占小狼 | 谈谈ConcurrentHashMap1.7和1.8的不同实现][00]</strong></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>JDK1.7 使用分段可重入锁，即锁的粒度变小了，相比原来直接对方法加锁更加高效<br>JDK1.8 使用 <code>CAS</code> + <code>Synchronized</code>，毕竟 <code>CAS</code> 这种无锁技术和优化过后的 <code>Synchronized</code> 效率还是高</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018 总结</title>
      <link href="/2018/12/18/2018/index.html/"/>
      <url>/2018/12/18/2018/index.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jcmd 命令</title>
      <link href="/2018/11/29/reprint_jvm/jcmd.html/"/>
      <url>/2018/11/29/reprint_jvm/jcmd.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2018-08-18%E4%B8%8A%E6%B5%B7%E5%A4%96%E6%BB%A9.jpg" alt><br><strong>jcmd</strong> 是 JDK1.7 之后出的命令行工具，如果你是 JDK1.7 之后的项目，建议你用 jcmd 替换掉 jps。<br>你可以使用它来查看堆信息：<code>jcmd pid GC.heap_dump</code><br>也可以用来查看当前所有的 VM 虚拟机：<code>jcmd -l</code><br>以及还有当前 VM 虚拟机的参数信息：<code>jcmd PID VM.flags</code><br>具体更多命令：<code>jcmd help</code> <code>jcmd PID help</code></p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>在JDK1.7以后，新增了一个命令行工具 jcmd。他是一个多功能的工具，可以用它来导出堆、查看Java进程、导出线程信息、执行GC、还可以进行采样分析（jmc 工具的飞行记录器）。</p><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2 命令格式"></a>2 命令格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid | main class&gt; &lt;command ... | PerfCounter.print | -f  file&gt;</span><br><span class="line">jcmd -l</span><br><span class="line">jcmd -h</span><br></pre></td></tr></table></figure><h2 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h2><ul><li>pid：接收诊断命令请求的进程ID。  </li><li>main class ：接收诊断命令请求的进程的main类。匹配进程时，main类名称中包含指定子字符串的任何进程均是匹配的。如果多个正在运行的Java进程共享同一个main类，诊断命令请求将会发送到所有的这些进程中。  </li><li>command：接收诊断命令请求的进程的main类。匹配进程时，main类名称中包含指定子字符串的任何进程均是匹配的。如果多个正在运行的Java进程共享同一个main类，诊断命令请求将会发送到所有的这些进程中。</li></ul><blockquote><p>注意: 如果任何参数含有空格，你必须使用英文的单引号或双引号将其包围起来。 此外，你必须使用转义字符来转移参数中的单引号或双引号，以阻止操作系统shell处理这些引用标记。当然，你也可以在参数两侧加上单引号，然后在参数内使用双引号(或者，在参数两侧加上双引号，在参数中使用单引号)。</p></blockquote><ul><li><p>Perfcounter.print：打印目标Java进程上可用的性能计数器。性能计数器的列表可能会随着Java进程的不同而产生变化。</p></li><li><p>-f file：从文件file中读取命令，然后在目标Java进程上调用这些命令。在file中，每个命令必须写在单独的一行。以”#”开头的行会被忽略。当所有行的命令被调用完毕后，或者读取到含有stop关键字的命令，将会终止对file的处理。</p></li><li><p>-l：查看所有的进程列表信息。</p></li><li><p>-h：查看帮助信息。（同 -help）</p></li></ul><h1 id="3-查看进程"><a href="#3-查看进程" class="headerlink" title="3. 查看进程"></a>3. 查看进程</h1><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd -l</span><br></pre></td></tr></table></figure></p><h2 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h2><p>查看 当前机器上所有的 jvm 进程信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jcmd </span><br><span class="line">jcmd -l</span><br><span class="line">jps</span><br></pre></td></tr></table></figure></p><p>这三个命令的效果是一样的</p><h1 id="4-查看性能统计"><a href="#4-查看性能统计" class="headerlink" title="4 查看性能统计"></a>4 查看性能统计</h1><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd pid PerfCounter.print</span><br></pre></td></tr></table></figure></p><h2 id="4-1-描述"><a href="#4-1-描述" class="headerlink" title="4.1 描述"></a>4.1 描述</h2><p>查看指定进程的性能统计信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;jcmd 9592 PerfCounter.print</span><br><span class="line">9592:</span><br><span class="line">java.ci.totalTime=16704</span><br><span class="line">java.cls.loadedClasses=438</span><br><span class="line">java.cls.sharedLoadedClasses=0</span><br><span class="line">java.cls.sharedUnloadedClasses=0</span><br><span class="line">java.cls.unloadedClasses=0</span><br><span class="line">java.property.java.class.path=&quot;D:\work\git\test\target\classes&quot;</span><br><span class="line">java.property.java.endorsed.dirs=&quot;D:\Program Files\Java\jre1.8.0_91\lib\endorsed&quot;</span><br><span class="line">java.property.java.ext.dirs=&quot;D:\Program Files\Java\jre1.8.0_91\lib\ext;C:\Windows\Sun\Java\lib\ext&quot;</span><br><span class="line">java.property.java.home=&quot;D:\Program Files\Java\jre1.8.0_91&quot;</span><br></pre></td></tr></table></figure></p><h1 id="5-列出当前运行的-java-进程可以执行的操作"><a href="#5-列出当前运行的-java-进程可以执行的操作" class="headerlink" title="5 列出当前运行的 java 进程可以执行的操作"></a>5 列出当前运行的 java 进程可以执行的操作</h1><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd PID help</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;jcmd 9592 help</span><br><span class="line">9592:</span><br><span class="line">The following commands are available:</span><br><span class="line">JFR.stop</span><br><span class="line">JFR.start</span><br><span class="line">JFR.dump</span><br><span class="line">JFR.check</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.check_commercial_features</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br></pre></td></tr></table></figure><p>查看具体命令的选项<br>如果想查看命令的选项，比如想查看 JFR.dump 命令选项，可以通过如下命令:<br><code>jcmd 11772 help JFR.dump</code></p><h1 id="6-JRF"><a href="#6-JRF" class="headerlink" title="6 JRF"></a>6 JRF</h1><h2 id="6-1-JRF-相关命令"><a href="#6-1-JRF-相关命令" class="headerlink" title="6.1 JRF 相关命令"></a>6.1 JRF 相关命令</h2><p>JRF 功能跟 jmc.exe 工具的飞行记录器的功能一样的。<br>要使用 JRF 相关的功能，必须使用 VM.unlock_commercial_features 参数取消锁定商业功能 。</p><p>jmc.exe 显示的提示<br>启动JFR<br>执行命令：jcmd $PID JFR.start name=abc,duration=120s</p><p>Dump JFR<br>等待至少duration（本文设定120s）后，执行命令：jcmd PID JFR.dump name=abc,duration=120s filename=abc.jfr（注意，文件名必须为.jfr后缀）</p><p>检查JFR状态<br>执行命令：jcmd $PID JFR.check name=abc,duration=120s</p><p>停止JFR<br>执行命令：jcmd $PID JFR.stop name=abc,duration=120s</p><p>JMC分析<br>切回开发机器，下载步骤3中生成的abc.jfr，打开jmc，导入abc.jfr即可进行可视化分析</p><h1 id="7-VM-uptime"><a href="#7-VM-uptime" class="headerlink" title="7 VM.uptime"></a>7 VM.uptime</h1><p>命令：jcmd PID VM.uptime<br>描述：查看 JVM 的启动时长：</p><h1 id="8-GC-class-histogram"><a href="#8-GC-class-histogram" class="headerlink" title="8 GC.class_histogram"></a>8 GC.class_histogram</h1><p>命令：jcmd PID GC.class_histogram<br>描述：查看系统中类统计信息</p><p>这里和jmap -histo pid的效果是一样的<br>这个可以查看每个类的实例数量和占用空间大小。</p><h1 id="9-Thread-print"><a href="#9-Thread-print" class="headerlink" title="9 Thread.print"></a>9 Thread.print</h1><p>命令：jcmd PID Thread.print<br>描述：查看线程堆栈信息。</p><p>该命令同 jstack 命令。</p><h1 id="10-GC-heap-dump"><a href="#10-GC-heap-dump" class="headerlink" title="10 GC.heap_dump"></a>10 GC.heap_dump</h1><p>命令：jcmd PID GC.heap_dump FILE_NAME<br>描述：查看 JVM 的Heap Dump</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 GC.heap_dump d:\dump.hprof</span><br><span class="line">10576:</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>跟 jmap命令：jmap -dump:format=b,file=heapdump.phrof pid 效果一样。<br>导出的 dump 文件，可以使用MAT 或者 Visual VM 等工具进行分析。</p><p>注意：如果只指定文件名，默认会生成在启动 JVM 的目录里。</p><h1 id="11-VM-system-properties"><a href="#11-VM-system-properties" class="headerlink" title="11 VM.system_properties"></a>11 VM.system_properties</h1><p>命令：jcmd PID VM.system_properties<br>描述：查看 JVM 的属性信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 VM.system_properties</span><br><span class="line">10576:</span><br><span class="line">#Wed Jan 31 22:30:20 CST 2018</span><br><span class="line">java.vendor=Oracle Corporation</span><br><span class="line">osgi.bundles.defaultStartLevel=4</span><br><span class="line">......</span><br><span class="line">os.version=10.0</span><br><span class="line">osgi.arch=x86_64</span><br><span class="line">path.separator=;</span><br><span class="line">java.vm.version=25.91-b15</span><br><span class="line">org.osgi.supports.framework.fragment=true</span><br><span class="line">user.variant=</span><br><span class="line">osgi.framework.shape=jar</span><br><span class="line">java.awt.printerjob=sun.awt.windows.WPrinterJob</span><br><span class="line">osgi.instance.area.default=file\:/C\:/Users/jjs/eclipse-workspace/</span><br><span class="line">sun.io.unicode.encoding=UnicodeLittle</span><br><span class="line">org.osgi.framework.version=1.8.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="12-VM-flags"><a href="#12-VM-flags" class="headerlink" title="12 VM.flags"></a>12 VM.flags</h1><p>命令：jcmd PID VM.flags<br>描述：查看 JVM 的启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 VM.flags</span><br><span class="line">10576:</span><br><span class="line">-XX:CICompilerCount=3 -XX:ConcGCThreads=1 </span><br><span class="line">-XX:G1HeapRegionSize=1048576 -XX:InitialHeapSize=268435456 </span><br><span class="line">-XX:MarkStackSize=4194304 -XX:MaxHeapSize=1073741824 </span><br><span class="line">-XX:MaxNewSize=643825664 -XX:MinHeapDeltaBytes=1048576 </span><br><span class="line">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class="line">-XX:+UseFastUnorderedTimeStamps -XX:+UseG1GC </span><br><span class="line">-XX:-UseLargePagesIndividualAllocation -XX:+UseStringDeduplication</span><br><span class="line">VM.command_line</span><br></pre></td></tr></table></figure><h1 id="13-命令：jcmd-PID-VM-command-line"><a href="#13-命令：jcmd-PID-VM-command-line" class="headerlink" title="13 命令：jcmd PID VM.command_line"></a>13 命令：jcmd PID VM.command_line</h1><p>描述：查看 JVM 的启动命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 VM.command_line</span><br><span class="line">10576:</span><br><span class="line">VM Arguments:</span><br><span class="line">jvm_args: -Dosgi.requiredJavaVersion=1.8 </span><br><span class="line">-Dosgi.instance.area.default=@user.home/eclipse-workspace </span><br><span class="line">-XX:+UseG1GC -XX:+UseStringDeduplication </span><br><span class="line">-Dosgi.requiredJavaVersion=1.8 -Xms256m -Xmx1024m</span><br><span class="line">java_command: &lt;unknown&gt;</span><br><span class="line">java_class_path (initial): D:\tool\...\org.eclipse.equinox.launcher.jar</span><br></pre></td></tr></table></figure><h1 id="14-GC-run-finalization"><a href="#14-GC-run-finalization" class="headerlink" title="14 GC.run_finalization"></a>14 GC.run_finalization</h1><p>命令：jcmd PID GC.run_finalization<br>描述： 对 JVM 执行 java.lang.System.runFinalization()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 GC.run_finalization</span><br><span class="line">10576:</span><br><span class="line">Command executed successfully</span><br></pre></td></tr></table></figure><p>执行一次finalization操作，相当于执行java.lang.System.runFinalization()</p><h1 id="15-GC-run"><a href="#15-GC-run" class="headerlink" title="15 GC.run"></a>15 GC.run</h1><p>命令：jcmd PID GC.run<br>描述：对 JVM 执行 java.lang.System.gc()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 GC.run</span><br><span class="line">10576:</span><br><span class="line">Command executed successfully</span><br></pre></td></tr></table></figure><p>告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的。</p><h1 id="16-PerfCounter-print"><a href="#16-PerfCounter-print" class="headerlink" title="16 PerfCounter.print"></a>16 PerfCounter.print</h1><p>命令：jcmd PID PerfCounter.print<br>描述：查看 JVM 性能相关的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 PerfCounter.print</span><br><span class="line">10576:</span><br><span class="line">java.ci.totalTime=93024843</span><br><span class="line">java.cls.loadedClasses=18042</span><br><span class="line">java.cls.sharedLoadedClasses=0</span><br><span class="line">java.cls.sharedUnloadedClasses=0</span><br><span class="line">java.cls.unloadedClasses=3</span><br></pre></td></tr></table></figure><h1 id="17-VM-version"><a href="#17-VM-version" class="headerlink" title="17 VM.version"></a>17 VM.version</h1><p>命令：jcmd PID VM.version<br>描述：查看目标jvm进程的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\jjs&gt;jcmd 10576 VM.version</span><br><span class="line">10576:</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM version 25.91-b15</span><br><span class="line">JDK 8.0_91</span><br></pre></td></tr></table></figure><p><strong>上文转载自：[jijs | jvm 性能调优工具之 jcmd][00]</strong></p><h1 id="18-总结"><a href="#18-总结" class="headerlink" title="18 总结"></a>18 总结</h1><p>参数用的最多还是 <code>jcmd -l</code>、<code>jcmd PID GC.heap_dump dump.hprof</code>、<code>jstat -gc PID 5000</code></p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>七、堆内存最佳实践</title>
      <link href="/2018/11/29/theory/java_performance_the_definitive_guide/7_heap.html/"/>
      <url>/2018/11/29/theory/java_performance_the_definitive_guide/7_heap.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2016-10-05%E5%B8%B8%E5%B7%9E%E6%81%90%E9%BE%99%E5%9B%AD.jpg" alt></p><a id="more"></a><p>这些工具能帮助我们理解堆内正在发生什么</p><hr><h1 id="1-堆分析"><a href="#1-堆分析" class="headerlink" title="1 堆分析"></a>1 堆分析</h1><h2 id="1-1-堆直方图"><a href="#1-1-堆直方图" class="headerlink" title="1.1 堆直方图"></a>1.1 堆直方图</h2><p>具体使用了 JCMD 命令，使用 <code>jcmd -l</code> 查看当前运行的 JVM 的所有进程，进而获取 PID。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/7_1.png" alt="jcmd"></p><p><code>jcmd pid GC.class_histogram</code>：查看系统中类统计信息。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/7_2.png" alt="GC.class_histogram"></p><h2 id="1-2-堆转储"><a href="#1-2-堆转储" class="headerlink" title="1.2 堆转储"></a>1.2 堆转储</h2><p><code>jcm pid GC.heap_dump /path/fileName.hprof</code><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/7_3.png" alt="GC.heap_dump"><br>接着使用 MAT 来进行分析</p><h2 id="1-3-内存溢出错误"><a href="#1-3-内存溢出错误" class="headerlink" title="1.3 内存溢出错误"></a>1.3 内存溢出错误</h2><p>OOM的几种原因：</p><ol><li>JVM 没有原生内存可用。</li><li>永久代/元空间内存不足。</li><li>Java 堆本身内存不足，对于给定的堆空间而言，应用中活跃对象太多。</li><li>JVM 执行 GC 耗时太多。</li></ol><h3 id="1-3-1-原生内存不足"><a href="#1-3-1-原生内存不足" class="headerlink" title="1.3.1 原生内存不足"></a>1.3.1 原生内存不足</h3><p>例如系统最大内存是 4G，然而 JVM 超过了这个限制就会出现这个异常：<br><code>unable to create new native thread</code></p><h3 id="1-3-2-永久代-元空间不足"><a href="#1-3-2-永久代-元空间不足" class="headerlink" title="1.3.2 永久代/元空间不足"></a>1.3.2 永久代/元空间不足</h3><p>第一种可能是使用的类太多，这时候可以增加元空间的最大大小来解决这个问题。<br>第二种是类加载器没有被卸载，一般在服务器环境中易出现（Tomcat）。<br><code>java.lang.OutOfMemoryError: PermGen space</code></p><h3 id="1-3-3-堆内存不足"><a href="#1-3-3-堆内存不足" class="headerlink" title="1.3.3 堆内存不足"></a>1.3.3 堆内存不足</h3><p>可以增加堆最大内存大小，但是如果是出现内存泄漏，仍然在以后的某个时间点会发生。<br><code>java.lang.OutOfMemoryError: Java heap sapce</code></p><blockquote><p>-XX:HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=<path><br>-XX:HeapDumpAfterFullGC<br>-XX:HeapDumpBeforeFullGC</path></p></blockquote><h3 id="1-3-4-达到-GC-的开销"><a href="#1-3-4-达到-GC-的开销" class="headerlink" title="1.3.4 达到 GC 的开销"></a>1.3.4 达到 GC 的开销</h3><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code><br>这个条件比较苛刻，需要满足以下条件：</p><ol><li>Full GC 时间超过了 98% 的时间。</li><li>Full GC 回收的内存量不足堆 2%。</li><li>上面两个条件连续 5次 Full GC 都成立。</li><li>-XX:UseGCOverhead-Limit 标志位为 true（默认值）。</li></ol><h1 id="2-减少内存使用"><a href="#2-减少内存使用" class="headerlink" title="2 减少内存使用"></a>2 减少内存使用</h1><h2 id="2-1-减少对象大小"><a href="#2-1-减少对象大小" class="headerlink" title="2.1 减少对象大小"></a>2.1 减少对象大小</h2><p>常见的八大基本类型大小</p><blockquote><p>但是 JVM 会对类的大小自动对齐，使其为 8字节 的倍数。</p></blockquote><h2 id="2-2-延迟初始化"><a href="#2-2-延迟初始化" class="headerlink" title="2.2 延迟初始化"></a>2.2 延迟初始化</h2><p>常见的集合类，在初始化时就使用了部门变量延迟初始化，只有你在使用时才会进行初始。</p><blockquote><p>但是如果是线程安全的类，最好不要使用延迟初始化，不然要使用双重锁检查，例如单例模式的双重锁实现例子。</p></blockquote><h2 id="2-3-不可变对象和标准对象"><a href="#2-3-不可变对象和标准对象" class="headerlink" title="2.3 不可变对象和标准对象"></a>2.3 不可变对象和标准对象</h2><p>例如 Boolean 变量，其实只需要 FALSE 和 TRUE，但是实际开发会在各个地方进行初始化，优化的手段是，将其变成两个不可变对象，每个使用的地方都可以引用。</p><h2 id="2-4-字符串的保留"><a href="#2-4-字符串的保留" class="headerlink" title="2.4 字符串的保留"></a>2.4 字符串的保留</h2><p>例如 String 是不可变对象，如果有很多都是相同的 String 字符串，通过保留字符串可以节省内存。例如 <code>intern()</code></p><blockquote><p>注意：保留字符串的表时保存在原生内存中，是个固定的 hashtable，JDK7 前默认 1009，之后是 60013。它是在 JVM 就创建了固定的大小。</p></blockquote><h1 id="3-对象生命周期管理"><a href="#3-对象生命周期管理" class="headerlink" title="3 对象生命周期管理"></a>3 对象生命周期管理</h1><h2 id="3-1-对象重用"><a href="#3-1-对象重用" class="headerlink" title="3.1 对象重用"></a>3.1 对象重用</h2><h3 id="3-1-1-对象池"><a href="#3-1-1-对象池" class="headerlink" title="3.1.1 对象池"></a>3.1.1 对象池</h3><ol><li>原生 NIO 缓存区（Netty 使用了池）</li><li>线程池</li><li>大数组</li><li>安全相关类（Signature）</li><li>StringBuilder</li></ol><p>但是对象池会对 GC 有很大影响，同时也有同步问题。</p><h3 id="3-1-2-线程局部变量"><a href="#3-1-2-线程局部变量" class="headerlink" title="3.1.2 线程局部变量"></a>3.1.2 线程局部变量</h3><ol><li>好处在于不需要考虑同步的问题。</li><li>但是一般线程局部变量和其线程有对应关系。</li></ol><h2 id="3-2-弱引用、软引用和其它引用"><a href="#3-2-弱引用、软引用和其它引用" class="headerlink" title="3.2 弱引用、软引用和其它引用"></a>3.2 弱引用、软引用和其它引用</h2><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h1>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java性能权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二十一、服务化最佳实践</title>
      <link href="/2018/06/22/theory/distributed_principle_prictice/21.html/"/>
      <url>/2018/06/22/theory/distributed_principle_prictice/21.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2018-06-22%E4%B9%A6%E6%A1%8C.jpg" alt></p><a id="more"></a><p>选取最合适的服务组合</p><hr><h1 id="1-性能和时延问题"><a href="#1-性能和时延问题" class="headerlink" title="1 性能和时延问题"></a>1 性能和时延问题</h1><p>由本地 API 调用变为远程网络通信，增加了额外的性能损耗。</p><h2 id="1-1-RPC-框架高性能设计"><a href="#1-1-RPC-框架高性能设计" class="headerlink" title="1.1 RPC 框架高性能设计"></a>1.1 RPC 框架高性能设计</h2><ol><li>I/O 调度模型</li><li>序列化框架</li><li>线程调度模型：并行/无锁化算法</li></ol><h3 id="1-1-1-I-O-调度模型"><a href="#1-1-1-I-O-调度模型" class="headerlink" title="1.1.1 I/O 调度模型"></a>1.1.1 I/O 调度模型</h3><p>使用 Netty，它在各种 NIO 框架中性能排名第一：</p><ol><li>零拷贝：使用堆外内存。</li><li>内存池：使用堆外内存池。</li><li>无锁化的串行设计：尽量局部无锁化的串行线程。</li><li>高效并发编程：Volatile、CAS。</li></ol><h3 id="1-1-2-序列化框架"><a href="#1-1-2-序列化框架" class="headerlink" title="1.1.2 序列化框架"></a>1.1.2 序列化框架</h3><p>二进制序列化框架</p><h3 id="1-1-3-高性能的-Reactor-线程模型"><a href="#1-1-3-高性能的-Reactor-线程模型" class="headerlink" title="1.1.3 高性能的 Reactor 线程模型"></a>1.1.3 高性能的 Reactor 线程模型</h3><ol><li>专门的 NIO 线程：Acceptor 线程用于监听服务端，接受客户端的 TCP 连接请求。</li><li>网络 I/O 操作：读、写等由一个 NIO 线程池负责。</li><li>1 个 NIO 线程可以同时处理 N 条链路（epoll）。</li></ol><h2 id="1-2-业务最佳实践"><a href="#1-2-业务最佳实践" class="headerlink" title="1.2 业务最佳实践"></a>1.2 业务最佳实践</h2><ol><li>能异步的尽可能使用异步或并行服务调用。</li><li>线程池的参数配置必须合理（上下文切换损耗）。</li><li>尽量减少要传输的码流大小。</li><li>超时时间合理设置。</li><li>核心服务独立线程池。</li><li>利用 Docker 做物理资源层隔离。</li></ol><h1 id="2-事务一致性问题"><a href="#2-事务一致性问题" class="headerlink" title="2 事务一致性问题"></a>2 事务一致性问题</h1><h2 id="2-1-分布式事务设计方案"><a href="#2-1-分布式事务设计方案" class="headerlink" title="2.1 分布式事务设计方案"></a>2.1 分布式事务设计方案</h2><p>使用两阶段提交（具体参考 Paxos协议）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_1.png" alt><br>阶段一：全局事务管理器向所有事务参与者发送准备请求：事务参与者向全局事务管理器恢复自己是否准备就绪。<br>阶段二：全局事务管理器接收到所有事务参与者的回复之后做判断，如果所有事务参与者都可以提交，则向所有事务提交者发送提交申请，否则进行回滚。事务参与者根据全局事务管理器的指令进行提交或者回滚操作。</p><h2 id="2-2-分布式事务优化"><a href="#2-2-分布式事务优化" class="headerlink" title="2.2 分布式事务优化"></a>2.2 分布式事务优化</h2><p>在大多数的业务场景中，我们可以使用最终一致性替代传统的强一致性，尽量避免使用分布式事务。<br>在实践中常用的最终一致性方案就是使用带有事务功能的 MQ 做中间人角色，它的工作原理如下：在做本地事务之前，先向 MQ 发送一个 prepare 消息，然后执行本地事务，本地事务提交成功的话，向 MQ 发送一个 commit 消息，否则发送一个 rollback 消息，取消之前的消息。MQ 只会收到 commit 确认才会将消息投递出去，所以这样的形式可以保证在一切正常的情况下，本地事务和 MQ 可以达到一致性。但是分布式调用存在很多异常场景，例如网络超时、VM宕机等，假如系统执行了 local_tx() 成功之后，还没来及将 commit 消息发送给 MQ ，或者说发送出去由于网络超时等原因， MQ 没有收到 commit ，发生了 commit 消息丢失，那么 MQ 就不会把 prepare 消息投递出去。 MQ 会根据策略去尝试询问（回调）发消息的系统（checkCommit）进行检查该消息是否应该投递出去或者丢弃，得到系统的确认之后， MQ 会做投递还是丢弃，这样就完全保证了 MQ 和发消息的系统的一致性，从而保证了接收消息系统的一致性。</p><h1 id="3-研发团队协作问题"><a href="#3-研发团队协作问题" class="headerlink" title="3 研发团队协作问题"></a>3 研发团队协作问题</h1><h2 id="3-1-共用服务注册中心"><a href="#3-1-共用服务注册中心" class="headerlink" title="3.1 共用服务注册中心"></a>3.1 共用服务注册中心</h2><p>为了方便开发测试，经常会在线下共用一个所有服务贡献过得服务注册中心，这时，一个正在开发中的服务发布到服务注册中心，可能会导致一些消费者不可用。<br>解决方案：可以让服务提供者开发方，只订阅服务（开发的服务可能依赖其它服务），而不注册正在开发的服务，通过直连测试正在开发的服务。工作原理图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/21_2.png" alt></p><h2 id="3-2-直连提供者"><a href="#3-2-直连提供者" class="headerlink" title="3.2 直连提供者"></a>3.2 直连提供者</h2><p>如果服务提供者多实例部署，但是服务提供者存在 BUG，就需要做远程端点调试，这会带来两个问题：  </p><ol><li>调试过程中可能被其它消费者消费。</li><li>服务提供者多实例部署，远程调试地址无法确定，调试效率低。</li></ol><p>解决策略：直连指定服务提供者。</p><h2 id="3-3-多团队进度协同"><a href="#3-3-多团队进度协同" class="headerlink" title="3.3 多团队进度协同"></a>3.3 多团队进度协同</h2><p>假如前端 Web 门户依赖后台 A/B/C/D 4 个服务，分别由 4 个不同的研发团队负责，门户要求新特性 2 周内上线。 A/B 可以按期，但是 C/D 由于有其它更高优先级的任务，只能延期。导致依赖的服务越多，交付效率越低。<br>解决策略：调用链将应用、服务、中间件之间的依赖关系串接并展示出来，基于调用链首入口的交付时间做输入，利用依赖管理工具，自动计算出调用链上各个服务的最迟交付时间点，避免人为需求排序失误导致的需求延期。</p><h2 id="3-4-服务降级和-Mock-测试"><a href="#3-4-服务降级和-Mock-测试" class="headerlink" title="3.4 服务降级和 Mock 测试"></a>3.4 服务降级和 Mock 测试</h2><h2 id="3-5-协同调试问题"><a href="#3-5-协同调试问题" class="headerlink" title="3.5 协同调试问题"></a>3.5 协同调试问题</h2><p>当依赖的服务尚未开发完成，将路由切换到模拟测试模式，自动调用 Mock 桩。上线时自动切换到真实的服务提供者。</p><h2 id="3-6-接口前后兼容性"><a href="#3-6-接口前后兼容性" class="headerlink" title="3.6 接口前后兼容性"></a>3.6 接口前后兼容性</h2><ol><li>严格遵守兼容性代码规范，文档实时同步更新通知。</li></ol><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>事务一致性问题、测试效率问题、依赖开发等，这只列举了部分问题，还有更多的问题需要在实践中探索，找出适合自己产品的服务化最佳实践。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二十、微服务架构</title>
      <link href="/2018/06/21/distributed_principle_prictice/20.html/"/>
      <url>/2018/06/21/distributed_principle_prictice/20.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微服务架构产生的历史背景"><a href="#1-微服务架构产生的历史背景" class="headerlink" title="1 微服务架构产生的历史背景"></a>1 微服务架构产生的历史背景</h1><h2 id="1-1-研发成本挑战"><a href="#1-1-研发成本挑战" class="headerlink" title="1.1 研发成本挑战"></a>1.1 研发成本挑战</h2><h3 id="1-1-1-代码重复率"><a href="#1-1-1-代码重复率" class="headerlink" title="1.1.1 代码重复率"></a>1.1.1 代码重复率</h3><ol><li>从技术架构角度看，传统垂直架构的特点是本地 API 接口调用，不存在业务的拆分和互相调用，使用到什么功能就本地开发，非常方便，不需要过度依赖于其它功能模块。</li><li>跨地域、跨开发小组协调很困难。</li></ol><h3 id="1-1-2-需求变更困难"><a href="#1-1-2-需求变更困难" class="headerlink" title="1.1.2 需求变更困难"></a>1.1.2 需求变更困难</h3><p>代码重复率变高之后，已有功能变更或者新需求加入都会非常困难，以充值缴费功能为例，不同的充值渠道开发了相同的限额保护功能，当限额保护功能发生变更之后，所有重复开发的限额保护功能都需要重新修改和测试，很容易出现修改不一致或者被遗漏，导致部分渠道充值功能正常：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_1.png" alt><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_2.png" alt></p><h2 id="1-2-运维成本高"><a href="#1-2-运维成本高" class="headerlink" title="1.2 运维成本高"></a>1.2 运维成本高</h2><h3 id="1-2-1-代码维护困难"><a href="#1-2-1-代码维护困难" class="headerlink" title="1.2.1 代码维护困难"></a>1.2.1 代码维护困难</h3><p>传统的业务流程是由一长串本地接口或者方法调用串联起来的，而且往往由一个负责开发和维护。随着业务的发展和需求变化，本地diamante在不断地迭代和变更，最后形成了一个个垂直的功能孤岛，只有原来的开发者才理解接口调用关系和功能需求，一旦原来的开发者离职或调到其它项目组，这些功能模块的运维就会变得非常困难：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_3.png" alt></p><h3 id="1-2-2-部署效率低"><a href="#1-2-2-部署效率低" class="headerlink" title="1.2.2 部署效率低"></a>1.2.2 部署效率低</h3><ol><li>业务没有拆分，很多功能模块都打到同一个 war 包中，一旦有一个功能发生变更，就需要重新打包和部署。</li><li>测试工作量较大，因此存在大量重复的功能类库，需要针对所有调用方进行测试，测试工作量大。</li></ol><h2 id="1-3-新需求上线周期长"><a href="#1-3-新需求上线周期长" class="headerlink" title="1.3 新需求上线周期长"></a>1.3 新需求上线周期长</h2><ol><li>新功能通常无法独立编译、打包、部署和上线，它可能混杂在老的系统中开发，很难剥离出来，这就无法通过服务灰度发布的形式快速上线。</li><li>由于业务没有进行水平和垂直拆分，导致代码重复率高，新需求的开发、测试、打包和部署成本都比较高。</li></ol><h1 id="2-微服务架构带来的改变"><a href="#2-微服务架构带来的改变" class="headerlink" title="2 微服务架构带来的改变"></a>2 微服务架构带来的改变</h1><h2 id="2-1-应用解耦"><a href="#2-1-应用解耦" class="headerlink" title="2.1 应用解耦"></a>2.1 应用解耦</h2><p>微服务化之前，一个大型的应用系统通常会包含多个子应用，不同应用之间存在很多重复的公共代码，所有应用共用一套数据库，架构图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_4.png" alt><br>将功能A 和功能B 服务化之后，应用作为消费者直接调用服务A 和服务B ，这样就实现了对原有重复代码的收编，同时系统之间的调用关系也更加清晰，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_5.png" alt><br>基于服务注册中心的定于发布机制，实现服务消费者和提供者之间的解耦。</p><h2 id="2-2-分而治之"><a href="#2-2-分而治之" class="headerlink" title="2.2 分而治之"></a>2.2 分而治之</h2><p>将核心业务抽取出来，作为独立的服务，逐渐形成稳定的底层微服务。<br>应用的拆分分为水平拆分和垂直拆分两种，水平拆分以业务领域为维度，抽象出几个不同的业务域，每个业务域作为一个独立的服务中心对外提供服务。领域服务可以独立地伸缩和升级，快速地响应需求变化，同时与其它业务领域解耦。原理图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_6.png" alt><br>应用的垂直拆分主要包括前后台逻辑拆分、业务逻辑和数据访问层拆分，拆分之后的效果图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_7.png" alt></p><h2 id="2-3-敏捷交付"><a href="#2-3-敏捷交付" class="headerlink" title="2.3 敏捷交付"></a>2.3 敏捷交付</h2><p>敏捷性的产生，是将运行中的系统解耦为一系列功能单一服务的结果。微服务架构能够对系统中其它部分的依赖加以限制，这种特性能够让基于微服务架构的应用在应对 BUG 或是对新特性需求时，能够快速地进行变更。而传统的垂直架构：“要对应用程序中某个小部分进行变更，就必须对整体架构进行重新编译和构建，并且重新进行全量部署。”</p><h1 id="3-微服务架构解析"><a href="#3-微服务架构解析" class="headerlink" title="3 微服务架构解析"></a>3 微服务架构解析</h1><p>微服务架构（MSA）是一种架构风格，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。对比图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_8.png" alt></p><h2 id="3-1-微服务划分原则"><a href="#3-1-微服务划分原则" class="headerlink" title="3.1 微服务划分原则"></a>3.1 微服务划分原则</h2><p>通用的划分原则是：微服务通常是简单、原子的微型服务，它的功能单一，只负责处理一件事，与代码行数并没有直接关系，与需要处理的业务复杂度有关。有些复杂的功能，尽管功能单一，但是代码量可能成百上千行，因此不能以代码量作为划分微服务的维度。  </p><p>“微”所表达的是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。</p><h2 id="3-2-开发微服务"><a href="#3-2-开发微服务" class="headerlink" title="3.2 开发微服务"></a>3.2 开发微服务</h2><p>对于不同的微服务，虽然实现逻辑不同，但是开发方式、持续集成环境、测试策略和部署机制以及后续的上线运维都是类似的，为了满足 DRY 原则并消除浪费，需要搭建统一的开发打包和持续集成环境。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_9.png" alt></p><h2 id="3-3-基于-Docker-容器部署微服务"><a href="#3-3-基于-Docker-容器部署微服务" class="headerlink" title="3.3 基于 Docker 容器部署微服务"></a>3.3 基于 Docker 容器部署微服务</h2><p>Docker 是一套开源工具，它能够以某种方式对现有的基于容器的虚拟化技术进行封装，使得它能够在更广阔的工程社区中得到应用，主要在于快速和可移植性。</p><h3 id="3-3-1-快速"><a href="#3-3-1-快速" class="headerlink" title="3.3.1 快速"></a>3.3.1 快速</h3><p>普通的虚拟机在每次开机时都需要启动一个完整的新操作系统实例，而 Docker 容器能够通过内核共享的方式，共享一套托管操作系统。这意味着，Docker 容器的启动和停止只需要几百毫秒。这样就有更高的敏捷性。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/20_10.png" alt><br>物理机 VS Docker VS 虚拟机 </p><h3 id="3-3-2-可移植性"><a href="#3-3-2-可移植性" class="headerlink" title="3.3.2 可移植性"></a>3.3.2 可移植性</h3><ol><li>线上线下环境等同性：本地模拟线上环境，定位 BUG 更快。</li><li>与特定的云提供商解耦：参考 JVM。</li><li>提升运维效率：Docker 对可移植的容器部署进行标准化，节省时间与精力。如果你在构建某个应用程序，你的选择包括物理机、虚拟化的本地基础设施、公有云和私有云，以及各种可用的 PaaS 选项。而通过 Docker 标准化的容器格式，任何一种提供商都可以实现一种统一的部署体验。</li><li>敏捷性：快速启动，更敏捷。</li></ol><h2 id="3-4-治理和运维微服务"><a href="#3-4-治理和运维微服务" class="headerlink" title="3.4 治理和运维微服务"></a>3.4 治理和运维微服务</h2><p>微服务架构对运维和部署流水线要求非常高，服务拆分的粒度越细，运维和治理成本就越高，挑战总结如下：  </p><ol><li>监控度量问题：海量微服务的各种维度性能 KPI 采集、汇总和分析，实时和历史数据同比和环比，对采集模块的实时性、汇总模块的计算能力、前端运维 Portal 多维度展示能力要求非常高。</li><li>分布式运维：服务拆分得越细，一个完整业务流程的调用链就越长，需要采集、汇总和计算的数据量就越大，分布式消息跟踪系统需要能够支撑大规模微服务化后带来的性能挑战。</li><li>海量微服务对服务注册中心的处理能力、通知的实时性也带来了巨大挑战。</li><li>微服务治理：微服务化之后，微服务相比于传统的 SOA 服务有了指数级增长，服务治理的展示界面、检索速度等需要能够支撑这种变化。</li><li>量变引起质变：当需要运维的服务规模达到一定上限后，就由量变引起质变，传统的运维框架架构可能无法支撑，需要重构。</li></ol><p>解决微服务运维的主要措施就是：分布式和自动化。利用分布式系统的性能线性增长和弹性扩容能力，支撑大规模微服务对运维系统带来的性能冲击，包括：  </p><ol><li>分布式性能数据采集、日志采集 Agent。</li><li>分布式汇总和计算框架。</li><li>分布式文件存储服务。</li><li>分布式日志检索服务。</li><li>分布式报表展示框架。</li></ol><h2 id="3-5-特点总结"><a href="#3-5-特点总结" class="headerlink" title="3.5 特点总结"></a>3.5 特点总结</h2><ol><li>单一职责原则：每个服务应该负责单独的功能。</li><li>独立部署、升级、扩展和替换。</li><li>支持异构/多语言。</li><li>轻量级。</li></ol><p>因此优点如下：  </p><ol><li>开发、测试和运维更加简单。</li><li>局部修改很容易部署，有利于持续集成和持续交付。</li><li>技术选择更灵活，不与特定语言和工具绑定。</li><li>有利于小团队作战，敏捷交付。</li></ol><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>微服务涉及到了组织架构、涉及、交付、运维等方面的变革，核心目标是为了解决系统的交付周期，降低维护成本和研发成本。<br>但是带来了运维成本、服务管理成本等。<br>不可脱离业务实际而强制使用微服务。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十九、可靠性设计</title>
      <link href="/2018/06/20/distributed_principle_prictice/19.html/"/>
      <url>/2018/06/20/distributed_principle_prictice/19.html/</url>
      
        <content type="html"><![CDATA[<p>相对于传统的本地 Java API 调用，跨进程的分布式服务调用面临的故障风险更高：  </p><ol><li>网络类故障：链路闪断、读写超时等。</li><li>序列化和反序列化失败。</li><li>畸形码流。</li><li>服务端流控和拥塞保护导致的服务调用失败。</li><li>其它异常。</li></ol><p>对于应用而言，分布式服务框架需要具备足够的健壮性，在平台底层能够拦截并向上屏蔽故障，业务只需要配置容错策略，即可实现高可靠性。</p><h1 id="1-服务状态监测"><a href="#1-服务状态监测" class="headerlink" title="1 服务状态监测"></a>1 服务状态监测</h1><p>在分布式服务调用时，某个服务提供者可能已经宕机，如果采用随机路由策略，消息会继续发送给已经宕机的服务提供者，导致消息发送失败。为了保证路由的正确性，消费者需要能够实时获取服务提供者的状态，当某个服务提供者不可用时，将它从缓存的路由表中删除掉，不再向其发送消息，直到对方恢复正常。</p><h2 id="1-1-基于服务注册中心状态监测"><a href="#1-1-基于服务注册中心状态监测" class="headerlink" title="1.1 基于服务注册中心状态监测"></a>1.1 基于服务注册中心状态监测</h2><p>以 ZooKeeper 为例，ZooKeeper 服务端利用与 ZooKeeper 客户端之间的长链接会话做心跳检测。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_1.png" alt></p><h2 id="1-2-链路有效性状态监测机制"><a href="#1-2-链路有效性状态监测机制" class="headerlink" title="1.2 链路有效性状态监测机制"></a>1.2 链路有效性状态监测机制</h2><p>分布式服务框架的服务消费者和提供者之间默认往往采用长链接，并且通过双向心跳检测保障链路的可靠性。<br>在一些特殊的场景中，服务提供者和注册中心之间网络可达，服务消费者和注册中心网络也可达，但是服务提供者和消费者之间网络不可达，或者服务提供者和消费者之间链路已经断连。此时，服务注册中心并不能检测到服务提供者异常，但是如果消费者仍旧向链路中断的提供者发送消息，写操作将会失败。  </p><p>为了解决该问题，通常需要使用服务注册中心检测 + 服务提供者和消费者之间的链路有效性检测双重检测来保障系统的可靠性，它工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_2.png" alt><br>当消费者通过双向心跳检测发现链路故障之后，会主动释放链接，并将对应的服务提供者从路由缓存表中删除。当链路恢复之后，重新将恢复的故障服务提供者地址信息加入地址缓存表中。</p><h1 id="2-服务健康度监测"><a href="#2-服务健康度监测" class="headerlink" title="2 服务健康度监测"></a>2 服务健康度监测</h1><p>在集群组网环境下，由于硬件性能差异、各服务提供者的负载不均等原因，如果采用随机路由分发策略，会导致负载较重的服务提供者不堪重负被压垮。<br>利用服务的健康度监测，可以对集群的所有服务实例进行体检，根据体检加过对健康度做打分，得分较低的亚健康服务节点，路由权重会被自动调低，发送到对应节点的消息会少很多。这样实现“能者多劳、按需分配”，实现更合理的资源分配和路由调度。  </p><p>服务的健康度监测通常需要采集如下性能 KPI 指标：  </p><ol><li>服务调用时延。</li><li>服务 QPS。</li><li>服务调用成功率。</li><li>基础资源使用情况，例如堆内存、CPU 使用率等。</li></ol><p>原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_3.png" alt></p><h1 id="3-服务故障隔离"><a href="#3-服务故障隔离" class="headerlink" title="3 服务故障隔离"></a>3 服务故障隔离</h1><p>分为四个层次：  </p><ol><li>进程级故障隔离</li><li>VM 级故障隔离</li><li>物理机故障隔离</li><li>机房故障隔离</li></ol><h2 id="3-1-进程级故障隔离"><a href="#3-1-进程级故障隔离" class="headerlink" title="3.1 进程级故障隔离"></a>3.1 进程级故障隔离</h2><p>个人理解为线程级。即通过将服务部署到不同的线程池实现故障隔离。对于订单、购物车等核心服务可以独立部署到一个线程池中，与其它服务做线程调度隔离。对于非核心服务，可以合设共享同一个/多个线程池，防止因为服务数过多导致线程数过度膨胀。  </p><p>服务发布的时候，可以指定服务发布到哪个线程池中，分布式服务框架拦截 Spring 容器的启动，解析 XML 标签，生成服务和线程池的映射关系，通信框架将解码后的消息投递到后端时，根据服务名选择对应的线程池，将消息投递到映射线程池的消息队列中。<br>原理图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_4.png" alt><br>如果故障服务发生了内存泄漏异常，它会导致整个进程不可用。</p><h2 id="3-2-VM-级故障隔离"><a href="#3-2-VM-级故障隔离" class="headerlink" title="3.2 VM 级故障隔离"></a>3.2 VM 级故障隔离</h2><p>将基础设施层虚拟化、服务化，将应用部署到不同的 VM 中，利用 VM 对资源层的隔离，实现高层次的服务故障隔离，工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_5.png" alt></p><h2 id="3-3-物理机故障隔离"><a href="#3-3-物理机故障隔离" class="headerlink" title="3.3 物理机故障隔离"></a>3.3 物理机故障隔离</h2><p>当组网规模足够大、硬件足够多的时候，硬件的故障就由小概率事件转变为普通事件。如何保证在物理机故障时，应用能够正常工作，是一个不小的挑战。<br>利用分布式服务框架的集群容错功能，可以实现位置无关的自动容错，工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_6.png" alt></p><p>如果要保证当前服务器宕机时不影响部署在上面运行的服务，需要采用分布式集群部署，而且要采用非亲和性安装：即服务实例需要部署到不同的物理机上，通常至少需要 3 台物理机，假如单台物理机的故障发生概率为 0.1 %，则 3 台同时发生故障的概率为 0.001%，服务的可靠性将会达到 99.999%，完全可以满足大多数应用场景的可靠性要求。<br>物理机故障重启之后，通过扩展插件通知 Watch Dog 重新将应用拉起，应用启动时会重新发布服务，服务发布成功之后，故障服务器节点就能重新恢复正常工作。 ·`      </p><h2 id="3-4-机房故障隔离"><a href="#3-4-机房故障隔离" class="headerlink" title="3.4 机房故障隔离"></a>3.4 机房故障隔离</h2><p>同城容灾时，都需要使用多个机房，下面针对跨机房的容灾和故障隔离方案进行探讨。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/19_7.png" alt><br>机房1 和机房2 对等部署了2套应用集群，每个机房部署一套服务注册中心集群，服务订阅和发布同时针对两个注册中心，对于机房1 或者机房2 的 Web 应用，可以同时看到两个机房的服务提供者列表。<br>理由时，优先访问同一个机房的服务提供者，当本机房的服务提供者大面积不可用或者全部不可用时，根据跨机房路由策略，访问另一个机房的服务提供者，待本机房服务提供者集群恢复到正常状态之后，重新切换到本机房访问模式。<br>当整个机房宕机之后，由前端的 SLB\F5 负载均衡器自动将流量切换到容灾机房，由于主机房整个瘫掉了，容灾机房的消费者通过服务状态监测将主机房的所有服务提供者从路由缓存表中删除，服务调用会自动切换到本机房调用模式，实现故障的自动容灾切换。  </p><p>上面的方案需要分布式服务框架支持多注册中心，同一个服务实例，可以同时注册到多个服务注册中心中，实现跨机房的服务调用。两个机房共用一套服务注册中心也可以，但是如果服务注册中心所在的机房整个宕掉，则分布式服务框架的服务注册中心将不可用。已有的服务调用不受影响，新的依赖服务注册中心的操作江辉失败，例如服务治理、运行期参数调整、服务的状态监测等功能将不可用。</p><h1 id="4-其它可靠性特性"><a href="#4-其它可靠性特性" class="headerlink" title="4 其它可靠性特性"></a>4 其它可靠性特性</h1><h2 id="4-1-服务注册中心"><a href="#4-1-服务注册中心" class="headerlink" title="4.1 服务注册中心"></a>4.1 服务注册中心</h2><p>服务注册中心需要采用对等集群设计，任意一台宕机之后，需要能够自动切换到下一台可用的注册中心。例如 ZooKeeper ，如果某个 Leader 节点宕机，通过选举算法会重新选举出一个新的 Leader，只要集群组网实例数不小于 3，整个集群就能够正常工作。</p><h2 id="4-2-监控中心"><a href="#4-2-监控中心" class="headerlink" title="4.2 监控中心"></a>4.2 监控中心</h2><p>监控中心集群宕机之后，只丢失部分采样数据，依赖性能 KPI 采样数据的服务健康度监测功能不能正常使用，服务提供者和消费者依然能够正常运行，业务不会中断。</p><h2 id="4-3-服务提供者"><a href="#4-3-服务提供者" class="headerlink" title="4.3 服务提供者"></a>4.3 服务提供者</h2><p>某个服务提供者宕机之后，利用集群容错策略，会舱室不同的容错恢复手段，例如使用 FailOver 容错策略，自动切换到下一个可用的服务，直到找到可用的服务为止。<br>如果整个服务提供者集群都宕机，可以利用服务放通、故障引流、容灾切换等手段。</p><h1 id="5-个人总结"><a href="#5-个人总结" class="headerlink" title="5 个人总结"></a>5 个人总结</h1><p>任何假设的宕机情况都会出现，解决手段不外乎：</p><ol><li>对等集群（例如跨机房）。</li><li>服务放通（远程错误直接切换为本地调用）。</li><li>隔离。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZK分布式锁</title>
      <link href="/2018/06/15/tech/zk_distribute_lock.html/"/>
      <url>/2018/06/15/tech/zk_distribute_lock.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0  前言"></a>0  前言</h1><p> 关于 ZooKeeper实现分布式锁，笔者在武汉小米一面（结果挂了）被问到过，因此记录如下。  </p><p>以下的理论知识源自<code>《 从Paxos到Zookeeper分布式一致性原理与实践 》</code>第六章，代码 完全根据书本理论进行实现，并且经多线程测试，在正常情况可行。  </p><p>源码：<a href="https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project" target="_blank" rel="noopener">https://github.com/LiWenGu/MySourceCode/tree/master/example/src/main/java/com/lwg/zk_project</a></p><h1 id="1-ZooKeeper实现排他锁"><a href="#1-ZooKeeper实现排他锁" class="headerlink" title="1 ZooKeeper实现排他锁"></a>1 ZooKeeper实现排他锁</h1><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>核心点：  </p><ol><li><code>抢占式创建相同名称的临时节点</code>，谁成功创建节点，则代表谁获得了锁。</li><li>没有创建成功该节点，并且该节点存在，则对该名称的节点进行删除监听。</li><li>如果该节点被删除了，则继续重复第 1步。</li></ol><h2 id="1-2-流程图"><a href="#1-2-流程图" class="headerlink" title="1.2 流程图"></a>1.2 流程图</h2><p>原书流程图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png" alt><br>我自己理解的流程：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_1.png" alt></p><h2 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h2><p>统一接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liwenguang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/6/15 下午9:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> liwenguang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2018/6/15 下午9:17</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取锁，默认等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">tryRead</span><span class="params">()</span> <span class="keyword">throws</span> ZkException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子类不支持"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> liwenguang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2018/6/15 下午9:18</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取锁，指定超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">tryRead</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子类不支持"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryWrite</span><span class="params">()</span> <span class="keyword">throws</span> ZkException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">tryWrite</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子类不支持"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> liwenguang</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2018/6/15 下午9:18</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> ZkException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGetLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.createEphemeral(EXCLUSIVE_LOCK_NAMESPACE + lockPath);</span><br><span class="line">            log.info(Thread.currentThread().getName() + <span class="string">"获取锁成功"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">            <span class="comment">// log.warn(Thread.currentThread().getName() + "获取锁失败");</span></span><br><span class="line">            <span class="keyword">if</span> (zkClient.exists(EXCLUSIVE_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class="line">                MyIZkDataListener myIZkChildListener = <span class="keyword">new</span> MyIZkDataListener(countDownLatch);</span><br><span class="line">                zkClient.subscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, myIZkChildListener);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里需要阻塞式通知，因此使用 countDownLatch实现</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"获取到了锁"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIZkDataListener</span> <span class="keyword">implements</span> <span class="title">IZkDataListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIZkDataListener</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//log.info(Thread.currentThread().getName() + "被回调了");</span></span><br><span class="line">        zkClient.unsubscribeDataChanges(EXCLUSIVE_LOCK_NAMESPACE + lockPath, <span class="keyword">this</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-ZooKeeper共享锁"><a href="#2-ZooKeeper共享锁" class="headerlink" title="2 ZooKeeper共享锁"></a>2 ZooKeeper共享锁</h1><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>核心点：  </p><ol><li>无论是读请求（读锁）还是写请求（写锁）都进行创建<code>顺序</code>临时节点，只看后缀的数字我们可以理解为 一种从小到大的队列（例：我们在做订单请求的时候，对订单A做创建-&gt;  支付-&gt; 完成三个操作，对应 ZK节点则节点A下有三个子节点，这时候节点A可以理解为一个队列）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_shared_lock_1.png" alt></li><li>创建完成之后，对读锁，则判断该队列之前是否有写锁，如果有写锁，则对写锁做删除监听。对写锁，判断队列之前是否有锁，如果有锁，则对序号最大的锁做删除监听。</li><li>删除监听触发，获取该锁节点下所有的子节点（一个节点即代表锁），重复第 2步。</li></ol><h2 id="2-2-流程图"><a href="#2-2-流程图" class="headerlink" title="2.2 流程图"></a>2.2 流程图</h2><p>原书流程图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png" alt><br>我自己理解的流程：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/zk_lock_2.png" alt></p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><p>核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryRead</span><span class="params">()</span> <span class="keyword">throws</span> ZkException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class="line">        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class="line">    &#125;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + <span class="string">"/"</span> + SHARED_READ_PRE, <span class="keyword">null</span>);</span><br><span class="line">    String curSequence = curNode.split(SHARED_READ_PRE)[<span class="number">1</span>];</span><br><span class="line">    log.info(curSequence + <span class="string">"创建读锁-R"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class="line">        <span class="comment">// 记录序号比自己小的写请求</span></span><br><span class="line">        List&lt;String&gt; writers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String brother : children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (brother.startsWith(SHARED_WRITE_PRE)) &#123;</span><br><span class="line">                String sequence = brother.split(SHARED_WRITE_PRE)[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (curSequence.compareTo(sequence) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    writers.add(brother);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (writers.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 没有比自己序号小的写请求，说明自己获取到了读锁</span></span><br><span class="line">            <span class="comment">//log.info(Thread.currentThread().getName() + "没有比自己序号小的写请求-R");</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取最近的那个写锁</span></span><br><span class="line">            String lastWriter = SHARED_LOCK_NAMESPACE + lockPath + <span class="string">"/"</span> + writers.get(writers.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 判断最近的那个写锁期间是否已经释放了</span></span><br><span class="line">            <span class="keyword">if</span> (zkClient.exists(lastWriter)) &#123;</span><br><span class="line">                MyReadIZkChildListener myReadIZkChildListener = <span class="keyword">new</span> MyReadIZkChildListener(lastWriter, countDownLatch);</span><br><span class="line">                zkClient.subscribeDataChanges(lastWriter, myReadIZkChildListener);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"获取到了锁-R"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReadIZkChildListener</span> <span class="keyword">implements</span> <span class="title">IZkDataListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastWriter;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyReadIZkChildListener</span><span class="params">(String lastWriter, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastWriter = lastWriter;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//log.info(Thread.currentThread().getName() + "比自己序号小的那个写请求被释放了-R");</span></span><br><span class="line">        zkClient.unsubscribeDataChanges(lastWriter, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 最近的那个写锁被释放了，但是不排除释放过程中，有其它写锁新加入，因此读锁需要重新获取列表</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryWrite</span><span class="params">()</span> <span class="keyword">throws</span> ZkException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!zkClient.exists(SHARED_LOCK_NAMESPACE + lockPath)) &#123;</span><br><span class="line">        zkClient.createPersistent(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class="line">    &#125;</span><br><span class="line">    curNode = zkClient.createEphemeralSequential(SHARED_LOCK_NAMESPACE + lockPath + <span class="string">"/"</span> + SHARED_WRITE_PRE, <span class="keyword">null</span>);</span><br><span class="line">    String curSequence = curNode.split(SHARED_WRITE_PRE)[<span class="number">1</span>];</span><br><span class="line">    log.info(curSequence + <span class="string">"创建写锁-W"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(SHARED_LOCK_NAMESPACE + lockPath);</span><br><span class="line">        <span class="comment">// 记录序号比自己小的请求</span></span><br><span class="line">        List&lt;String&gt; writersOrReader = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String brother : children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (brother.equals(SHARED_WRITE_PRE + curSequence)) &#123;</span><br><span class="line">                <span class="comment">// 排除自己</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String sequence = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (brother.contains(SHARED_WRITE_PRE)) &#123;</span><br><span class="line">                sequence = brother.split(SHARED_WRITE_PRE)[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (brother.contains(SHARED_READ_PRE)) &#123;</span><br><span class="line">                sequence = brother.split(SHARED_READ_PRE)[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 异常名称节点的处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curSequence.compareTo(sequence) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                writersOrReader.add(brother);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (writersOrReader.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 没有比自己序号小的请求，说明自己获取到了读锁</span></span><br><span class="line">            <span class="comment">//log.info(Thread.currentThread().getName() + "没有比自己序号小的请求-W");</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取最近的那个锁</span></span><br><span class="line">            String lastWriterOrReader = SHARED_LOCK_NAMESPACE + lockPath + <span class="string">"/"</span> + writersOrReader.get(writersOrReader.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 判断最近的那个锁期间是否已经释放了</span></span><br><span class="line">            <span class="keyword">if</span> (zkClient.exists(lastWriterOrReader)) &#123;</span><br><span class="line">                MyWriteIZkChildListener myWriteIZkChildListener = <span class="keyword">new</span> MyWriteIZkChildListener(lastWriterOrReader, countDownLatch);</span><br><span class="line">                zkClient.subscribeDataChanges(lastWriterOrReader, myWriteIZkChildListener);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"获取到了锁-W"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWriteIZkChildListener</span> <span class="keyword">implements</span> <span class="title">IZkDataListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastWriterOrReader;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyWriteIZkChildListener</span><span class="params">(String lastWriterOrReader, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastWriterOrReader = lastWriterOrReader;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//log.info(Thread.currentThread().getName() + "比自己序号小的那个请求被释放了，循环-W");</span></span><br><span class="line">        zkClient.unsubscribeDataChanges(lastWriterOrReader, <span class="keyword">this</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-待续"><a href="#3-待续" class="headerlink" title="3. 待续"></a>3. 待续</h1><p>readlock</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十八、分布式消息跟踪</title>
      <link href="/2018/06/15/distributed_principle_prictice/18.html/"/>
      <url>/2018/06/15/distributed_principle_prictice/18.html/</url>
      
        <content type="html"><![CDATA[<p>随着业务分布式架构的发展，系统间的系统调用日趋复杂，以电商的商品购买为例，前台界面的购买操作设计到底层上百次服务调用，涉及到的中间件包括：  </p><ol><li>分布式服务框架</li><li>消息队列</li><li>分布式缓存</li><li>分布式数据访问中间件</li><li>分布式文件存储系统</li><li>分布式日志采集</li><li>其它……</li></ol><p>如果无法有效清理后端的分布式调用和依赖关系，故障定界将会非常困难。利用分布式消息跟踪系统可以有效解决服务化之后系统面临的运维挑战，提高运维效率。</p><h1 id="1-业务场景分析"><a href="#1-业务场景分析" class="headerlink" title="1 业务场景分析"></a>1 业务场景分析</h1><p>以下为分布式调用示意图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_1.png" alt></p><h2 id="1-1-故障的快速定界定位"><a href="#1-1-故障的快速定界定位" class="headerlink" title="1.1 故障的快速定界定位"></a>1.1 故障的快速定界定位</h2><p>传统应用软件发生故障时，往往通过接口日志手工从故障节点采集日志进行问题分析定位，分布式服务化之后，一次业务调用可能涉及到后台上百次服务调用，每个服务又是集群组网，传统人工到各个服务节点人肉搜索的方式效率很低。<br>希望能够通过调用链跟踪，将一次业务调用的完整轨迹以调用链的形式展示出来，通过图形化界面查看每次服务调用结果，以及故障信息。  </p><p>通过在业务日志中增加调用链 ID ，可以实现业务日志和调用链的动态关联。通过调用链进行快速故障定界，然后通过 ID 关联查询，可以快速定位到业务日志相关信息。</p><h2 id="1-2-调用路径分析"><a href="#1-2-调用路径分析" class="headerlink" title="1.2 调用路径分析"></a>1.2 调用路径分析</h2><p>通过对调用链调用路径的分析，可以识别应用的关键路径：应用被调用得最多的入口、服务是哪些，找出服务的热点、耗时瓶颈和易故障点。同时为性能优化、容量规划等提供数据支撑。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_2.png" alt></p><h2 id="1-3-调用来源和去向分析"><a href="#1-3-调用来源和去向分析" class="headerlink" title="1.3 调用来源和去向分析"></a>1.3 调用来源和去向分析</h2><p>通过调用去向分析，可以对服务的依赖关系进行梳理：  </p><ol><li>应用直接和间接依赖了哪些服务。</li><li>各层次依赖的调用时延、QPS、成功率等性能 KPI指标。</li><li>识别不合理的强依赖，或者冗余依赖，反向要求开发进行依赖解耦和优化。  </li></ol><p>通过对调用来源进行 TOP排序，识别当前服务的消费来源，以及获取各消费者的 QPS、平均时延、出错率等，针对特定的消费者，可以做针对性治理，例如针对某个消费者的限流降级、路由策略修改等，保障服务的 SLA。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_3.png" alt></p><h1 id="2-分布式消息跟踪系统设计"><a href="#2-分布式消息跟踪系统设计" class="headerlink" title="2 分布式消息跟踪系统设计"></a>2 分布式消息跟踪系统设计</h1><p>消息跟踪系统的核心就是调用链：每次业务请求都生成一个全局唯一的 TraceID,通过跟踪 ID将不同节点间的日志串接起来，形成一个完整的日志调用链，通过对调用链日志做实时采集、汇总和大数据分析，提取各种维度的价值数据，为系统运维和运营提供大数据支撑。</p><h2 id="2-1-系统架构"><a href="#2-1-系统架构" class="headerlink" title="2.1 系统架构"></a>2.1 系统架构</h2><p>分布式消息跟踪系统的整体架构如下，由四部分组成：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_4.png" alt></p><ol><li>调用链埋点日志生成</li><li>分布式采集和存储埋点日志</li><li>在线、离线大数据计算，对调用链数据进行分析和汇总</li><li>调用链的界面展示、排序和检索等</li></ol><h2 id="2-2-埋点日志"><a href="#2-2-埋点日志" class="headerlink" title="2.2 埋点日志"></a>2.2 埋点日志</h2><p>埋点就是分布式消息跟踪系统在当前节点的上下文信息，埋点可以分为两类：  </p><ol><li>客户端埋点，客户端发送请求消息时生成的调用上下文，通常包括 TraceID、调用方 IP、调用方接口或者业务名称、调用的发起时间、被调用的服务名、方法名、IP 地址和端口等信息。</li><li>服务端埋点，服务端返回应答消息时在当前节点生成的上下文，包括 TraceID、调用方上下文信息、服务端处理的耗时、处理结果等信息。</li></ol><p>埋点日志的实现，通常会包含如下几个功能：  </p><ol><li>埋点规范，主要用于业务二次定制开发和第三方中间件/系统对接。</li><li>埋点日志类库，服务生成埋点上下文，打印埋点日志等。</li><li>中间件预置埋点功能，应用不需要开发任何业务代码即可直接使用，也可以通过埋点类库将应用自身的业务字段携带到调用链上下文中，例如终端类型、手机号等。  </li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_5.png" alt><br>消息跟踪 ID 通常由调用首节点负责生成（各种门户 Portal），本 JVM 之内通常线程上下文传递 TraceID，跨节点传递时，往往通过分布式服务框架的显式传参传递到下游节点，实现消息跟踪上下文的跨节点传递。<br>埋点日志上下文通常需要包含如下内容：  </p><ol><li>TraceID、RPCID、调用的开始时间、调用类型、协议类型、调用方 IP 和端口、被调用方 IP 和端口、请求方接口名、被调用方服务名等信息。</li><li>调用耗时、调用结果、异常信息、处理的消息报文大小等。</li><li>可扩展字段，通常用于应用扩展埋点上下文信息。</li></ol><p>消息跟踪ID（TraceID）是关联一次完整应用调用的唯一标识，需要在整个集群内唯一，它的取值策略有很多，例如 UUID，UUID（Universally Unique Identifier）即全局唯一标识符，是指在一台机器上生成的数字，它保证对在同一时空中所有机器都是唯一的。按照开发软件基金会（OSF）制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片 ID 码和许多可能的数字。由以下几部分组合：当前日期和时间（UUID 的第一部分与时间有关，如果你在生成一个 UUID 之后，过几秒又生成一个 UUID，则第一部分不同，其余相同），时钟序列，全局唯一的 IEEE 机器识别号（如果有网卡，从网卡获得，没有网卡以其它方式获得），UUID 的唯一缺陷在于生成的结果串会比较长。  </p><ol><li>IP 地址和端口：调用发起方和被调用方 IP 地址、端口号</li><li>时间戳：埋点上下文的生成时间</li><li>顺序号：标识链路传递序列的 RpcID</li><li>进程号：应用的进程 ID</li><li>随机数：例如可以选择 8 位数的随机数  </li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_6.png" alt>  </p><p>原理上，埋点日志比较简单，实现起来并不复杂。但是在实际工作中，埋点日志也会面临一些技术挑战，举例如下：  </p><ol><li>异步调用：业务服务中直接调用 MQ 客户端，或者其它中间件的客户端时，可能会发生线程切换，通常线程上下文传递的埋点信息丢失，MQ 客户端会认为自己是首节点，重新生成 TraceID，导致调用链串接不起来。</li><li>性能影响：由于 Java I/O 操作通常都是同步的，如果磁盘的 WIO 比较高，会导致写埋点日志阻塞应用线程，导致时延增大。频繁地写埋点日志，也会占用大量的 CPU、带宽等系统资源，影响正常业务的运行。  </li></ol><p>对于线程切换问题，在切换时需求做线程上下文的备份，将埋点上下文复制到切换的线程上下文中，即可解决问题。<br>频繁写埋点日志影响性能问题，可以通过如下措施改善该问题：  </p><ol><li>支持异步写日志，防止写埋点日志慢阻塞服务线程。具体实现上可以通过采用 log4j 的异步 Appender、独立的日志线程池甚至是 JDK1.7 之后提供的异步文件操作接口。</li><li>提供可灵活配置的埋点采样率，控制埋点日志量。</li><li>批量写日志，日志流控机制。</li></ol><h2 id="2-3-采样率"><a href="#2-3-采样率" class="headerlink" title="2.3 采样率"></a>2.3 采样率</h2><p>对于高 QPS 的应用，服务调用埋点本身的性能损耗也不容忽视，为了解决 100% 全采样的性能损耗，可以通过采样率来实现埋点低损耗的目标。<br>采样包括静态采用和动态采样两种，静态采样就是系统上线时设置一个采样率，无论负载高低，均按照采样率执行。动态采样率根据系统的负载可以自动调整，当负载比较低的时候可以实现 100% 全采样，在负载非常重时甚至可以降低到 0 采样。  </p><p>是否采样由调用链的首节点进行判断，首节点根据采样率算法，决定某个业务访问是否采样，如果需要采样，则把采样标识、TraceID 等采样上下文发送到下游服务节点，下游服务节点根据采样标识做判断，如果采样则获取调用链上下文并补充完整，反之则不埋点。</p><h2 id="2-4-采集和存储埋点日志"><a href="#2-4-采集和存储埋点日志" class="headerlink" title="2.4 采集和存储埋点日志"></a>2.4 采集和存储埋点日志</h2><p>开源 的 ELK，原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/18_7.png" alt><br>需要考虑：  </p><ol><li>采集过程中发生宕机，如何在中断点恢复采集。</li><li>采集过程中如果埋点日志发生了文件切换（例如达到单个日志文件 100MB 上限之后，自动进行文件切换），如何正确应对。</li><li>采集 Channel 发生网络故障，导致采集的日志部分发送失败，故障恢复之前，日志如何缓存，故障恢复之后，已采集尚未发送的日志如何发送。</li><li>考虑到性能，是不是单条采集、批量发送性能更优。</li></ol><h1 id="3-个人总结"><a href="#3-个人总结" class="headerlink" title="3 个人总结"></a>3 个人总结</h1><p>通过对业务流程的记录和采集，进行在线和离线的大数据计算，数据清洗获取有价值的数据。同时还能根据运行情况做服务的调整。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十七、服务治理</title>
      <link href="/2018/06/14/distributed_principle_prictice/17.html/"/>
      <url>/2018/06/14/distributed_principle_prictice/17.html/</url>
      
        <content type="html"><![CDATA[<p>随着业务发展，服务越来越多，如何协调线上运行的各个服务，保障服务的 SLA，以及小服务资源浪费的问题，需要能够基于服务调用的性能 KPI数据进行容量管理，合理分配各个服务的资源占用。<br>线上业务发生故障，需要对故障业务做服务降级、流量控制，快速恢复业务。<br>为了满足服务线下管控、保障线上高效运行，需要有一个统一的服务治理框架对服务进行统一、有效管控，保障服务的高效、健康运行。</p><h1 id="1-服务治理技术的历史变迁"><a href="#1-服务治理技术的历史变迁" class="headerlink" title="1 服务治理技术的历史变迁"></a>1 服务治理技术的历史变迁</h1><ol><li>第一代服务治理 SOA Governance：以 IBM为首的 SOA解决方案提供商推出的针对企业 IT系统的服务治理框架，它主要聚焦在对企业 IT系统中异构服务的质量管理、服务发布审批流程管理和服务建模、开发、测试以及运行的全生命周期管理。</li><li>第二代以分布式服务框架为中心的服务治理：随着电商和移动互联网的快速发展，以阿里为首的基于同一分布式服务框架的全新服务治理理念诞生，它聚焦于对内部同构服务的线上治理，保障线上服务的运行质量。相对比传统 IT架构的服务治理，由于服务的开发模式、部署规模、组网类型、业务特点等差异巨大，因此服务治理的重点也从线下转移到了线上服务质量保障。</li><li>微服务架构+云端服务治理：2013年至今，随着云计算和微服务架构的发展，以 AWS为首的基于微服务架构+云服务化的云端服务治理体系诞生，它的核心理念是服务微自治，利用云调度的弹性和敏捷，逐渐消除人工治理。  </li></ol><p>微服务架构可以实现服务一定程度的自治，例如服务独立打包、独立部署、独立升级和独立扩容。通过云计算的弹性伸缩、单点故障迁移、服务健康度管理和自动容量规划等措施，结合微服务治理，逐步实现微服务的自治。</p><h2 id="1-1-SOA-Governance"><a href="#1-1-SOA-Governance" class="headerlink" title="1.1 SOA Governance"></a>1.1 SOA Governance</h2><p>SOA Governance的定位：面向企业 IT系统异构服务的治理和服务生命周期管理，它治理的服务通常是 SOA服务。<br>传统的 SOA Governance包含以下四部分内容：  </p><ol><li>服务建模：验证功能需求与业务需求，发现和评估当前服务，服务建模和性能需求，开发治理规范。</li><li>服务组装：创建服务更新计划，创建和修改服务以满足所有业务需求，根据治理策略评估服务，批准组装完成。</li><li>服务部署：确保服务的质量，措施包括功能测试、性能测试和满足度测试，批准服务部署。</li><li>服务管理：在整个生命周期内管理和监控服务，跟踪服务注册表中的服务，根据 SLA上报服务的性能 KPI数据进行服务质量管理。</li></ol><p>SOA Governance 工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_1.png" alt><br>传统 SOA Governance 缺点如下：  </p><ol><li>分布式服务框架的发展，内部服务框架需要统一，服务治理也需要适应新的架构，能够由表及里，对服务进行细粒度的管控。</li><li>微服务架构的发展和业务规模的扩大，导致服务规模量变引起质变，服务治理的特点和难点也随之发生变化。</li><li>缺少服务运行时动态治理能力，面对突发的流量高峰和业务冲击，传统的服务治理在响应速度、故障快速恢复等方面存在不足，无法更敏捷地应对业务需求。</li></ol><h2 id="1-2-分布式服务框架服务治理"><a href="#1-2-分布式服务框架服务治理" class="headerlink" title="1.2 分布式服务框架服务治理"></a>1.2 分布式服务框架服务治理</h2><ol><li>分布式服务矿机的服务治理定位：面向互联网业务的服务治理，聚焦在对内部采用统一服务框架服务化的业务运行态、细粒度的敏捷治理体系。</li><li>治理的对象：基于统一分布式服务框架开发的业务服务，与协议本身无关，治理的可以是 SOA服务，也可以是基于内部服务框架私有协议开发的各种服务。</li><li>治理策略：针对互联网业务的特点，例如突发的流量高峰、网络延时、机房故障等，重点针对大规模跨机房的海量服务进行运行态治理，保障线上服务的高 SLA，满足用户的体验。常用的治理策略包括服务的限流降级、服务迁入迁出、服务动态路由和灰度发布等。</li></ol><p>以分布式服务框架 Dubbo为例，它的服务治理体系如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_2.png" alt></p><h2 id="1-3-AWS-云端微服务治理"><a href="#1-3-AWS-云端微服务治理" class="headerlink" title="1.3 AWS 云端微服务治理"></a>1.3 AWS 云端微服务治理</h2><p>随着云计算的发展，Dev&amp;Ops 逐渐流行起来，基础设施服务化（IaaS）为大规模、批量流水线式软件交付提供了便利，AWS 作为全球最大的云计算解决方案提供商，在微服务云化开发和治理方面积累了非常多的经验，具体总结如下：  </p><ol><li>全公司统一服务化开发环境，统一简单化服务框架（Coral Service），统一运行平台，快速高效服务开发。</li><li>所有后端应用服务化，系统由多项服务化组件构成。</li><li>服务共享、原子化、重用。</li><li>服务由小研发团队负责服务开发、测试、部署和治理，运维整个生命周期支撑。</li><li>高度自动化和 Dev&amp;Ops 支持，一键式服务部署和回退。</li><li>超大规模支持：后台几十万个服务，成千上万开发者同时使用，平均每秒钟有 1~2 个服务部署。</li><li>尝试基于 Docket 容器部署微服务。</li><li>服务治理是核心：服务性能 KPI统计、告警、服务健康度管理、灵活的弹性伸缩策略、故障自动迁移、服务限流和服务降级等多种治理手段，保障服务高质量运行。</li></ol><h1 id="2-应用服务化后面临的挑战"><a href="#2-应用服务化后面临的挑战" class="headerlink" title="2 应用服务化后面临的挑战"></a>2 应用服务化后面临的挑战</h1><h2 id="2-1-跨团队协作问题"><a href="#2-1-跨团队协作问题" class="headerlink" title="2.1 跨团队协作问题"></a>2.1 跨团队协作问题</h2><ol><li>服务提供者 S分布式部署，存在多个服务实例，如果做端点调试，路由模块会动态分发消息，随机路由，服务提供者 S无法确定要连接的 IP地址。</li><li>如果打断点，其它消费者也正在进行服务调用，调试会被干扰，需要通知所有的开发者不要调用服务 S，显然不可能。</li></ol><h2 id="2-2-服务的上下线管控"><a href="#2-2-服务的上下线管控" class="headerlink" title="2.2 服务的上下线管控"></a>2.2 服务的上下线管控</h2><p>需要结束某些服务的生命周期，服务提供者直接将服务下线，导致依赖该服务的应用不能正常工作。服务下线时，应先标记为过时，然后通知调用方尽快修改调用，通过性能 KPI接口和调用链分析，确认没有消费者再调用此服务，才能下线。</p><h2 id="2-3-服务安全"><a href="#2-3-服务安全" class="headerlink" title="2.3 服务安全"></a>2.3 服务安全</h2><p>针对内部应用，服务框架通常采用长链接管理客户端连接，针对非信任的第三方应用，或者恶意消费者，需要具备黑白名单访问控制机制，防止客户端非法链路过多，占用大量的句柄、线程和缓存资源，影响服务提供者的运行质量。</p><h2 id="2-4-服务-SLA-保障"><a href="#2-4-服务-SLA-保障" class="headerlink" title="2.4 服务 SLA 保障"></a>2.4 服务 SLA 保障</h2><p>由于非核心服务跟系统其它服务打包部署在同一个 Tomcat等容器进程中，一旦非核心服务需要停止，也影响其它合设的服务，如何高效的关停非核心服务，但又不影响其它合设的服务，需要服务治理框架统一考虑。<br>另外超时时间也要方便的在线可视化的修改，不需要重启即可动态生效。</p><h2 id="2-5-故障快速定界定位"><a href="#2-5-故障快速定界定位" class="headerlink" title="2.5 故障快速定界定位"></a>2.5 故障快速定界定位</h2><p>由于分布式和大规模的部署，导致服务的 SLA将很难有效保障。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_3.png" alt></p><h1 id="3-服务治理"><a href="#3-服务治理" class="headerlink" title="3 服务治理"></a>3 服务治理</h1><p>分布式服务框架的服务治理目标如下：  </p><ol><li>防止业务服务架构腐化：通过服务注册中心对服务强弱依赖进行分析，结合运行时服务调用链关系分析，梳理不合理的依赖和调用路径，优化服务化架构，防止代码腐化。</li><li>快速故障定界定位：通过 Flume 等分布式日志采集框架，实时收集服务调用链日志、服务性能 KPI数据、服务接口日志、运行日志等，实时汇总和在线分析，集中存储和展示，实现故障的自动发现、自动分析和在线条件检索，方便运维人员、研发人员进行实时故障诊断。</li><li>服务微管控：细粒度的运行期服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、统一配置、优先级调度和流量迁移等，提供方法级治理和动态生效功能，通过一系列细粒度的治理策略，在故障发生时可以多管齐下，在线调整，快速恢复业务。</li><li>服务生命周期管理：包括服务的上线审批、下线通知，服务的在线升级，以及线上和线下服务文档库的建设。</li></ol><h2 id="3-1-服务治理架构设计"><a href="#3-1-服务治理架构设计" class="headerlink" title="3.1 服务治理架构设计"></a>3.1 服务治理架构设计</h2><p>分布式服务框架的服务治理分三层：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_4.png" alt><br>第二层为服务治理 SDK层，主要由如下组成：  </p><ol><li>服务治理元数据：服务治理元数据主要包括服务治理实体对象，包括服务模型、应用模型、治理组织模型、用户权限模型、数据展示模型等。元数据模型通过 DataMapper和模型扩展，向上层界面屏蔽底层服务框架的数据模型，实现展示层和服务架构的解耦，元数据也可以用于展示界面的定制扩展。</li><li>服务治理接口：服务治理 Portal调用服务治理接口，实现服务治理。例如服务降级接口、服务流控接口、服务路由权重调整接口、服务迁移接口等。服务接口与具体的协议无关，它通常基于分布式服务框架自身实现，可以是 Restful接口，也可以是内部的私有协议。</li><li>服务治理客户端类库：由于服务治理服务本身通常也是基于分布式服务框架开发，因此服务治理 Portal需要继承分布式服务框架的客户端类库，实现服务的自动发现和调用。</li><li>调用示例：客户端 SDK需要提供服务治理接口的参数说明、注意事项以及给出常见的调用示例，方便前端开发人员使用。</li><li>继承开发指南：服务治理 SDK需要提供继承开发指南。</li></ol><h2 id="3-2-运行态服务治理功能设计"><a href="#3-2-运行态服务治理功能设计" class="headerlink" title="3.2 运行态服务治理功能设计"></a>3.2 运行态服务治理功能设计</h2><p>运行态服务治理首先要做到可视：当前系统发布了哪些服务，这些服务部署在哪些机器上，性能 KPI数据如何，指标是否正常等。<br>由于性能 KPI数据的统计周期、统计指标和报表呈现方式差异比较大，因此服务框架很难抽象出一套放之四海而皆准的性能统计功能，因此在设计的时候需要注意以下两点：  </p><ol><li>扩展性：服务性能 KPI数据采集由插件 Handler 负责，平台和业务均可以通过扩展性能统计插件 Handler的方式扩展采集指标和采集周期等。</li><li>原子性：服务提供者和消费者只负责原始数据的采集和上报，不在本节点内做复杂的汇总操作，汇总和计算由性能汇聚节点的 Spark等大数据流式框架负责。</li></ol><h2 id="3-3-线下服务治理"><a href="#3-3-线下服务治理" class="headerlink" title="3.3 线下服务治理"></a>3.3 线下服务治理</h2><p>为了解决消费者提供者之间的文档过时、错误问题，需要简历服务文档中心，方便线上运维人员查看和多团队之间的协作，它的工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_5.png" alt><br>基于 java DOC工具进行扩展，将规则内置到 IDE开发模板中，并通过 CI构建工具做编译检测，将不符合要求的服务接口输出到 CI构建报告并邮件发送给服务责任人。<br>服务的上线审批、下线通知机制需要建立并完善起来，工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_6.png" alt></p><h2 id="3-4-安全和权限管理"><a href="#3-4-安全和权限管理" class="headerlink" title="3.4 安全和权限管理"></a>3.4 安全和权限管理</h2><p>安全涉及到两个层面：  </p><ol><li>服务的开放和鉴权机制。</li><li>服务治理的安全和权限管理。</li></ol><p>服务治理的使用者通常分三类：  </p><ol><li>开发或者测试：主要定位问题，协助运维人员做服务治理。</li><li>运维人员：主要日常运维巡检，查看服务性能 KPI是否正常，是否有报警，利用服务治理进行故障恢复。</li><li>管理者：主要关心运营层面的 KPI数据，只看不管。</li></ol><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>服务治理总体结构图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/17_7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十六 服务优先级调度</title>
      <link href="/2018/06/11/distributed_principle_prictice/16.html/"/>
      <url>/2018/06/11/distributed_principle_prictice/16.html/</url>
      
        <content type="html"><![CDATA[<p>当系统当前资源非常有限时，为了保证高优先级的服务能够正常运行，保障服务 SLA，需要降低一些非核心服务的调度频次，释放不防资源占用，保障系统的整体运行平稳。</p><h1 id="1-设置服务优先级"><a href="#1-设置服务优先级" class="headerlink" title="1 设置服务优先级"></a>1 设置服务优先级</h1><p>服务优先级调度有多种策略：  </p><ol><li>基于线程调度器的优先级调度策略。</li><li>基于优先级队列的优先级调度策略。</li><li>基于加权配置的优先级调度策略。</li><li>基于服务迁入迁出的优先级调度策略。</li></ol><h1 id="2-线程调度器方案"><a href="#2-线程调度器方案" class="headerlink" title="2 线程调度器方案"></a>2 线程调度器方案</h1><p>Thread.setPriority()。<br>线程优先级被线程调度器用来判定何时运行哪个线程，理论上，优先级高的线程比优先级低的线程获得更多的 CPU时间。而实际上，线程获得的 CPU时间通常由包括优先级在内的多个因素决定。<br>服务在发布的时候，可以根据用户的优先级配置策略，将服务优先级映射到线程优先级中，然后创建多个不同的优先级线程，分别调度对应的服务，工作原理如下：<br>![][1]<br>算法简单，开发工作量小，但是不同的操作系统上，有自己不同的策略，这对于需要某些精确控制执行比例的服务是不可接受的。  </p><p>线程优先级可以用来提高一个已经能够正常工作的服务的运行质量，但是却无法保证精确性和跨平台移植性。因此，通常不建议使用线程调度器实现服务的优先级调度。</p><h1 id="3-Java-优先级队列"><a href="#3-Java-优先级队列" class="headerlink" title="3 Java 优先级队列"></a>3 Java 优先级队列</h1><p>Java的 PriorityQueue是一个基于优先级堆的无界优先级队列。<br>![][2]<br>缺点在于：如果持续有优先级高的消息需要处理，会导致优先级低的消息得不到及时处理而积压。而积压到一定程度之后，低优先级的消息可能已经超时，即便后续得到执行机会，由于已经超时也需要丢弃掉，在此之前，它灰一直占用优先级队列的堆内存，同时导致客户端业务线程被挂住等待应答消息直到超时，从资源调度层面看，PriorityQueue 的算法并不太适合分布式服务框架。</p><h1 id="4-加权优先级队列"><a href="#4-加权优先级队列" class="headerlink" title="4 加权优先级队列"></a>4 加权优先级队列</h1><p>分布式服务框架的服务优先级调度并不是只处理高优先级的消息，而是按照一定比例优先调度高优先级的服务，采用加权优先级队列可以很好地满足这个需求。<br>原理如下：它由一系列的普通队列组成，每个队列与服务优先级 1:1 对应。当服务端接收到客户端请求消息时，根据消息对应的服务优先级取值将消息投递到指定的优先级队列中。<br>工作线程按照服务优先级的加权值，按比例从各个优先级队列中获取消息，然后按照优先级的高低将消息设置到工作线程的待处理消息数组中，由于只有本工作线程会读写消息数组，因此该数组是线程安全的。<br>![][3]<br>缺点在于：如果优先级等级比较多，对应的优先级队列就会膨胀，如果优先级队列发生积压，这将导致内存占用迅速飙升。</p><h1 id="5-服务迁入迁出"><a href="#5-服务迁入迁出" class="headerlink" title="5 服务迁入迁出"></a>5 服务迁入迁出</h1><p>前面的几种优先级调度策略是比较传统的做法，基于服务迁入迁出的则是利用分布式服务框架的服务动态发现机制，通过调整服务运行实例数来实现优先级调度。<br>原理如下：  </p><ol><li>当系统资源紧张时，通过服务治理 Portal的服务迁入迁出界面，将低优先级服务的部分运行实例从服务注册中心中迁出，也就是动态去注册。</li><li>消费者动态发现去注册的服务，将这部分服务实例的地址信息从路由表中删除，后续消息将不会路由到已经迁出的服务实例上。</li><li>由于只迁出了部分服务实例，被迁出的低优先级服务仍然能够正常处理，只不过由于部署实例的减少，得到调度的机会就同比降低了很多，释放的资源将被高优先级服务使用。通过资源的动态调配，实现服务的优先级调度。</li><li>当业务高峰期结束之后，通过服务治理 Portal将迁出的服务重新迁入，低优先级的消息恢复正常执行，优先级调度结束。  </li></ol><p>缺点：自动化程度较低，对运维人员的要求较高。</p><h1 id="6-个人总结"><a href="#6-个人总结" class="headerlink" title="6 个人总结"></a>6 个人总结</h1><p>服务的优先级调度与动态流控不同，流控最终会拒绝消息，导致部分请求失败。优先级调度是在资源紧张时，优先执行高优先级的服务，在保障高优先级服务能够被合理调度的同时，也兼顾处理部分优先级低的消息，它们之间存在一定的比例关系。  </p><p>优先级调度本身并不拒绝消息，但是如果在运行过程中发生了流控，则由流控负责拒消息。通常对于高优先级的管理类消息，例如心跳消息、指令消息等们不能被流控掉。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十五、服务降级</title>
      <link href="/2018/06/11/distributed_principle_prictice/15.html/"/>
      <url>/2018/06/11/distributed_principle_prictice/15.html/</url>
      
        <content type="html"><![CDATA[<ol><li>业务高峰期，为了保证核心服务的 SLA，往往需要停掉一些不太重要的业务，例如商品评论、论坛或者粉丝积分等。  </li><li>某些服务因为某种原因不可用，但是流程不能直接失败，需要本地 Mock 服务端实现，做流程放通。例如图书阅读，如果用户登录余额鉴权服务不能正常工作，需要做业务放通，记录消费话单，允许用户继续阅读，而不是返回失败。  </li></ol><p>这就是服务降级，分为容错降级和屏蔽降级两种模式。</p><h1 id="1-屏蔽降级"><a href="#1-屏蔽降级" class="headerlink" title="1 屏蔽降级"></a>1 屏蔽降级</h1><p>在一个应用中，服务往往是合设的，尽管可以通过线程池隔离等方式保证服务之间的资源隔离，但是 100%的隔离是不现实的。特别是对缓存、网络 I/O、磁盘 I/O、数据库连接资源等公共依赖无法隔离，在业务高峰期时，服务往往存在激烈的竞争，导致订购等核心服务运行质量下降，影响系统的稳定运行和客户体验。  </p><p>此时需要对非核心服务做强制降级，不发起远程服务调用，直接返回空、异常或者执行特定的本地逻辑，减少自身对公共资源的消费，把资源释放出来供核心服务使用。  </p><h2 id="1-1-屏蔽降级的流程"><a href="#1-1-屏蔽降级的流程" class="headerlink" title="1.1 屏蔽降级的流程"></a>1.1 屏蔽降级的流程</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_1.png" alt></p><h2 id="1-2-屏蔽降级的设计实现"><a href="#1-2-屏蔽降级的设计实现" class="headerlink" title="1.2 屏蔽降级的设计实现"></a>1.2 屏蔽降级的设计实现</h2><p>屏蔽降级通常用于服务运行态治理，开发时不会配置，当外界的触发条件达到某个临界值时，由运维人员/开发人员决策，通过服务治理控制台，进行人工降级操作，它的取值有如下三种：  </p><ol><li>mock = force: return null。不发起远程服务调用，直接返回空对象。</li><li>mock = force: throw Exception。不发起远程服务调用，直接抛出指定异常。</li><li>mock = force: execute Bean。不发起远程服务调用，直接执行本地模拟接口实现类。  </li></ol><p>屏蔽降级操作是可逆的，当系统压力恢复正常水平或者不再需要屏蔽降级时，可以对已经屏蔽降级的服务恢复正常。恢复之后，消费者重新调用远程的服务提供者，同时服务状态被修改为正常状态。</p><h1 id="2-容错降级"><a href="#2-容错降级" class="headerlink" title="2 容错降级"></a>2 容错降级</h1><p>当非核心服务不可用时，可以对故障服务做业务逻辑放通，分布式服务框架的业务放通实际属于容错降级的一种。<br>容错降级不仅仅只用于业务放通，它也常用于服务提供方在客户端执行容错逻辑，容错逻辑主要包括两种：  </p><ol><li>RPC异常：通常指超时异常、消息解码异常、流控异常、系统拥塞保护异常等。</li><li>Service异常：例如登录校验失败异常、数据库操作失败异常等。</li></ol><h2 id="2-1-容错降级的工作原理"><a href="#2-1-容错降级的工作原理" class="headerlink" title="2.1 容错降级的工作原理"></a>2.1 容错降级的工作原理</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_2.png" alt><br>容错降级与屏蔽降级的主要差异：  </p><ol><li>触发条件不同：容错降级时根据服务调用结果，自动匹配触发的；而屏蔽降级往往是通过人工根据系统运行情况手工操作触发的。</li><li>作用不同：容错降级时当服务提供者不可用时，让消费者执行业务放通：屏蔽降级的主要目的是将原属于降级业务的资源调配出来供核心业务使用。</li><li>调用机制不同：一个发起远程服务调用，一个只做本地调用。  </li></ol><p>业务放通的 Mock接口实现往往放在消费者端，主要在于提供端可能为多个消费者服务，为了解耦，单独的消费者自己进行放通。</p><ol><li>mock = fail: throw Exception。将异常转义。</li><li>mock = fail: execute Bean。将异常屏蔽掉，直接执行本地模拟解耦实现类，返回 Mock接口的执行结果。  </li></ol><p>与屏蔽降级不同的是，通常在开发态，就需要指定容错降级的策略。  </p><p>无论是屏蔽降级还是容错降级，都支持从消费者或者服务提供者两个维度去配置，从而消费端配置更灵活，实现差异化降级策略。<br>服务降级策略配置的优先级：消费者配置策略 &gt; 服务提供者配置策略。屏蔽降级 &gt; 容错降级。 </p><h2 id="2-2-运行时容错降级"><a href="#2-2-运行时容错降级" class="headerlink" title="2.2 运行时容错降级"></a>2.2 运行时容错降级</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/15_3.png" alt><br>如果开发态没有指定容错降级策略，系统上线运行后，需要临时增加容错降级策略，服务框架也需要支持在线动态增加容错降级策略，它的工作流程与屏蔽降级类似。</p><p>而在实际项目中，利用容错降级做业务放通是主要的应用场景。</p><h1 id="3-业务层降级"><a href="#3-业务层降级" class="headerlink" title="3 业务层降级"></a>3 业务层降级</h1><p>实际业务开发过程中，可能会存在比较复杂的业务放通场景，例如“调用 A 服务 + 执行本地方法调用”组合成一个流程，针对这个流程的执行结果做放通，这种场景由于本地方法调用并不经过分布式服务框架，因此需要业务自己做放通处理。  </p><p>服务降级并不能 100% 满足所有业务放通场景，需要业务层开发自己的降级框架。 </p><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>在服务化之前，业务往往需要自己实现放通逻辑或者框架，不同的业务模块，甚至不同的开发者都自己实现了一套私有的放通流程，这对项目的开发和运维都会造成很多麻烦。  </p><p>更为严重的是由于没有统一的服务降级策略和框架，无法在服务治理 Portal 上进行统一线上降级，在应对业务高峰时，运维人员会力不从心，往往需要一大群开发在背后支撑，运维效率非常低下。<br>基于分布式服务框架的服务降级功能，有效提升线上的服务治理效率，保证服务的 SLA，尽管服务降级更多是为了提升服务线上运行质量，但是它反向对服务的设计和开发也有约束。它要求服务在设计之初就要做如下识别：  </p><ol><li>哪些服务是核心服务、哪些是非核心服务？</li><li>哪些服务支持降级，降级策略是什么？</li><li>除了服务降级之外，是否还存在更为复杂的业务放通场景，它的策略是什么？  </li></ol><p>系统的高效、健康运行仅仅依赖线上服务治理和运维是解决不了的，需要通过分布式服务框架的特性反向映射到设计和开发态，从设计阶段就开始考虑未来如何高效运维，才能在根本上提升服务和产品的质量，这也是矛盾对立和统一的一个具体体现。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十四、流量控制</title>
      <link href="/2018/06/07/distributed_principle_prictice/14.html/"/>
      <url>/2018/06/07/distributed_principle_prictice/14.html/</url>
      
        <content type="html"><![CDATA[<p>当资源成为瓶颈时，服务框架需要对消费者做限流，启动流控保护机制。</p><h1 id="1-静态流控"><a href="#1-静态流控" class="headerlink" title="1 静态流控"></a>1 静态流控</h1><p>主要针对客户端访问速率进行控制，它通常根据服务质量等级协定（SLA）中约定的 QPS做全局流量控制，例如订单服务的静态流控阈值为 100QPS，则无论集群有多少个订单服务实例，它们总的处理速率之和不能超过 100QPS。</p><h2 id="1-1-传统静态流控设计方案"><a href="#1-1-传统静态流控设计方案" class="headerlink" title="1.1 传统静态流控设计方案"></a>1.1 传统静态流控设计方案</h2><p>在软件安装时，根据集群服务节点个数和静态流控阈值，计算每个服务及诶单分摊的 QPS阈值，系统运行时，各个服务节点按照自己分配的阈值进行流控，对于超出流控阈值的请求则拒绝访问。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_1.png" alt><br>服务框架启动时，将本节点的静态流控阈值加载到内存中，服务框架通过 Handler拦截器咋服务调用前做拦截计数，当计数器在指定周期 T到达 QPS上限时，启动流控，拒绝信的请求消息接入。注意：  </p><ol><li>服务实例通常由多线程执行，因此计数时需要考虑线程并发安全，可以使用 Atomic原子类进行原子操作。</li><li>达到流控阈值之后拒绝新的请求消息接入，不能拒绝后续的应答消息，否则这会导致客户端超时或者触发 FailOver，增加服务端的负载。</li></ol><h2 id="1-2-传统方案的缺点"><a href="#1-2-传统方案的缺点" class="headerlink" title="1.2 传统方案的缺点"></a>1.2 传统方案的缺点</h2><ol><li>云端服务的弹性伸缩性使服务节点数处于动态变化过程中，预分配方案行不通。</li><li>服务节点宕机，或者有新的服务节点动态加入，导致服务节点数发生变化，静态分配的 QPS需要实时动态调整，否则会导致流控不准。</li></ol><p>当应用和服务迁移到云上之后， PaaS 平台的一个重要功能就是支持应用和服务的弹性伸缩，在云上，资源都是动态分配和调整的，静态分配阈值方案无法适应服务迁移到云上。</p><h2 id="1-3-动态配额分配制"><a href="#1-3-动态配额分配制" class="headerlink" title="1.3 动态配额分配制"></a>1.3 动态配额分配制</h2><p>原理：由服务注册中心以流控周期 T为单位，动态推送每个节点分配的流控阈值 QPS。当服务节点发生变更时，会触发服务注册中心重新计算每个节点的配额，然后进行推送，这样无论是新增还是减少服务节点数，都能够在下一个流控周期内被识别和处理。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_2.png" alt><br>而在生产环境中，每台机器/VM 的配置可能不同，如果每个服务节点采用流控总阈值/服务节点数这种平均主义，可能会发生性能高、处理快的节点配额很快用完，但是性能差的节点配额有剩余的情况，这会导致总的配额没用完，但是系统却发生了静态流控的问题。<br>解决方案一：根据各个服务节点的性能 KPI数据（例如服务调用平均时延）做加权。<br>解决方案二：配额指标返还和重新申请，每个服务节点根据自身分配的指标值、处理速率做预测，如果计算结果表明指标会有剩余，则把多余的返还给服务注册中心；对于配额已经使用完的服务节点，重新主动去服务注册中心申请配额，如果连续 N次都申请不到新的配额指标，则对于新接入的请求消息做流控。  </p><p>结合负载均衡进行静态流控，才能够实现更精确的调度和控制。消费者根据各服务节点的负载情况做加权路由，性能差的节点路由到的消息更少，这样保证了系统的负载均衡和配额的合理分配。</p><h2 id="1-4-动态配额申请制"><a href="#1-4-动态配额申请制" class="headerlink" title="1.4 动态配额申请制"></a>1.4 动态配额申请制</h2><p>尽管动态配额分配制可以解决节点变化引起的流控不准问题，也能改善平均主义配额分配缺点如下：</p><ol><li>如果流控周期 T比较大，各服务节点的负载情况变化比较快，服务节点的负载反馈到注册中心，统一计算后再做配额均衡，误差会比较大。</li><li>如果流控周期 T比较小，服务注册中心需要实时获取各服务节点的性能 KPI数据并计算负载情况，经过性能数据采集、上报、汇总和计算之后会有一定的时延，这会导致流控滞后产生误差。</li><li>如果采用配额返还和重新申请方式，则会增加交互次数，同时也会存在时序误差。</li><li>扩展性差，负载的汇总、计算和配额分配、下发都由服务注册中心完成，如果服务注册中心管理的节点数非常多，则服务注册中心的计算压力就非常大，随着服务节点数的增加服务注册中心配额分配效率会急速下降、系统不具备平滑扩展能力。  </li></ol><p>而动态配额申请制，工作原理如下：  </p><ol><li>系统部署的时候，根据服务节点数和静态流控 QPS阈值，拿出一定比例的配额做初始分配，剩余的配额放在配额资源池中。</li><li>哪个服务节点使用完了配额，就主动向服务注册中心申请配额。配额的申请策略是，如果流控周期为 T，则将周期 T分成更小的周期 T/N（N为经验值，默认值为 10），当前的服务节点数为 M个，则申请的配额为（总 QPS配额-已经分配的 QPS）/ M * T / N。</li><li>总的配额如果被申请完，则返回 0 配额给各个申请配额的服务节点，服务节点对新接入的请求消息进行流控。</li></ol><p>动态配额申请制的优点：</p><ol><li>各个服务节点最清楚自己的负载情况，性能 KPI数据在本地内存中计算获得，实时性高。</li><li>由各个服务节点根据自身负载情况去申请配额，保证性能高的节点有更高的配额，性能差的自然配额就少，实现合理资源，流控的精确性。</li></ol><h1 id="2-动态流控"><a href="#2-动态流控" class="headerlink" title="2 动态流控"></a>2 动态流控</h1><p>动态流控的最终目标是为了保命，并不是对流量或者访问速度做精确控制。<br>触发动态流控的因子是资源，资源又分为系统资源和应用资源两大类，根据不同的资源负载情况，动态流控又分为多个级别，每个级别流控系数都不同，也就是被拒绝掉的消息比例不同。每个级别都有相应的流控阈值，这个阈值通常支持在线动态调整。</p><h2 id="2-1-动态流控因子"><a href="#2-1-动态流控因子" class="headerlink" title="2.1 动态流控因子"></a>2.1 动态流控因子</h2><p>动态流控因子包括系统资源和应用资源两大类，常见的系统资源包括：</p><ol><li>应用进程所在主机/VM 的 CPU使用率。</li><li>应用进程所在主机/VM 的 内存使用率。  </li></ol><p>使用 java.lang.Process 执行 top、sar 等外部命令获取系统资源使用情况。<br>常用的应用资源：  </p><ol><li>JVM 堆内存使用率</li><li>消息队列积压率</li><li>会话积压率  </li></ol><p>具体实现策略是系统启动时拉起一个管理线程，定时采集应用资源的使用率，并刷新动态流控的应用资源阈值。</p><h2 id="2-2-分级流控"><a href="#2-2-分级流控" class="headerlink" title="2.2 分级流控"></a>2.2 分级流控</h2><p>不同级别拒掉的消息比例不同，例如一级流控拒绝掉 1/8 的消息；发生二级流控时，拒绝掉 1/4 消息。<br>为了防止系统波动导致的偶发性流控，无论是进入流控状态还是从流控状态恢复，都需要连续采集 N次并计算平均值，如果连续 N次平均值大于流控阈值，则进入流控状态。<br>而在一个流控周期内，不会发生流控级别的跳变。</p><h1 id="3-并发控制"><a href="#3-并发控制" class="headerlink" title="3 并发控制"></a>3 并发控制</h1><p>并发控制针对线程的并发执行数进行控制，它的本质是限制对某个服务或者服务的方法过度消息，耗用过多的资源而影响其它的服务的正常运行。有两种形式：  </p><ol><li>针对服务提供者的全局控制。</li><li>针对服务消费者的局部控制。</li></ol><h1 id="4-连接控制"><a href="#4-连接控制" class="headerlink" title="4 连接控制"></a>4 连接控制</h1><p>通常分布式服务框架服务提供者和消费者之间采用长连接私有协议，为了防止因为消费者连接数过多导致服务端负载压力过大，系统需要针对连接数进行流控。  </p><h1 id="5-并发和连接控制算法"><a href="#5-并发和连接控制算法" class="headerlink" title="5 并发和连接控制算法"></a>5 并发和连接控制算法</h1><p>并发连接的控制算法原理如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/14_3.png" alt></p><p>基于服务调用 Pipeline 机制，可以对请求消息接收和发送、应答消息接收和发送、异常消息等做切面拦截（类似 Spring 的 AOP 机制，但是没采用反射机制，性能更高），利用 Pipeline 拦截切面接口，对请求消息做服务调用前的拦截和计数，根据计数器做流控，服务端的算法如下：  </p><ol><li>获取流控阈值。</li><li>从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。</li><li>如果等于或者大于流控阈值，则抛出 RPC流控异常给客户端。</li><li>服务调用执行完成之后，获取 RPC上下文中的并发执行数，做原子自减。  </li></ol><p>客户端的算法如下：  </p><ol><li>获取流控阈值。</li><li>从全局 RPC上下文中获取当前的并发执行数，与流控阈值对比，如果小于流控阈值，则对当前的计数器做原子自增。</li><li>如果等于或大于流控阈值，则当前线程进入 wait状态， wait超时时间为服务调用的超时时间。</li><li>如果有其它线程服务调用完成，调用计数器自减，则并发执行数小于阈值，线程被 notify，退出 wait，继续执行。</li></ol><h1 id="6-个人总结"><a href="#6-个人总结" class="headerlink" title="6 个人总结"></a>6 个人总结</h1><p>流量控制是保证服务 SLA（Sevice-Level Agreement）的重要措施，也是业务高峰期故障预防和恢复的有效手段，分布式服务框架需要支持流控阈值、策略的在线调整，不需要重启应用即可生效。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十三、服务多版本</title>
      <link href="/2018/06/06/distributed_principle_prictice/13.html/"/>
      <url>/2018/06/06/distributed_principle_prictice/13.html/</url>
      
        <content type="html"><![CDATA[<p>服务上线之后，由于功能变更、BUG修复，以及服务升级，需要对服务采用多版本管理。</p><h1 id="1-服务多版本管理设计"><a href="#1-服务多版本管理设计" class="headerlink" title="1 服务多版本管理设计"></a>1 服务多版本管理设计</h1><p>管理的对象包括服务提供者和消费者：  </p><ol><li>服务提供者：发布服务的时候，支持指定服务的版本号。</li><li>服务消费者：消费服务的时候，支持指定引用的服务版本号或者版本范围。</li></ol><h2 id="1-1-服务版本号管理"><a href="#1-1-服务版本号管理" class="headerlink" title="1.1 服务版本号管理"></a>1.1 服务版本号管理</h2><p>服务的版本号是有序的，在服务名相同的情况下，两个相同服务名的不同服务版本的版本号可以比较大小。完整的版本号由“主版本号（Major）+副版本号（Minor）+微版本号（Micro）”构成：  </p><ol><li>主版本号：表示重大特性或者功能变更，接口或功能可能会不兼容。</li><li>副版本号：发生了少部分功能变更，或者新增了一些功能。</li><li>微版本号：主要用于 BUG修改，对应于常见的 SP补丁包。</li></ol><h2 id="1-2-服务提供者"><a href="#1-2-服务提供者" class="headerlink" title="1.2 服务提供者"></a>1.2 服务提供者</h2><p>服务开发完成之后，需要将一个或者多个服务打包成一个 jar/war 包，为了便于对服务进行物理管理，打包后的名称中会包含服务的版本号信息，例如 com.huawei.orderService_1.0.1.jar。<br>在微服务架构中，微服务独立开发、打包、部署和升级，因此微服务的版本和软件包的版本可以一一映射。但是在实际开发中，尤其是大规模企业应用开发，单独为每个服务打包和部署目前尚未成为主流，它会增加服务软件包的管理和线上治理成本，因此目前的主流模式仍然是多个服务提供者合一个大的 jar/war 包，这就会存在一个问题：项目开发后期，有些服务进行了版本升级，有些服务没有，这样当它们被打包成同一个软件包时，就会导致版本号不一致。  </p><p>每个服务都指定一个版本号，对开发而言也比较麻烦。一个比较好的实践就是微服务+全局版本模式。对于经常发生功能变更、需要独立升级的服务，将其独立拆分出来进行微服务化，实现单个微服务级的打包和部署。  </p><p>对于其它服务，服务框架提供全局版本功能，在 Maven组件工程开发时，只需要为整个工程配置一个版本号，该组件工程包含的所有服务都共用该版本号。如果组件工程包含的某个服务发生了版本变更，就统一升级全局版本号，其它未发生功能变更但是打包在一起的服务做级联升级。这样做的一个原因是服务被打包在一起后，无论其它服务是否需要升级，只要软件包中的一个服务发生了版本升级，其它合设的服务也必须与其一起打包升级，它们之间存在物理上的耦合，这也是为什么微服务架构提倡微服务独立打包、部署和升级的原因。</p><h2 id="1-3-服务消费者"><a href="#1-3-服务消费者" class="headerlink" title="1.3 服务消费者"></a>1.3 服务消费者</h2><p>与服务提供者不同，服务消费者往往不需要指定具体依赖的服务版本，而是一版本范围，例如：version=“[1.0.1, 2.0.8]”。  </p><ol><li>消费者关心的是某个新特性从哪个服务版本中开始提供，它并不关系服务提供者的版本演进以及具体的版本号。</li><li>消费者想使用当前环境中服务的最新版本，但不清楚具体的版本号，希望自动适配最新的服务版本。</li></ol><p>当然需要指定一个默认的服务提供者版本号。</p><h2 id="1-4-基于版本号的服务路由"><a href="#1-4-基于版本号的服务路由" class="headerlink" title="1.4 基于版本号的服务路由"></a>1.4 基于版本号的服务路由</h2><p>服务提供者将服务注册到服务注册中心时，将服务名+服务版本号+服务分组作为路由关键信息存放到注册中心，服务消费者在发起服务调用时，除了携带服务名、方法名、参数列表之外，还需要携带要消费的服务版本信息，由路由接口负责服务版本过滤，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_1.png" alt></p><h2 id="1-5-服务热升级"><a href="#1-5-服务热升级" class="headerlink" title="1.5 服务热升级"></a>1.5 服务热升级</h2><p>在业务不中断的情况下，实现系统的平滑升级，考虑到版本升级的风险，往往需要做多次滚动升级，最终根据升级之后新版本服务的运行状况决定是继续升级还是回退。这就意味着在同一时刻，整个集群环境中会同时存在服务的多个版本咋线运行，这就是热升级相比于传统 AB Test等升级方式的差异，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_2.png" alt><br>核心点如下：</p><ol><li>升级的节点需要重启，由于自动发现机制，停机升级的节点自动被隔离，停机并不会中断业务。</li><li>服务路由规则的定制：如果是滚动式的灰度发布，在相当长的一段时间（例如一周）内线上都会存在服务的多个版本。哪些用户或者业务需要路由到新版本上，需要通过路由策略和规则进行制定，服务框架应该支持用户配置自定义的路由规则来支持灵活的路由策略。</li><li>滚动升级和回退机制：为了降低服务热升级对业务的影响，同时考虑到可靠性，在实际工作中往往采用滚动升级的方式，分批次进行服务的热升级，实现敏捷的特性交付，滚动升级如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/13_3.png" alt></li></ol><h1 id="2-与-OSGI-的对比"><a href="#2-与-OSGI-的对比" class="headerlink" title="2 与 OSGI 的对比"></a>2 与 OSGI 的对比</h1><p>OSGI，成立于 1999年，全名原为：Open Services Gateway initiative，但现在这个全名已经废弃。<br>致力于家用设备、汽车、手机、桌面、其它环境指定下一代网络服务标准的领导者，推出了 OSGI 服务平台规范，用于提供开放和通用的架构，使得服务提供商、开发人员、软件提供商、网关操作者和设备提供商以统一的方式开发、部署和管理服务。  </p><p>目前最广泛和应用是 OSGI规范5（Release 5），共由核心规范、标准服务（Standard Services）、框架服务（Framework Services）、系统服务（System Services）、协议服务（Protocol Services）、混合服务（Miscellaneous Services）等几部分共同组成。<br>核心规范通过一个分层的框架，实现了 OSGI最为成功的动态插件机制，它主要提供了：</p><ol><li>OSGI Bundle 的运行环境。</li><li>OSGI Bundle 间的依赖管理。</li><li>OSGI Bundle 的生命周期管理。</li><li>OSGI 服务的动态交互模型。</li></ol><p>OSGI 两个最核心的特性就是模块化和热插拔机制，分布式服务框架的服务多版本管理和热升级是否可以基于 OSGI来实现？下面围绕着模块化和插件热插拔这两个特性进行详细分析。</p><h2 id="2-1-模块化开发"><a href="#2-1-模块化开发" class="headerlink" title="2.1 模块化开发"></a>2.1 模块化开发</h2><p>在 OSGI中，我们以模块化的方式去开发一个系统，每个模块被称为 Bundle，OSGI 提供了对 Bundle的整个生命周期管理，包括打包、部署、运行、升级、停止等。<br>模块化的核心并不是简单地把系统拆分成不同的模块，如果仅仅是拆分，原生的 Jar包+Eclipse工程就能够解决问题。更为重要的是要考虑到模块中接口的导出、隐藏、依赖、版本管理、打包、部署、运行和升级等全生命周期管理，这些对于原生的 Jar包而言是不支持的。<br>传统开发的模块划分通常由两种方式：  </p><ol><li>使用 package来进行隔离。</li><li>定义多个子工程，工程之间通过工程引用的方式进行依赖管理。<br>存在的问题：无法实现资源的精细划分和对依赖做统一管理。以 Jar包依赖为例，依赖一个 Jar包就意味着这个 Jar包中所有 public的资源都可能被引用，但事实上也许只需要依赖该 Jar包中的某几个 public接口。无法对资源做细粒度、精确的管控，不知道 public的接口都被哪些模块依赖和使用，消费者是谁，更为复杂的场景是如果消费者需要依赖不同的接口版本，那该肿么办？  </li></ol><p>OSGI 很好地解决了这个问题，每个 OSGI工程是一个标准的插件工程，实际就是一个 Bundle。实现了 package级的管理依赖关系，而 Maven则是 Jar包级的管理依赖。<br>而分布式服务：</p><ol><li>服务提供者通过 service export将某个服务接口发布出去，供消费者使用。</li><li>服务消费者通过 service import导入某个服务接口，它不关心服务提供者的具体位置，也不关心服务的具体实现细节。<br>这样就比 OSGI的 package导入导出功能粒度更细。<br>利用 Maven的模块化管理 + 分布式服务框架自身的服务接口导入导出功能，解决了模块化开发和精细化依赖管理难题，完成可以替代 OSGI的相关功能，</li></ol><h2 id="2-2-插件热部署和热升级"><a href="#2-2-插件热部署和热升级" class="headerlink" title="2.2 插件热部署和热升级"></a>2.2 插件热部署和热升级</h2><p>OSGI 另外一个非常酷的特性就是动态性，即插件的热部署和热升级，它可以在不重启 JVM的情况下安装部署一个插件，实现升级不中断业务。<br>OSGI 的插件热部署和热升级原理就是基于自身的网状类加载机制实现的，下面我们分析在分布式服务框架中，如何实现服务热部署和热升级：  </p><ol><li>服务是分布式集群部署的，通常也是无状态的，停掉其中某一个服务节点，并不会影响系统整体的运行质量。</li><li>服务自动发现和隔离机制，当有新的服务节点加入时，服务注册中心会向消费者集群推送新的服务地址信息；当有服务节点宕机或重启时，服务注册中心会发送服务下线通知消息给消费者集群，消费者会将下线服务自动隔离。</li><li>优雅停机功能，在进程退出之前，处理完消息队列积压的消息，不再接受新的消息，最大限度保障丢失消息。</li><li>集群容错功能，如果服务提供者正在等待应答消息时系统推出了，消费者会发生服务调用超时，集群容错功能会根据策略重试其它正常的服务节点，保证流程不会因为某个服务实例宕机而中断。</li><li>服务多版本管理，支持集群中同一个服务的多个版本同时运行，支持路由规则定制，不同的消费者可以消费不同的服务版本。</li></ol><p>相比于 OSGI在 JVM内部通过定制类加载机制实现插件的多版本运行和升级，使用分布式服务框架自身的分布式集群特性实现服务的热部署和热升级，更加简单、灵活和可控。</p><h1 id="3-个人总结"><a href="#3-个人总结" class="headerlink" title="3 个人总结"></a>3 个人总结</h1><p>服务多版本在实际项目中非常实用，用于实现服务的热部署和热升级，同时支持按照消费者做差异化路由，同时也方便演进到微服务架构，来迁移到服务的独立打包、部署、运行和运维。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十二、参数传递</title>
      <link href="/2018/06/05/distributed_principle_prictice/12.html/"/>
      <url>/2018/06/05/distributed_principle_prictice/12.html/</url>
      
        <content type="html"><![CDATA[<p>服务消费者和提供者之间进行通信时，除了接口定义的请求参数，往往还需要携带一些额外参数，例如消费提供者的 IP地址、消息调用链的跟踪 ID等；这些参数不能通过业务接口来进行传递，需要底层的分布式服务框架支持这种参数传递方式。</p><h1 id="1-内部参数"><a href="#1-内部参数" class="headerlink" title="1 内部参数"></a>1 内部参数</h1><h2 id="1-1-业务内部参数传递"><a href="#1-1-业务内部参数传递" class="headerlink" title="1.1 业务内部参数传递"></a>1.1 业务内部参数传递</h2><ol><li>硬编码，在业务逻辑中进行 API调用，参数通过 API接口进行引用传参。</li><li>业务编排引擎对业务流程进行编排，参数往往通过抽象的编排上下文进行传递。</li><li>通过专业的 BPM流程引擎进行业务逻辑编排，参数通过流程上下文进行传递。</li></ol><p>硬编码通常会直接通过方法参数进行参数传递，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_1.png" alt><br>还有一种比较常用的方法就是通过线程上下文进行参数传递。通常情况下业务逻辑处理过程很少发生线程切换，因此通过线程上下文进行隐式传参可以不与某个具体方法接口耦合，对业务解耦接口没有侵入性。例如 Spring 的资源和事务线程绑定机制，利用的就是 JDK 提供的线程上下文。使用线程上下文传参是一种隐式传参，上面的方法调用可以简化成如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_2.png" alt><br>最后一种方式就是 BPM流程引擎，流程引擎通过流程上下文进行参数传递，用户可以在流程编排界面声明流程级参数和全局参数，流程引擎通过流程上下文进行参数传递。</p><h2 id="1-2-服务框架内部参数擦混地"><a href="#1-2-服务框架内部参数擦混地" class="headerlink" title="1.2 服务框架内部参数擦混地"></a>1.2 服务框架内部参数擦混地</h2><p>服务框架内部由多个模块组成，模块之间的调用通常会发生线程切换；另外，当服务框架通过反射调用服务接口实现类时，也需要向业务代码传递一些额外的参数，这些参数如何传递？下面我们分别对这两类场景进行分析：  </p><ol><li>通信框架将数据报反序列化成业务请求对象之后，需要将消息封装成 Task，丢到后面的业务线程池中执行，此时会发生线程切换，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_4.png" alt><br>由于发生了线程切换，如果通过线程变量的方式传递参数，需要遍历线程上下文，将线程变量复制到业务线程池的线程变量中，非常麻烦。如果后续新增系统参数，往往会忘记复制，导致参数不一致。<br>这种场景中，一般会选择通过消息上下文进行参数传递，例如在业务请求参数中定义了 Map 扩展参数，用于跨线程的参数传递。  </li><li>当服务框架回调业务接口实现类时，由于是通过反射调用，业务接口的参数已经定义好了，无法传递其它参数（例如消费者的 IP地址、调用链 ID等参数）。为了解决这个问题，需要利用线程变量，因为平台调用服务实现类不会发生线程切换，所以通过线程变量传参是安全的。</li></ol><h1 id="2-外部参数"><a href="#2-外部参数" class="headerlink" title="2 外部参数"></a>2 外部参数</h1><p>主要用途：</p><ol><li>服务框架自身的参数传递，例如分布式事务中事务上下文信息传递。</li><li>业务之间的参数传递，例如业务调用链 ID的传递，用于唯一表示某个完整业务流程。</li></ol><h2 id="2-1-通信协议支持"><a href="#2-1-通信协议支持" class="headerlink" title="2.1 通信协议支持"></a>2.1 通信协议支持</h2><p>消费者的自定义参数传递到服务端，需要有一个载体，它就是通信协议。一个设计良好的协议，往往支持用户自定义扩展消息头，在协议消息头中，可以预留一个 Map&lt;String, byte[]&gt; 类型的字段，用于服务框架或者用户自定义参数扩展。</p><h2 id="2-2-传参接口定义"><a href="#2-2-传参接口定义" class="headerlink" title="2.2 传参接口定义"></a>2.2 传参接口定义</h2><p>服务框架需要提供参数设置 API接口，用于业务跨进程的参数传递。建议使用线程变量，例如平台定义一个 RPCContext 线程变量供业务传参使用。<br>服务框架在业务请求参数传递到通信框架时，需要遍历 RPCContext，将框架和业务设置的参数复制到通信线程中，由通信线程在序列化时将请求参数设置到消息头中，传递到通信对端，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/12_5.png" alt></p><h1 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h1><h2 id="3-1-防止参数互相覆盖"><a href="#3-1-防止参数互相覆盖" class="headerlink" title="3.1 防止参数互相覆盖"></a>3.1 防止参数互相覆盖</h2><p>由于使用的是 Map 或线程变量，因此需要防止参数互相覆盖：  </p><ol><li>服务框架系统参数和业务参数的互相覆盖。</li><li>业务之间的参数覆盖。</li></ol><p>一些系统参数往往默认会被平台占用，例如 IP、timeStamp、Host、ServiceName、Group 等常见字段。因此系统平台需要规范，对于业务来说需要有一个全局的业务传参规则。</p><h2 id="3-2-参数声明周期管理"><a href="#3-2-参数声明周期管理" class="headerlink" title="3.2 参数声明周期管理"></a>3.2 参数声明周期管理</h2><p>预防内存泄漏！通常，服务框架能对参数生命周期进行自动管理，例如对于服务端，服务调用前设置参数，服务调用后清空参数。<br>但是对于消费者比较复杂，如果在将参数序列化到请求头发送之后自动清空参数，后续应答返回之后消费者可能需要继续访问之前的参数，但是有可能后续不使用该参数或者忘记删除该参数就会导致参数堆积。如果参数名每次都不同，则会发生内存泄漏。  </p><p>最好的方式就是平台的提供一个删除模式参数的 API，允许用户手动删除，如果用户不指定就自动删除。</p><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>参数传递涉及到上下文、通信框架的线程切换、以及自动删除的自动管理等，而服务框架需要提供不同的参数传递模式以适应业务。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十一、服务灰度发布</title>
      <link href="/2018/06/04/distributed_principle_prictice/11.html/"/>
      <url>/2018/06/04/distributed_principle_prictice/11.html/</url>
      
        <content type="html"><![CDATA[<p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test 就是一种灰度发布方式：让一部分用户继续用 A，一部分用户开始用 B；如果用户对 B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><h1 id="1-服务灰度发布流程设计"><a href="#1-服务灰度发布流程设计" class="headerlink" title="1 服务灰度发布流程设计"></a>1 服务灰度发布流程设计</h1><p>服务灰度发布的主要作用如下：  </p><ol><li>解决服务升级不兼容问题。</li><li>及早获得用户的意见反馈，完善产品功能，提升服务质量。</li><li>缩小服务升级所影响的用户范围，降低升级风险。</li><li>让用户及早参与产品测试，加强用户互动。</li></ol><h2 id="1-1-灰度环境准备"><a href="#1-1-灰度环境准备" class="headerlink" title="1.1 灰度环境准备"></a>1.1 灰度环境准备</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_1.png" alt>  </p><ol><li>系统运维人员通过管理员账号登录灰度发布 Portal或者进入服务治理的灰度发布界面。</li><li>在生产环境中圈定本轮灰度发布的范围，它通常是一个应用集群，包括前后台服务，当然可能是单个服务。</li><li>将选择的服务灰度发布范围信息保存到服务注册中心，用于后续的规则下发和灰度升级历史记录查询等。</li><li>通知灰度升级查询内的服务实例下线，通常会采用优雅停机的方式让待升级的服务下线，保证升级不中断业务。</li><li>应用金城接收到优雅停机指令后，将本进程内缓存的消息处理完，然后优雅退出。</li><li>从软件仓库选择需要升级的服务安装镜像包，用于灰度环境的版本升级。</li><li>将升级包批量上传到灰度环境中，把原来的业务软件包做本地备份之后，升级服务版本。</li><li>灰度环境升级部署成功之后，返回灰度环境部署成功消息给灰度发布管理控制台，然后进行后续的灰度发布操作。</li></ol><h2 id="1-2-灰度规则设置"><a href="#1-2-灰度规则设置" class="headerlink" title="1.2 灰度规则设置"></a>1.2 灰度规则设置</h2><p>灰度环境准备完成之后，运维人员对灰度规则进行配置，灰度规则主要用于服务路由。<br>按照规则的不同，部分用户将调用老的服务，另一部分用户则会调用灰度环境中新发布的服务，常用的灰度规则分类如下：  </p><ol><li>按照接入门户类型分类，例如网上营业厅、手机客户端、营业厅实体店、自主业务办理终端等。</li><li>按照终端类型分类，例如 Android、IOS、Windows Phone 等。</li><li>按照区域进行划分，例如东北、华北、华中等。</li><li>其它策略。</li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_2.png" alt></p><h2 id="1-3-灰度规则下发"><a href="#1-3-灰度规则下发" class="headerlink" title="1.3 灰度规则下发"></a>1.3 灰度规则下发</h2><p>灰度规则设置完成之后，需要将规则下发给参与消费路由的软负载均衡器 SLB、Web前台和后台服务，它的处理流程如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_3.png" alt><br>灰度规则下发，主要由服务注册中心负责推送，推送的目标包括前端的 SLB负载均衡器、Web 前台集群和 App 后台服务集群，各节点将灰度规则缓存到本地内存中；消息或者服务路由时，通过路由插件解析灰度规则，将消息路由到指定到服务版本中。需要指出的是，灰度规则的通知范围是整个生产环境集群，包括灰度发布环境和非灰度生产环境。</p><h2 id="1-4-灰度路由"><a href="#1-4-灰度路由" class="headerlink" title="1.4 灰度路由"></a>1.4 灰度路由</h2><p>通过 SLB定制的灰度发布插件，可以将 HTTP消息按照规则分发到不同的 Web前台；Web前台根据内置的服务框架 SDK，通过客户端灰度路由插件，解析灰度规则，将服务路由到灰度或者非灰度环境，实现服务的灰度路由。<br>灰度路由的流程如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_4.png" alt><br>需要指出的是，如果灰度规则解析失败，实际上就无法区分哪些服务应该路由到灰度环境，这种场景下比较合适的做法就是将服务路由到非灰度环境。如果服务提供者无法处理或者处理失败，则需要对灰度发布做回退处理，并通知所有受影响的服务消费者。</p><h2 id="1-5-失败回滚"><a href="#1-5-失败回滚" class="headerlink" title="1.5 失败回滚"></a>1.5 失败回滚</h2><p>失败回滚的流程如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/11_5.png" alt></p><h2 id="1-6-灰度发布总结"><a href="#1-6-灰度发布总结" class="headerlink" title="1.6 灰度发布总结"></a>1.6 灰度发布总结</h2><p>灰度发布之后，需要对灰度发布之后的服务运行和运营情况进行分析，包括服务调用来源分析、服务性能 KPI数据、用户行为分析报告、用户问卷调查等，通过对这些数据进行分析来改进服务功能，完善产品，为新一轮灰度发布做铺垫。</p><h1 id="2-个人总结"><a href="#2-个人总结" class="headerlink" title="2 个人总结"></a>2 个人总结</h1><p>互联网产品在于不停地升级、升级，再升级，但是升级伴随着风险，新旧版本兼容的风险，用户使用习惯突然改变而造成用户流失的风险，系统宕机的风险等。为了避免这些风险，很多产品都采用了灰度发布的策略，其主要思想就是把影响集中到一个点，然后再发散到一个面，出现意外情况后就容易回退。<br>分布式服务框架支持服务的灰度发布，可以实现业务的快速试错和敏捷交付。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十、服务发布和引用</title>
      <link href="/2018/06/03/distributed_principle_prictice/10.html/"/>
      <url>/2018/06/03/distributed_principle_prictice/10.html/</url>
      
        <content type="html"><![CDATA[<p>服务提供者需要支持通过配置、注解、API调用等方式，把本地接口发布成远程服务；对于消费者，可以通过对等的方式引用远程服务提供者，实现服务的发布和引用。</p><h1 id="1-服务发布设计"><a href="#1-服务发布设计" class="headerlink" title="1 服务发布设计"></a>1 服务发布设计</h1><p>服务发布流程：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_1.png" alt></p><h2 id="1-1-服务发布的几种方式"><a href="#1-1-服务发布的几种方式" class="headerlink" title="1.1 服务发布的几种方式"></a>1.1 服务发布的几种方式</h2><ol><li>XML配置化方式：业务代码零侵入</li><li>注解方式：业务代码低侵入</li><li>API调用方式：业务代码侵入较强</li></ol><h2 id="1-2-本地实现类封装成代理"><a href="#1-2-本地实现类封装成代理" class="headerlink" title="1.2 本地实现类封装成代理"></a>1.2 本地实现类封装成代理</h2><p>对于服务提供者，将本地实现类封装成代理对象不是必需的：也可以利用一系列工具类解析服务提供者信息，然后将服务提供者的地址信息注册到服务注册中心。采用动态代理的好处如下：  </p><ol><li>不管是什么服务，它们的发布流程都是相似的，通过抽象代理层，可以对服务发布行为本身进行封装和抽象。</li><li>通过动态代理对象，可以对服务发布进行动态拦截，方便平台和业务对服务发布进行个性化定制。</li><li>便于扩展和替换。</li></ol><h2 id="1-3-服务发布成指定协议"><a href="#1-3-服务发布成指定协议" class="headerlink" title="1.3 服务发布成指定协议"></a>1.3 服务发布成指定协议</h2><p>同一个服务，允许发布成多种协议，例如 HTTP、Thrift 等。</p><h2 id="1-4-服务提供者信息注册"><a href="#1-4-服务提供者信息注册" class="headerlink" title="1.4 服务提供者信息注册"></a>1.4 服务提供者信息注册</h2><p>服务按指定协议发布之后，需要将服务发布信息注册到注册中心，用于服务路由和服务治理。  </p><p>服务注册的结构有多种方式，例如按照主机地址、按照服务名或者 URL。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_2.png" alt></p><h1 id="2-服务引用设计"><a href="#2-服务引用设计" class="headerlink" title="2 服务引用设计"></a>2 服务引用设计</h1><p>消费者导入服务提供者的接口 API定义，配置服务引用信息，即可在代码中直接调用远程服务：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_3.png" alt>  </p><h2 id="2-1-本地接口调用转换成远程服务调用"><a href="#2-1-本地接口调用转换成远程服务调用" class="headerlink" title="2.1 本地接口调用转换成远程服务调用"></a>2.1 本地接口调用转换成远程服务调用</h2><p>原理在于根据导入的服务提供者接口 API和服务引用信息，生成远程服务的本地动态代理对象；它负责将本地的 API调用转换成远程服务调用，然后将结果返回给调用者。</p><h2 id="2-2-服务地址的本地缓存"><a href="#2-2-服务地址的本地缓存" class="headerlink" title="2.2 服务地址的本地缓存"></a>2.2 服务地址的本地缓存</h2><p>服务消费者和提供者的启动顺序无法控制，因此消费者需要检测指定服务目录，监听新的服务提供者注册和已发布服务的下线，工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_4.png" alt></p><h2 id="2-3-远程服务调用"><a href="#2-3-远程服务调用" class="headerlink" title="2.3 远程服务调用"></a>2.3 远程服务调用</h2><p>消费者从本地缓存的服务列表中按照指定策略路由，将请求消息封装成协议消息：调用相关协议的客户端将请求发送给服务提供者，业务线程按照服务调用方式选择同步等待或者注册监听器回调。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/10_5.png" alt></p><h1 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h1><h2 id="3-1-对等设计原则"><a href="#3-1-对等设计原则" class="headerlink" title="3.1 对等设计原则"></a>3.1 对等设计原则</h2><p>例如，通过 XML的 Method 元素可以配置方法级参数，那么 API或者注解也应该支持方法级设置，以防止能力不对等。</p><h2 id="3-2-启动顺序问题"><a href="#3-2-启动顺序问题" class="headerlink" title="3.2 启动顺序问题"></a>3.2 启动顺序问题</h2><p>服务注册中心如果后启动，需要服务提供者和消费者能够自动重连。</p><h2 id="3-3-同步还是异步发布服务"><a href="#3-3-同步还是异步发布服务" class="headerlink" title="3.3 同步还是异步发布服务"></a>3.3 同步还是异步发布服务</h2><p>通常情况下，服务全部准备就绪的时间比较短，而且系统启动之后也并不意味着所有服务都会被立即消费，因此，采用异步的方式发布服务也是可行的。<br>当然还有另外一些办法可减少系统启动时间。例如对于不经常访问的服务采用延迟发布的策略；还有就是服务的懒加载，只发布服务但是不初始化，等到消费者真正调用的时候才进行初始化服务。</p><h2 id="3-4-警惕网络风暴"><a href="#3-4-警惕网络风暴" class="headerlink" title="3.4 警惕网络风暴"></a>3.4 警惕网络风暴</h2><p>在大规模集群系统中，服务注册中心可能管理数十万条的服务注册信息以及上万个服务提供者和消费者节点。如果服务注册中心管理了大量经常变更的信息，就会发生频繁的变更通知：而这种海量的变更通知可能会挤占服务注册中心的网络带宽，严重时还会导致网络风暴。<br>因此，在设计时需要考虑如下几个要素：  </p><ol><li>哪些信息需要注册到服务注册中心，需要甄别。</li><li>服务注册中心能够管理的服务上限。</li><li>服务注册中心的网络带宽规划。</li><li>服务注册中心的磁盘空间规划。</li><li>服务注册中心的性能。</li></ol><h2 id="3-5-配置扩展"><a href="#3-5-配置扩展" class="headerlink" title="3.5 配置扩展"></a>3.5 配置扩展</h2><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>好的分布服务框架对业务代码的侵入要足够低（使用 XML配置方式），将普通的 Java 接口发布成远程服务。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>九、服务注册中心</title>
      <link href="/2018/06/02/distributed_principle_prictice/9.html/"/>
      <url>/2018/06/02/distributed_principle_prictice/9.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-几个概念"><a href="#1-几个概念" class="headerlink" title="1 几个概念"></a>1 几个概念</h1><h2 id="1-1-服务提供者"><a href="#1-1-服务提供者" class="headerlink" title="1.1 服务提供者"></a>1.1 服务提供者</h2><h2 id="1-2-服务消费者"><a href="#1-2-服务消费者" class="headerlink" title="1.2 服务消费者"></a>1.2 服务消费者</h2><h2 id="1-3-服务注册中心"><a href="#1-3-服务注册中心" class="headerlink" title="1.3 服务注册中心"></a>1.3 服务注册中心</h2><p>服务注册中心是分布式服务框架的目录服务器，相比于传统的目录服务器，它有如下几个特点：  </p><ol><li>高 HA：支持数据持久化、支持集群。</li><li>数据一致性问题：集群中所有的客户端应该看到同一份数据，不能出现读或者写数据不一致。</li><li>数据变更主动推送：当注册中心的数据发生变更时（增加、删除、修改）需要能够及时将变化的数据通知给客户端。</li></ol><h1 id="2-关键功能特性设计"><a href="#2-关键功能特性设计" class="headerlink" title="2 关键功能特性设计"></a>2 关键功能特性设计</h1><p>服务注册中心的工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_1.png" alt>  </p><ol><li>服务提供者在启动时，根据服务发布文件中配置的服务发布信息向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，根据消费者配置文件中配置的服务消费信息向注册中心订阅自己所需的服务，消费者刷新本地缓存的路由表。</li><li>注册中心返回服务提供者地址列表，如果有变更，注册中心主动推送变更数据给消费者，消费者刷新本地缓存的路由表。</li><li>服务消费者从本地缓存的服务提供者地址列表中，基于负载均衡算法选择一台服务提供者进行调用。</li></ol><h2 id="2-1-支持对等集群"><a href="#2-1-支持对等集群" class="headerlink" title="2.1 支持对等集群"></a>2.1 支持对等集群</h2><p>服务注册中心需要支持对等集群，如下图，其中某一个或者多个服务注册中心进程宕机，不会导致服务注册中心集群功能不可用。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_2.png" alt><br>对于客户端，无论服务注册中心集群配置多少个进程，客户端只需要连接其中某一个即可（服务端之间自己进行数据同步），如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_3.png" alt></p><h2 id="2-2-提供-CRUD-接口"><a href="#2-2-提供-CRUD-接口" class="headerlink" title="2.2 提供 CRUD 接口"></a>2.2 提供 CRUD 接口</h2><p>客户端连接服务注册中心之后，需要能够对服务注册中心的数据进行操作：</p><ol><li>查询接口：查询系统当前发布的服务信息和订阅的消费者信息。</li><li>修改接口：修改已经发布的服务属性或者消费者属性信息，通常用于运行态的服务治理。</li><li>新增接口：发布或者订阅新的服务。</li><li>删除接口：去注册已经发布的服务，或者消费者取消订阅关系。</li></ol><h2 id="2-3-安全加固"><a href="#2-3-安全加固" class="headerlink" title="2.3 安全加固"></a>2.3 安全加固</h2><p>服务注册中心需要进行安全加固，安全加固主要涉及两部分：  </p><ol><li>链路的安全性。</li><li>数据的安全性。</li></ol><p>链路的安全性指的是服务注册中心对客户端连接进行安全认证，认证策略非常多，最简单的就是基于 IP地址的黑名单校验，更加复杂的有基于用户名+密码的认证，或者基于秘钥+数字证书的认证。<br>认证失败，则关闭链路，拒绝客户端连接。  </p><p>数据的安全性主要针对服务注册中心的数据进行权限控制：  </p><ol><li>非授权客户端既不能读取也不能写入数据。</li><li>普通运维人员只能读取数据，不能修改数据。</li><li>管理员既可以读取也可以修改数据。</li><li>不同的服务目录可以设置不同的访问权限，例如消费者只能查看它所在机房的服务。<br>数据安全性工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_4.png" alt></li></ol><h2 id="2-4-订阅发布机制"><a href="#2-4-订阅发布机制" class="headerlink" title="2.4 订阅发布机制"></a>2.4 订阅发布机制</h2><p>对于服务提供者，可以根据服务名等信息动态发布服务；对于消费者，可以根据订阅关系主动获得服务发布者的地址信息等。订阅发布机制还有一个比较重要的机制就是对变化的监听和主动推送能力：</p><ol><li>消费者可以监听一个或者多个服务目录，当目录名称、内容发生变更时，消费者可以实时地获得变更的数据或者变更后的结果信息。</li><li>服务提供者可以发布一个或者多个服务，动态修改服务名称、服务内容等，可以主动将修改后的数据或者修改后的结果推送给所有监听此服务目录的消费者。<br>订阅发布机制有如下优点：  </li><li>透明化路由：服务提供者和消费者互相解耦，服务提供者未知透明，消费者不需要再硬编码服务提供者地址。</li><li>服务健康状态监测：服务注册中心可以实时监测发布服务的质量，如果服务提供者宕机，由服务注册中心实时通知消费者。</li><li>弹性伸缩能力（动态发现）：应用在云端部署之后，由于 VM资源占用率过高，动态伸展出一个新的服务提供者，服务注册中心会将新增的服务提供者地址信息推送给消费者，消费者刷新本地路由表之后可以访问新的服务提供者，实现服务的弹性伸缩。</li></ol><h2 id="2-3-可靠性"><a href="#2-3-可靠性" class="headerlink" title="2.3 可靠性"></a>2.3 可靠性</h2><p>服务注册中心需要支持对等集群，任意一台宕机后，服务都能自动切换到其它正常的服务注册中心。<br>如果服务注册中心全部宕机，只影响新的服务注册、已发布服务的下线。（想想为什么）<br>服务提供者的健康状态监测也由服务注册中心负责监测，通过长连接心跳检测服务提供者的存在，宕机则实时推送消息，实现实时故障隔离。</p><h1 id="3-基于-ZooKeeper-的服务注册中心设计"><a href="#3-基于-ZooKeeper-的服务注册中心设计" class="headerlink" title="3 基于 ZooKeeper 的服务注册中心设计"></a>3 基于 ZooKeeper 的服务注册中心设计</h1><h2 id="3-1-服务订阅发布流程设计"><a href="#3-1-服务订阅发布流程设计" class="headerlink" title="3.1 服务订阅发布流程设计"></a>3.1 服务订阅发布流程设计</h2><p>流程设计如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/9_5.png" alt></p><h2 id="3-2-服务健康状态监测"><a href="#3-2-服务健康状态监测" class="headerlink" title="3.2 服务健康状态监测"></a>3.2 服务健康状态监测</h2><p>基于 ZK 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态监测。</p><h2 id="3-3-对等集群防止单点故障"><a href="#3-3-对等集群防止单点故障" class="headerlink" title="3.3 对等集群防止单点故障"></a>3.3 对等集群防止单点故障</h2><p>ZK 使用了原子广播（恢复服务和广播服务）实现故障转移以及同步。</p><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>服务注册中心要保证可靠性、安全性、可扩展性。ZK 是常用的技术。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同学聚会</title>
      <link href="/2018/06/01/talker/schoolmate01.html/"/>
      <url>/2018/06/01/talker/schoolmate01.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第一次聚会：2018-06-08-南京"><a href="#1-第一次聚会：2018-06-08-南京" class="headerlink" title="1. 第一次聚会：2018/06/08 南京"></a>1. 第一次聚会：2018/06/08 南京</h1><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名</th><th style="text-align:center">达到日期</th><th style="text-align:center">起始时间</th><th style="text-align:center">起始地点</th><th style="text-align:center">车次号</th><th style="text-align:center">婚育概要</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">陈佳慧</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">孔令洲</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">高帅星</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">蒋鑫</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">王雨木</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">16:10~18:45</td><td style="text-align:center">长春~南京禄口</td><td style="text-align:center">DZ6258</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">黄菡璐</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">20:09~22:10</td><td style="text-align:center">义乌~南京南</td><td style="text-align:center">G1504</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">谢飘飘</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">20:42~22:10</td><td style="text-align:center">杭州东~南京南</td><td style="text-align:center">G1504</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">陈圳</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">18:39~22:12</td><td style="text-align:center">汉口~南京南</td><td style="text-align:center">D2374</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">吴琦薇</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">20:35~22:27</td><td style="text-align:center">上海~南京南</td><td style="text-align:center">G7286</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">李文广</td><td style="text-align:center">2018-06-08</td><td style="text-align:center">20:35~22:27</td><td style="text-align:center">上海~南京南</td><td style="text-align:center">G7286</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">孙任</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">李婷婷</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">杨璐菡</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">未婚</td></tr></tbody></table><p>第一次聚会视频，暂定，完成后上传优酷：  </p><video src="https://securt.oss-cn-hangzhou.aliyuncs.com/first_classmate_reunion_in_nanjing.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"><br>your browser does not support the video tag<br></video><h1 id="2-第二次聚会：2019-06-06-南京"><a href="#2-第二次聚会：2019-06-06-南京" class="headerlink" title="2. 第二次聚会：2019/06/06 南京"></a>2. 第二次聚会：2019/06/06 南京</h1><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名</th><th style="text-align:center">达到日期</th><th style="text-align:center">起始时间</th><th style="text-align:center">起始地点</th><th style="text-align:center">车次号</th><th style="text-align:center">婚育概要</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">陈佳慧</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">孔令洲</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">高帅星</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">蒋鑫</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">全天</td><td style="text-align:center">南京~南京</td><td style="text-align:center">无</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">王雨木</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">15:35~18:20</td><td style="text-align:center">长春~南京禄口</td><td style="text-align:center">深航ZH9382</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">黄菡璐</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">18:52~21:03</td><td style="text-align:center">义乌~南京南</td><td style="text-align:center">G7620</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">谢飘飘</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">17:19~18:41</td><td style="text-align:center">杭州东~南京南</td><td style="text-align:center">G7456</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">陈圳</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">18:00~20:58</td><td style="text-align:center">汉口~南京南</td><td style="text-align:center">D2264</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"><strong>吴琦薇</strong></td><td style="text-align:center">?</td><td style="text-align:center">?</td><td style="text-align:center">?</td><td style="text-align:center">?</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">李文广</td><td style="text-align:center">2019-06-06</td><td style="text-align:center">21:41~22:57</td><td style="text-align:center"><strong>杭州</strong>~南京南</td><td style="text-align:center">G7628</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">孙任</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">李婷婷</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">未婚</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">杨璐菡</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">？</td><td style="text-align:center">未婚</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同学聚会 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八、服务调用</title>
      <link href="/2018/05/31/distributed_principle_prictice/8.html/"/>
      <url>/2018/05/31/distributed_principle_prictice/8.html/</url>
      
        <content type="html"><![CDATA[<p>由于惯性思维，很多人会将传统 MVC架构/RPC架构的做法带入到分布式服务框架的架构设计中，其中有些思想存在误区，或者已经过时，它们会破坏分布式服务框架的架构品质。</p><h1 id="1-几个误区"><a href="#1-几个误区" class="headerlink" title="1 几个误区"></a>1 几个误区</h1><h2 id="1-1-NIO-就是异步服务"><a href="#1-1-NIO-就是异步服务" class="headerlink" title="1.1 NIO 就是异步服务"></a>1.1 NIO 就是异步服务</h2><p>NIO 只解决了通信层面的异步问题，跟服务调用的异步没有必然关系，也就是说，即便采用传统的 BIO 通信，依然可以实现异步服务调用，只不过通信效率和可靠性比较差。<br>下面对异步服务调用和通信框架的关系进行说明：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_1.png" alt><br>用户发起远程服务调用之后，经历层层业务逻辑处理、消息编码，最终序列化后的消息会被放入到通信框架的消息队列中。业务线程可以选择同步等待、也可以选择直接返回，通过消息队列的方式实现业务层和通信层的分离是比较成熟、典型的做法。<br>采用 NIO还是 BIO对上层的业务是不可见的，双方的汇聚点就是消息队列。业务线程将消息放入到发送队列中，可以选择主动等待或者立即返回，跟通信框架是否是 NIO 没有任何关系。</p><h2 id="1-2-服务调用天生就是同步的"><a href="#1-2-服务调用天生就是同步的" class="headerlink" title="1.2 服务调用天生就是同步的"></a>1.2 服务调用天生就是同步的</h2><p>服务调用主要有两种模式：</p><ol><li>OneWay 模式：只有请求，没有应答，例如通知消息。</li><li>请求-应答模式：一请求，一应答的模式，这种模式最常用。</li></ol><p>OneWay 模式的服务调用由于不需要返回应答，因此很容易被设计成异步的：消费者发起远程服务调用之后，立即返回，不需要同步阻塞等待应答。<br>对于请求-应答模式，可以利用 Future-Listener 机制来实现异步服务调用。从业务角度看，它的效果与同步等待等价，但是从技术角度来看，可以保证业务线程在不同步阻塞的情况下实现同步等待的效果，执行效率更高。</p><h2 id="1-3-异步服务调用性能更高"><a href="#1-3-异步服务调用性能更高" class="headerlink" title="1.3 异步服务调用性能更高"></a>1.3 异步服务调用性能更高</h2><p>复杂的场景，异步服务调用会更高，越复杂的场景，异步服务调用优势越大。</p><h1 id="2-服务调用方式"><a href="#2-服务调用方式" class="headerlink" title="2 服务调用方式"></a>2 服务调用方式</h1><h2 id="2-1-同步服务调用"><a href="#2-1-同步服务调用" class="headerlink" title="2.1 同步服务调用"></a>2.1 同步服务调用</h2><p>没什么可说的，只是需要注意设置用户线程等待超时时间。</p><h2 id="2-2-异步服务调用"><a href="#2-2-异步服务调用" class="headerlink" title="2.2 异步服务调用"></a>2.2 异步服务调用</h2><p>基于 JDK的 Future机制，异步服务调用的工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_2.png" alt>  </p><ol><li>消费者调用服务端发布的接口，接口调用由分布式服务框架包装成动态代理，发起远程服务调用。</li><li>通信框架异步发送请求消息，如果没有发生 I/O异常，返回。</li><li>请求消息发送成功后，I/O 线程构造 Future 对象，设置到 RPC上下文中。</li><li>用户线程通过 RPC上下文获取 Future对象。</li><li>构造 Listener 对象，将其添加到 Future中，用于服务端应答异步回调通知。</li><li>用户线程返回，不阻塞等待应答，</li><li>服务端返回应答消息，通信框架负责反序列化等。</li><li>I/O 线程将应答设置到 Future 对象的操作结果中。</li><li>Future 对象扫描注册的监听器列表，循环调用监听器的 operationComplete方法，将结果通知给监听器，监听器获取到结果，执行后续业务，异步调用结束。</li></ol><p>还有一种异步调用形式，就是不添加 Listener，用户连续发起 N次服务调用，然后依次从 RPC上下文中获取 Futrue对象，最终再主动 get结果，业务线程阻塞，相对比老的同步服务调用，它的阻塞时间更短，工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_3.png" alt>  </p><p>其串行到并行的优化原理如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_4.png" alt><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/8_5.png" alt>  </p><p>异步服务调用的代码示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XxxService1.xxxMethod(Req); <span class="comment">// 立即返回 null</span></span><br><span class="line">Future f1 = RpcContext.getContext().getFuture();</span><br><span class="line">XxxService2.xxxMethod(Req);</span><br><span class="line">Future f2 = RpcContext.getContext().getFuture();</span><br><span class="line">Object xResult1 = f1.get(<span class="number">3000</span>);</span><br><span class="line">Object xResult2 = f2.get(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>第二种基于 Future-Listener 的纯异步服务调用示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XxxService1.xxxMethod(Req);</span><br><span class="line">Future f1 = RpcContext.getContext().getFuture();</span><br><span class="line">Listener l = <span class="keyword">new</span> Listener();</span><br><span class="line">f1.addListener(l);</span><br></pre></td></tr></table></figure></p><h2 id="2-3-并行服务调用"><a href="#2-3-并行服务调用" class="headerlink" title="2.3 并行服务调用"></a>2.3 并行服务调用</h2><p>A服务-&gt;B服务-&gt;C服务-&gt;…<br>串行服务调用比较简单，但在一些业务场景中，需要采用并行服务调用来降低 E2E 的时延。</p><ol><li>多个服务之间逻辑不存在互相依赖关系，执行先后顺序没有严格的要求，逻辑上可以被并行执行。</li><li>长流程业务，调用多个服务，对时延比较敏感，其中有部分服务逻辑上无上下文关联。<br>目标主要有两个：</li><li>降低业务 E2E 时延。</li><li>提升整个系统的吞吐量。</li></ol><h2 id="2-4-泛化调用"><a href="#2-4-泛化调用" class="headerlink" title="2.4 泛化调用"></a>2.4 泛化调用</h2><p>主要用于客户端没有API 接口及数据模型的场景，使用 Map表示。</p><h1 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h1><p>服务框架支持多种服务调用方式，在实现项目中中如何选择，建议从以下几个角度考虑：  </p><ol><li>降低业务 E2E时延：业务调用链是否太长、某些服务是否不太可靠，需要对服务调用流程进行梳理，看是否可以通过并行服务调用来提升调用效率，降低服务调用时延。</li><li>可靠性角度：某些业务调用链上的关键服务不太可靠，一旦出故障会导致大量线程资源被挂住，可以考虑使用异步服务调用防止故障扩展。</li><li>业务场景：对于测试，不想为每个测试用例都开发一个服务接口，能否做一个通用的测试框架，通过 Map等泛容器实现通用服务调用。</li><li>传统的 RPC调用：服务调用比较简单，对时延要求不高的场景，可以考虑同步服务调用。</li></ol><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>服务调用有多种形式，需要从业务和技术做出取舍。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>七、集群容错</title>
      <link href="/2018/05/30/distributed_principle_prictice/7.html/"/>
      <url>/2018/05/30/distributed_principle_prictice/7.html/</url>
      
        <content type="html"><![CDATA[<p>集群服务调用失败后，服务框架需要能够在底层自动容错。</p><h1 id="1-集群容错场景"><a href="#1-集群容错场景" class="headerlink" title="1 集群容错场景"></a>1 集群容错场景</h1><p>在分布式服务框架中，业务消费者不需要了解服务提供者的具体未知，它发起的服务调用请求也不包含服务提供者具体地址信息。因此，某个服务提供者是否可用对消费者而言无关紧要，最终的服务调用成功才是最重要的。<br>经过服务路由之后，选定某个服务提供者进行远程服务调用，但是服务调用可能会出错，下面进行故障场景进行分析。</p><h2 id="1-1-通信链路故障"><a href="#1-1-通信链路故障" class="headerlink" title="1.1 通信链路故障"></a>1.1 通信链路故障</h2><p>这里的链路指的是消费者和服务提供者之间的链路（通常为长连接），可能导致链路中断的原因有：  </p><ol><li>通信过程中，对方突然宕机导致链路中断。</li><li>通信过程中，对方因为解码失败等原因 Rest 掉连接，导致链路中断。</li><li>通信过程中，消费者 write SocketChannel 发生 IOException 导致链路中断。</li><li>通信过程中，消费者 read SocketChannel 发生 IOException 导致链路中断。</li><li>通信双方因为心跳超时，主动 close SocketChannel 导致链路中断。</li><li>通信过程中，网络发生闪断故障。</li><li>通信过程中，交换机异常导致链路中断。</li><li>通信过程中，消费者或者服务提供者因为长时间 Full GC 导致链路中断。</li></ol><h2 id="1-2-服务端超时"><a href="#1-2-服务端超时" class="headerlink" title="1.2 服务端超时"></a>1.2 服务端超时</h2><ol><li>服务端的 I/O 线程没有及时从网络中读取客户端请求消息，导致该问题的原因通过是 I/O 线程被意外阻塞或者执行长周期操作。</li><li>服务端业务处理缓慢，或者被长时间阻塞，例如查询数据库，由于没有索引导致全表查询，耗时较长。</li><li>服务端发生长时间 Full GC，导致所有业务线程暂停运行，无法及时返回应答给客户端。</li></ol><h2 id="1-3-服务端调用失败"><a href="#1-3-服务端调用失败" class="headerlink" title="1.3 服务端调用失败"></a>1.3 服务端调用失败</h2><ol><li>服务端解码失败，返回消息解码失败异常。</li><li>服务端发生动态流控，返回流控异常。</li><li>服务端消息队列积压率超过最大阈值，返回系统阻塞异常。</li><li>访问权限校验失败，返回权限相关异常。</li><li>违反 SLA 策略，返回 SLA 控制相关异常。</li><li>其它系统异常。</li></ol><p>服务调用异常不包括业务层面的处理异常，例如数据库操作异常、用户记录不存在等异常。</p><h1 id="2-容错策略"><a href="#2-容错策略" class="headerlink" title="2 容错策略"></a>2 容错策略</h1><p>服务不同，容错策略往往也不同，下面是集群容错和服务路由的关系：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/7_1.png" alt><br>消费者根据配置的路由策略选择某个目标地址之后，发起远程服务调用，发起远程服务调用，在此期间如果发生了远程服务调用异常，则需要服务框架进行集群容错，重新进行选路和调用。集群容错是系统自动执行的，上层用户并不需要关心底层的服务调用过程。</p><h2 id="2-1-失败自动切换（FailOver）"><a href="#2-1-失败自动切换（FailOver）" class="headerlink" title="2.1 失败自动切换（FailOver）"></a>2.1 失败自动切换（FailOver）</h2><p>服务调用失败自动切换策略指的是当发生 RPC调用异常时，重新选路，查找下一个可用的服务提供者。<br>服务发布的时候，可以指定服务的集群容错策略。消费者可以覆盖服务提供者的通用配置，实现个性化的容错策略。  </p><p>FailOver 策略的设计思路如下：消费者路由操作完成之后，获得目标地址，调用通信框架的消息发送接口发送请求，监听服务端应答。如果返回的结果是 RPC调用异常（超时、流控、解码失败等系统异常），根据消费者集群容错的策略进行容错路由，如果是 FailOver，则重新返回到路由 Handler 的入口，从路由节点继续执行。选录完成之后，对目标地址进行对比，防止重新路由到故障服务节点，过滤掉上次的故障服务提供者之后，调用通信框架的消息发送接口发送请求消息。  </p><ul><li>读操作，因为通常它是幂等的。</li><li>幂等性服务，保证调用1 次和 N 次效果相同。<br>注意：失败重试会增加服务调用时延，因此框架必须对失败重试的最大次数做限制，通常默认为 3，防止无限制重试导致服务调用时延不可控。</li></ul><h2 id="2-2-失败通知（Failback）"><a href="#2-2-失败通知（Failback）" class="headerlink" title="2.2 失败通知（Failback）"></a>2.2 失败通知（Failback）</h2><p>适用于非幂等性的服务调用，通过对失败错误码等异常信息的判断，决定后续的执行策略。<br>Failback 的设计方案如下：服务框架获取到服务提供者返回的 RPC 异常响应之后，根据策略进行容错。将 RPC异常通知给消费者，由消费者捕获异常进行后续处理。</p><h2 id="2-3-失败缓存（Failcache）"><a href="#2-3-失败缓存（Failcache）" class="headerlink" title="2.3 失败缓存（Failcache）"></a>2.3 失败缓存（Failcache）</h2><p>Failcache 策略是失败自动恢复的一种，应用场景如下：</p><ol><li>服务有状态路由，必须定点发送到指定的服务提供者。当发生链路中断、流控等服务暂时不可用时，服务框架将消息临时缓存起来，等待周期T，重新发送，直到服务提供者能够正常处理该消息。</li><li>对时延要求不敏感的服务。系统服务调用失败，通常是链路暂时不可用、服务流控、GC 挂住服务提供者进程等，这种失败不是永久性的失败，它的恢复是可预期的。如果消费者对服务调用时延不敏感，可以考虑采用自动恢复模式，即先缓存，再等待，最后重试。</li><li>通知类服务。例如通知粉丝积分增长、记录接口日志等，对服务调用的实时性要求不高，可以容忍自动恢复带来的时延增加。  </li></ol><p>为了保证可靠性，Failcache 策略在设计的时候需要考虑如下几个要素：</p><ol><li>缓存时间、缓存对象上限数等需要做出限制，防止内存溢出。</li><li>缓存淘汰算法的选择，是否支持用户配置。</li><li>定时重试的周期T、重试的最大次数等需要做出限制并支持用户指定。<br>重试达到最大上限仍失败，需要丢弃消息，记录异常日志。</li></ol><h2 id="2-4-快速失败（Failfast）"><a href="#2-4-快速失败（Failfast）" class="headerlink" title="2.4 快速失败（Failfast）"></a>2.4 快速失败（Failfast）</h2><p>在业务高峰期，对于一些非核心的服务，希望只调用一次，失败也不再重试，为重要的核心服务解约宝贵的运行资源。此时，快速失败是不错的选择。<br>原理在于，获取服务调用异常之后，直接忽略异常，记录异常日志。</p><h2 id="2-5-容错策略扩展"><a href="#2-5-容错策略扩展" class="headerlink" title="2.5 容错策略扩展"></a>2.5 容错策略扩展</h2><p>无论默认支持多少种容错策略，在业务实际使用过程中都需要支持用户自定义扩展容错策略。</p><h1 id="3-个人总结"><a href="#3-个人总结" class="headerlink" title="3 个人总结"></a>3 个人总结</h1><p>集群容错虽然功能简单，设计也并不复杂（不复杂？？？），但是该特性却非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六、服务路由</title>
      <link href="/2018/05/29/distributed_principle_prictice/6.html/"/>
      <url>/2018/05/29/distributed_principle_prictice/6.html/</url>
      
        <content type="html"><![CDATA[<p>分布式服务框架上线运行时都是集群组网，这意味着急群众存在某个服务的多实例部署，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。</p><h1 id="1-透明化路由"><a href="#1-透明化路由" class="headerlink" title="1 透明化路由"></a>1 透明化路由</h1><h2 id="1-1-基于服务注册中心的订阅发布"><a href="#1-1-基于服务注册中心的订阅发布" class="headerlink" title="1.1 基于服务注册中心的订阅发布"></a>1.1 基于服务注册中心的订阅发布</h2><p>在分布式服务框架中，服务注册中心用于存储服务提供者地址信息、服务发布相关的属性信息，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不需要像之前那样在代码中硬编码服务提供者地址信息。消费者只需要知道当前系统发布了哪些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。它的工作原理就是基于服务注册中心（例如 ZooKeeper）的订阅发布机制。<br>服务注册中心的工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_1.png" alt>  </p><p>由于消费者可能由于服务提供者启动，或者系统运行过程中新增服务提供者，或者某个服务提供者宕机退出，就会导致注册中心发生服务提供者地址变更。注册中心检测到服务提供者列表变更之后，将变更内容主动推送到服务消费者，消费者根据变更列表，动态刷新本地缓存的服务提供者地址。</p><h2 id="1-2-消费者缓存服务提供者地址"><a href="#1-2-消费者缓存服务提供者地址" class="headerlink" title="1.2 消费者缓存服务提供者地址"></a>1.2 消费者缓存服务提供者地址</h2><p>采用客户端缓存服务提供者地址的方案不仅仅能提升服务调用性能，还能保证系统的可靠性。当注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存的地址信息进行通信，只是影响新服务的注册和老服务的下线，不影响已经发布和运行的服务。</p><h1 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2 负载均衡"></a>2 负载均衡</h1><h2 id="2-1-随机"><a href="#2-1-随机" class="headerlink" title="2.1 随机"></a>2.1 随机</h2><p>缺点：  </p><ol><li>在一个截面上碰撞的概率较高。</li><li>非对等集群组网，或者硬件配置差异较大，会导致各节点负载均匀。</li></ol><h2 id="2-2-轮询"><a href="#2-2-轮询" class="headerlink" title="2.2 轮询"></a>2.2 轮询</h2><p>轮询，按公约后的权重设置轮询比率，到达边界之后，继续绕接。缺点：  </p><ol><li>存在慢的提供者累计请求问题，例如第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ol><h1 id="2-3-服务调用时延"><a href="#2-3-服务调用时延" class="headerlink" title="2.3 服务调用时延"></a>2.3 服务调用时延</h1><p>消费者缓存所有服务提供者的服务调用时延，周期性的计算服务调用平均时延，然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积，  </p><p>该策略的特点就是要保证处理能力强的服务提供者接收到更多的消息，通过动态自动权重调整消除服务调用时延的振荡范围，使所有服务提供者服务调用时延接近平均值，实现负载均衡。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_2.png" alt> <img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_3.png" alt></p><h1 id="2-4-一致性哈希"><a href="#2-4-一致性哈希" class="headerlink" title="2.4 一致性哈希"></a>2.4 一致性哈希</h1><p>相同参数的请求总是发到同一个服务提供者，当某一台提供者宕机时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。平台提供默认的虚拟节点数，可以通过配置参数进行修改。<br>一致性 Hash 环工作原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/6_4.png" alt></p><h1 id="2-5-粘滞连接"><a href="#2-5-粘滞连接" class="headerlink" title="2.5 粘滞连接"></a>2.5 粘滞连接</h1><p>粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起服务调用，除非该提供者宕机，再连接另一台。由于服务通常被强烈建议设计成无状态的，因此，粘滞连接在实际项目中很少使用。<br>粘滞连接的实现比较简单，客户端首次跟服务端创建链路时，将该链路标记为粘滞连接，每次路由时直接选择粘滞连接，不执行负载均衡路由接口，当链路中断时，更新粘滞连接为不可用，重新寻找下一个可用的连接，将其标记为粘滞连接。</p><h1 id="3-本地路由优先策略"><a href="#3-本地路由优先策略" class="headerlink" title="3 本地路由优先策略"></a>3 本地路由优先策略</h1><h2 id="3-1-injvm-模式"><a href="#3-1-injvm-模式" class="headerlink" title="3.1 injvm 模式"></a>3.1 injvm 模式</h2><p>在一些业务场景中，本地 JVM 内部也发布了需要消费的服务。该场景下，从性能、可靠性等角度考虑，需要优先调用本 JVM内部的服务提供者，这种本地优先的路由模式被称为 injvm模式。</p><h2 id="3-2-innative-模式"><a href="#3-2-innative-模式" class="headerlink" title="3.2 innative 模式"></a>3.2 innative 模式</h2><p>如果物理机或者 VM配置较好，多个应用金城往往会选择合设。服务消费者和服务提供者可能会被部署到同一台机器上（VM）。服务路由时优先选择本机的服务提供者，如果找不到再重新发起远程服务调用，该模式被称为 innative模式。</p><ol><li>首先看本进程 JVM内部是否有符合要求的服务提供者。</li><li>JVM 内部没有，选择服务提供者 IP地址与本机 IP地址相同的本地合设的服务提供者进程，通过本地网卡回环调用服务提供则。</li><li>如果 VM内部没有，则发起远程调用。</li></ol><h1 id="4-路由规则"><a href="#4-路由规则" class="headerlink" title="4 路由规则"></a>4 路由规则</h1><h2 id="4-1-条件路由规则"><a href="#4-1-条件路由规则" class="headerlink" title="4.1 条件路由规则"></a>4.1 条件路由规则</h2><p>应用场景如下：</p><ol><li>通过 IP条件表达式进行黑白名单访问控制，例如 comsumerIP != 192.168.1.1</li><li>流量引导，只暴露部分服务提供者，防止整个集群服务都被冲垮，导致其它服务也不可用，例如 providerIP = 192.168.3*</li><li>读写分离：method=find<em>,list</em>,get<em>,query</em>=&gt;providerIP=192.168.1.*</li><li>前后台分离：app=web<em>=&gt;providerIP=192.168.1.</em>,app=java<em>=&gt;providerIP=192.168.2.</em></li><li>灰度升级，将 Web前台应用路由到新的服务版本上：app=web<em>=&gt;providerIP=192.168.1.</em></li></ol><h2 id="4-2-脚本路由规则"><a href="#4-2-脚本路由规则" class="headerlink" title="4.2 脚本路由规则"></a>4.2 脚本路由规则</h2><p>使用脚本来实现路由规则，在于动态编译，修改实时生效，常见的脚本语言有 JavaScript、Groovy、MVEL 等。</p><h1 id="5-路由策略定制"><a href="#5-路由策略定制" class="headerlink" title="5 路由策略定制"></a>5 路由策略定制</h1><p>除了提供默认的路由策略之外，在架构上还需要支持业务扩展路由算法，实现业务自定义路由。  </p><ol><li>灰度升级，用户需要按照业务规则进行灰度路由：例如按照用户省份路由、按照请求来源中断类型（IOS、Android）、按照手机号段等；不同的用户按照规则路由到不同的集群环境中，例如没有同步升级的用户路由到升级前的环境，同步配套升级的消费者请求路由到灰度升级后的新版本中。</li><li>服务故障、业务高峰期的导流：通过自定义路由，将异常的峰值流量导流到几台或者1 台服务器上，防止整个集群负载过重导致整个生产系统雪崩。</li></ol><p>路由扩展策略如下：  </p><ol><li>提供接口。</li><li>提供配置 XML Schema定义。</li><li>通过 Spring Bean 方式的服务发布、通过 JDK 的 SPI 方式扩展，即 META-INF/services。</li></ol><h1 id="6-配置化路由"><a href="#6-配置化路由" class="headerlink" title="6 配置化路由"></a>6 配置化路由</h1><ol><li>本地配置：包括服务提供者和服务消费者、默认全局配置三种。</li><li>统一注册管理：无论是服务提供者还是消费者，本地配置的路由策略统一注册到服务注册中心，进行集中化配置管理。</li><li>动态下发：运维人员通过服务治理 Portal修改路由规则，更新后的路由规则被持久化到服务注册中心。</li></ol><p>路由配置优先级：客户端配置&gt;服务端配置&gt;全局配置。</p><h1 id="7-最佳实践————多机房路由"><a href="#7-最佳实践————多机房路由" class="headerlink" title="7 最佳实践————多机房路由"></a>7 最佳实践————多机房路由</h1><p>为了能够相互发现对方的服务，不同机房会共用同一个服务注册中心集群（异地容灾机房除外）。假如机房1 发布了服务A，机房2 同样也发布了服务A，此时服务注册中心就会将2 个不同机房的服务A 地址信息推送给消费者，无论是机房1 还是机房2 的消费者，都将看到两个不同机房的服务。  </p><p>如果仅仅依靠随机、轮询等负载均衡策略，消息将会被路由到两个机房，达不到不跨机房调用的目标。此时可以使用配置条件路由策略，通过网段条件匹配来实现地址过滤。<br>也可以使用虚拟分组策略，将整个集群系统的服务提供者（跨机房）逻辑分成若干个组，某个消费者只访问一个虚拟分组的服务提供者，防止跨组服务调用。</p><h1 id="8-个人总结"><a href="#8-个人总结" class="headerlink" title="8 个人总结"></a>8 个人总结</h1><p>服务路由需要既具备丰富的路由策略，还要具备扩展能力，是非常重要的分布式下的基础功能。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、协议栈</title>
      <link href="/2018/05/27/distributed_principle_prictice/5.html/"/>
      <url>/2018/05/27/distributed_principle_prictice/5.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-关键技术点分析"><a href="#1-关键技术点分析" class="headerlink" title="1 关键技术点分析"></a>1 关键技术点分析</h1><h1 id="1-1-是否必须支持多协议"><a href="#1-1-是否必须支持多协议" class="headerlink" title="1.1 是否必须支持多协议"></a>1.1 是否必须支持多协议</h1><p>分布式服务框架需要具备通过扩展的方式支持多协议的能力，协议栈应该作为一个架构扩展点开放出来。</p><h1 id="1-2-公有协议还是私有协议"><a href="#1-2-公有协议还是私有协议" class="headerlink" title="1.2 公有协议还是私有协议"></a>1.2 公有协议还是私有协议</h1><p>以 Web Service 公有协议为例，它的性能存在如下缺陷：  </p><ol><li>SOAP 消息使用 XML 进行序列化，相比于 PB 等二进制序列化框架，性能低很多。</li><li>SOAP 通常由 HTTP 协议承载，HTTP 1.0 不支持双向全工通信，而且一般使用短连接通信，性能比较差。</li></ol><p>如果没有特殊需求，分布式服务框架默认使用性能更高、扩展性更好的私有协议（二进制）进行通信。对 HTTP/Restful 等公有协议进行扩展</p><h1 id="1-3-集成开元还是自研"><a href="#1-3-集成开元还是自研" class="headerlink" title="1.3 集成开元还是自研"></a>1.3 集成开元还是自研</h1><ol><li>如果已经有可以满足需求的框架，优先选择继承开源框架。</li><li>如果使用到的功能不多，或者对性能要求极高，可以考虑基于 Netty 自研。</li></ol><h1 id="2-功能设计"><a href="#2-功能设计" class="headerlink" title="2 功能设计"></a>2 功能设计</h1><h2 id="2-1-功能描述"><a href="#2-1-功能描述" class="headerlink" title="2.1 功能描述"></a>2.1 功能描述</h2><p>私有协议栈承载了业务内部各模块之间的消息交互和服务调用，主要功能如下：  </p><ol><li>定义了私有协议的通信模型和消息定义。</li><li>支持服务提供者和消费者之间采用点对点长连接通信</li><li>基于 Java NIO 通信框架，提供高性能的异步通信能力。</li><li>提供可扩展的编解码框架，支持多种序列化格式。</li><li>握手和安全认证机制。</li><li>链路的高可靠性。</li></ol><h2 id="2-2-通信模型"><a href="#2-2-通信模型" class="headerlink" title="2.2 通信模型"></a>2.2 通信模型</h2><p>私有协议栈通信模型如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/5_1.png" alt>  </p><ol><li>客户端发送握手请求消息，携带节点ID 等有效神风认证信息。</li><li>服务端对握手请求消息进行合法性校验，包括节点ID 有效性校验、节点重复登录校验和IP 地址合法性校验，校验通过后，返回登录成功的握手应答消息。</li><li>链路建立成功之后，客户端发送业务消息。</li><li>链路成功之后，服务端发送心跳消息。</li><li>链路建立成功之后，客户端发送心跳消息。</li><li>链路建立成功之后，服务端发送业务消息。</li><li>服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。</li></ol><h2 id="2-3-协议消息定义"><a href="#2-3-协议消息定义" class="headerlink" title="2.3 协议消息定义"></a>2.3 协议消息定义</h2><p>通信协议栈的消息模型分为两部分，消息头和消息体。消息头存放协议公共字段和用户扩展字段，消息体则用于承载消息内容。以 HTTP 协议为例，请求消息头允许客户端向服务端传递请求的附加信息以及客户端自身的信息，常见的消息头关键字有 Accept、Authorization、Host 等。</p><h2 id="2-4-协议消息的序列化和反序列化"><a href="#2-4-协议消息的序列化和反序列化" class="headerlink" title="2.4 协议消息的序列化和反序列化"></a>2.4 协议消息的序列化和反序列化</h2><p>消息的序列化分为两部分，消息头的序列化和消息体的序列化，两者采用的机制不一样。原因是协议栈可以由不同的序列化框架承载，标识序列化格式的字段在消息头中定义，因此我们必须首先对消息头做通用解码，获取序列化格式，然后根据类型再调用对应的解码器对消息体做解码。消息头是通用编解码。</p><h2 id="2-5-链路创建"><a href="#2-5-链路创建" class="headerlink" title="2.5 链路创建"></a>2.5 链路创建</h2><p>协议栈包括服务端和客户端，对于上层应用来说，一个节点可能既是服务端也是客户端。<br>考虑到安全，链路简历需要通过基于 IP 地址或者号段的黑白名单安全认证机制，以及通过秘钥等。</p><h2 id="2-6-链路关闭"><a href="#2-6-链路关闭" class="headerlink" title="2.6 链路关闭"></a>2.6 链路关闭</h2><p>由于采用长连接通信，在正常的业务运行期间，双方通过心跳和业务消息维持链路，任何一方都不需要主动关闭连接。以下情况，客户端和服务端需要关闭连接：  </p><ol><li>当对方宕机或重启时，会主动关闭链路。</li><li>消息读写过程中，发生了 I/O 异常，需要主动关闭连接。</li><li>心跳消息读写过程中发生了 I/O 异常，需要主动关闭连接。</li><li>心跳超时，需要主动关闭连接。</li><li>发生编码异常或其它不可恢复错误时，需要主动关闭连接。</li></ol><h1 id="3-可靠性分析"><a href="#3-可靠性分析" class="headerlink" title="3 可靠性分析"></a>3 可靠性分析</h1><h2 id="3-1-客户端连接超时"><a href="#3-1-客户端连接超时" class="headerlink" title="3.1 客户端连接超时"></a>3.1 客户端连接超时</h2><p>客户端业务需要、以及资源的长时间占有等，需要设置超时时间。</p><h2 id="3-2-客户端重连机制"><a href="#3-2-客户端重连机制" class="headerlink" title="3.2 客户端重连机制"></a>3.2 客户端重连机制</h2><p>客户端通过链路关闭监听器监听链路状态，如果链路中断，等待 INTERVAL 时间后，由客户端发起重连操作，如果重连失败，间隔周期 INTERVAL 后再次发起重连，直到重连成功。  </p><p>为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。</p><h2 id="3-3-客户端重复握手保护"><a href="#3-3-客户端重复握手保护" class="headerlink" title="3.3 客户端重复握手保护"></a>3.3 客户端重复握手保护</h2><p>当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复握手，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。  </p><p>服务端接收到客户端的握手请求消息之后，首先对IP 地址进行合法性检验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果已经登录，则拒绝登录，返回错误码 -1，同时关闭 TCP 链路，并在服务端的日志中打印握手失败的原因。  </p><p>客户端接收到握手失败的应答消息之后，关闭客户端的 TCP连接，等待 INTERVAL 时间之后，再次发起 TCP连接，直到认证成功。</p><h2 id="3-4-消息缓存重发"><a href="#3-4-消息缓存重发" class="headerlink" title="3.4 消息缓存重发"></a>3.4 消息缓存重发</h2><p>无论客户端还是服务端，当发生链路中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。  </p><p>考虑到内存溢出的风险，建议消息缓存队列设置上限，当达到上限之后，应该拒绝继续向该队列添加新的消息。</p><h2 id="3-5-心跳机制"><a href="#3-5-心跳机制" class="headerlink" title="3.5 心跳机制"></a>3.5 心跳机制</h2><p>在凌晨等业务低谷期时段，如果发生网络闪断、连接被 Hang 住等网络问题时，由于没有业务消息，应用金城很难发现。到了白天业务高峰期时，会发生大量的网络通信失败。为了解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络网络故障，立即关闭链路，主动重连。</p><h1 id="4-最佳实现–协议的前后兼容性"><a href="#4-最佳实现–协议的前后兼容性" class="headerlink" title="4 最佳实现–协议的前后兼容性"></a>4 最佳实现–协议的前后兼容性</h1><p>考虑到协议的前向兼容性，核心的设计原则有2 个：  </p><ol><li>消息头第一个字段中携带协议的版本号，用于标识消息协议版本。</li><li>消息头最后一个字段是 Map 类型的扩展字段，用于服务框架自身或者用户扩展消息头。</li></ol><h1 id="5-个人总结"><a href="#5-个人总结" class="headerlink" title="5 个人总结"></a>5 个人总结</h1><p>协议栈描述了分布式服务框架的通信契约，序列化和反序列化框架用于协议消息对象和二进制数组之间的相互转换，通信框架在技术上承载协议，协议依赖通信。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、序列化和反序列化</title>
      <link href="/2018/05/22/distributed_principle_prictice/4.html/"/>
      <url>/2018/05/22/distributed_principle_prictice/4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-几个关键概念澄清"><a href="#1-几个关键概念澄清" class="headerlink" title="1 几个关键概念澄清"></a>1 几个关键概念澄清</h1><p>通常我们习惯将序列化（Serialization）称为编码（Encode）,它将对象序列化为字节数组，用于网络传输、数据持久化或其它用途。<br>反之，反序列化（Deserialization）/解码（Decode）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的副本）。</p><h2 id="1-1-序列化与通信框架的关系"><a href="#1-1-序列化与通信框架的关系" class="headerlink" title="1.1 序列化与通信框架的关系"></a>1.1 序列化与通信框架的关系</h2><p>序列化与通信框架不是强耦合的关系，通信框架提供的编解码框架可以非常方便地支持用户通过扩展实现自定义的序列化格式。通信框架的编解码接口作为可选插件，并不强制用户一定要在通信框架内部实现消息的序列化和反序列化。</p><h2 id="1-2-序列化与通信协议的关系"><a href="#1-2-序列化与通信协议的关系" class="headerlink" title="1.2 序列化与通信协议的关系"></a>1.2 序列化与通信协议的关系</h2><p>序列化与通信协议是解耦的，同一种通信协议可能由多种序列化方式承载，同一种序列化方式也可以用在不同协议里。  </p><p>以 HTTP 协议为例，承载消息体的可以是 XML、JSON 等文本类的协议，也可以是图片附件等二进制流媒体协议。<br>在设计分布式服务框架时，序列化和反序列化是一个独立的接口和插件，它可以被多种协议重用、替换和扩展，以实现服务框架序列化方式的多样性。</p><h2 id="1-3-是否需要支持多种序列化方式"><a href="#1-3-是否需要支持多种序列化方式" class="headerlink" title="1.3 是否需要支持多种序列化方式"></a>1.3 是否需要支持多种序列化方式</h2><p>整体而言，序列化可以分为文本类和二进制类两种，不同的业务场景需求也不同，分布式服务框架面向的领域是多样化的，因此它的序列化/反序列化框架需要具备如下特性：  </p><ol><li>默认支持多种常用的序列化/反序列化方式，文本类例如 XML/JSON 等，二进制的如 PB（Protocol Buffer）/Thrift 等。</li><li>序列化框架可扩展，用户可以非常灵活、方便地扩展其它序列化方式。</li></ol><h1 id="2-功能设计"><a href="#2-功能设计" class="headerlink" title="2 功能设计"></a>2 功能设计</h1><p>从功能、跨语言支持、兼容性、性能等多个角度进行综合考量。  </p><ol><li>功能丰富。</li><li>跨语言支持。</li><li>兼容性</li><li>性能。</li></ol><h1 id="3-扩展性设计"><a href="#3-扩展性设计" class="headerlink" title="3 扩展性设计"></a>3 扩展性设计</h1><p>利用 Netty 提供的编解码框架，可以非常快速的实现序列化/反序列化框架的扩展。</p><h2 id="3-1-内置的序列化-反序列化功能类"><a href="#3-1-内置的序列化-反序列化功能类" class="headerlink" title="3.1 内置的序列化/反序列化功能类"></a>3.1 内置的序列化/反序列化功能类</h2><p>为了降低用户的开发难度，Netty 对常用的功能和 API 做了装饰，以屏蔽底层的实现细节。Netty 内置的编解码功能包括 base64、Protobuf、JBoss Marshalling、spdy 等。</p><h2 id="3-2-反序列化扩展"><a href="#3-2-反序列化扩展" class="headerlink" title="3.2 反序列化扩展"></a>3.2 反序列化扩展</h2><ol><li>业务发布服务的时候，可以指定协议类型和承载数据的序列化方式，例如将购买商品服务发布成 HTTP 服务，序列化格式采用 XML；同时允许用户指定新增的序列化格式发布服务。</li><li>序列化类库能够以插件的格式插入到通信调用链中，实现序列化格式的扩展。在这个过程中，需要考虑 TCP 的黏包和拆包等底层相关的技术细节。</li></ol><p>我们看半包的处理，如果不处理半包，Netty 调用 decode 方法传递的 ByteBuf 对象可能就是个半包，我们拿半包做反序列化就会失败，因此在反序列化之前，我们需要保证调用解码方法时传递的是个完整的数据包。  </p><p>了解 TCP 通信机制的渎职应该都知道 TCP 底层的黏包和拆包，当我们在接收消息的时候，不能认为读取到的报文就是个整包消息，特别是对于采用非阻塞 I/O 和长连接通信的程序。<br>如何区分一个整包消息，通常有如下四种做法：  </p><ol><li>固定长度，例如每 120 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定长消息的时候比较简单，每次读到指定长度的字节后进行解码。</li><li>通过回车换行符区分消息，例如 HTTP 协议。这类区分消息的方式多用于文本协议。</li><li>通过特定的分隔符区分整包消息。</li><li>通过在协议头/消息头中设置长度字段来标识整包消息。</li></ol><h1 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4 最佳实践"></a>4 最佳实践</h1><h2 id="4-1-接口的前向兼容性规范"><a href="#4-1-接口的前向兼容性规范" class="headerlink" title="4.1 接口的前向兼容性规范"></a>4.1 接口的前向兼容性规范</h2><ol><li>制定”分布式服务框架接口兼容性规范“，在规范中要明确服务框架支持哪些兼容性，例如新增字段、删除字段还是修改字段。</li><li>引导客户。</li></ol><h2 id="4-2-高并发下的稳定性"><a href="#4-2-高并发下的稳定性" class="headerlink" title="4.2 高并发下的稳定性"></a>4.2 高并发下的稳定性</h2><p>需要模拟现网高并发场景对序列化框架做压测和稳定性测试，如果序列化框架存在全局锁较激烈的线程竞争等问题，多线程、高并发压力测试就会出现问题。究其原因是因为一些序列化框架为了实现线程安全，使用了全局锁等，这从实用角度看确实简单，但是在高并发场景下就会出现性能下降、耗时不稳定等问题。  </p><p>解决此类问题的方案很多，例如每个线程聚合一个序列化/反序列化类库，避免多线程竞争。</p><h1 id="5-个人总结"><a href="#5-个人总结" class="headerlink" title="5 个人总结"></a>5 个人总结</h1><p>序列化/反序列化是 RPC 框架的基础组成部分，从性能、业务考虑，而 Netty 非常适合去做扩展。当然，还是清楚其中的经典黏包、拆包。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、通信框架</title>
      <link href="/2018/05/20/distributed_principle_prictice/3.html/"/>
      <url>/2018/05/20/distributed_principle_prictice/3.html/</url>
      
        <content type="html"><![CDATA[<h1 id="恭喜-RNG，恭喜-UZI"><a href="#恭喜-RNG，恭喜-UZI" class="headerlink" title="恭喜 RNG，恭喜 UZI"></a>恭喜 RNG，恭喜 UZI</h1><p>六年<br>恋恋不忘<br>必有回响<br><img src="http://photocdn.sohu.com/20180521/Img538252610.jpg" alt></p><hr><h1 id="1-关键技术点分析"><a href="#1-关键技术点分析" class="headerlink" title="1 关键技术点分析"></a>1 关键技术点分析</h1><h2 id="1-1-长连接还是短连接"><a href="#1-1-长连接还是短连接" class="headerlink" title="1.1 长连接还是短连接"></a>1.1 长连接还是短连接</h2><p>绝大多数的分布式服务框架（RPC框架）都推荐使用长连接进行内部通信，为什么选择长连接而不是短连接呢？具体原因如下：  </p><ol><li>相对比短连接，长连接更节省资源。长连接只会在首次创建时或者链路断连重连才创建链路，链路创建成功之后服务提供者和消费者会通过业务消息和心跳维系链路，实现多消息复用同一个链路节省资源。</li><li>远程通信是常态，调用时延是关键指标：服务化之后，本地 API 调用变成了远程服务调用，大量本地方法演进成了跨进程通信，网络时延称为关键指标之一。相比于一次简单的服务调用，链路的重建通常耗时更多，这就会导致链路层的时延消耗远远大于服务调用本身的损耗，这对于大型的业务系统而言是无法接受的。</li></ol><h2 id="1-2-BIO-还是-NIO"><a href="#1-2-BIO-还是-NIO" class="headerlink" title="1.2 BIO 还是 NIO"></a>1.2 BIO 还是 NIO</h2><p>经典的 BIO 通信模型如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_1.png" alt><br>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回给客户端，线程销毁，这就是典型的一请求一应答通信模型。<br>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈 1:1 的正比关系。由于线程是 Java 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。  </p><p>在 I/O 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或 I/O 多路复用技术进行处理。 I/O 多路复用技术通过把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外线程/进程，也不需要维护这些线程/进程的运行，节省系统资源。  </p><p>JDK1.4 提供了对非阻塞I/O（NIO）的支持，JDK1.5 使用 epoll 替代了传统的 select/poll，极大提升了 NIO 通信的性能。<br>NIO 采用多路复用技术，一个多路复用器 Selector 可以同时轮询多个 Channel ，由于 JDK 使用了 epoll() 代替了传统的 select 实现，所以它并没有最大连接句柄 1024/2048 的限制。这就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。<br>采用多路复用器 Selector 实现的 Reactor 通信模型如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_2.png" alt></p><h2 id="1-3-自研还是选择开源-NIO-框架"><a href="#1-3-自研还是选择开源-NIO-框架" class="headerlink" title="1.3 自研还是选择开源 NIO 框架"></a>1.3 自研还是选择开源 NIO 框架</h2><p>选择 Netty！</p><h1 id="2-功能设计"><a href="#2-功能设计" class="headerlink" title="2 功能设计"></a>2 功能设计</h1><p>分布式服务框架的底层通信框架首先是一个通用的通信框架，它不应该与具体的协议绑定。基于通信框架智商，可以构建私有协议栈和公有协议栈。<br>架构原理如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_3.png" alt></p><h2 id="2-1-服务端设计"><a href="#2-1-服务端设计" class="headerlink" title="2.1 服务端设计"></a>2.1 服务端设计</h2><p>通信框架服务端的职责如下：  </p><ol><li>提供上层 API，用于初始化服务端实例，设置服务端通信相关参数，包括服务端的 I/O 线程池、监听地址、TCP 相关参数、接收和发送缓冲区大小等。</li><li>提供可扩展的编解码插件，用户可以通过扩展的方式实现自定义协议的编码和解码。</li><li>提供拦截面，用于私有协议栈开发。例如通过新增鉴权插件实现服务端对客户端的安全认证。</li></ol><h2 id="2-2-客户端设计"><a href="#2-2-客户端设计" class="headerlink" title="2.2 客户端设计"></a>2.2 客户端设计</h2><p>客户端需要考虑网络连接超时、连接失败等异常场景。</p><h1 id="3-可靠性设计"><a href="#3-可靠性设计" class="headerlink" title="3 可靠性设计"></a>3 可靠性设计</h1><h2 id="3-1-链路有效性检测"><a href="#3-1-链路有效性检测" class="headerlink" title="3.1 链路有效性检测"></a>3.1 链路有效性检测</h2><p>当网络发生单通、连接被防火墙 Hang 住，长时间 GC 或者通信线程发生非预期异常时，会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间，当早晨业务高峰期到来时，由于链路不可用会导致瞬间的大批量业务失败或者超时。  </p><p>从技术层面看，要解决链路的可靠性问题，必须周期性地对链路进行有效性检测。目前最流行和最通用的做法就是心跳检测。  </p><ol><li>TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈。</li><li>协议层的心跳检测，主要存在于长连接协议中，例如 SMPP 协议。</li><li>应用层的心跳检测，主要由各业务产品通过约定方式定时给对方发送心跳消息实现。</li></ol><p>心跳的检测原理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_8.png" alt></p><p>不同的协议，心跳检测机制也存在差异，归类两类：  </p><ol><li>Ping-Pong 型心跳：由通信一方定时发送 Ping 消息，对方接收到 Ping 消息之后，立即返回 Pong 应答消息给对方，属于请求-响应型心跳。</li><li>Ping-Ping 型心跳：不区分心跳请求和应答，由通信双方按照约定定时向对方发送心跳 Ping 消息，属于双向心跳。</li></ol><p>心跳检测策略如下：  </p><ol><li>连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称为心跳超时。</li><li>读取和发送心跳消息的时候如果直接发生了 I/O 异常，说明链路已经失效，这被称为心跳失败。</li></ol><p>无论发生心跳超时还是心跳失败，都需要关闭链路，由客户端发起重连操作，保证链路能够恢复正常。<br>Netty 的心跳检测实际上是利用了链路空闲检测机制实现的，它的空闲检测机制分为三种：  </p><ul><li>读空闲，链路持续时间 t 没有读取到任何消息。</li><li>写空闲，链路持续时间 t 没有发送任何消息。</li><li>读写空闲，链路持续时间 t 没有接受或者发送任何消息。</li></ul><h2 id="3-2-断连重连机制"><a href="#3-2-断连重连机制" class="headerlink" title="3.2 断连重连机制"></a>3.2 断连重连机制</h2><p>为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待 INTERVAL 时间之后再发起重连，而不是失败后就立即重连。<br>为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于 SocketChannel、Socket等。</p><h2 id="3-3-消息缓存重发"><a href="#3-3-消息缓存重发" class="headerlink" title="3.3 消息缓存重发"></a>3.3 消息缓存重发</h2><p>当我们调用消息发送接口的时候，消息并没有真正被写入到 Socket 中，而是先放入 NIO 通信框架的消息发送队列中，由 Reactor 线程扫描待发送的消息队列，异步地发送给通信对端。假如很不辛，消息队列中积压了部分消息，此时链路中断，这会导致部分消息并没有真正发送给通信对端，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/3_9.png" alt>  </p><p>发生此故障时，我们希望 NIO 框架能够自动实现消息缓存和重新发送，遗憾的是作为基础的 NIO 通信框架，无论是 Mina 还是 Netty，都没有提供该功能，需要通信框架自己封装实现。  </p><p>并非所有场景都需要通信框架做重发，例如服务框架的客户端，如果某个服务提供者不可用，会自动切换到下一个可用的服务提供者之上。假定是链路中断导致的服务提供者不可用，即便链路重新恢复，也没有必要将之前积压的消息重新发送，因为消息已经通过 FailOver 机制切换到另一个服务提供者处理。所以，消息缓存重发只是一种策略，通信框架应该支持链路级重发策略。</p><h2 id="3-4-资源优雅释放"><a href="#3-4-资源优雅释放" class="headerlink" title="3.4 资源优雅释放"></a>3.4 资源优雅释放</h2><p>Java 的优雅停机通常通过注册 JDK 的 ShutdownHook 来实现，当系统接收到退出指令后，首先标记系统处于退出状态，不再接收新的消息，然后将积压的消息处理完，最后调用资源回收接口将资源销毁，最后各线程退出执行。  </p><p>通常优雅退出有个时间限制，例如 30s，如果到达执行时间仍然没有完成推出前的操作，则由监控监本直接 kill -9 pid，强制退出。</p><h1 id="4-性能设计"><a href="#4-性能设计" class="headerlink" title="4 性能设计"></a>4 性能设计</h1><p>分布式服务框架被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。对通信框架有很高的性能要求。</p><h2 id="4-1-性能差的三宗罪"><a href="#4-1-性能差的三宗罪" class="headerlink" title="4.1 性能差的三宗罪"></a>4.1 性能差的三宗罪</h2><ol><li>网络传输方式：同步阻塞 I/O，采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后，为其创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，导致并发量的增加，发生句柄溢出。</li><li>序列化性能差：Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言；相对其它开源的序列化框架，Java 序列化后的码流太大，导致额外的资源占用；序列化性能差，资源占用率高（主要是 CPU 资源占用高）。</li><li>线程模型问题：由于采用同步阻塞 I/O，导致每个 TCP 连接都占用了一个线程。</li></ol><h2 id="4-2-通信性能三原则"><a href="#4-2-通信性能三原则" class="headerlink" title="4.2 通信性能三原则"></a>4.2 通信性能三原则</h2><ol><li>传输：用什么样的通道将数据发送给对方：BIO/NIO/AIO。I/O 模型在很大程度上决定了通信的性能。</li><li>协议：采用什么样的通信协议， HTTP 等公有协议或者内部私有协议。通常内部私有协议可以被设计得更优。</li><li>线程：数据报如何读取？读取之后的编解码在哪个线程进行？编解码后的消息如何派发？Reactor 线程模型的不同，对性能的影响也非常大。</li></ol><h2 id="4-3-高性能之道"><a href="#4-3-高性能之道" class="headerlink" title="4.3 高性能之道"></a>4.3 高性能之道</h2><p>Netty 支持高性能通信的架构特性进行总结：  </p><ol><li>异步非阻塞通信：Netty 的 I/O 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 SocketChannel。由于读写都是非阻塞的，这就可以充分提升 I/O 的运行效率，避免由频繁的 I/O 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li><li>高效的 I/O 线程模型：Netty 支持 Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型，可以满足不同的容量和性能需求。</li><li>高性能的序列化框架：默认提供了 Protobuf 二进制序列化框架，其它二进制序列化框架可以进行编解码框架扩展实现。  </li></ol><p>还支持零拷贝、内存池等其它性能相关的特性。</p><h1 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5 最佳实践"></a>5 最佳实践</h1><ol><li>服务端只负责客户端的接入，不处理 I/O 读写操作，因此服务端的 boosGroup 设置线程数为1：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);</code>。</li><li>客户端的 NioEventLoopGroup 由于服务提供者可能有 1000个或更多，导致创建了 1000个对象，可以使用大的线程池，或者创建一个包含 NioEventLoopGroup 的数组，将客户端连接按照 Hash 算法分组，将所有连接均匀的打散在 NioEventLoopGroup 中。</li></ol><h1 id="6-个人总结"><a href="#6-个人总结" class="headerlink" title="6 个人总结"></a>6 个人总结</h1><p>通信框架的重点在于 BIO、NIO、AIO，以及序列化。<br>这就是为什么别人面试会问 BIO/NIO/AIO/序列化。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、分布式服务框架入门</title>
      <link href="/2018/05/19/distributed_principle_prictice/2.html/"/>
      <url>/2018/05/19/distributed_principle_prictice/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分布式服务框架诞生背景"><a href="#1-分布式服务框架诞生背景" class="headerlink" title="1 分布式服务框架诞生背景"></a>1 分布式服务框架诞生背景</h1><h2 id="1-1-集中式到分布式"><a href="#1-1-集中式到分布式" class="headerlink" title="1.1 集中式到分布式"></a>1.1 集中式到分布式</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_1.png" alt>  </p><ol><li>业务发展、应用规模变大，大型复杂应用的开发维护成本高，部署效率低，应用数量膨胀，数据库连接数变高。</li><li>代码复用低：由于公共模块都是进程内部的本地 API 调用，开发者按需开发，导致大量相同功能的 API 被重复开发。一旦涉及到公共模块的功能变更，所有重复实现都需要重新修改、编译和测试。</li><li>敏捷持续交付：想要在一个架构师都无法理解的巨无霸业务中新增或者修改一个功能，难度是非常大的。业务模块之间的循环依赖、重复 API 定义和开发、不合理的调用、冗长复杂的业务流程对新特性的上线简直是梦魇。  </li></ol><p>大规模系统架构的设计一般就是尽可能的拆分，以达到更好的独立扩展、部署、开发效率等。<br>具体的拆分策略大体上可以分为横向拆分和纵向拆分。  </p><p>纵向拆分：不同业务模块独立部署，例如一个 CRM 系统就可以根据客户域、产品域、资源域、营销管理域等拆分。由大变小、分而治之。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_2.png" alt>  </p><p>横向拆分：将核心的、公共的业务拆分出来，通过分布式服务框架对业务进行服务化，消费者通过标准的契约来消费这些服务。服务提供者独立打包、部署，与消费者解耦。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_3.png" alt></p><h2 id="1-2-引入服务治理"><a href="#1-2-引入服务治理" class="headerlink" title="1.2 引入服务治理"></a>1.2 引入服务治理</h2><p>使用 RPC 框架对业务进行拆分之后，随着服务数的增多，急需一个服务治理框架，有效管控服务，提升服务运行期质量，防止业务服务代码架构腐化。因为，服务治理的主要应用如下：  </p><ol><li>生命周期管理：服务上线下线通知机制规范化。</li><li>服务容量规划。</li><li>运行期治理：对非核心服务采取降级、限流措施；缓存失效时，系统压力转移到数据库，服务调用时延突然增大，业务失败率升高，需要在线调大服务调用超时时间，保证业务成功率。</li><li>服务安全。  </li></ol><p>典型的 SOA 服务治理生命周期如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_4.png" alt></p><ol><li>计划：确定服务治理的重点。</li><li>定义：定义服务治理模型。</li><li>启用：实现并实施服务治理。</li><li>度量：根据实施效果，改进服务治理模型。</li></ol><h1 id="2-业务分布式服务框架介绍"><a href="#2-业务分布式服务框架介绍" class="headerlink" title="2 业务分布式服务框架介绍"></a>2 业务分布式服务框架介绍</h1><h2 id="2-1-阿里-Dubbo"><a href="#2-1-阿里-Dubbo" class="headerlink" title="2.1 阿里 Dubbo"></a>2.1 阿里 Dubbo</h2><p>架构图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_5.png" alt><br>功能总结：  </p><ol><li>根据服务提供者配置的 XML 文件将服务按照指定协议发布，完成服务的初始化工作。</li><li>服务提供者根据配置的服务注册中心地址连接服务注册中心，将服务提供者信息发布到服务注册中心。</li><li>消费者根据服务消费者 XML 配置文件的服务引用信息，连接注册中心，获取指定服务的地址等路由信息。</li><li>服务注册中心根据服务订阅关系，动态地向指定消费者推送服务地址信息。</li><li>消费者调用远程服务时，根据路由策略，从本地缓存的服务提供者地址列表中选择一个服务提供者，然后根据协议类型建立链路，跨进程调用服务提供者。  </li></ol><p>原理图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_6.png" alt></p><h2 id="2-2-淘宝-HSF"><a href="#2-2-淘宝-HSF" class="headerlink" title="2.2 淘宝 HSF"></a>2.2 淘宝 HSF</h2><p>架构图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_7.png" alt><br>功能总结：  </p><ol><li>配置 XML 方式发布和消费服务。</li><li>插件管理体系：平台与应用分开部署，运行期依赖，外部采用与应用独立的 classloader 隔离，内部采用 OSGI 隔离。</li><li>异步 NIO 通信。多种序列化方式。服务提供者和消费者之间采用长连接通信。</li><li>灵活的路由能力：客户端软负载，随机、轮询等多种路由策略，支持容灾和失效恢复等。</li><li>多协议支持：WebService、PB（Protocol buffer）和 Hession（HTTP）等。</li></ol><p>整体结构图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_8.png" alt></p><h2 id="2-3-亚马逊-Coral-Service"><a href="#2-3-亚马逊-Coral-Service" class="headerlink" title="2.3 亚马逊 Coral Service"></a>2.3 亚马逊 Coral Service</h2><h1 id="3-分布式服务框架设计"><a href="#3-分布式服务框架设计" class="headerlink" title="3 分布式服务框架设计"></a>3 分布式服务框架设计</h1><p>本章介绍分布式服务框架的架构原理和概要设计。</p><h2 id="3-1-架构原理"><a href="#3-1-架构原理" class="headerlink" title="3.1 架构原理"></a>3.1 架构原理</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/2_10.png" alt><br>通常分布式服务框架的架构可以抽象为三层：  </p><ol><li>RPC 层：包括底层通信框架（例如 NIO 框架的封装、公有协议的封装等）、序列化和反序列化框架、用于屏蔽底层通信协议细节和序列化方式差异的 Remoting 框架。</li><li>Filter Chain 层：服务调用职责链，提供多种服务调用切面供框架自身和使用者扩展，例如负责均衡、服务调用性能统计、服务调用完成通知机制、失败重发等。</li><li>Service 层：主要包括 Java 动态代理，消费者使用，主要用于将服务提供者的接口封装成远程服务调用：Java 反射，服务提供者使用，根据消费者请求消息中的接口名、方法名、参数列表反射调用服务提供者的接口本地实现类。</li></ol><p>从功能角度看，分布式服务框架通常会包含另外两个重要功能：服务治理中心和服务注册中心。</p><h2 id="3-2-功能特性"><a href="#3-2-功能特性" class="headerlink" title="3.2 功能特性"></a>3.2 功能特性</h2><ol><li>服务订阅发布之配置化发布和引用服务：支持通过 XML 配置的方式发布和导入服务，降低对业务代码的侵入。</li><li>服务订阅发布之服务自动发现机制：由注册中心推送服务地址，消费者不需要配置服务提供者地址，服务地址透明化。</li><li>服务订阅发布之服务在线注册和去注册：支持运行态注册新服务，也支持运行态取消某个服务的注册。</li><li>服务路由之默认提供随机路由、轮询、基于权重的路由策略等。</li><li>服务路由之粘滞连接：总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台。</li><li>服务路由之路由定制：支持用户自定义路由策略。</li><li>集群容错之 FailOver：失败自动切换，常用读操作；也可用于幂等性写操作。</li><li>集群容错之 Failback：失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。</li><li>集群容错之 Failfast：快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li><li>服务调用之同步调用：消费者发起服务调用之后，同步阻塞等待服务端响应。</li><li>服务调用之异步调用：消费者发起服务调用之后，不阻塞立即返回，由服务端返回应答后异步通知消费者。</li><li>服务调用之并行调用：消费者同时对多个服务提供者批量发起服务调用请求，批量发起请求，集中等待应答。</li><li>多协议之私有协议：支持二进制等私有协议，支持自定义。</li><li>多协议之公有协议：支持 Web Service 等公有协议，用于外部服务对象。</li><li>序列化方式之二进制类序列化：支持 Thrift、Protocol buffer 等二进制协议，提升序列化性能。</li><li>序列化方式之文本类序列化：支持 JSON、XML 等文本类型的序列化方式。</li><li>统一配置之本地静态配置：安装部署一次，运行态不修改的配置，可以存放到本地配置文件中。</li><li>统一配置之基于配置中心的动态配置：运行态需要调整的参数，统一放到配置中心，修改之后统一下发，实时生效。</li></ol><h2 id="3-3-服务治理"><a href="#3-3-服务治理" class="headerlink" title="3.3 服务治理"></a>3.3 服务治理</h2><ol><li>服务运行态管控之服务路由：业务高峰期，通过动态修改路由策略实现导流。</li><li>服务运行态管控之服务限流：资源成为瓶颈时，服务端和消费者的动态流控。</li><li>服务运行态管控之服务迁入迁出：实现资源的动态分配。</li><li>服务运行态管控之服务降级：服务提供者故障时或者业务高峰期，进行服务强制或者容错降级，执行本地降级逻辑，保证系统平稳运行。</li><li>服务运行态管控之服务超时控制：动态调整超时时间，在业务高峰期保障业务调用成功率。</li><li>服务监控之性能统计：统计项包括服务调用时延、成功率、调用次数等。</li><li>服务监控之统计报表：提供多维度、实时和历史数据报表，同比、环比等性能对比数据，供运维、运营等使用。</li><li>服务监控之告警：指标异常，根据告警策略发送告警，包括但不限于短信、E-mail、记录日志等。</li><li>服务生命周期管理之上线审批：服务提供者不能随意线上发布服务，需要通过正规的审批流程批准之后才能上线。</li><li>服务生命周期管理之下线通知：服务提供者在下线某个服务之前一段时间，需要根据 SLA 策略，通知消费者。</li><li>服务生命周期管理之服务灰度发布：灰度环境划分原则、接口前向兼容性策略，以及消费者如何路由，都需要灰度发布引擎负责管理。</li><li>故障快速定界定位之分布式日志采集：支持在大规模分布式环境中实时采集容器、中间件和应用的各种日志。</li><li>故障快速定界定位之海量日志在线检索：支持分布式环境海量日志的在线检索，支持多维度索引和模糊查询。</li><li>故障快速定界定位之调用链可视化展示：通过分布式消息跟踪系统输出调用链，可视化、快速地进行故障定界。</li><li>故障快速定界定位之运行日志故障定位：通过调用链的故障关键字，在日志检索界面快速检索故障日志，用于故障的精确定位。</li><li>服务安全之敏感服务的授权策略：敏感服务如何授权，防止恶意调用。</li><li>服务安全之链路的安全防护“消费者和服务提供者之间的长连接，需要增加安全防护，例如基于 Token 的安全认证机制。</li></ol><h1 id="4-个人总结"><a href="#4-个人总结" class="headerlink" title="4 个人总结"></a>4 个人总结</h1><p>分布式服务框架在原理、目标是类似的，因此不同的分布式服务框架原理也是相似的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、应用框架演进</title>
      <link href="/2018/05/18/distributed_principle_prictice/1.html/"/>
      <url>/2018/05/18/distributed_principle_prictice/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-传统垂直应用架构"><a href="#1-传统垂直应用架构" class="headerlink" title="1 传统垂直应用架构"></a>1 传统垂直应用架构</h1><p>以经典的 MVC 垂直架构为例，通常分三层：  </p><ol><li>View：视图展示层，使用 JSP/JS/HTML+CSS。</li><li>Controller：调度控制层，请求的分发。</li><li>Model：应用模型层，业务数据和业务执行逻辑，被多个视图重用。</li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_1.png" alt></p><p>标准的 MVC 模式并不包含数据访问层，但实际开发中需要专门的数据库连接池和统一的数据库访问接口对接数据库，于是 ORM 框架逐渐流行起来。  </p><p>通常基于 MVC 架构开发的应用代码会统一打成一个 war 包，不同的应用功能之间通过本地 API 进行调用，基本不存在跨进程的远程服务调用。  </p><p>通常的基于热双机备份，判断应用进程宕机或僵死后，应用切换备机，然后尝试重新拉起主机。<br>而在高并发、大流量的应用场景中，需要做集群，通常前端通过 F5 等负载均衡器做七层负载均衡，后端做对等集群部署。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_2.png" alt><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_3.png" alt></p><h1 id="2-RPC-架构"><a href="#2-RPC-架构" class="headerlink" title="2 RPC 架构"></a>2 RPC 架构</h1><p>RPC 全称 Remote Procedure Call，它是一种进程间通信方式。允许像调用本地服务一样调用远程服务，具体实现可以不同。</p><h2 id="2-1-RPC-框架原理"><a href="#2-1-RPC-框架原理" class="headerlink" title="2.1 RPC 框架原理"></a>2.1 RPC 框架原理</h2><p>RPC 框架的目标就是让远程过程（服务）调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP/UDP）、序列化方式（XML/JSON/二进制）和通信细节。<br>调用原理图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_4.png" alt>  </p><ol><li>远程服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构，或者中间态的服务定义文件，例如 Thrift 的 IDL 文件；服务调用者需要通过一定的途径获取远程服务调用相关信息，例如服务端接口定义 Jar 包导入，获取服务端 IDL 文件等。</li><li>远程代理对象：服务调用者调用的服务实际是远程服务的本地代理，对于 Java 语言，它的实现就是 JDK 的动态代理，通过动态代理的拦截机制，将本地调用封装成远程服务调用。</li><li>通信：RPC 框架与具体的协议无关。</li><li>序列化：远程通信，需要将对象转换成二进制码流进行网络传输，不同的序列化框架，支持的数据类型、数据包大小、异常类型及性能等都不同。有的甚至支持用户自定义序列化框架（Hadoop Avro）。</li></ol><h2 id="2-2-实现一个简单的-RPC-框架"><a href="#2-2-实现一个简单的-RPC-框架" class="headerlink" title="2.2 实现一个简单的 RPC 框架"></a>2.2 实现一个简单的 RPC 框架</h2><ol><li>分四个聚合项目：Provider、Consumer、RpcFramework、ServiceApi。为了简单期间，RPC 核心和 ServiceApi 合并一个项目 C。</li><li>Provider 依赖 C 项目，Consumer 依赖 C 项目。这样 Provider 和 Consumer 都有了同一个顶级接口以及同版本的 RPC 框架。</li><li>RPC 框架提供 export() 用于 Provider 发布自己的实现类、refer() 用于 Consumer 调用对应的顶级接口。</li><li>refer() 方法用于生成代理，此代理每次执行方法都会调用 invoke() 方法，而 invoke() 方法实际通过 socket 连接 Provider ，将调用的方法名、参数等传递给 Provider。</li><li>export() 方法用于获取 Consumer 传递的方法名，参数等，以及自己暴露的接口实现类，来反射执行获取结果，并返回给 Consumer。</li><li>代理对象获取到了结果，返回给调用者。</li><li>Provider 使用了反射，用于将调用者的方法名、参数、自己暴露的服务调用执行获取结果。Consumer 使用了代理，每次执行方法，都会调用 invoke() 即将调用的方法名、参数、调用的接口传递给 Provider。实现远程服务的本地代理。</li><li><a href="6">参考的 GITHUB 地址</a></li></ol><h2 id="2-3-业界主流-RPC-框架"><a href="#2-3-业界主流-RPC-框架" class="headerlink" title="2.3 业界主流 RPC 框架"></a>2.3 业界主流 RPC 框架</h2><ol><li>Facebook 的 Apache Thrift。</li><li>Hadoop 的 Avro-RPC。</li><li>caucho 的 Hession。</li><li>Google 的 gRPC。</li></ol><h2 id="2-4-RPC-框架面临的挑战"><a href="#2-4-RPC-框架面临的挑战" class="headerlink" title="2.4 RPC 框架面临的挑战"></a>2.4 RPC 框架面临的挑战</h2><ol><li>提供服务的机器越来越多，服务 URL 配置管理变得非常困难（服务发布订阅中心）。</li><li>服务间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动（链路追踪）。</li><li>某个服务调用量特别大，需要加机器。为了解决容量规划问题，需要采集服务调用 KPI 数据，进行汇总和分析，计算出服务部署实例数和服务器的配置规格。</li><li>服务上线容易下线难，下线通知，需要统一的服务生命周期管理流程进行管控，如何保证敏感服务不被误调用，服务的访问安全策略又如何制定？</li><li>服务治理问题。</li></ol><h1 id="3-SOA-服务化架构"><a href="#3-SOA-服务化架构" class="headerlink" title="3 SOA 服务化架构"></a>3 SOA 服务化架构</h1><p>SOA 是一种粗粒度、松耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信。  </p><h2 id="3-1-面向服务设计的原则"><a href="#3-1-面向服务设计的原则" class="headerlink" title="3.1 面向服务设计的原则"></a>3.1 面向服务设计的原则</h2><ol><li>服务可服用：不管是否存在即时复用的机会，服务均被设计为支持潜在的可复用。</li><li>服务共享一个标准契约：IDL 文件、Java 接口定义、甚至是一个接口说明文档。</li><li>服务是松耦合的：服务被设计为功能相对独立、尽量不依赖其它服务的独立功能提供者。</li><li>服务是底层逻辑的抽象：只有经服务契约所暴露的服务队外部世界可见，契约之外底层的实现逻辑是不可见的。</li><li>服务是可组合、可编排的：多个服务可能被编排组合成一个新的服务。</li><li>服务是可自治的：逻辑由服务所控制，并位于一个清晰的边界内，服务已经在边界内被控制，不依赖于其它服务。</li><li>服务是无状态的：这意味着要讲状态管理移至他处。</li><li>服务是可被自动发现的：服务发布上线后，允许被其它消费者自动发现。服务下线后，允许消费者接收服务下线通知。</li></ol><h2 id="3-2-服务治理"><a href="#3-2-服务治理" class="headerlink" title="3.2 服务治理"></a>3.2 服务治理</h2><p>SOA 服务治理主要包括如下几个方面：</p><ol><li>服务定义：SOA 治理最基础的方面就是监视服务的创建过程。</li><li>服务生命周期管理：服务需要进行规划、设计、实现、部署、维护、下线主要阶段。</li><li>服务版本治理：新版本的兼容性。</li><li>服务注册中心：服务提供者如何发布服务？服务消费者如何订阅服务？</li><li>服务监控：服务监控中心需要对服务的调用时延、成功率、吞吐率等数据进行实时采样和汇总。</li><li>运行期服务质量保障：包括服务限流、服务迁入迁出、服务升降级、服务权重调整和服务超时控制等，通过运行期的动态治理，可以在不重启服务的前提下达到快速提升服务运行质量的目标。</li><li>快速的故障定界定位手段：大规模分布式环境下海量业务/平台日志的采集、汇总和实时在线检索；分布式消息跟踪。</li><li>服务安全：是否允许任何人调用任何服务，数据敏感型服务是否允许所有用户访问所有数据，交互数据是否需要进行保护，服务的安全认证等。服务安全访问策略有多重，例如动态生成 Token 的方式做安全访问授权。</li></ol><h1 id="4-微服务架构"><a href="#4-微服务架构" class="headerlink" title="4 微服务架构"></a>4 微服务架构</h1><p>微服务架构（MSA）是一种服务化架构风格。<br>SOA 架构解决了应用服务化问题，但是随着服务规模越来越大、服务治理越来越多，微服务架构风格应运而生。微服务架构的主要特征如下：  </p><ol><li>原子服务。</li><li>高密度部署：利用LXC（例如 Docker）实现容器级部署。</li><li>敏捷交付：服务由小研发团队负责设计、开发、测试、部署、线上治理、灰度发布和下线，运维整个生命周期支撑，实现真正的 DevOps。</li><li>微自治：服务足够小，功能单一，可以独立打包、部署、升级、回滚和弹性伸缩，不依赖其它服务，实现局部自治。</li></ol><p>相对于 SOA，主要差异如下：  </p><ol><li>服务拆分粒度。</li><li>服务依赖：SOA 尽量重用，微服务功能单一独立。</li><li>服务规模：SOA 服务粒度大，多数会采用多个服务合并打 war 包，因此服务实例数比较有限。微服务强调尽可能拆分，同时很多服务会独立部署。</li><li>架构差异。</li><li>服务治理。</li><li>敏捷交付。</li></ol><h1 id="5-个人理解总结"><a href="#5-个人理解总结" class="headerlink" title="5 个人理解总结"></a>5 个人理解总结</h1><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/distributed_principle_prictice/1_5.png" alt></p><ol><li>MVC架构：在于多个功能部署同一个进程，一个 war 包，通过 HTTP 请求来实现互相的调用。重点在于前后端分离。</li><li>RPC架构：将核心和公共业务抽取出来，独立运行进程，使用 RPC 调用服务屏蔽底层通信逻辑。重点在于业务复用以及通用拆分。</li><li>SOA架构：服务生命周期管控和SOA服务治理是关键。</li><li>微服务架构：敏捷开发、持续交付、DevOps理论，基于 Docker 等轻量级容器。重点在于独立打包、部署和升级，小团队敏捷交付，交付周期短。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、bash shell 命令</title>
      <link href="/2018/05/16/linux_cli_shell/1.html/"/>
      <url>/2018/05/16/linux_cli_shell/1.html/</url>
      
        <content type="html"><![CDATA[<h3 id="1-bash-手册"><a href="#1-bash-手册" class="headerlink" title="1. bash 手册"></a>1. bash 手册</h3><p>用于查看命令的具体详情</p><p>man xxx</p><h2 id="2-ls-文件和目录列表"><a href="#2-ls-文件和目录列表" class="headerlink" title="2. ls 文件和目录列表"></a>2. ls 文件和目录列表</h2><p>-a 显示隐藏文件<br>文件名支持 <code>*？</code> 符号过滤  </p><h3 id="3-处理文件"><a href="#3-处理文件" class="headerlink" title="3. 处理文件"></a>3. 处理文件</h3><p>-i 询问参数<br>touch<br>cp file1 file2：复制文件。参数 -R 用于递归复制文件<br>mv file1 file2：移动文件<br>rm file1：删除文件，文件名支持<code>?*</code></p><h3 id="4-处理目录"><a href="#4-处理目录" class="headerlink" title="4. 处理目录"></a>4. 处理目录</h3><p>mkdir：创建目录。-p 创建多个目录和子目录<br>rmdir：删除空目录<br>rm -rf：递归删除，-r 递归遍历，-f 删除不提示</p><h3 id="5-查看文件内容"><a href="#5-查看文件内容" class="headerlink" title="5. 查看文件内容"></a>5. 查看文件内容</h3><p>file file1：获取文件的类型<br>cat file1：显示文本所有内容，参数 -n 加上行数，参数 -b 只给有内容的行加行数<br>more file1：<br>less file1：<br>tail file1：参数 -f，动态查看文件内容</p><h3 id="6-检测程序"><a href="#6-检测程序" class="headerlink" title="6. 检测程序"></a>6. 检测程序</h3><p>ps： -ef<br>top：实时检测，q 退出<br>kill PID：-9 参数强制<br>killall Name：关闭进程名，可以使用通配符</p><h3 id="7-检测磁盘空间"><a href="#7-检测磁盘空间" class="headerlink" title="7. 检测磁盘空间"></a>7. 检测磁盘空间</h3><p>mount：挂载媒体的<br>unmount：移除可移动设备<br>sort file：文件排序<br>grep pattern file：在 file 文件中查找 pattern 的行。-v 参数反向搜索<br>gzip/gunzip：压缩解压文件<br>tar：-A 追加归档，-x 提取文件</p><h3 id="8-理解-shell"><a href="#8-理解-shell" class="headerlink" title="8. 理解 shell"></a>8. 理解 shell</h3><p>&amp;：将任务置入后台模式<br>which 命令：查看命令的对应路径<br>history：最近的使用过的命令列表  </p><h3 id="9-使用Linux环境变量"><a href="#9-使用Linux环境变量" class="headerlink" title="9. 使用Linux环境变量"></a>9. 使用Linux环境变量</h3><p>查看环境全局变量：printenv/env<br>查看环境局部变量：set<br>export：将一个局部变量的key导出到全局环境中  </p><h3 id="10-管理文件系统"><a href="#10-管理文件系统" class="headerlink" title="10. 管理文件系统"></a>10. 管理文件系统</h3><ol><li>ext 文件系统：单文件不能超过2GB。</li><li>ext2 文件系统：保存更多信息。</li><li>日志文件系统：先将数据直接写入存储设备再更新索引节点表-&gt;文件的更改写入到临时文件中，数据成功写到存储设备和索引节点表后再删除对应的日志条目。</li><li>ext3 文件系统：在 ext2 基础上，给每个存储设备增加了一个日志文件。</li><li>ext4 文件系统。</li></ol><h3 id="11-安装软件程序"><a href="#11-安装软件程序" class="headerlink" title="11. 安装软件程序"></a>11. 安装软件程序</h3><ol><li>Debian（Ubuntu）：dpkg 命令。</li><li>Red Hat：rpm 命令。yum 命令。</li></ol><h3 id="12-使用编辑器"><a href="#12-使用编辑器" class="headerlink" title="12. 使用编辑器"></a>12. 使用编辑器</h3><p>vim<br>nano<br>emacs</p><h2 id="13-参考"><a href="#13-参考" class="headerlink" title="13. 参考"></a>13. 参考</h2><ol><li>初识Linux shell：<a href="http://www.ituring.com.cn/book/tupubarticle/11430" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/11430</a></li><li>走进shell：<a href="http://www.ituring.com.cn/book/tupubarticle/11431" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/11431</a></li><li>基本的bash shell命令：<a href="http://www.ituring.com.cn/book/tupubarticle/11432" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/11432</a></li><li>更多的bash shell命令： <a href="http://www.th7.cn/system/lin/201704/210752.shtml" target="_blank" rel="noopener">http://www.th7.cn/system/lin/201704/210752.shtml</a></li><li>理解shell：<a href="http://www.th7.cn/system/lin/201704/211006.shtml" target="_blank" rel="noopener">http://www.th7.cn/system/lin/201704/211006.shtml</a></li><li>使用Linux环境变量：<a href="http://www.voidcn.com/article/p-vizgjbtx-bmq.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-vizgjbtx-bmq.html</a></li><li>理解Linux文件权限：<a href="http://www.voidcn.com/article/p-whblgnni-bmq.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-whblgnni-bmq.html</a></li><li>管理文件系统：<a href="https://www.aliyun.com/jiaocheng/123749.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/123749.html</a></li><li>安装软件程序：<a href="https://www.aliyun.com/jiaocheng/123748.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/123748.html</a></li><li>使用编辑器：<a href="http://www.voidcn.com/article/p-fokuslvn-bnt.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-fokuslvn-bnt.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Linux命令行与shell脚本编程大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、shell 脚本</title>
      <link href="/2018/05/16/linux_cli_shell/2.html/"/>
      <url>/2018/05/16/linux_cli_shell/2.html/</url>
      
        <content type="html"><![CDATA[<h2 id="13-参考"><a href="#13-参考" class="headerlink" title="13 参考"></a>13 参考</h2><p>第十一章 构建基本脚本：<a href="http://www.suoniao.com/article/15930" target="_blank" rel="noopener">http://www.suoniao.com/article/15930</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Linux命令行与shell脚本编程大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试自我反省总结</title>
      <link href="/2018/05/08/tech/learn_what_how_why.html/"/>
      <url>/2018/05/08/tech/learn_what_how_why.html/</url>
      
        <content type="html"><![CDATA[<h3 id="1-第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做-ERP-这类的系统，最后-HR-等年后通知就没通知了。"><a href="#1-第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做-ERP-这类的系统，最后-HR-等年后通知就没通知了。" class="headerlink" title="1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。"></a>1. 第一个面试大概是年前还差半个月放假的某天晚上，一个电话面试，杭州的一个偏传统公司，应该是主要做 ERP 这类的系统，最后 HR 等年后通知就没通知了。</h3><p>主要问了 java 集合，包括里面 List、Set、Map 各个区别以及相关算法、Spring 的设计模式、Spring MVC 和 Servlet 的联系区别、Spring 的相关源码，我当时只说了 Spring MVC 启动、运行源码流程，@Autowire 注入的时候的 AutowireAnnotationBeanPostProcessor 的相关逻辑，顺带讲了 Bean 的生命周期，循环注入等，还有一些常见的面试题给忘了。</p><h3 id="2-第二个面试是4-26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。"><a href="#2-第二个面试是4-26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。" class="headerlink" title="2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。"></a>2. 第二个面试是4.26号武汉小米的面试，以为一面不会过，没想到过了，可惜二面BOS没过，主要是对自己的项目没答好，可能由于没怎么复习以前的项目，不过学了很多。</h3><p>一面先问 hashmap 的 put，currenthashmap 的 put，以及 size，然后是 ThreadLocal，订阅模式、命令模式、代理模式，sql，组合索引，手写一些 sql 问是否用到了索引，<br>手写一个 幻读，隔离级别与事务传播，那个幻读没写出来，然后被一面的面试官评价为基础可以但是 sql 不行，唉，然后问我最得意的项目，我说的是一个基于 ZooKeeper 的一个项目，然后问了 zk 的一些知识，两阶段提交、paxos（这个没答出来）、CAP、BASE，然后问如何实现一个分布式锁，然后问了项目的一些问题，涉及到了线程池。<br>二面直接让我把一个 BI 的项目技术架构图画出来，然后问 ETL ，RPC 和 http 的区别，然后其它一些小问题，跟我说要多敲代码，不是本专业只能要非常突出的代码能力才行。。。然后谈论了业务和技术，最后直接跟我说没过。比较奇怪没有问 JVM，可能是三面才会问这么高深的吧。。。<br>事后也把我做的项目都复习总结拿出来重新过了一遍，学了很多，然后好好复习，准备下一个面试。</p><h3 id="3-第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到-offer-没去。"><a href="#3-第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到-offer-没去。" class="headerlink" title="3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。"></a>3. 第三个面试是上海的一家创业公司，笔试，两轮技术，HR，拿到 offer 没去。</h3><p>笔试：两个类A extend B，考察静态方法和构造方法的执行顺序，二分查找法，mysql 的 having order 等。<br>技术面试，一问 hashmap 然后问简历项目。最后问多个线程同时下载报表如何下载。主问简历。<br>二轮BOS，一问 某个业务从请求到最后日志记录的业务全过程。然后聊了很多，treemap 和 hashmap，git rebase merge，最后一个问题是一千个排好序的文件，如果成为一个大的排序好的文件。大概这么多</p><h3 id="4-第四个面试是上海同事推荐，两面技术，拿到-offer。"><a href="#4-第四个面试是上海同事推荐，两面技术，拿到-offer。" class="headerlink" title="4. 第四个面试是上海同事推荐，两面技术，拿到 offer。"></a>4. 第四个面试是上海同事推荐，两面技术，拿到 offer。</h3><p>一面电话：集合、threadlocal、锁、线程池。多态、继承、封装的理解，主要是基础，具体问的大概忘了，并不深入。<br>二面聊天：一问，nginx 实现负载均衡的方式，底层如何实现负载均衡，zk 的实际案例，为什么用 zk，内部如何选举。大概这么多。</p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> 其它爱好 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jboot_1</title>
      <link href="/2018/01/10/tech/Jboot_1.html/"/>
      <url>/2018/01/10/tech/Jboot_1.html/</url>
      
        <content type="html"><![CDATA[<p>Jboot的入门demo —— JbooFly。</p><a id="more"></a><hr><h1 id="1-项目组成"><a href="#1-项目组成" class="headerlink" title="1 项目组成"></a>1 项目组成</h1><p>后端基础框架：Jboot 1.2.7<br>前端基础框架：Fly Template 社区模版<br>界面渲染框架：JFinal Template Engine</p><h1 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2 数据库"></a>2 数据库</h1><p>使用 Mysql，一共有七张表，暂时使用的只有六张表，即文章分类表、评论表、文章表、用户表、用户行为表、用户收藏表。用户消息表没有用上。</p><h1 id="3-前端页面"><a href="#3-前端页面" class="headerlink" title="3 前端页面"></a>3 前端页面</h1><ol><li>社区首页：外层架子（_layout.html），分类导航（_navigation.html），置顶文章（_top_posts.html），内容列表（content()），右边四个小页面（_signin_panel/_recommend/_hot_posts/_links）<ol start="2"><li>个人页面：外层架子，左侧导航（_user_left_menu.html），我的主页（index.html），我的帖子（post.html/collection.html），基本设置（setting.html），我的消息（message.html），账号激活（activate.html）</li></ol></li></ol><h1 id="4-定时任务"><a href="#4-定时任务" class="headerlink" title="4 定时任务"></a>4 定时任务</h1><ol><li><p>文章浏览量，一分钟一次。使用了 <code>ConcurrentHashMap</code> + <code>AtomicLong</code> 的方式处理线程问题。最后更新缓存（默认缓存开启并有五种）：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * name: io.jboot.core.cache.JbootCacheConfig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_EHCACHE = <span class="string">"ehcache"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_REDIS = <span class="string">"redis"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_EHREDIS = <span class="string">"ehredis"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_NONE_CACHE = <span class="string">"none"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_J2CACHE = <span class="string">"j2cache"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type = TYPE_EHCACHE;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></li><li><p>文章评论量，和文章浏览量一样的业务逻辑。</p></li></ol><h1 id="5-Caffeine-缓存使用"><a href="#5-Caffeine-缓存使用" class="headerlink" title="5 Caffeine 缓存使用"></a>5 Caffeine 缓存使用</h1><ol><li>签到缓存：SigninManager，缓存用户以及签到时间的映射关系，过期时间为两小时。</li><li>消息缓存：MessageManager，作者未开发完，猜测是缓存用户以及用户未读消息的映射关系。</li></ol><h1 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6 拦截器"></a>6 拦截器</h1><ol><li>全局强制拦截器 UserIntercepor ，每次请求服务，都会使用解密算法查看存储在 cookie 中的用户信息，并获取该用户的签到缓存以及消息缓存信息。</li><li>ajax api 强制拦截器 ApiNeedUser。</li><li>页面强制拦截器 NeedUser。</li></ol><h1 id="7-本地事件"><a href="#7-本地事件" class="headerlink" title="7 本地事件"></a>7 本地事件</h1><ol><li>用户注册事件监听 UserRegister ，作者未开发完，猜测应该是用户注册后发送邮件或者验证码，抑或是通知版主？</li></ol><h1 id="8-JFinal"><a href="#8-JFinal" class="headerlink" title="8 JFinal"></a>8 JFinal</h1><ol><li>JFinal Template Engine，查看 JFinal 自定义指令文档即可。主要是 directive 下的文件。</li></ol><h1 id="9-目的"><a href="#9-目的" class="headerlink" title="9 目的"></a>9 目的</h1><p>猜测应该是 JBoot 论坛。</p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
          <category> jboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jboot_2</title>
      <link href="/2018/01/10/tech/Jboot_2.html/"/>
      <url>/2018/01/10/tech/Jboot_2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-启动流程"><a href="#0-启动流程" class="headerlink" title="0 启动流程"></a>0 启动流程</h1><ol><li>解析启动参数，打印 logo。</li><li>通过工厂对配置进行判断获取相应的应用服务器（默认 undertow）。</li><li>判断是否是开发模式（默认），如果是则定期对文件进行扫描（3 * 1010）。</li><li>回调各个 listener 的 onJbootStarted() 方法。</li></ol><h1 id="1-如何使用-main-文件启动一个应用服务器？"><a href="#1-如何使用-main-文件启动一个应用服务器？" class="headerlink" title="1 如何使用 main 文件启动一个应用服务器？"></a>1 如何使用 main 文件启动一个应用服务器？</h1><p>如果你会使用，可以直接跳过这节。</p><p>pom.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.8.v20171121<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.8.v20171121<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>SimpleServer.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"0.0.0.0"</span>, <span class="number">8081</span>);</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(address);</span><br><span class="line">        ResourceHandler handler = <span class="keyword">new</span> ResourceHandler();</span><br><span class="line">        handler.setDirectoriesListed(<span class="keyword">true</span>);</span><br><span class="line">        handler.setResourceBase(<span class="string">"/Users/liwenguang/Downloads"</span>);</span><br><span class="line">        server.setHandler(handler);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="http://blog.csdn.net/kiterunner/article/details/51695293" target="_blank" rel="noopener">http://blog.csdn.net/kiterunner/article/details/51695293</a></p><h1 id="2-Jboot-启动精简版"><a href="#2-Jboot-启动精简版" class="headerlink" title="2 Jboot 启动精简版"></a>2 Jboot 启动精简版</h1><p>Jboot.java 主文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jboot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JbootServer jbootServer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ensureServerCreated();</span><br><span class="line">        <span class="keyword">if</span> (!startServer()) &#123;</span><br><span class="line">            System.err.println(<span class="string">"jboot start fail!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureServerCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jbootServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            JbootServerFactory factory = JbootServerFactory.me();</span><br><span class="line">            jbootServer = factory.buildServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jbootServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Jboot().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JbootServer 抽象类，方便各种应用服务器的工厂创建，其中作者只编写了 undertow 和 jetty 的实现。（可知作者对 tomcat 不大喜欢）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JbootServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">restart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">JbootServerFactory 工厂类：</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JbootServerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JbootServerFactory me = <span class="keyword">new</span> JbootServerFactory();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JbootServerFactory <span class="title">me</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> me;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JbootServer <span class="title">buildServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// switch </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JettyServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着是应用服务器的配置文件， JbootServerConfig：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JbootServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_UNDERTOW = <span class="string">"undertow"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_TOMCAT = <span class="string">"tomcat"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_JETTY = <span class="string">"jetty"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type = TYPE_UNDERTOW;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"0.0.0.0"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> String contextPath = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set/get 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是实现的 Jetty 应用服务器， JettyServer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServer</span> <span class="keyword">extends</span> <span class="title">JbootServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Log log = Log.getLog(JettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JbootServerConfig config;</span><br><span class="line">    <span class="comment">// private JbootWebConfig webConfig;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Server jettyServer;</span><br><span class="line">    <span class="keyword">private</span> ServletContextHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JettyServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        config = <span class="keyword">new</span> JbootServerConfig();</span><br><span class="line">        <span class="comment">// webConfig = Jboot.config(JbootWebConfig.class);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initJettyServer();</span><br><span class="line">            <span class="comment">// JbootAppListenerManager.me().onAppStartBefore(this);</span></span><br><span class="line">            jettyServer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            log.error(ex.toString(), ex);</span><br><span class="line">            stop();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initJettyServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(config.getHost(), config.getPort());</span><br><span class="line">        jettyServer = <span class="keyword">new</span> Server(address);</span><br><span class="line"></span><br><span class="line">        handler = <span class="keyword">new</span> ServletContextHandler();</span><br><span class="line">        handler.setContextPath(config.getContextPath());</span><br><span class="line">        handler.setClassLoader(<span class="keyword">new</span> JbootServerClassloader(JettyServer.class.getClassLoader()));</span><br><span class="line">        handler.setResourceBase(getRootClassPath());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        增加 shiro 全局过滤器</span></span><br><span class="line"><span class="comment">        JbootShiroConfig shiroConfig = Jboot.config(JbootShiroConfig.class);</span></span><br><span class="line"><span class="comment">        if (shiroConfig.isConfigOK()) &#123;</span></span><br><span class="line"><span class="comment">            handler.addEventListener(new EnvironmentLoaderListener());</span></span><br><span class="line"><span class="comment">            handler.addFilter(ShiroFilter.class, "/*", EnumSet.of(DispatcherType.REQUEST));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        增加 Jfinal Handler，Jboot 基于 Jfinal</span></span><br><span class="line"><span class="comment">        //JFinal</span></span><br><span class="line"><span class="comment">        FilterHolder jfinalFilter = handler.addFilter(JFinalFilter.class, "/*", EnumSet.of(DispatcherType.REQUEST));</span></span><br><span class="line"><span class="comment">        jfinalFilter.setInitParameter("configClass", Jboot.me().getJbootConfig().getJfinalConfig());</span></span><br><span class="line"><span class="comment">        增加 Hystrix 监控 servlet</span></span><br><span class="line"><span class="comment">        JbootHystrixConfig hystrixConfig = Jboot.config(JbootHystrixConfig.class);</span></span><br><span class="line"><span class="comment">        if (StringUtils.isNotBlank(hystrixConfig.getUrl())) &#123;</span></span><br><span class="line"><span class="comment">            handler.addServlet(HystrixMetricsStreamServlet.class, hystrixConfig.getUrl());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        增加 metric 监控</span></span><br><span class="line"><span class="comment">        JbootMetricConfig metricsConfig = Jboot.config(JbootMetricConfig.class);</span></span><br><span class="line"><span class="comment">        if (StringUtils.isNotBlank(metricsConfig.getUrl())) &#123;</span></span><br><span class="line"><span class="comment">            handler.addEventListener(new JbootMetricServletContextListener());</span></span><br><span class="line"><span class="comment">            handler.addEventListener(new JbootHealthCheckServletContextListener());</span></span><br><span class="line"><span class="comment">            handler.addServlet(AdminServlet.class, metricsConfig.getUrl());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        最后增加 Jboot 本身的 servlet</span></span><br><span class="line"><span class="comment">        io.jboot.server.Servlets jbootServlets = new io.jboot.server.Servlets();</span></span><br><span class="line"><span class="comment">        ContextListeners listeners = new ContextListeners();</span></span><br><span class="line"><span class="comment">        JbootAppListenerManager.me().onJbootDeploy(jbootServlets, listeners);</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;String, io.jboot.server.Servlets.ServletInfo&gt; entry : jbootServlets.getServlets().entrySet()) &#123;</span></span><br><span class="line"><span class="comment">            for (String path : entry.getValue().getUrlMapping()) &#123;</span></span><br><span class="line"><span class="comment">                handler.addServlet(entry.getValue().getServletClass(), path);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        事件监听</span></span><br><span class="line"><span class="comment">        for (Class&lt;? extends ServletContextListener&gt; listenerClass : listeners.getListeners()) &#123;</span></span><br><span class="line"><span class="comment">            handler.addEventListener(ClassKits.newInstance(listenerClass));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        jettyServer.setHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRootClassPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            path = JettyServer.class.getClassLoader().getResource(<span class="string">""</span>).toURI().getPath();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> File(path).getAbsolutePath();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">        start();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jettyServer.stop();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(ex.toString(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是自定义 ClassLoader，JbootServerClassLoader：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JbootServerClassloader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JbootServerClassloader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义 ClassLoader 在应用服务器中都会自定义，用于文件的隔离和热更新。  </p><p>目录结构如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_demo.png" alt></p><h1 id="3-启动到底启动了什么"><a href="#3-启动到底启动了什么" class="headerlink" title="3 启动到底启动了什么"></a>3 启动到底启动了什么</h1><h2 id="1-参数解析"><a href="#1-参数解析" class="headerlink" title="1. 参数解析"></a>1. 参数解析</h2><p>类似 JVM options 的 -Dxxx=xxx 参数的作用，用于全局访问，Jboot 将启动参数使用 Jboot.setBootArg() 放在了一个 Map 中，你可以使用 Jboot.getBootArg() 获取。<br>Jboot.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseArgs</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">int</span> indexOf = arg.indexOf(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">if</span> (arg.startsWith(<span class="string">"--"</span>) &amp;&amp; indexOf &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String key = arg.substring(<span class="number">2</span>, indexOf);</span><br><span class="line">                String value = arg.substring(indexOf + <span class="number">1</span>);</span><br><span class="line">                setBootArg(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-判断启动模式"><a href="#2-判断启动模式" class="headerlink" title="2. 判断启动模式"></a>2. 判断启动模式</h2><p>默认为 dev 模式，查看 JbootConfig.java 文件可知，但是我们可能为想，我们怎么才能设置启动模式呢？  </p><p>没错，使用启动参数！请看 JbootConfigManager 文件，该文件是用于读取配置文件，你可能会想，为什么配置文件都加了 <code>@PropertyConfig(prefix = &quot;&quot;)</code> 这样的注解呢，其实，这是作者为了方便 JavaBean 与 参数 进行转换。直接上代码：  </p><p>第一种：启动参数，如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/jboot_start_server_args.png" alt><br>我们配置了两个参数（对照 JbootConfig 你就知道，只有 mode 有 set 方法，而 version 是只有 get 方法的）。<br>最后启动 debug 的时候你就会发现 Jboot.isDevMode() 方法返回 false 而不是默认的 true。 </p><blockquote><p>有很多地方判断了，如果是 dev 模式，则会打印一些参数，例如 JbootEventManager 方法。</p></blockquote><p>第二种：使用 <code>Jboot.setBootArg(&quot;jboot.mode&quot;, &quot;test&quot;);</code> 这种，从前面的 <strong>参数解析</strong> 一节我们已经知道，其实启动参数底层使用的就是 setBootArg 方法。</p><blockquote><p>测试类中很多使用了这种方法，例如 <code>DubboClientZookeeperDemo</code>。</p></blockquote><p>如果是 dev 模式，就会定时 3 秒扫描应用服务器文件夹，但是作者注释了，这里不懂作者的意思。<br>AutoDeployManager.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(PathKit.getRootClassPath());</span><br><span class="line">        JbootFileScanner scanner = <span class="keyword">new</span> JbootFileScanner(file.getAbsolutePath(), <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String action, String file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    System.err.println("file changes : " + file);</span></span><br><span class="line"><span class="comment">//                    Jboot.me().getServer().restart();</span></span><br><span class="line"><span class="comment">//                    JbootServerFactory.me().buildServer().start();</span></span><br><span class="line"><span class="comment">//                    System.err.println("Loading complete.");</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Error reconfiguring/restarting webapp after change in watched files"</span>);</span><br><span class="line">                    LogKit.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        scanner.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-回调所有-JbootAppListener-实现类的-onJbootStarted-方法"><a href="#3-回调所有-JbootAppListener-实现类的-onJbootStarted-方法" class="headerlink" title="3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法"></a>3. 回调所有 JbootAppListener 实现类的 onJbootStarted()方法</h2><p>在 Jboot 启动的最后一步，实例化了 JbootAppListenerManager 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">JbootAppListenerManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扫描获取所有 JbootAppListener 的子类</span></span><br><span class="line">    List&lt;Class&lt;JbootAppListener&gt;&gt; allListeners = ClassScanner.scanSubClass(JbootAppListener.class, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (allListeners == <span class="keyword">null</span> || allListeners.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除 JbootAppListenerManager 本身</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends JbootAppListener&gt; clazz : allListeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (JbootAppListenerManager.class == clazz || JbootAppListenerBase.class == clazz) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        JbootAppListener listener = ClassKits.newInstance(clazz, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onJbootStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (JbootAppListener listener : listeners) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listener.onJbootStarted();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            log.error(ex.toString(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并通过 <code>JbootAppListenerManager.me().onJbootStarted();</code> 回调了 <code>onJbootStarted()</code> 方法，来调用用户的逻辑。</p><h1 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h1><ol><li>从一些 Manager 方法看的出作者习惯通过构造方法进行一些必要的初始化，我以前看的 《架构探险——从零开始写Java Web框架》 则喜欢用静态块进行初始化。  </li><li>启动的一些细节需要大家去 debug 一步一步看，看懂了也是很高兴的，毕竟作者也是大牛，更近了一步。  </li><li>作者代码习惯方法名由于注释。说实话初看有点不习惯，因为习惯看注释了，但是作者方法名真的能让你可以不用注释（除却一些必要方法作者加了注释）。</li><li>jbootfly 是入门，不要想直接看源码，欲速则不达。</li><li>你要懂 jfinal 的知识，至少看过 jfinal 文档，写过 jfinal 经典的 blog 项目。</li></ol><h2 id="如果有错误，请指出，谢谢，共勉。"><a href="#如果有错误，请指出，谢谢，共勉。" class="headerlink" title="如果有错误，请指出，谢谢，共勉。"></a>如果有错误，请指出，谢谢，共勉。</h2>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
          <category> jboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017 总结</title>
      <link href="/2017/12/31/2017/index.html/"/>
      <url>/2017/12/31/2017/index.html/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="除非你知道 Y 代表什么，不然请不要输入 Y" />    <label for="pass">除非你知道 Y 代表什么，不然请不要输入 Y</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 行为总结 </category>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2017总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、创建高性能的索引</title>
      <link href="/2017/12/28/high_performance_MySQL/5.html/"/>
      <url>/2017/12/28/high_performance_MySQL/5.html/</url>
      
        <content type="html"><![CDATA[<p>索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。</p><h1 id="1-索引基础"><a href="#1-索引基础" class="headerlink" title="1 索引基础"></a>1 索引基础</h1><h2 id="1-1-索引的类型"><a href="#1-1-索引的类型" class="headerlink" title="1.1 索引的类型"></a>1.1 索引的类型</h2><p>在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准。即使多个存储引擎支持同一种类型的索引，其底层的事先也可能不同。</p><h3 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B-Tree 索引"></a>1. B-Tree 索引</h3><p>InnoDB 本质是“B+Tree”。假设有如下数据表：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">    last_name  <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">50</span>)    <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dob        <span class="built_in">date</span>           <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gender     enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于表中的每一行数据，索引中包含了 last_name、first_name和 dob 列的值，下图显示了该索引是如何组织数据的存储的：  </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_1.png" alt></p><p>注：索引对多个值进行排序的依据是<code>CREATE TABLE</code>语句中定义索引时列的顺序。</p><ol><li>全值匹配：指和索引中的所有列进行匹配。</li><li>匹配最左前缀：前面提到的索引可用于查询所有姓为 Allen 的人，即只使用索引的第一列。</li><li>匹配列前缀：例如查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。</li><li>匹配范围值：例如查找姓在 Allen 和 Barrymore 之间的人。</li><li>精确匹配某一列并范围匹配另外一列：查找所有姓为 Allen，并且名字是字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</li><li>只访问索引的查询</li></ol><p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的<code>ORDER BY</code>操作（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果<code>ORDER BY</code>子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。  </p><p>下面是一些关于 B-Tree 索引的限制：</p><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引。例，上面的例子的索引无法查找名字为 Bill 的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。这是关于<code>like &#39;%关键字&#39;</code>的知乎讨论：<a href="https://www.zhihu.com/question/52718330?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/52718330?sort=created</a></li><li>不能跳过索引中的列。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。</li></ul><p>有些限制并不是 B-Tree 本身导致的，而是 MySQL 优化器和存储引擎使用索引的方式导致的，这部分限制在未来的版本中可能就不再是限制了。</p><h3 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h3><p>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。  </p><ol><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况这一点对性能的影响并不明显。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li><li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例，在（A,B）建立哈希索引，如果查询只有 A ，则无法使用该索引。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针。</li></ol><p>当字段过大，例如存储 URL 时，可以额外使用一个列，用于存储该列的哈希，用于排序。但为了避免哈希冲突的问题，需要<code>where url = &#39;http://www.mysql.com&#39; AND url_crc=CRC32(&#39;http://www.mysql.com&#39;)</code>，这样的性能会非常高。（可以使用触发器来自身插入哈希列）。</p><h3 id="3-空间数据索引（R-Tree）"><a href="#3-空间数据索引（R-Tree）" class="headerlink" title="3. 空间数据索引（R-Tree）"></a>3. 空间数据索引（R-Tree）</h3><p>MyISAM 表支持空间索引。</p><h3 id="4-全文索引"><a href="#4-全文索引" class="headerlink" title="4. 全文索引"></a>4. 全文索引</h3><p>使用<code>MATCH AGAINST</code>操作，而不是普通的<code>WHERE</code>。</p><h1 id="2-索引的优点"><a href="#2-索引的优点" class="headerlink" title="2 索引的优点"></a>2 索引的优点</h1><p>最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据时有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询：  </p><ol><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机 I/O 变为顺序 I/O。</li></ol><p>对于中到大型表，索引就非常有效。但对于特大型表，需要技术直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配，例，分区技术：建立元数据信息表，例，假如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。</p><h1 id="3-高性能索引的索引策略"><a href="#3-高性能索引的索引策略" class="headerlink" title="3 高性能索引的索引策略"></a>3 高性能索引的索引策略</h1><h2 id="3-1-前缀索引和索引选择性"><a href="#3-1-前缀索引和索引选择性" class="headerlink" title="3.1 前缀索引和索引选择性"></a>3.1 前缀索引和索引选择性</h2><p>索引选择性：不重复的索引值/数据表的记录总数，范围在0~1间，越高则查询越快。唯一索引的选择性是1，性能也是最好的。<br>列值过长，可以使用部分字段<code>LEFT(city,3)</code>作为前缀索引，这个值是通过<code>COUNT(DISTINCT LEFT(city,5))/COUNT(*)</code>的值来决定的，结果在 0.031 基本上就可用了。接着创建：<code>ALTER TABLE sakila.city_demo ADD KEY(city(5));</code><br>但是前缀索引虽然使索引更小、更快，但是无法使用前缀索引做<code>ORDER BY</code>和<code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。</p><blockquote><p>后缀索引（suffix index）也很有用途（电子邮箱），可以使用字符串反转后存储。</p></blockquote><h2 id="3-2-多列索引"><a href="#3-2-多列索引" class="headerlink" title="3.2 多列索引"></a>3.2 多列索引</h2><p>为每个列创建独立的索引，从<code>SHOW CREATE TABLE</code>中很容易看到这种情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(</span><br><span class="line">    c1 <span class="built_in">INT</span>,</span><br><span class="line">    c2 <span class="built_in">INT</span>,</span><br><span class="line">    c3 <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">key</span>(c1),</span><br><span class="line">    <span class="keyword">key</span>(c2),</span><br><span class="line">    <span class="keyword">key</span>(c3)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这种索引策略是由于“把 WHERE 条件里面的列都建上索引”这样模糊的建议导致的。这最多是“一星”索引。例，<code>WHERE c1 = &#39;1&#39; OR c2 = &#39;2&#39;</code>，虽然在 MySQL5.0+ 会优化使用这两个索引，但是在 <code>explain</code> 的 <code>extra</code> 中会有 <code>Using union</code>，因此说明了索引的糟糕：  </p><ol><li>出现多个 <code>AND</code> 条件，则需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</li><li>多个 <code>OR</code> 或者联合操作时，如果有些索引的选择性不高，需要合并扫描返回的大量数据。</li><li>如果在 <code>EXPLAIN</code> 中看到有索引合并，应该好好检查查询和表的结构，也可以通过参数 <code>optimizer_switch</code> 来关闭索引合并功能，也可以使用 <code>IGNORE INDEX</code> 提示让优化器忽略掉某些索引。</li></ol><h2 id="3-3-选择合适的索引列顺序"><a href="#3-3-选择合适的索引列顺序" class="headerlink" title="3.3 选择合适的索引列顺序"></a>3.3 选择合适的索引列顺序</h2><p>最好通过 <code>pt-query-digest</code> 这样的工具报告重提取“最差”查询，再按照索引顺序进行优化。如果没有类似的具体查询来运行，那么最好还是按照经验法则来做，因为经验法则考虑的是全局性和选择性，而不是某个具体查询：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_2.png" alt><br><code>customer_id</code> 的选择性更高，所以答案是将其作为索引列的第一列。</p><h2 id="3-4-覆盖索引"><a href="#3-4-覆盖索引" class="headerlink" title="3.4 覆盖索引"></a>3.4 覆盖索引</h2><p>如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”。  </p><ol><li>因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。</li><li>并不是所有类型的索引都可以称为覆盖索引。覆盖索引必须要存储索引列的值。</li></ol><p>当发起一个被覆盖的查询，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>Using index</code> 的信息。</p><blockquote><p><code>type</code> 列的 <code>index</code> 和 <code>Extra</code> 列的 <code>Using index</code> 是完全不同，前者和覆盖索引毫无关系，它只是表示这个查询访问数据的方式。</p></blockquote><p>索引覆盖查询还有很多陷阱可能导致无法实现优化：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_3.png" alt>  </p><ol><li>没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。</li><li>MySQL 不能再索引中执行 <code>LIKE</code> 操作，MySQL5.5- 只允许在索引中做简单比较操作，MySQL 能在索引中做最左前缀匹配的 <code>LIKE</code> 查询，因为该操作可以转为简单的比较操作，但是如果是通配符开头的 <code>LIKE</code> 查询，存储引擎就无法做比较匹配。这种情况下，MySQL 服务器只能提取数据行的值，而不是索引值来做比较。</li></ol><p>也有办法解决上面说的两个问题，重写查询并巧妙地设计索引。先将索引扩展至三个数据列（artist，title，prod_id），然后按如下方式重写查询：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/High_Performance_MySQL/5_4.png" alt></p><h2 id="3-5-使用索引扫描来做排序"><a href="#3-5-使用索引扫描来做排序" class="headerlink" title="3.5 使用索引扫描来做排序"></a>3.5 使用索引扫描来做排序</h2><p>MySQL 有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描；如果 <code>EXPLAIN</code> 出来的 type 列的值为 “index”，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）。<br>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机 I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。<br>如果查询需要关联多张表，则只有当 <code>ORDER BY</code> 子句引用的字段全部为第一个表时，才能使用索引做排序。</p><p>例： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rental(</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(rental_id),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> rental_date(rental_date, inventory_id, customer_id),</span><br><span class="line">    <span class="keyword">KEY</span> idx_fk_inventory_id(inventory_id),</span><br><span class="line">    <span class="keyword">KEY</span> idx_fk_customer_id(customer_id),</span><br><span class="line">    <span class="keyword">KEY</span> idx_fk_staff_id(staff_id),</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id</code> 因为索引第一列被指定为一个常数，所以查询排序。<br><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id</code> 也可以使用查询排序。<br><code>WHERE rental_date &gt; &#39;2005-05-25 ORDER BY rental_date, inventory_id</code> 也可以。<br>下面是不能使用索引做排序的查询：  </p><ol><li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id DESC, customer_id ASC;</code> 因为索引列都是正序排序。</li><li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY inventory_id, staff_id;</code> 因为引用了一个不再索引中的列。</li><li><code>WHERE rental_date = &#39;2015-05-25&#39; ORDER BY customer_id;</code> 无法组成索引的最左前缀。</li><li><code>WHERE rental_date &gt; &#39;2015-05-25&#39; ORDER BY inventory_id, customer_id;</code> 因为第一列上是范围条件。</li><li><code>WHERE rental_date = &#39;2015-05-25&#39; AND inventory_id IN (1,2) ORDER BY customer_id;</code> 还是范围查询。</li></ol><h1 id="4-索引案例学习"><a href="#4-索引案例学习" class="headerlink" title="4 索引案例学习"></a>4 索引案例学习</h1><h1 id="5-维护索引和表"><a href="#5-维护索引和表" class="headerlink" title="5 维护索引和表"></a>5 维护索引和表</h1><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、Schema与数据类型优化</title>
      <link href="/2017/12/25/high_performance_MySQL/4.html/"/>
      <url>/2017/12/25/high_performance_MySQL/4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-选择优化的数据类型"><a href="#1-选择优化的数据类型" class="headerlink" title="1 选择优化的数据类型"></a>1 选择优化的数据类型</h1><ol><li>更小的通常更好</li><li>简单就好：整型比字符操作代价更低，使用 MySQL 内建的类型而不是字符串来存储日期和时间，以及使用整型存储 IP 地址</li><li>尽量避免 NULL：可为 NULL 的列会使用更多的存储空间。 InnoDB 使用单独的位（bit）存储 NULL 值，但这不适用于 MyISAM</li></ol><p>在为列选择数据类型时，先确定大类型：数字、字符串、时间等。下一步是选择具体类型，很多数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。例如， TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，另一方面， TIMESTAMP 允许的时间范围要小得多。  </p><p>本章只讨论基本的数据类型。 MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC ，它们只是别名，使用 SHOW CREATE TABLE 检查， MYSQL 报告的是基本类型，而不是别名。</p><h2 id="1-1-整数类型"><a href="#1-1-整数类型" class="headerlink" title="1.1 整数类型"></a>1.1 整数类型</h2><p>TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8、16、24、32、64 位存储空间。它们可以存储的值得范围 -2^(N-1) ~ 2^(N-1) - 1，其中 N 是存储空间的位数。整数类型有可选的 UNSIGNED 属性，表示不允许负数，这样可以提高一倍的正数上限。  </p><p>整数计算一般使用 64 位的 BIGINT 整数。整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如 MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。</p><h2 id="1-2-实数类型"><a href="#1-2-实数类型" class="headerlink" title="1.2 实数类型"></a>1.2 实数类型</h2><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也不支持不精确类型。<br>因为 CPU 不支持对 DECIMAL 的直接计算，所以在 MySQL5.0+ MySQL 服务器自身实现了 DECIMAL 的高精度计算，相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。<br>DECIMAL 的字节存储：每四个字节存储 9 个数字，例：DECIMAL(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节：小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。<br>浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。 FLOAT 使用 4 个字节存储。 DOUBLE 占用 8 个字节。MySQL 使用 DOUBLE 作为内部浮点计算的类型。<br>将结果存储在 BIGINT 里，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。（根据小数的位数乘以相应的倍数）</p><h2 id="1-3-字符串类型"><a href="#1-3-字符串类型" class="headerlink" title="1.3 字符串类型"></a>1.3 字符串类型</h2><h3 id="1-VARCHAR-和-CHAR-类型"><a href="#1-VARCHAR-和-CHAR-类型" class="headerlink" title="1.VARCHAR 和 CHAR 类型"></a>1.VARCHAR 和 CHAR 类型</h3><h4 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h4><p>VARCHAR 类型用于存储可变长字符串，如果 MySQL  表使用 ROW_ FORMAT = FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。<br>VARCHAR 在列最大长度 &lt;=255 字节的时候，额外用 1 个字节用于记录字符串的长度。 例：VARCHAR(10) 的列需要 11 个字节的存储空间。VARCHAR(1000) 的列则需要 1002 个字节，因为需要 2 个字节存储长度信息。<br>MySQL5.0+ 在存储和检索时会保留末尾空格。<br>但是，由于行是变长的，在 UPDATE 时可能使行变得比原来长，这就导致需要额外的工作。<br>另外，InnoDB 可以把过长的 VARCHAR 存储为 BLOB，稍后讨论该问题。</p><h4 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h4><p>CHAR 类型是定长的，MySQL 总是根据定义的字符串长度分配足够的空间。<br>存储 CHAR 值时，MySQL 会删除所有的末尾空格。</p><h4 id="CHAR-VS-VARCHAR"><a href="#CHAR-VS-VARCHAR" class="headerlink" title="CHAR VS VARCHAR"></a>CHAR VS VARCHAR</h4><p>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例：存储密码的 MD5 值，因为这是一个定长的值。<br>对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。<br>对于非常短的值， CHAR(1) 比 VARCHAR(1) 在存储空间上也更有效率（后者需要额外一个字节存储长度）。<br>VARCHAR(100) 和 VARCHAR(200) 虽然在存储空间相同，但是在内存消耗不同，后者更大。尤其在排序和临时表（中间表）时。<br> 摘自：<a href="http://tech.it168.com/a2011/0426/1183/000001183173.shtml" target="_blank" rel="noopener">http://tech.it168.com/a2011/0426/1183/000001183173.shtml</a></p><h3 id="2-BLOB-和-TEXT-类型"><a href="#2-BLOB-和-TEXT-类型" class="headerlink" title="2. BLOB 和 TEXT 类型"></a>2. BLOB 和 TEXT 类型</h3><p>BLOB 采用二进制存储、TEXT 采用字符存储。<br>与其它类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。当其太大时， InnoDB 会使用专门的“外部”存储区域进行存储。此时每个值在行内需要 1~4 个字节存储一个指针，然后再外部存储区域实际的值。<br>排序：MySQL 只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。可以减少 max_sort_length 的值或者使用 ORDER BY SUBSTRING(column, length)。<br>MySQL 不能讲 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。<br>进行 ORDER BY 为了防止临时表过大，可以使用 SUBSTRING(column, length) 进行长度切割。</p><h3 id="3-使用枚举（ENUM）-代替字符串类型"><a href="#3-使用枚举（ENUM）-代替字符串类型" class="headerlink" title="3. 使用枚举（ENUM） 代替字符串类型"></a>3. 使用枚举（ENUM） 代替字符串类型</h3><p>MySQL 在存储枚举时非常紧凑，会根据列表值得数量压缩到一个或者两个字节中。 MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 “数字-字符串”映射关系的“查找表”。<br>在 VARCHAR 与 ENUM 互相 JOIN 关联时，ENUM 与 ENUM 最快。因此如果不是必须和 VARCHAR 列进行关联，那么转换这些列为 ENUM 就是个好主意。这是一个通用的设计实践，在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。</p><h2 id="1-4-日期和时间类型"><a href="#1-4-日期和时间类型" class="headerlink" title="1.4 日期和时间类型"></a>1.4 日期和时间类型</h2><h3 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1.DATETIME"></a>1.DATETIME</h3><p>这个类型能保存大范围的值，精度为秒。使用 8 个字节的存储空间。</p><h3 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2.TIMESTAMP"></a>2.TIMESTAMP</h3><p>保存了从 1970年1月1日~2038年，MySQL 提供了 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数将日期和 Unix 时间戳转换。使用 4 个字节存储。</p><h2 id="1-5-位数据类型"><a href="#1-5-位数据类型" class="headerlink" title="1.5 位数据类型"></a>1.5 位数据类型</h2><h3 id="1-BIT"><a href="#1-BIT" class="headerlink" title="1.BIT"></a>1.BIT</h3><p>尽量少用。</p><h3 id="2-SET"><a href="#2-SET" class="headerlink" title="2.SET"></a>2.SET</h3><p>如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间。缺点是改变列的定义代价较高：需要 ALTER TABLE（这对大表是非常昂贵的操作，但是后面给出了解决方法）。一般来说，也无法再 SET 列上通过索引查找。</p><blockquote><p>在整数列进行按位操作<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;SET @CAN_READ   := 1 &lt;&lt; 0,</span><br><span class="line">&gt;     @CAN_WRITE  := 1 &lt;&lt; 1,</span><br><span class="line">&gt;     @CAN_DELETE := 1 &lt;&lt; 2;</span><br><span class="line">&gt;CREATE TABLE acl (</span><br><span class="line">&gt;     perms TINYINT UNSIGNED NOT NULL DEFAULT 0    </span><br><span class="line">&gt;);</span><br><span class="line">&gt;INSERT INTO acl(perms) VALUES (@CAN_READ+@CAN_DELETE);</span><br><span class="line">&gt;SELECT perms FROM acl WHERE perms &amp; @CAN_READ;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当然，也可以使用代码变量而不是 MySQL 变量。</p></blockquote><h2 id="1-6-选择标识符（identifier）"><a href="#1-6-选择标识符（identifier）" class="headerlink" title="1.6  选择标识符（identifier）"></a>1.6  选择标识符（identifier）</h2><p>标识列与其它值进行比较（例，在关联操作中），或通过标识列寻找其它列。标识列也可能在另外的表中作为外键使用。<br>选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。例， MySQL 在内部使用整数存储 ENUM 和 SET 类型，然后在做比较操作时转换为字符串。<br>在可以满足值得范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。例如，TINYINT 比 INT 少了 3 个字节，但是可能导致很大的性能差异。<br>尽量使用整数。如果存储 UUID 值，用 UNHEX() 函数转换为 16 字节的数字存储，并且存储在一个 BINARY(16) 列中。</p><h2 id="1-7-特殊类型数据"><a href="#1-7-特殊类型数据" class="headerlink" title="1.7 特殊类型数据"></a>1.7 特殊类型数据</h2><p>例，IPv4 地址人们通常使用 VARCHAR(15) 列来存储 IP 地址。然而，它们实际上是 32 位无符号整数，不是字符串。所以应该用无符号整数存储 IP 地址。 MySQL 提供 INET_ATON() 和 INET_NTOA() 函数在这两种表示方法之间转换。</p><h1 id="2-MySQL-schema-设计中的陷阱"><a href="#2-MySQL-schema-设计中的陷阱" class="headerlink" title="2 MySQL schema 设计中的陷阱"></a>2 MySQL schema 设计中的陷阱</h1><h2 id="2-1-太多的列"><a href="#2-1-太多的列" class="headerlink" title="2.1 太多的列"></a>2.1 太多的列</h2><p>MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。列转行的操作代价是非常高的。</p><h2 id="2-2-太多的关联"><a href="#2-2-太多的关联" class="headerlink" title="2.2 太多的关联"></a>2.2 太多的关联</h2><p>阿里手册规定单次关联不能超过 3 张表。</p><h2 id="2-3-全能的枚举"><a href="#2-3-全能的枚举" class="headerlink" title="2.3 全能的枚举"></a>2.3 全能的枚举</h2><p>CREATE TABLE … ( country enum(‘’, ‘0’, ‘1’, … , ‘31’))<br>当需要在枚举列表中增加一个新的国家时就要做一次 ALTER TABLE 操作，在 MySQL5.0- 这是一种阻塞操作，即使在 MySQL5.0+ ，如果不是在列表的末尾增加值也会一样需要 ALTER TABLE。</p><h2 id="2-4-变相的枚举"><a href="#2-4-变相的枚举" class="headerlink" title="2.4 变相的枚举"></a>2.4 变相的枚举</h2><p>枚举列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值的一个或多个值。这会导致混乱。</p><h2 id="2-5-非此发明（Not-Invent-Here）的-NULL"><a href="#2-5-非此发明（Not-Invent-Here）的-NULL" class="headerlink" title="2.5 非此发明（Not Invent Here）的 NULL"></a>2.5 非此发明（Not Invent Here）的 NULL</h2><p>CREATE TABLE … (dt DATETIME NOT NULL DEFAULT ‘0000-00-00 00:00:00’)<br>伪造的全 0 值可能导致很多问题。（可以配置 MySQL 的 SQL_MODE 来禁止不可能的日期，对于新应用这是个非常好的实践经验）。</p><h1 id="3-缓存表和汇总表"><a href="#3-缓存表和汇总表" class="headerlink" title="3 缓存表和汇总表"></a>3 缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。</p><h2 id="3-1-计数器表"><a href="#3-1-计数器表" class="headerlink" title="3.1 计数器表"></a>3.1 计数器表</h2><p>创建一张独立的表存储计数器通常是个好主意。例，有一个计数器表，只有一行数据，记录网站的点击次数：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</span><br><span class="line">    cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>每次点击：<code>UPDATE hit_counter SET cnt = cnt + 1;</code><br>问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex）。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。<br>要获得统计结果：<code>SELECT SUM(cnt) FROM hit_count;</code>。<br>一个常见的需求是每隔一段时间开始一个新的计数器（例，每天一个）。如果需要这么做，则可以再简单地修改一下表设计：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter (</span><br><span class="line">    <span class="keyword">day</span> <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    slot tinyint <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">day</span>, slot)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>在这个场景下，可以不用像前面的例子那样预先生成行，而是<code>ON DUPLICATE KEY UPDATE</code>代替。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> daily_hit_counter(<span class="keyword">day</span>, slot, cnt)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="keyword">CURRENT_DATE</span>, <span class="keyword">RAND</span>() * <span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> cnt = cnt + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果希望减少表的行数，以避免表变得太大，可以写一个周期执行的任务，合并所有结果到 0 号槽，并删除所有其它的槽：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> daily_hit_counter <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="keyword">SUM</span>(cnt) <span class="keyword">AS</span> cnt, <span class="keyword">MIN</span>(slot) <span class="keyword">AS</span> mslot</span><br><span class="line">        <span class="keyword">FROM</span> daily_hit_counter</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br><span class="line">    ) <span class="keyword">AS</span> x <span class="keyword">USING</span>(<span class="keyword">day</span>)</span><br><span class="line"><span class="keyword">SET</span> c.cnt  = <span class="keyword">IF</span>(c.slot = x.mslot, x.cnt, <span class="number">0</span>),</span><br><span class="line">    c.slot = <span class="keyword">IF</span>(c.slot = x.mslot, <span class="number">0</span>, c.slot); </span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> daily_hit_counter <span class="keyword">WHERE</span> slot &lt;&gt; <span class="number">0</span> <span class="keyword">AND</span> cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="4-加快-ALTER-TABLE-操作的速度"><a href="#4-加快-ALTER-TABLE-操作的速度" class="headerlink" title="4 加快 ALTER TABLE 操作的速度"></a>4 加快 ALTER TABLE 操作的速度</h1><p>假如要修改电影的默认租赁期限，从三天改到五天，下面是很慢的方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film </span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> rental_duration tinyint(<span class="number">3</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><code>show status</code>语句显示这个语句做了 1000 次读和 1000 次插入操作。换句话说，它拷贝了整张表到一张新表。<br>理论上，MySQL 可以跳过创建新表的步骤，即直接修改 .frm 文件而不设计表数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> film</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> rental_duraion <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ol><li>避免过度设计</li><li>使用小而简单的合适数据类型，避免使用 NULL 值</li><li>关联标识符尽量使用相同的数据类型</li><li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存</li><li>尽量使用整型定义标识列</li><li>小心使用 ENUM 和 SET</li><li><code>ALTER TABLE</code>在大部分情况下都会锁表并且重建整张表。建议先在备库执行<code>ALTER</code>完成后将其切换为主库</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 分布式服务框架原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal 的心得</title>
      <link href="/2017/12/22/tech/threadlocal_1.html/"/>
      <url>/2017/12/22/tech/threadlocal_1.html/</url>
      
        <content type="html"><![CDATA[<p>在《架构探险——从零开始架构》中，第四章的自己实现 ThreadLocal 感悟：<br>ThreadLocal 中虽然使用了 Map 进行保存线程变量，但是为了防止引入锁（Map 的多线程访问）影响性能，从而使用让不同的 Thread 保存不同的 Map（ThreadLoaclMap）实例，这样不同的Thread 有不同的 ThreadLocalMap 实例，就不用考虑锁的问题。<br>另外为了避免内存泄漏、回收不及时等问题，从而让 ThreadLocalMap 的 key 使用弱引用。<br>同时，为了保证当 key 为 null 时，value 无法正常释放时，在每次 set 时，都会遍历 key ，当 key 为 null 则会执行 replaceStaleEntry()，即将 key 为 null 的 value 值也置为 null，从而来让其回收。<br>这里讲解更加详细：<a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">http://www.jasongj.com/java/threadlocal/</a><br>这是原理：<img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/others/threadlocal.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> java拾遗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《MyBatis 从入门到精通》总结</title>
      <link href="/2017/12/18/tech/mybatis0to1.html/"/>
      <url>/2017/12/18/tech/mybatis0to1.html/</url>
      
        <content type="html"><![CDATA[<p>笔记总结+源码：<a href="https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1" target="_blank" rel="noopener">https://github.com/LiWenGu/MySourceCode/tree/master/mybatis0to1</a><br>在前七章都打了对应的标签，可以通过 git checkout来。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/mybatis0to1/summary.png" alt><br>总结就是，将 sql 语句从代码中抽离出来，通过 xml 的配置来实现单表、多表的映射，最后通过动态代理来执行方法，很强的解耦性。<br>把 SQL 放在了 XML 中，然后用一些判断来实现动态 SQL ，最后通过 SqlSession 、SqlSessionFacotry 的生命周期来绑定一级、二级缓存。<br>不学之前感觉很神奇，学完之后也就那么回事，不过还是要多学学基础，例如读取配置、缓存、一级动态代理等。</p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>电影《帕丁顿熊》有感</title>
      <link href="/2017/12/13/talker/paddington.html/"/>
      <url>/2017/12/13/talker/paddington.html/</url>
      
        <content type="html"><![CDATA[<p>Please look after this bear, thank you.</p><p>联想最近的北京大兴事件，有点苦涩，现代人的城市，忘记如何对待一个流浪的人。  </p><p>每个城市都会有着提着行李箱，下着雨，在站台上的外乡人，唯一的区别是如何对待他们。  </p><hr><p>城市应该有它自己的包容心。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十三、PGP——密码技术的完美组合</title>
      <link href="/2017/12/07/graphic2cryptography/13.html/"/>
      <url>/2017/12/07/graphic2cryptography/13.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>本章中，将以密码软件 PGP（Pretty Good Privacy）为题材，思考一下将前面章节中学习的密码技术进行组合的方法。</p><h1 id="2-PGP简介"><a href="#2-PGP简介" class="headerlink" title="2 PGP简介"></a>2 PGP简介</h1><p>PGP 是 1990 年编写的密码软件。</p><h2 id="2-1-PGP-的功能"><a href="#2-1-PGP-的功能" class="headerlink" title="2.1 PGP 的功能"></a>2.1 PGP 的功能</h2><h3 id="1-对称密码"><a href="#1-对称密码" class="headerlink" title="1.对称密码"></a>1.对称密码</h3><h3 id="2-公钥密码"><a href="#2-公钥密码" class="headerlink" title="2.公钥密码"></a>2.公钥密码</h3><h3 id="3-数字签名"><a href="#3-数字签名" class="headerlink" title="3.数字签名"></a>3.数字签名</h3><h3 id="4-单向散列函数"><a href="#4-单向散列函数" class="headerlink" title="4.单向散列函数"></a>4.单向散列函数</h3><h3 id="5-证书"><a href="#5-证书" class="headerlink" title="5.证书"></a>5.证书</h3><h3 id="6-压缩"><a href="#6-压缩" class="headerlink" title="6.压缩"></a>6.压缩</h3><h3 id="7-文本数据"><a href="#7-文本数据" class="headerlink" title="7.文本数据"></a>7.文本数据</h3><h3 id="8-大文件的拆分和平和"><a href="#8-大文件的拆分和平和" class="headerlink" title="8.大文件的拆分和平和"></a>8.大文件的拆分和平和</h3><h3 id="9-钥匙串管理"><a href="#9-钥匙串管理" class="headerlink" title="9.钥匙串管理"></a>9.钥匙串管理</h3><h1 id="3-生成秘钥对"><a href="#3-生成秘钥对" class="headerlink" title="3 生成秘钥对"></a>3 生成秘钥对</h1><h1 id="4-加密与解密"><a href="#4-加密与解密" class="headerlink" title="4 加密与解密"></a>4 加密与解密</h1><h1 id="5-生成和验证数字签名"><a href="#5-生成和验证数字签名" class="headerlink" title="5 生成和验证数字签名"></a>5 生成和验证数字签名</h1><h1 id="6-生成数字签名并加密以及解密并验证数字签名"><a href="#6-生成数字签名并加密以及解密并验证数字签名" class="headerlink" title="6 生成数字签名并加密以及解密并验证数字签名"></a>6 生成数字签名并加密以及解密并验证数字签名</h1><h1 id="7-信任网"><a href="#7-信任网" class="headerlink" title="7 信任网"></a>7 信任网</h1><h2 id="7-1-公钥合法性"><a href="#7-1-公钥合法性" class="headerlink" title="7.1 公钥合法性"></a>7.1 公钥合法性</h2><p>在使用 PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换（参 5.7.4节）。<br>第十章介绍的证书就是确认公钥合法性的方法之一。证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。<br>然而，PGP 中却没有使用认证机构，而是采用了一种叫<strong>信任网</strong>（web of trust）的方法。在这种方法中， PGP 用户会<strong>互相对对方的公钥进行数字签名</strong>。<br>信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。<br>下面介绍 PGP 的信任网是如何建立起来的。</p><h3 id="1-场景1：通过自己的数字签名进行确认"><a href="#1-场景1：通过自己的数字签名进行确认" class="headerlink" title="1.场景1：通过自己的数字签名进行确认"></a>1.场景1：通过自己的数字签名进行确认</h3><p>Alice 和 Bob 约会，在告别的时候， Bob 给了 Alice 一张存储卡，并说“这是我的公钥”。<br>Alice 回到家中，从存储卡中取出 Bob 的公钥，并存放到自己所使用的 PGP 的公钥串中（导入公钥）。由于 Alice 确信刚刚导入的公钥确实是属于 Bob 本人的，因此 Alice 对这个公钥加上了自己的数字签名。<br>对 Bob 的公钥加上数字签名，就相当于 Alice 生命“这个公钥属于 Bob 本人（即这个公钥是合法的）”。<br>随后，Alice 收到了来自 Bob 的邮件，由于这封邮件带有 Bob 的数字签名，因此 Alice 想用 PGP 来验证 Bob 的数字签名。 PGP 将执行下面这些操作：  </p><ol><li>为了验证 Bob 的数字签名， PGP 需要从 Alice 的公钥串中寻找 Bob 的公钥。</li><li>Alice 的公钥串中包含 Bob 的公钥，因为前几天约会之后 Alice 导入了 Bob 的公钥。</li><li>PGP 发现 Bob 的公钥带有 Alice 的数字签名。</li><li>为了验证 Alice 的数字签名，PGP 需要从 Alice 的公钥串中寻找 Alice 自己的公钥。</li><li>PGP 使用 Alice 的公钥对 Bob 的公钥上的 Alice 的数字签名进行验证。如果验证成功，则可以确认这的确就是 Bob 的公钥。</li><li>PGP 使用合法的 Bob 的公钥对邮件上附带的 Bob 的数字签名进行验证。</li></ol><h3 id="2-场景2：通过自己完全信任的人的数字签名进行确认"><a href="#2-场景2：通过自己完全信任的人的数字签名进行确认" class="headerlink" title="2.场景2：通过自己完全信任的人的数字签名进行确认"></a>2.场景2：通过自己完全信任的人的数字签名进行确认</h3><p>Alice 有一个叫 Trent 的男朋友。在 Alice 的公钥串中，也包含带有 Alice 的数字签名的 Trent 的公钥。 Alice 非常信任 Trent ，她想：<strong>经过他签名的公钥一定是合法的</strong>。<br>假设 Alice 收到了一封来自 Carrol 的邮件</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十二、随机数——不可预测性的源泉</title>
      <link href="/2017/12/06/graphic2cryptography/12.html/"/>
      <url>/2017/12/06/graphic2cryptography/12.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-骡子的锁匠铺"><a href="#1-骡子的锁匠铺" class="headerlink" title="1 骡子的锁匠铺"></a>1 骡子的锁匠铺</h1><p>很久很久之前，骡子开了一家锁匠铺，他说：“我做的锁头很坚固，小偷绝对打不开。”因此动物村里所有的动物都为自己的房子装上了骡子做的锁。<br>骡子做的锁确实很坚固，但是每把锁头上用的钥匙居然都是同一个形状的。因此小偷只要得到了一栋房子的钥匙，就可以打开所有房子的锁了。<br>教训：坚固的锁头固然重要，但不可预测的钥匙更加重要。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><ul><li>使用随机数的密码技术</li><li>随机数的性质</li><li>伪随机数生成器</li><li>具体的伪随机数生成器</li><li>对伪随机数生成器的攻击</li></ul><h1 id="3-使用随机数的密码技术"><a href="#3-使用随机数的密码技术" class="headerlink" title="3 使用随机数的密码技术"></a>3 使用随机数的密码技术</h1><h2 id="3-1-随机数是干什么的"><a href="#3-1-随机数是干什么的" class="headerlink" title="3.1 随机数是干什么的"></a>3.1 随机数是干什么的</h2><ol><li>生成秘钥：用于对称密码和消息认证码。</li><li>生成密钥对：用于公钥密码和数字签名。</li><li>生成初始化向量（IV）：用于分组密码的 CBC、CFC 和 OFB 模式。</li><li>生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式等。</li><li>生成盐：用于基于口令的密码（PBE）等。</li></ol><p>在这里，请大家记住<strong>为了不让攻击者看穿而使用随机数</strong>这一观点，因为“无法看穿”，及不可预测性，正是本章的主题。</p><h1 id="4-随机数的性质"><a href="#4-随机数的性质" class="headerlink" title="4 随机数的性质"></a>4 随机数的性质</h1><h2 id="4-1-对随机数的性质分类"><a href="#4-1-对随机数的性质分类" class="headerlink" title="4.1 对随机数的性质分类"></a>4.1 对随机数的性质分类</h2><ol><li>随机性：不存在统计学偏差，是完全杂乱的数列。</li><li>不可预测性：不能从过去的数列推测出下一个出现的数。</li><li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列。</li></ol><p>为了方便起见，将上述三个性质按顺序分别命名为“弱伪随机数”、“强伪随机数”和“真随机数”。<br>||随机性|不可预测性|不可重现性||<br>|:-:|:-:|:-:|:-:|:-:|<br>|弱伪随机数|✔️|✘|✘|只具备随机性|<br>|强伪随机数|✔️|✔️|✘|具备不可预测性|<br>|真随机数|✔️|✔️|✔️|具备不可重现性|</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_1.png" alt></p><h2 id="4-2-随机性"><a href="#4-2-随机性" class="headerlink" title="4.2 随机性"></a>4.2 随机性</h2><p>杂乱无章并不代表不会被看穿，因此本书中将只具备随机性的伪随机数称为“弱伪随机数”。</p><h2 id="4-3-不可预测性"><a href="#4-3-不可预测性" class="headerlink" title="4.3 不可预测性"></a>4.3 不可预测性</h2><p>不可预测性（unpredictability），是一种“不可能事先说中”的性质，及不可预测性。即，攻击者在知道过去生成的为随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。</p><h2 id="4-4-不可重现性"><a href="#4-4-不可重现性" class="headerlink" title="4.4 不可重现性"></a>4.4 不可重现性</h2><p>即，无法重现和某一随机数列完全相同的数列的性质。如果除了将随机数列本身保存下来意外，没有其它方法能够重现该数列，则我们就说该随机数列具备不可重现性。<br>要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。</p><h1 id="5-伪随机数生成器"><a href="#5-伪随机数生成器" class="headerlink" title="5 伪随机数生成器"></a>5 伪随机数生成器</h1><p>仅仅靠软件无法生成真随机数，因此要加上一个“伪”。</p><h2 id="5-1-伪随机数生成器的结构"><a href="#5-1-伪随机数生成器的结构" class="headerlink" title="5.1 伪随机数生成器的结构"></a>5.1 伪随机数生成器的结构</h2><p>伪随机数生成器具有“内部状态”，并根据外部输入的“种子”来生成伪随机数列。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_2.png" alt>  </p><h3 id="1-伪随机数生成器的内部状态"><a href="#1-伪随机数生成器的内部状态" class="headerlink" title="1.伪随机数生成器的内部状态"></a>1.伪随机数生成器的内部状态</h3><p>伪随机数生成器的内部状态，是指伪随机数生成器所管理的内存中的数值。伪随机数生成器会根据内存中的数值进行计算，并将计算的结果作为伪随机数输出。随后，为了响应下一个伪随机数请求。伪随机数生成器会改变自己的内部状态。</p><h3 id="2-伪随机数生成器的种子"><a href="#2-伪随机数生成器的种子" class="headerlink" title="2.伪随机数生成器的种子"></a>2.伪随机数生成器的种子</h3><p>伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_3.png" alt></p><h1 id="6-具体的伪随机数生成器"><a href="#6-具体的伪随机数生成器" class="headerlink" title="6 具体的伪随机数生成器"></a>6 具体的伪随机数生成器</h1><h2 id="6-1-杂乱的方法"><a href="#6-1-杂乱的方法" class="headerlink" title="6.1 杂乱的方法"></a>6.1 杂乱的方法</h2><p>用一个程序员都不懂的算法生成，但是这是错误的，不能用于密码技术。因为，周期太短，使用复杂算法所生成的数列大多数都会具有很短的周期（即短数列的不断重复）。另外则是，无法判断所生成的随机数是否具备不可预测性。</p><h2 id="6-2-线性同余法"><a href="#6-2-线性同余法" class="headerlink" title="6.2 线性同余法"></a>6.2 线性同余法</h2><p>线性同余法（linear congruential method）是一种使用很广泛的伪随机数生成器算法。然而，它并不能用于密码技术。<br>A、C、M 都是常量，且 A 和 C 需要小于 M。接下来，根据种子 R0 计算下一个伪随机数 R1：<br>R1 = （A <em> R0 + C） mod M。<br>当前得到的伪随机数即是下一个伪随机数的种子：<br>Rn+1 = (A </em> Rn + C) mod M。<br>但是这具有周期性，而且可以通过上一个种子得到下一个伪随机数。因此不具备不可预测性，不能将线性同余法用于密码技术。<br>很多伪随机数生成器的库函数都是采用线性同余法编写的。包括 C 语言的库函数 rand。 以及 java 的 java.util.Random 类等。</p><h2 id="6-3-单向散列函数法"><a href="#6-3-单向散列函数法" class="headerlink" title="6.3 单向散列函数法"></a>6.3 单向散列函数法</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_4.png" alt><br>攻击者要预测下一个伪随机数，需要知道计数器的当前值，以及，破解单向散列函数的单向性。利用了单向散列函数的单向性。</p><h2 id="6-4-密码法"><a href="#6-4-密码法" class="headerlink" title="6.4 密码法"></a>6.4 密码法</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/12_5.png" alt><br>密码的机密性是支撑伪随机数生成器不可预测性的基础。</p><h1 id="7-对伪随机数生成器的攻击"><a href="#7-对伪随机数生成器的攻击" class="headerlink" title="7 对伪随机数生成器的攻击"></a>7 对伪随机数生成器的攻击</h1><h2 id="7-1-对种子进行攻击"><a href="#7-1-对种子进行攻击" class="headerlink" title="7.1 对种子进行攻击"></a>7.1 对种子进行攻击</h2><h2 id="7-2-对随机数池进行攻击"><a href="#7-2-对随机数池进行攻击" class="headerlink" title="7.2 对随机数池进行攻击"></a>7.2 对随机数池进行攻击</h2><p>一般不会到了需要的时候才当场生成真随机数，而是会事先在一个名为<strong>随机数池</strong>（random pool）的文件中积累随机比特序列。当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。这是不能被攻击所知道的。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>由于密码技术的伪随机数生成器，需要使用单向散列函数和密码等技术来确保不可预测性。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><ol><li>伪随机数的种子需要对攻击者保密。</li><li>线性同余法可以作为用于密码的伪随机数生成器。</li><li>具备随机性的伪随机数生成器不一定具备不可预测性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>去中心化</title>
      <link href="/2017/12/05/talker/decentralization_1.html/"/>
      <url>/2017/12/05/talker/decentralization_1.html/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为区块链存在的主要理由，去中心的定义却含糊不清，这需要澄清一下。</p></blockquote><hr><p>编者按：去中心化是个热词。但是究竟什么是去中心化却存在很多异议。为此比特币改良版在线系统Ethereum的创始人之一Vitalik Buterin从结构、政治和逻辑三个维度剖析了去中心化的含义。  </p><p>“去中心化”是在加密经济学领域使用最频繁的词之一 ，而且往往被视为区块链存在的全部理由所在，但这个词可能也是定义最糟糕的一个。仅仅为了尝试实现去中心化的这一主要目标，以及为了保护和改善它，已经投入了成千上万小时的研究，数十亿美元的哈希能力。而且当讨论开始出现火药味时，某一协议（或者协议扩展）的支持者把对方提案说成“中心化”作为终极大招使出来实在是太过常见的事情了。  </p><p>但对于这个词到底是什么含义往往会出现很多的困惑。比方说，我们可以看看下面这个完全毫无帮助但是却不幸地太过常见的示意图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_1.png" alt>  </p><p>现在再来看看Quora上面有关“<a href="https://www.quora.com/Whats-the-difference-between-distributed-and-decentralized-in-Bitcoin-land" target="_blank" rel="noopener">分布式和去中心化的区别</a>”这一问题的两个回答。第一个回答基本上是对上面这张图的鹦鹉学舌，而第二个回答则要大相径庭，声称“分布式意味着并非所有的交易处理都是在同一个地方完成的，”而“去中心化意味着单个实体不能控制完所有的处理。”与此同时，在Ethereum stack exchange上面得票率最高的回答也给出了类似的<a href="https://ethereum.stackexchange.com/questions/7812/question-on-the-terms-distributed-and-decentralised" target="_blank" rel="noopener">图解</a>，但是“去中心化”和“分布式”这两个词却交换了位置！显然，这里有做出澄清的必要。</p><h2 id="三种类型的去中心化"><a href="#三种类型的去中心化" class="headerlink" title="三种类型的去中心化"></a>三种类型的去中心化</h2><p>当大家在讨论软件去中心化的时候，实际上往往有3种不同维度的中心化/去中心化。虽然在一些情况下这些中心化形式往往缺一不可，但通常它们还是彼此相对独立的。这几个维度是：  </p><ol><li>结构（去）中心化——系统由多少物理计算机组成？该系统可容忍这些计算机多少台同时发生崩溃？</li><li>政治（去）中心化——有多少个人或者组织最终控制着组成该系统的那些计算机？</li><li>逻辑（去）中心化——该系统展现和维护的界面和数据结构看起来更像是单一的一体式对象呢，还是无定形的一大群？或者用这个问题来启发一下：如果包括提供商和用户在内把你的系统一分为二的话，那两部分是不是还可以继续作为独立单元完全运作？</li></ol><p>我们可以把这三个维度用下面这张表来表示：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/reprint/zz_1_2.png" alt>  </p><p>要指出的是这些设定还是非常粗糙的，还有待商榷。但我们先稍微过一下这几种情况：  </p><ul><li>传统企业是政治中心化（有一个CEO），结构中心化（一个总部）以及逻辑中心化的（并不能真正一分为二）。</li><li>民法依赖于一个中心化的法律制定实体，而习惯法是基于许多独立判决的基础上制订的。民法仍然有一些结构上的去中心化，因为有很多法庭仍然是由很大的自由裁量权的，但习惯法的自由裁量权更大。这两个都是逻辑中心化的。</li><li>语言是逻辑去中心化的；Alice和Bob之间讲的英语与Charlie和David之间讲的英语完全不需要一致。语言并不需要一个中心化的基础设施存在，而英语的语法规则也不是由一个人创建或控制的（世界语则是源自Ludwig Zamenhof,的发明，尽管其现在的功能更像是一门无人监管、逐渐演变的活语言）。</li><li>BitTorrent在逻辑上是去中心化的，类似于英语的样子。内容交付网络也类似，但却是被一个公司所控制。</li><li>区块链是政治去中心化（没人控制区块链）、结构去中心化（没有基础设施性的中心失败点）的，但是在逻辑上是中心化的（有一个公认的状态，整个系统行为就像一个计算机一样）。  </li></ul><p>很多时候当大家讨论区块链的优点时，他们会描述拥有“一个集中数据库”的便利性；这种中心化是逻辑上的中心化，而且是一种无疑从很多方面来说都是有好处的中心化（尽管IPFS的Juan Benet也希望在可能的情况下推进逻辑去中心化，因为逻辑去中心化系统往往擅长在网络分区中存活，在连接性糟糕的世界各地都工作得很好等；参见Scuttlebot的这篇明确呼吁逻辑去中心化的<a href="http://scuttlebot.io/more/articles/design-challenge-avoid-centralization-and-singletons.html" target="_blank" rel="noopener">文章</a>）。  </p><p>结构中心化往往导致政治中心化，尽管未必会如此——在正式的民主中，政治家以某种实体的治理形式会面和投票，但这种议事厅的维护者最终并不能因此从中获得任何实质性的决策权。而在一个计算化的系统中，结构上去中心化但政治上却是中心化的情况是有可能发生的——如果有一个在线社区出于便利考虑利用了中心化的论坛，但是却没有一个广泛公认的社会契约，比如约定如果论坛所有者出现恶意行为则每个人都会跑到另一个论坛去。  </p><p>逻辑中心化会导致结构去中心化更加困难，但并非不可能——看看去中心化的舆论网络已被证明有效，但却比维护BitTorrent更加困难就知道了。逻辑中心化也使得政治去中心化更加困难——在逻辑中心化的系统中，你是很难仅仅靠“和平共存”来解决争端的。</p><h2 id="去中心化的三个原因"><a href="#去中心化的三个原因" class="headerlink" title="去中心化的三个原因"></a>去中心化的三个原因</h2><p>接下来的问题就是为什么去中心化会有用？这通常会有几种观点：  </p><ul><li>可容错——去中心化的系统意外失效的可能性更低，因为它们依靠于许多独立的组件，这些组件不大可能全都失效。</li><li><p>抗攻击性——对去中心化系统的攻击、摧毁或者操纵的代价要高很多，因为它们缺乏敏感的中心点，对这些中心点发起攻击的成本要比对周边系统发动攻击的经济规模小得多。</p></li><li><p>抗共谋——去中心化系统的参与者串通行动，以牺牲其他参与者的利益谋取自身利益的难度要大得多，而企业和政府的领导层就可以串通起来谋求自身利益却损害了不那么协调的市民、客户、员工以及普罗大众的利益。</p></li></ul><p>这三种观点都是重要的，也是合理的，但如果你开始思考各自应该采用什么协议时这三种观点都会导致一些有趣但不同的结论。如果感兴趣的可以到<a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274" target="_blank" rel="noopener">原文</a>了解进一步的讨论。</p><hr><p>此文转载自：<a href="https://36kr.com/p/5063699.html" target="_blank" rel="noopener">&lt;去中心化的三个维度_36氪&gt;</a></p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 去中心化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十四、SSL/TLS-为了更安全的通信</title>
      <link href="/2017/12/04/graphic2cryptography/14.html/"/>
      <url>/2017/12/04/graphic2cryptography/14.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>SSL（Secure Socket Layer）与TLS(Transport Layer Security)是不同的，TLS 相当于是 SSL 的后续版本。</p><h1 id="2-什么是-SSL-TLS"><a href="#2-什么是-SSL-TLS" class="headerlink" title="2 什么是 SSL/TLS"></a>2 什么是 SSL/TLS</h1><h2 id="2-1-客户端与服务器"><a href="#2-1-客户端与服务器" class="headerlink" title="2.1 客户端与服务器"></a>2.1 客户端与服务器</h2><p>将 Alice 和 Bob 书店的通信过程整理如下图（不使用SSL/TLS）：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_1.png" alt><br>Alice 向 Bob 书店发送信用卡号使用 HTTP 来完成。 Alice 输入信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为 HTTP 请求发送给服务器。服务器则会将“生成订单”的网页作为 HTTP 响应返回给客户端。  </p><p>不过，如果直接发送请求的话，信用卡号就很可能被窃听。</p><h2 id="2-2-用-SSL-TLS-承载-HTTP"><a href="#2-2-用-SSL-TLS-承载-HTTP" class="headerlink" title="2.2 用 SSL/TLS 承载 HTTP"></a>2.2 用 SSL/TLS 承载 HTTP</h2><p>当 Web 浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。使用 SSL/TLS 作为对通信进行加密的协议，然后在此之上承载 HTTP。通过将两种协议进行叠加，我们就可以对 HTTP 的通信（请求和响应）进行加密，从而防止窃听。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_2.png" alt></p><h2 id="2-3-SSL-TLS-的工作"><a href="#2-3-SSL-TLS-的工作" class="headerlink" title="2.3 SSL/TLS 的工作"></a>2.3 SSL/TLS 的工作</h2><p>进行安全的通信，我们有几个必须要解决的问题：  </p><ol><li>Alice 的信用卡号和地址在发送到 Bob 书店的过程中不能被窃听。</li><li>Alice 的信用卡号和地址在发送到 Bob 书店的过程终不能被篡改。</li><li>确认通信对方的 Web 服务器是真正的 Bob 书店。</li></ol><p>在这里，1 是机密性问题，2 是完整性的问题， 3 则是认证的问题。<br>要解决这些问题，让我们在密码学家的工具箱中找一找：<br>要确保机密性，可以使用对称密码。由于对称密码的秘钥不能被攻击者预测，因此我们使用伪随机数生成器来生成秘钥。若要将对称密码的秘钥发送给通信对象，可以使用公钥密码或者 Diffie-Hellman 秘钥交换。<br>要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。<br>要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。<br>好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TSL 协议其实就扮演了这样一种框架的角色。</p><h2 id="2-4-SSL-TLS-也可以保护其它的协议"><a href="#2-4-SSL-TLS-也可以保护其它的协议" class="headerlink" title="2.4 SSL/TLS 也可以保护其它的协议"></a>2.4 SSL/TLS 也可以保护其它的协议</h2><p>刚刚我们提到用 SSL/TLS 承载 HTTP 通信，这是因为 HTTP 是一种很常见的协议。其实 SSL/TSL 上面不仅可以承载 HTTP，还可以承载其它很多协议。例如，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接收邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TSL 进行承载。在这样的情况下， SSL/TSL 就可以对收发的邮件进行保护。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_3.png" alt></p><h2 id="2-5-密码套件"><a href="#2-5-密码套件" class="headerlink" title="2.5 密码套件"></a>2.5 密码套件</h2><p>SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。也就是说，如果发现现在所使用的某个密码技术存在弱点，那么只要将这一部分进行替换就可以了。<br>尽管如此，也并不是说所有的组件都可以自由选择。由于实际进行对话的客户端和服务器必须使用相同的密码技术才能进行通信，因此如果选择过于自由，就难以确保整体的兼容性。为此， SSL/TSL 就事先搭配好饭盒一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为<strong>密码套件</strong>（cipher suite）。</p><h2 id="2-6-SSL-与-TLS-的区别"><a href="#2-6-SSL-与-TLS-的区别" class="headerlink" title="2.6 SSL 与 TLS 的区别"></a>2.6 SSL 与 TLS 的区别</h2><p>SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议。而 TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL3.0 的基础上设计的协议，在 1999 年作为 RFC2246 发布的 TLS1.0 ，实际上相当于 SSL3.1 。</p><h1 id="3-使用-SSL-TLS-进行通信"><a href="#3-使用-SSL-TLS-进行通信" class="headerlink" title="3 使用 SSL/TLS 进行通信"></a>3 使用 SSL/TLS 进行通信</h1><p>下面介绍使用 SSL/TLS 进行通信的步骤。本节内容是基于 TLS1.0 编写的，因此直接写作 TLS。</p><h2 id="3-1-层次化的协议"><a href="#3-1-层次化的协议" class="headerlink" title="3.1 层次化的协议"></a>3.1 层次化的协议</h2><p>TLS 协议是由“TLS记录协议”（TLS record protocol）和“TLS握手协议”（TLS handshake protocol）这两层协议叠加而成的。位于底层的 TLS记录协议负责进行加密，而位于上层的 TLS握手协议则负责除加密以为的其它各种操作。上层的 TLS握手协议又可以分为 4 个子协议。TLS协议的层次结构如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_4.png" alt><br>下面简单介绍一下其中各个协议的功能</p><h3 id="1-TLS记录协议"><a href="#1-TLS记录协议" class="headerlink" title="1.TLS记录协议"></a>1.TLS记录协议</h3><p>TLS记录协议位于 TLS握手协议的下层，是负责使用对称密码对消息进行加密通信的部分。<br>TLS记录协议中使用了对称密码和消息认证码，但是具体的算法和共享秘钥则是通过握手协议在服务器和客户端之间协商决定的。</p><h3 id="2-TLS握手协议"><a href="#2-TLS握手协议" class="headerlink" title="2.TLS握手协议"></a>2.TLS握手协议</h3><p>TLS 握手协议分为下列 4 个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议。</p><h4 id="2-1-握手协议"><a href="#2-1-握手协议" class="headerlink" title="2-1 握手协议"></a>2-1 握手协议</h4><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责在客户端和服务器之间协商决定密码算法和共享秘钥。基于证书的认证操作也是在这个协议中完成的。它是 4 个子协议中最复杂的一个。这个协议大致相当于下面这段对话：<br>客户端：“你好。我能够理解额密码套件由 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？”<br>服务器：“你好。那么我们用 RSA/3DES 来进行通信吧，这是我的证书。”<br>在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。</p><h4 id="2-2-密码规格变更协议"><a href="#2-2-密码规格变更协议" class="headerlink" title="2-2 密码规格变更协议"></a>2-2 密码规格变更协议</h4><p><strong>密码规格变更协议</strong>是 TLS握手协议的一部分，负责向通信对象传达变更密码方式的信号。简单地说，就跟向对方喊“1、2、3！”差不多。<br>这个协议所发送的消息，大致相当于下面的对话：<br>客户端：“好，我们按照刚才的约定切换密码吧。1、2、3！”<br>当协议中途发生错误时，就会通过下面的警告协议传达给对方。</p><h4 id="2-3-警告协议"><a href="#2-3-警告协议" class="headerlink" title="2-3 警告协议"></a>2-3 警告协议</h4><p><strong>警告协议</strong>是 TLS握手协议的一部分。警告协议负责在发生错误时将错误传达给对方。<br>这个协议所发送的消息，大致相当于下面的对话：<br>服务器：“刚才的消息无法正确解密哦！”<br>如果没有发生错误，则会使用下面的应用数据协议来进行通信。</p><h4 id="2-4-应用数据协议"><a href="#2-4-应用数据协议" class="headerlink" title="2-4 应用数据协议"></a>2-4 应用数据协议</h4><p><strong>应用数据协议</strong>是 TLS 握手协议的一部分。应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。<br>下面我们按照相同的顺序，更加详细地介绍一下 TLS协议。</p><h2 id="3-2-TLS记录协议"><a href="#3-2-TLS记录协议" class="headerlink" title="3.2 TLS记录协议"></a>3.2 TLS记录协议</h2><p><strong>TLS记录协议</strong>负责消息的压缩、加密以及数据的认证，其处理过程如下：  </p><ol><li>消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需与通信对象协商决定。</li><li>经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段编号。单向散列函数的算法，以及消息认证码所使用的共享秘钥都需要与通信对象协商决定。</li><li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC模式。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS记录协议所承载的 4 个子协议的其中之一。</li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_5.png" alt></p><h2 id="3-3-TLS握手协议"><a href="#3-3-TLS握手协议" class="headerlink" title="3.3 TLS握手协议"></a>3.3 TLS握手协议</h2><h3 id="1-握手协议"><a href="#1-握手协议" class="headerlink" title="1.握手协议"></a>1.握手协议</h3><p><strong>握手协议</strong>是 TLS握手协议的一部分，负责生成共享秘钥以及交换证书。其中，生成共享秘钥是为了进行密码通信，交换证书是为了通信双方互相进行认证。<br>握手协议这一名乘中的“握手”（handshake），是服务器和客户端在密码通信之前交换一些必要信息这一过程的比喻。<br>由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 所窃听，因此，在这一过程中必须使用公钥密码或者 Diffie-Hellman 秘钥交换。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_6.png" alt><br>下面我们来详细讲解握手协议中所交换的消息。</p><h3 id="2-密码规格变更协议"><a href="#2-密码规格变更协议" class="headerlink" title="2.密码规格变更协议"></a>2.密码规格变更协议</h3><p>TLS 的密码规格变更协议（change cipher spec protocol）是 TLS握手协议的一部分，用于密码切换的同步。<br>那么为什么这个协议不叫密码规格开始协议，而叫密码规格变更协议呢？这是因为即便在密码通信开始之后，客户端和服务器也可以通过重新握手来再次改变密码套件。也就是说，在最开始的时候，客户端和服务器是使用“不加密”这一密码套件进行通信的，因此通信内容没有进行加密。</p><h3 id="3-警告协议"><a href="#3-警告协议" class="headerlink" title="3.警告协议"></a>3.警告协议</h3><p>TLS 的警告协议（alert protocol）是 TLS握手协议的一部分，用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。</p><h3 id="4-应用数据协议"><a href="#4-应用数据协议" class="headerlink" title="4.应用数据协议"></a>4.应用数据协议</h3><p><strong>应用数据协议</strong>是 TLS握手协议的一部分，用于和通信对象之间传送应用数据。<br>当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。</p><h2 id="3-4-主密码"><a href="#3-4-主密码" class="headerlink" title="3.4 主密码"></a>3.4 主密码</h2><p>主密码是 TLS 客户端和服务器之间协商出来的一个密码的数值。这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。<br>主密码是根据：预备主密码、客户端随机数、服务器随机数计算出来的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_7.png" alt></p><h2 id="3-5-TLS-中使用的密码技术小结"><a href="#3-5-TLS-中使用的密码技术小结" class="headerlink" title="3.5 TLS 中使用的密码技术小结"></a>3.5 TLS 中使用的密码技术小结</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/14_8.png" alt></p><h1 id="4-对-SSL-TLS-的攻击"><a href="#4-对-SSL-TLS-的攻击" class="headerlink" title="4 对 SSL/TLS 的攻击"></a>4 对 SSL/TLS 的攻击</h1><h2 id="4-1-对各个密码技术的攻击"><a href="#4-1-对各个密码技术的攻击" class="headerlink" title="4.1 对各个密码技术的攻击"></a>4.1 对各个密码技术的攻击</h2><p>针对 SSL/TLS 中使用的各个密码技术的攻击，会直接成为对 SSL/TLS 的攻击。例如，如果能够找到 SSL/TLS 中使用的对称密码的弱点，就相当于找到了 SSL/TLS 通信机密性的弱点。<br>然而， SSL/TLS 作为框架的特性也正是在这里能够得以体现。 SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。这就好像一台机器的某个零件损坏时，只要更换这个损坏的零件就可以了。</p><h2 id="4-2-对伪随机数生成器的攻击"><a href="#4-2-对伪随机数生成器的攻击" class="headerlink" title="4.2 对伪随机数生成器的攻击"></a>4.2 对伪随机数生成器的攻击</h2><p>只要生成伪随机数生成器的种子在可预测范围内，其生成的秘钥是可以被预测的。</p><h2 id="4-3-利用证书的时间差进行攻击"><a href="#4-3-利用证书的时间差进行攻击" class="headerlink" title="4.3 利用证书的时间差进行攻击"></a>4.3 利用证书的时间差进行攻击</h2><p>SSL/TLS 中，客户端会使用服务器证书对服务器进行认证。在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。正如第十章所提到那样，如果证书已过期，但是 Web 浏览器没有获取到最新版的信息，这是无法保证通信的安全的。</p><h1 id="5-SSL-TLS-用户的注意事项"><a href="#5-SSL-TLS-用户的注意事项" class="headerlink" title="5 SSL/TLS 用户的注意事项"></a>5 SSL/TLS 用户的注意事项</h1><h2 id="5-1-不要误解证书的含义"><a href="#5-1-不要误解证书的含义" class="headerlink" title="5.1 不要误解证书的含义"></a>5.1 不要误解证书的含义</h2><p>在 SSL/TLS 中，我们能够通过证书对服务器进行认证。然后这里的认证，知识确认了通信对象是经过认证机构确认的服务器，并不能确认是否可以和该通信对象进行安全的在线购物交易。直白点，就是<strong>即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号，</strong>因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。<br>此外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。<br>为了提高 SSL/TLS 运用的可靠性，一个名为 CA/Brower 论坛的组织制定了 EV SSL 证书（Extended Validation Certificate）规范。</p><h2 id="5-2-密码通信之前的数据时不受保护的"><a href="#5-2-密码通信之前的数据时不受保护的" class="headerlink" title="5.2 密码通信之前的数据时不受保护的"></a>5.2 密码通信之前的数据时不受保护的</h2><p>SSL/TLS 仅对通信过程中的数据进行保护，而无法保护通信前的的数据。</p><h2 id="5-3-密码通信之后的数据时不受保护的"><a href="#5-3-密码通信之后的数据时不受保护的" class="headerlink" title="5.3 密码通信之后的数据时不受保护的"></a>5.3 密码通信之后的数据时不受保护的</h2><p>SSL/TLS 也无法保护通信之后的数据。<br>因此信用卡号<strong>不会再通信过程中被第三方获取</strong>，而信用卡号在通信之前被偷窥，以及在通信之后，服务器被窃取可能性还是存在的。</p><h1 id="6-本章小结"><a href="#6-本章小结" class="headerlink" title="6 本章小结"></a>6 本章小结</h1><p>SSL/TLS 是将对称密码、公钥密码、单向散列函数、消息认证码、伪随机数生成器、数字签名等技术相结合来实现安全通信的。通过切换密码套件来使用强度更高的密码算法。</p><h1 id="7-小测验"><a href="#7-小测验" class="headerlink" title="7 小测验"></a>7 小测验</h1><ol><li>使用 SSL/TLS 可以确保通信的机密性。</li><li>在 SSL/TLS 中，使用数字签名技术来认证通信双发的身份。</li><li>在 SSL/TLS 中，由于使用了公钥密码或者秘钥交换技术，因此伪随机数生成器的品质低一点也没有关系。</li><li>在 SSL/TLS 中，由于公钥是服务器发送的，因此客户端无需持有任何公钥就可以对服务器进行认证。</li><li>使用 SSL/TLS 的公司是可信的，因此可以放心地发送信用卡号。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十一、秘钥——秘密的精华</title>
      <link href="/2017/11/23/graphic2cryptography/10.html/"/>
      <url>/2017/11/23/graphic2cryptography/10.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>密码的本质就是将较长得密码——消息，变成较短的密码——秘钥。</p><h1 id="2-什么是秘钥"><a href="#2-什么是秘钥" class="headerlink" title="2 什么是秘钥"></a>2 什么是秘钥</h1><h2 id="2-1-秘钥就是一个巨大的数字"><a href="#2-1-秘钥就是一个巨大的数字" class="headerlink" title="2.1 秘钥就是一个巨大的数字"></a>2.1 秘钥就是一个巨大的数字</h2><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术，都需要一个称为<strong>秘钥</strong>（key）的巨大数字。然后，数字本身的带下并不重要，重要的是<strong>秘钥空间的大小</strong>，也就是可能出现的秘钥的总数量，因为秘钥空间越大，进行暴力破解就越困难。秘钥空间的大小是由<strong>秘钥长度</strong>决定的。</p><h3 id="1-DES-的秘钥"><a href="#1-DES-的秘钥" class="headerlink" title="1.DES 的秘钥"></a>1.DES 的秘钥</h3><p>对称密码 DES 的秘钥的实质长度为 56 比特。<br>例如，一个 DES 秘钥用二进制可以表示为：<br>01010001 10100101 10100011 10101010 01101101 10100001 11100011 00100100<br>用十六进制则可以表示为：<br>51 EC 4B 12 3D 4A A1<br>而用十进制则可以表示为：<br>12309120398102938102983<br>为了显得专业，将统一使用十六进制。</p><h3 id="2-三重-DES-的秘钥"><a href="#2-三重-DES-的秘钥" class="headerlink" title="2.三重 DES 的秘钥"></a>2.三重 DES 的秘钥</h3><p>在对称密码三重 DES 中，包括使用两个 DES 秘钥的 DES-EDE2 和使用三个 DES 秘钥的 DES-EDE3 两种方式。<br>DES-EDE2 的秘钥实际长度为 112 比特。<br>DES-EDE3 的秘钥实际长度为 168 比特。</p><h3 id="3-AES-的秘钥"><a href="#3-AES-的秘钥" class="headerlink" title="3.AES 的秘钥"></a>3.AES 的秘钥</h3><p>对称密码 AES 的秘钥长度可以从 128、192和 256 比特中进行选择。  </p><blockquote><p>实际长度会更长，因为会加一些用于识别通信错误的校验比特。</p></blockquote><h2 id="2-2-秘钥和明文是等价的"><a href="#2-2-秘钥和明文是等价的" class="headerlink" title="2.2 秘钥和明文是等价的"></a>2.2 秘钥和明文是等价的</h2><p>对于窃听密文的 Eve 来说，得到秘钥和得到明文是等价的。即，<strong>秘钥和明文是等价的</strong>。假设明文具有 100 万元的价值，那么用来加密这段明文的秘钥也就具有 100 万元的价值。</p><h2 id="2-3-密码算法与秘钥"><a href="#2-3-密码算法与秘钥" class="headerlink" title="2.3 密码算法与秘钥"></a>2.3 密码算法与秘钥</h2><p>信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的秘钥。这是密码世界的赏识之一。</p><h1 id="3-各种不同的秘钥"><a href="#3-各种不同的秘钥" class="headerlink" title="3 各种不同的秘钥"></a>3 各种不同的秘钥</h1><h2 id="3-1-对称密码的秘钥与公钥密码的秘钥"><a href="#3-1-对称密码的秘钥与公钥密码的秘钥" class="headerlink" title="3.1 对称密码的秘钥与公钥密码的秘钥"></a>3.1 对称密码的秘钥与公钥密码的秘钥</h2><p>在对称密码中，加密和解密使用同一个秘钥。由于发送者和接收者之间需要共享秘钥，因此对称密码又称为共享秘钥密码。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_1.png" alt><br>在公钥密码中，加密和解密使用的是不同的秘钥。用于加密的秘钥称为公钥；用于解密的秘钥称为私钥。公钥可以被公开，私钥只能被解密者拥有。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_2.png" alt></p><h2 id="3-2-消息认证码的秘钥与数字签名的秘钥"><a href="#3-2-消息认证码的秘钥与数字签名的秘钥" class="headerlink" title="3.2 消息认证码的秘钥与数字签名的秘钥"></a>3.2 消息认证码的秘钥与数字签名的秘钥</h2><p>在消息认证码中，发送者和接收者使用共享的秘钥来进行认证。消息认证码只能由持有合法秘钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。由于“持有合法的秘钥”就是发送者和接收者合法身份的证明，因此消息认证码的秘钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_3.png" alt><br>在数字签名中，签名的生成和验证使用不同的秘钥。只有持有私钥的本人才能够生成签名，但由于验证签名使用的是公钥，因此任何人都能够验证签名。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_4.png" alt></p><h2 id="3-3-用于确保机密性的秘钥与用于认证的秘钥"><a href="#3-3-用于确保机密性的秘钥与用于认证的秘钥" class="headerlink" title="3.3 用于确保机密性的秘钥与用于认证的秘钥"></a>3.3 用于确保机密性的秘钥与用于认证的秘钥</h2><p>对称密码和公钥密码的秘钥都是用于确保机密性的秘钥。如果不知道用于解密的合法秘钥，就无法得知明文的内容。  </p><p>相对地，消息认证码和数字签名所使用的秘钥，则是用于认证的秘钥。如果不知道合法的秘钥，就无法篡改数据，也无法伪装本人的身份。</p><h2 id="3-4-会话秘钥与主秘钥"><a href="#3-4-会话秘钥与主秘钥" class="headerlink" title="3.4 会话秘钥与主秘钥"></a>3.4 会话秘钥与主秘钥</h2><p>刚刚我们关注的是秘钥的用途，下面我们来关注一下秘钥被使用的次数。<br>当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。在这样通信中所使用的秘钥仅限于本次通信的一次性秘钥，下次通信时就不能使用了。像这样每次通信只能使用一次的秘钥称为<strong>会话秘钥</strong>（session key）。<br>虽然每次通信都会更会秘钥，但如果用来生成秘钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话秘钥，这样就会产生内容被破译的风险。<br>相对于每次通信都更换的会话秘钥，一直被重复使用的秘钥称为<strong>主秘钥</strong>（master key）。</p><h2 id="3-5-用于加密内容的秘钥与用于加密秘钥的秘钥"><a href="#3-5-用于加密内容的秘钥与用于加密秘钥的秘钥" class="headerlink" title="3.5 用于加密内容的秘钥与用于加密秘钥的秘钥"></a>3.5 用于加密内容的秘钥与用于加密秘钥的秘钥</h2><p>一般来说，加密的对象使用户直接使用的信息，这样的情况下所使用的秘钥称为 CEK（Contents Encrypting Key，内容加密秘钥）；相对地，用于加密秘钥的秘钥则称为 KEK（Key Encrypting Key，秘钥加密秘钥）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_5.png" alt>  </p><p>在很多情况下，之前提到的会话秘钥都是被作为 CEK 使用的，而主秘钥则是被作为 KEK 使用的。</p><h1 id="4-秘钥的管理"><a href="#4-秘钥的管理" class="headerlink" title="4 秘钥的管理"></a>4 秘钥的管理</h1><h2 id="4-1-生成秘钥"><a href="#4-1-生成秘钥" class="headerlink" title="4.1 生成秘钥"></a>4.1 生成秘钥</h2><h3 id="1-用随机数生成秘钥"><a href="#1-用随机数生成秘钥" class="headerlink" title="1.用随机数生成秘钥"></a>1.用随机数生成秘钥</h3><h3 id="2-用口令生成秘钥"><a href="#2-用口令生成秘钥" class="headerlink" title="2.用口令生成秘钥"></a>2.用口令生成秘钥</h3><p>即人类可以记住的口令（password或passphrase）生成秘钥，但是由字典攻击。</p><h2 id="4-2-配送秘钥"><a href="#4-2-配送秘钥" class="headerlink" title="4.2 配送秘钥"></a>4.2 配送秘钥</h2><p>在第五章介绍，可以采用<strong>事先共享秘钥、使用秘钥分配中心、使用公钥密码</strong>等方法。一会将介绍<strong>Diffie-Hellman秘钥交换</strong>。</p><h2 id="4-3-更新秘钥"><a href="#4-3-更新秘钥" class="headerlink" title="4.3 更新秘钥"></a>4.3 更新秘钥</h2><p>有一种提高通信机密性的技术被称为<strong>秘钥更新</strong>（key updating），这种方法就是在使用共享秘钥进行通信的过程中，定期（例如每发送 1000 个字）改变秘钥。  </p><p>在更新秘钥时，发送者和接收者使用单向散列函数计算当前秘钥的散列值，并将这个散列值用作新的秘钥。简单说，就是<strong>用当前秘钥的散列值作为下一个秘钥</strong>。<br>这种防止破译过去的通信内容的机制，称为<strong>后向安全</strong>（backward security）。</p><h2 id="4-4-保存秘钥"><a href="#4-4-保存秘钥" class="headerlink" title="4.4 保存秘钥"></a>4.4 保存秘钥</h2><p>由于会话秘钥在通信过程中仅限使用一次，因此我们不需要保存这种秘钥。然而，当秘钥需要重复使用时，就必须要考虑<strong>保存秘钥</strong>的问题了。</p><h3 id="1-人类无法记住秘钥"><a href="#1-人类无法记住秘钥" class="headerlink" title="1.人类无法记住秘钥"></a>1.人类无法记住秘钥</h3><p>首先我们必须要理解一个重要的事实，那就是人类是<strong>无法记住具有使用长度的秘钥</strong>的。 </p><h3 id="2-对秘钥进行加密的意义"><a href="#2-对秘钥进行加密的意义" class="headerlink" title="2.对秘钥进行加密的意义"></a>2.对秘钥进行加密的意义</h3><p>例如，计算机上有 100 万个文件，分别使用不同的秘钥进行加密生成 100 万个密文，结果我们手上就产生了 100 万个秘钥。于是，我们用一个秘钥将这 100 万个秘钥进行加密，那么我们只要保管这一个秘钥就行了。</p><h2 id="4-5-作废秘钥"><a href="#4-5-作废秘钥" class="headerlink" title="4.5 作废秘钥"></a>4.5 作废秘钥</h2><p>如果秘钥是计算机上的一个文件，那么仅仅删除这个文件是不足以删除秘钥的，此外，很多情况下文件的内容还会残留在计算机的内存中。简而言之，要完全删除秘钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分的考虑。当然，还要防止秘钥丢失。</p><h1 id="5-Diffie-Hellman秘钥交换"><a href="#5-Diffie-Hellman秘钥交换" class="headerlink" title="5 Diffie-Hellman秘钥交换"></a>5 Diffie-Hellman秘钥交换</h1><h2 id="5-1-什么是-Diffie-Hellman-秘钥交换"><a href="#5-1-什么是-Diffie-Hellman-秘钥交换" class="headerlink" title="5.1 什么是 Diffie-Hellman 秘钥交换"></a>5.1 什么是 Diffie-Hellman 秘钥交换</h2><p>使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成共享的秘密数字，而这一秘密数字就可以被用作对称密码的秘钥。 IPsec 中就使用了经过改良的 Diffie-Hellman 秘钥交换。  </p><p>虽然名字叫做“秘钥交换”，但实际上双方并没有真正交换秘钥，而是通过计算机生成出了一个相同的共享秘钥。因此，这种方法也称为 Diffie-Hellman 秘钥协商（Diffie-Hellman key agreement）。</p><h2 id="5-2-Diffie-Hellman-秘钥交换的步骤"><a href="#5-2-Diffie-Hellman-秘钥交换的步骤" class="headerlink" title="5.2 Diffie-Hellman 秘钥交换的步骤"></a>5.2 Diffie-Hellman 秘钥交换的步骤</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_6.png" alt>  </p><h3 id="1-Alice-向-Bob-发送两个质数-P-和-G"><a href="#1-Alice-向-Bob-发送两个质数-P-和-G" class="headerlink" title="1.Alice 向 Bob 发送两个质数 P 和 G"></a>1.Alice 向 Bob 发送两个质数 P 和 G</h3><p>P 必须是一个非常大的质数，而 G 则是一个和 P 相关的数，称为<strong>生成元</strong>。 G 可以是一个较小的数字。 P 和 G 不需要保密。</p><h3 id="2-Alice-生成一个随机数-A"><a href="#2-Alice-生成一个随机数-A" class="headerlink" title="2.Alice 生成一个随机数 A"></a>2.Alice 生成一个随机数 A</h3><p>A 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob ，也不能让 Eve 知道。</p><h3 id="3-Bob-生成一个随机数-B"><a href="#3-Bob-生成一个随机数-B" class="headerlink" title="3.Bob 生成一个随机数 B"></a>3.Bob 生成一个随机数 B</h3><p>B 是一个 1 ~ P-2 之间的整数。这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。</p><h3 id="4-Alice-将-G-A-mod-P-这个数发送给-Bob"><a href="#4-Alice-将-G-A-mod-P-这个数发送给-Bob" class="headerlink" title="4.Alice 将 G^A mod P 这个数发送给 Bob"></a>4.Alice 将 G^A mod P 这个数发送给 Bob</h3><p>这个数让 Eve 知道也没关系</p><h3 id="5-Bob-将-G-B-mod-P-这个数发送给-Alice"><a href="#5-Bob-将-G-B-mod-P-这个数发送给-Alice" class="headerlink" title="5.Bob 将 G^B mod P 这个数发送给 Alice"></a>5.Bob 将 G^B mod P 这个数发送给 Alice</h3><p>这个数让 Eve 知道也没关系</p><h3 id="6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P"><a href="#6-Alice-用-Bob-发过来的数计算-A-次方并求-mod-P" class="headerlink" title="6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P"></a>6.Alice 用 Bob 发过来的数计算 A 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^B mod P)^A mod P</p><h3 id="7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P"><a href="#7-Bob-用-Alice-发过来的数计算-B-次方并求-mod-P" class="headerlink" title="7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P"></a>7.Bob 用 Alice 发过来的数计算 B 次方并求 mod P</h3><p>这个数就是共享秘钥。 (G^A mod P)^B mod P</p><h3 id="8-这样-Alice-和-Bob-得到的值就是相同的"><a href="#8-这样-Alice-和-Bob-得到的值就是相同的" class="headerlink" title="8.这样 Alice 和 Bob 得到的值就是相同的"></a>8.这样 Alice 和 Bob 得到的值就是相同的</h3><h2 id="5-3-Eve-能计算出秘钥吗"><a href="#5-3-Eve-能计算出秘钥吗" class="headerlink" title="5.3 Eve 能计算出秘钥吗"></a>5.3 Eve 能计算出秘钥吗</h2><p>这是一个离散数学的问题，根据 G^A mod P 的值，以及 G、P 求出 A。非常的困难。</p><h1 id="6-基于口令的密码（PBE）"><a href="#6-基于口令的密码（PBE）" class="headerlink" title="6 基于口令的密码（PBE）"></a>6 基于口令的密码（PBE）</h1><h2 id="6-1-什么是基于口令的密码"><a href="#6-1-什么是基于口令的密码" class="headerlink" title="6.1 什么是基于口令的密码"></a>6.1 什么是基于口令的密码</h2><p>用口令来生成秘钥（KEK）,但只用口令容易遭到字典攻击，那么就用口令和盐共同生成秘钥（KEK），盐可以和加密后的秘钥（CEK）一起保存在磁盘上，而秘钥可以直接丢弃，口令就记在脑子里吧。</p><h2 id="6-2-PBE-加密"><a href="#6-2-PBE-加密" class="headerlink" title="6.2 PBE 加密"></a>6.2 PBE 加密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_7.png" alt></p><h2 id="6-3-PBE-解密"><a href="#6-3-PBE-解密" class="headerlink" title="6.3 PBE 解密"></a>6.3 PBE 解密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/11_8.png" alt></p><h1 id="7-本章小结"><a href="#7-本章小结" class="headerlink" title="7 本章小结"></a>7 本章小结</h1><p>对秘钥本身做了简单介绍。</p><h1 id="8-小测验"><a href="#8-小测验" class="headerlink" title="8 小测验"></a>8 小测验</h1><ol><li>由于秘钥只是随机的比特序列，因此被别人知道了也没关系。</li><li>私钥是可以公开的。</li><li>在 Diffie-Hellman 秘钥交换中，双方可以通过交换一些可以公开的信息生成出共享秘钥。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>电影《一个叫欧维的男人决定去死》有感~</title>
      <link href="/2017/11/23/talker/2.html/"/>
      <url>/2017/11/23/talker/2.html/</url>
      
        <content type="html"><![CDATA[<p>整部电影感觉有股悲伤的基调，欧维一生皆是不顺，很是平淡，看的确实难受，他是一个好人，却被社会所嫌弃。  </p><p>他在乎的和在乎他的人都已不在人世，无论是妻子还是好朋友鲁尼（从影片看出，他们是从青年到老年的好朋友了），生活对欧维来说都是如此平淡，每天都面对的是“白痴“。</p><p>他孩童时期最高兴的应该是和他父亲一起开车，“这才是人生”，他爸告诉他。这句话，他对那个可爱的小女孩也说了，“这才是人生”。尽管，他很想和自己的孩子说。  </p><p>我以为应该是个美好结局。  </p><p>“这才是人生”。 </p><hr><p>life is not easy. So is suicide.</p><blockquote><p>《En Man Som Heter Ove》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十、证书——为公钥加上数字签名</title>
      <link href="/2017/11/22/graphic2cryptography/10.html/"/>
      <url>/2017/11/22/graphic2cryptography/10.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>第五章学习了公钥密码；第九章学习了数字签名。其中公钥都扮演了重要的角色。然后，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书，就是用来对公钥合法性提供证明的技术。  </p><p>我们先介绍什么是证书，以及证书的应用场景，然后介绍 X.509 证书规范，以及利用证书来进行公钥传输的公钥基础设施（PKI）和认证机构。</p><h1 id="2-证书"><a href="#2-证书" class="headerlink" title="2 证书"></a>2 证书</h1><h1 id="2-1-什么是证书"><a href="#2-1-什么是证书" class="headerlink" title="2.1 什么是证书"></a>2.1 什么是证书</h1><p>公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面记有姓名、组织、邮箱、地址等个人信息，以及属于此人的公钥，并由<strong>认证机构（Certification Authority、Certifying Authority，CA）</strong>施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为<strong>证书</strong>（certificate）。<br>认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织。既有国际性组织和政府所设立的组织，也有通过认证服务来盈利的一般企业，此外个人也可以成立认证机构。世界上最有名的认证机构当属 VeriSign 公司。</p><h1 id="2-2-证书的应用场景"><a href="#2-2-证书的应用场景" class="headerlink" title="2.2 证书的应用场景"></a>2.2 证书的应用场景</h1><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_1.png" alt>  </p><ol><li>Bob 生成密钥对。这里秘钥既可以 Bob 自己生成，也可以由认证机构代为生成。</li><li>Bob 在认证机构 Trent 注册自己的公钥。 Bob，需要请认证机构 Trent 对他的公钥加上数字签名（即生成证书）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_2.png" alt></li><li>认证机构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书。</li><li>Alice 得到带有认证机构 Trent 的数字签名的 Bob 的公钥（证书）。</li><li>Alice 使用认证机构 Trent 的公钥验证数字签名，确认 Bob 的公钥的合法性。</li><li>Alice 用 Bob 的公钥加密消息并发送给 Bob。</li><li>Bob 用自己的私钥解密密文得到 Alice 的消息。</li></ol><h1 id="3-证书标准规范-X-509"><a href="#3-证书标准规范-X-509" class="headerlink" title="3 证书标准规范 X.509"></a>3 证书标准规范 X.509</h1><ol><li>签名前的证书——签名对象的信息</li><li>数字签名算法——对证书签名时所使用的算法</li><li>数字签名——对证书施加的数字签名</li></ol><h1 id="4-公钥基础设施（PKI）"><a href="#4-公钥基础设施（PKI）" class="headerlink" title="4 公钥基础设施（PKI）"></a>4 公钥基础设施（PKI）</h1><h2 id="4-1-什么是公钥基础设施"><a href="#4-1-什么是公钥基础设施" class="headerlink" title="4.1 什么是公钥基础设施"></a>4.1 什么是公钥基础设施</h2><p><strong>公钥基础设施</strong>（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一些列规范和规格的总称，简称 PKI。它只是一个总称。</p><h2 id="4-2-PKI-的组成要素"><a href="#4-2-PKI-的组成要素" class="headerlink" title="4.2 PKI 的组成要素"></a>4.2 PKI 的组成要素</h2><ol><li>用户——使用 PKI 的人</li><li>认证机构——颁发证书的人</li><li>仓库——保存证书的数据</li></ol><h2 id="4-3-认证机构的工作"><a href="#4-3-认证机构的工作" class="headerlink" title="4.3 认证机构的工作"></a>4.3 认证机构的工作</h2><ol><li>生成密钥对</li><li>注册证书</li><li>作废证书与 CRL（证书作废清单 Certificate Revocation List）</li></ol><h2 id="4-4-证书的层级结构"><a href="#4-4-证书的层级结构" class="headerlink" title="4.4 证书的层级结构"></a>4.4 证书的层级结构</h2><p>证书颁发：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。<br>验证证书：根CA -&gt; 分公司认证机构 -&gt; 办事处认证机构 -&gt; 用户。如果连根CA都无法验证说明证书是存在问题的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/10_3.png" alt></p><h1 id="5-对证书的攻击"><a href="#5-对证书的攻击" class="headerlink" title="5. 对证书的攻击"></a>5. 对证书的攻击</h1><h2 id="5-1-在公钥注册之前进行攻击"><a href="#5-1-在公钥注册之前进行攻击" class="headerlink" title="5.1 在公钥注册之前进行攻击"></a>5.1 在公钥注册之前进行攻击</h2><h2 id="5-2-注册相似人名进行攻击"><a href="#5-2-注册相似人名进行攻击" class="headerlink" title="5.2 注册相似人名进行攻击"></a>5.2 注册相似人名进行攻击</h2><h2 id="5-3-窃取认证机构的私钥进行攻击"><a href="#5-3-窃取认证机构的私钥进行攻击" class="headerlink" title="5.3 窃取认证机构的私钥进行攻击"></a>5.3 窃取认证机构的私钥进行攻击</h2><h2 id="5-4-攻击者伪装成认证机构进行攻击"><a href="#5-4-攻击者伪装成认证机构进行攻击" class="headerlink" title="5.4 攻击者伪装成认证机构进行攻击"></a>5.4 攻击者伪装成认证机构进行攻击</h2><h2 id="5-5-钻-CRL-的空子进行攻击"><a href="#5-5-钻-CRL-的空子进行攻击" class="headerlink" title="5.5 钻 CRL 的空子进行攻击"></a>5.5 钻 CRL 的空子进行攻击</h2><p>Mallory 在晚上入侵 Bob 的电脑，向 Alice 发了邮件。第二天早上， Bob 发现自己电脑被入侵，而且私钥被盗，于是 Bob 赶紧联系认证机构 Trent ，通知自己的公钥被盗，但是已经晚了。同时 Bob 也可以是坏人，利用这个时间差。</p><h1 id="6-关于证书的-Q-amp-A"><a href="#6-关于证书的-Q-amp-A" class="headerlink" title="6. 关于证书的 Q&amp;A"></a>6. 关于证书的 Q&amp;A</h1><h2 id="6-1-为什么需要证书"><a href="#6-1-为什么需要证书" class="headerlink" title="6.1 为什么需要证书"></a>6.1 为什么需要证书</h2><p>疑问：我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不一样呢？<br>回答：从认证机构获取公钥，可以降低遭到中间人攻击的风险。因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。</p><h2 id="6-2-通过自己的方法进行认证是不是更安全"><a href="#6-2-通过自己的方法进行认证是不是更安全" class="headerlink" title="6.2 通过自己的方法进行认证是不是更安全"></a>6.2 通过自己的方法进行认证是不是更安全</h2><p>疑问：使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？<br>回答：靠隐蔽式来保证安全是错误的！</p><h2 id="6-3-为什么要相信认证机构"><a href="#6-3-为什么要相信认证机构" class="headerlink" title="6.3 为什么要相信认证机构"></a>6.3 为什么要相信认证机构</h2><p>？？？</p><h1 id="7-本章小结"><a href="#7-本章小结" class="headerlink" title="7. 本章小结"></a>7. 本章小结</h1><p>从使用证书的场景开始，学习了证书标准规范 X.509、颁发证书的认证机构，以及公钥基础设施（PKI）的相关知识。还介绍了对 PKI 的攻击方法和对策。<br>无论是数字签名、证书。还是认证机构的层级结构，都不可能在完全不可信的状态下创造出信任关系。这是一种社会的实体问题。</p><h1 id="8-小测验"><a href="#8-小测验" class="headerlink" title="8. 小测验"></a>8. 小测验</h1><ol><li>证书是认证机构将用户的公钥加密后的产物</li><li>要确认证书中所包含的公钥是否合法，需要得到认证机构的公钥</li><li>世界上颁发的所有证书，沿着认证机构的层级关系都能够找到唯一的根 CA</li><li>用户发现自己的私钥泄露之后，需要立刻联系注册相应公钥的认证机构</li><li>用户需要定期从认证机构获取 CRL</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>九、数字签名——消息到底是谁写的</title>
      <link href="/2017/11/21/graphic2cryptography/9.html/"/>
      <url>/2017/11/21/graphic2cryptography/9.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-羊妈妈的认证"><a href="#1-羊妈妈的认证" class="headerlink" title="1 羊妈妈的认证"></a>1 羊妈妈的认证</h1><p>大灰狼把黑色的爪子伸进门缝，说道：<br>“我是你们的妈妈，快快开门吧！”<br>七只小羊回答道：<br>“不是不是，妈妈的手是白色的，你的手的黑色的，你不是我们的妈妈！”<br>听了小羊的话，大灰狼把它的爪子染成了白色，于是小羊们就被大灰狼的白爪子给骗了，便打开了门。<br>这是因为小羊们用来认证的“白色的手”是大灰狼也能够模仿出来的。<br>如果有一种“只有羊妈妈才能生成的信息”，那就可以实现更可靠的认证了吧。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。</p><h1 id="3-数字签名"><a href="#3-数字签名" class="headerlink" title="3 数字签名"></a>3 数字签名</h1><h2 id="3-1-Alice-的借条"><a href="#3-1-Alice-的借条" class="headerlink" title="3.1 Alice 的借条"></a>3.1 Alice 的借条</h2><p>假设 Alice 需要向 Bob 借 100 万元。不过 Alice 和 Bob 离得很远，无法直接见面。通过银行汇款， Alice 可以立刻从 Bob 那里收到钱，但是 Alice 的借条应该怎样发送给 Bob 呢？挂号信寄过去，但是会花费时间，能不能用电子邮件来发送借条呢？比如：<br>“Bob，我向你借款 100 万元。”————Alice。<br>显然，Bob 看到这封邮件也不会轻易相信，因为电子邮件容易被伪造也可能被篡改，或者事后 Alice 可以以“我不知道这张借条”为理由来否认。</p><h2 id="3-2-从消息认证码到数字签名"><a href="#3-2-从消息认证码到数字签名" class="headerlink" title="3.2 从消息认证码到数字签名"></a>3.2 从消息认证码到数字签名</h2><h3 id="1-消息认证码的局限性"><a href="#1-消息认证码的局限性" class="headerlink" title="1. 消息认证码的局限性"></a>1. 消息认证码的局限性</h3><p>第八章介绍的消息认证码由局限性，即，无法防止否认，以及无法向第三方证明消息是对方发的。</p><h3 id="2-通过数字签名解决问题"><a href="#2-通过数字签名解决问题" class="headerlink" title="2. 通过数字签名解决问题"></a>2. 通过数字签名解决问题</h3><p>假设 Alice 使用的秘钥是一个只有 Alice 自己才知道的私钥。当 Alice 发送消息时，她用私钥生成一个“签名”。相对的，接收者 Bob 则使用一个和 Alice 不同的秘钥对签名进行验证。使用 Bob 的秘钥无法根据消息生成签名，但是用 Bob 的秘钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的秘钥计算出来的。<br>实际上，这种看似神奇的技术，早就已经问世了，这就是<strong>数字签名</strong>（digital signature）。</p><h2 id="3-3-签名的生成和验证"><a href="#3-3-签名的生成和验证" class="headerlink" title="3.3 签名的生成和验证"></a>3.3 签名的生成和验证</h2><p>在数字签名技术中，出现了下面两种行为：  </p><ul><li>生成消息签名的行为</li><li>验证消息签名的行为</li></ul><p>生成消息签名：由消息发送者 Alice 来完成。表明“我认可该消息的内容”。<br>验证数字签名：由消息接收者 Bob 来完成或者需要验证消息的第三方来完成，即验证者 Victor。  </p><p>Alice 使用“签名秘钥”来生成消息的签名，而 Bob 和 Victor 则使用“验证秘钥”来验证消息的签名。<strong>数字签名对签名秘钥和验证秘钥进行了区分，使用验证秘钥是无法生成签名的。</strong>这一点非常重要。此外，<strong>签名秘钥只能由签名的人持有，而验证秘钥则是任何需要验证签名的人都可以持有。</strong><br>这里和第五章的公钥密码很相似。实际上，数字签名和公钥密码有着非常紧密的联系，简而言之，<strong>数字签名</strong>就是通过将公钥密码“反过来用”而实现的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_1.png" alt></p><h2 id="3-4-公钥密码与数字签名"><a href="#3-4-公钥密码与数字签名" class="headerlink" title="3.4 公钥密码与数字签名"></a>3.4 公钥密码与数字签名</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_2.png" alt><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_3.png" alt></p><h1 id="4-数字签名的方法"><a href="#4-数字签名的方法" class="headerlink" title="4 数字签名的方法"></a>4 数字签名的方法</h1><p>我们来介绍两种生成和验证数字签名的方法：  </p><ol><li>直接对消息签名的方法</li><li>对消息的散列值签名的方法</li></ol><p>后者虽然复杂，但实际中我们一般都使用这种方法。</p><h2 id="4-1-直接对消息签名的方法"><a href="#4-1-直接对消息签名的方法" class="headerlink" title="4.1 直接对消息签名的方法"></a>4.1 直接对消息签名的方法</h2><p>发送者 Alice 要对消息签名，而接收者 Bob 要对签名进行验证。<br>Alice 需要事先生成一个包括公钥和私钥的密钥对，而需要验证签名 签名的 Bob 则需要得到 Alice 公钥。过程如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_4.png" alt>  </p><ol><li>Alice 用自己的私钥对消息进行加密。</li><li>Alice 将消息和签名发送给 Bob。</li><li>Bob 用 Alice 的公钥对收到的签名进行解密。如果不是 Alice 的私钥加密的密文，则无法用 Alice 的公钥正确解密。</li><li>Bob 将签名解密后得到的消息与 Alice 直接发送的消息进行对比。</li></ol><h2 id="4-2-对消息的散列值签名的方法"><a href="#4-2-对消息的散列值签名的方法" class="headerlink" title="4.2 对消息的散列值签名的方法"></a>4.2 对消息的散列值签名的方法</h2><p> 与对消息签名的不同是， 这里的消息变成了消息的散列值。流程参考上图。</p><h1 id="5-对数字签名的疑问"><a href="#5-对数字签名的疑问" class="headerlink" title="5 对数字签名的疑问"></a>5 对数字签名的疑问</h1><h2 id="5-1-密文为什么能作为签名使用"><a href="#5-1-密文为什么能作为签名使用" class="headerlink" title="5.1 密文为什么能作为签名使用"></a>5.1 密文为什么能作为签名使用</h2><p>疑问：为什么密文能够具备签名的意义呢？<br>解答：数字签名是 利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。并非为了保证机密性，而是代表<strong>只有持有该秘钥的人才能够生成的信息</strong>。<br>这样的信息一般称为<strong>认证符号</strong>（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。</p><h2 id="5-2-数字签名不能保证机密性吗"><a href="#5-2-数字签名不能保证机密性吗" class="headerlink" title="5.2 数字签名不能保证机密性吗"></a>5.2 数字签名不能保证机密性吗</h2><p>疑问：从流程图看到，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？<br>解答：的确，数字签名的作用本来就不是保证机密性。关于密码和签名的组合方法，将在第十三章 PGP 详解。</p><h2 id="5-3-这种签名可以随意复制吗"><a href="#5-3-这种签名可以随意复制吗" class="headerlink" title="5.3 这种签名可以随意复制吗"></a>5.3 这种签名可以随意复制吗</h2><p>疑问：数字签名貌似可以轻易复制出相同内容，那还能用作签名吗？<br>解答：签名重要的是，<strong>特定的签名者与特定的消息绑定在了一起</strong>这一事实。无论将签名复制了多少份，“是谁对这条消息进行了签名”这一事实是不会发生任何改变的。签名可以被复制，但这并不代表签名会失去意义。</p><h2 id="5-4-消息内容会不不会任意修改"><a href="#5-4-消息内容会不不会任意修改" class="headerlink" title="5.4 消息内容会不不会任意修改"></a>5.4 消息内容会不不会任意修改</h2><p>疑问：消息和签名两者都是可以任意修改的，这样的签名还有意义吗？<br>解答：数字签名所要实现的并不是<strong>防止修改</strong>，而是<strong>识别修改</strong>。修改没问题，但验证签名会失败。</p><h2 id="5-5-删除签名也无法“作废合同”吗"><a href="#5-5-删除签名也无法“作废合同”吗" class="headerlink" title="5.5 删除签名也无法“作废合同”吗"></a>5.5 删除签名也无法“作废合同”吗</h2><p>疑问：带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其它地方是否还留有副本。无法作废的签名是不是非常不方便呢？<br>解答：我们可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况，将在第十章详解。</p><h2 id="5-6-如何防止否认"><a href="#5-6-如何防止否认" class="headerlink" title="5.6 如何防止否认"></a>5.6 如何防止否认</h2><p> 严格来说，如果数字签名的声称这说“我的私钥被别人窃取了”，也是有可能进行否认的，将在第十章探讨。</p><h2 id="5-7-数字签名真的能够代替签名吗"><a href="#5-7-数字签名真的能够代替签名吗" class="headerlink" title="5.7 数字签名真的能够代替签名吗"></a>5.7 数字签名真的能够代替签名吗</h2><p>不能代替，而是共存。</p><h1 id="6-数字签名的应用实例"><a href="#6-数字签名的应用实例" class="headerlink" title="6 数字签名的应用实例"></a>6 数字签名的应用实例</h1><h2 id="6-1-安全信息公告"><a href="#6-1-安全信息公告" class="headerlink" title="6.1 安全信息公告"></a>6.1 安全信息公告</h2><p> 一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这么警告是否真的是该组织所发布的呢？因此，人们可以通过公钥 可以排除有人恶意伪装成该组织来发布假消息的风险。</p><h2 id="6-2-软件下载"><a href="#6-2-软件下载" class="headerlink" title="6.2 软件下载"></a>6.2 软件下载</h2><p> 保证网络下载的软件是否被篡改过。</p><h2 id="6-3-公钥证书"><a href="#6-3-公钥证书" class="headerlink" title="6.3 公钥证书"></a>6.3 公钥证书</h2><p>在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？我们可以将公钥当作消息，对它加上数字签名。像这样对公钥施加数字签名所得到的就是<strong>公钥证书</strong>，将在第十章详解。</p><h2 id="6-4-SSL-TLS"><a href="#6-4-SSL-TLS" class="headerlink" title="6.4 SSL/TLS"></a>6.4 SSL/TLS</h2><p>SSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。相对的，服务器为了对客户端（用户）进行认证也会使用客户端证书。将在第十四章详解。</p><h1 id="7-通过-RSA-实现数字签名"><a href="#7-通过-RSA-实现数字签名" class="headerlink" title="7 通过 RSA 实现数字签名"></a>7 通过 RSA 实现数字签名</h1><h2 id="7-1-用-RSA-生成签名"><a href="#7-1-用-RSA-生成签名" class="headerlink" title="7.1 用 RSA 生成签名"></a>7.1 用 RSA 生成签名</h2><h2 id="签名-消息-D-mod-N"><a href="#签名-消息-D-mod-N" class="headerlink" title="签名 = 消息 ^ D mod N"></a>签名 = 消息 ^ D mod N</h2><p>这里所使用的 D 和 N 就是签名者的私钥。</p><h2 id="7-2-用-RSA-验证签名"><a href="#7-2-用-RSA-验证签名" class="headerlink" title="7.2 用 RSA 验证签名"></a>7.2 用 RSA 验证签名</h2><h2 id="由签名求得的消息-签名-E-mod-N"><a href="#由签名求得的消息-签名-E-mod-N" class="headerlink" title="由签名求得的消息 = 签名 ^ E mod N"></a>由签名求得的消息 = 签名 ^ E mod N</h2><p>这里所使用的 E 和 N 就是签名者的公钥。</p><h2 id="7-3-具体实践"><a href="#7-3-具体实践" class="headerlink" title="7.3 具体实践"></a>7.3 具体实践</h2><p>假设密钥对：<br>公钥：E = 5; N = 323;<br>私钥：D = 29; N = 323;</p><h3 id="1-生成签名"><a href="#1-生成签名" class="headerlink" title="1.生成签名"></a>1.生成签名</h3><p>消息^D mod N = 123^29 mod 323 = 157<br>得到签名是 157，向接收者发送的内容为：(123，157)。</p><h3 id="2-验证签名"><a href="#2-验证签名" class="headerlink" title="2.验证签名"></a>2.验证签名</h3><p>签名^E mod N = 157^5 mod 323 = 123<br>得到的消息 123 与发送者直接发送过来的消息 123 是一致的，因此签名验证成功。</p><h1 id="8-其它的数字签名"><a href="#8-其它的数字签名" class="headerlink" title="8 其它的数字签名"></a>8 其它的数字签名</h1><ol><li>EIGamal 方式：利用了在 mod N 中求离散对数的困难度。</li><li>DSA。</li><li>Rabin 方式：利用了在 mod N 中其平方根的困难度。</li></ol><h1 id="9-对数字签名的攻击"><a href="#9-对数字签名的攻击" class="headerlink" title="9 对数字签名的攻击"></a>9 对数字签名的攻击</h1><h2 id="9-1-中间人攻击"><a href="#9-1-中间人攻击" class="headerlink" title="9.1 中间人攻击"></a>9.1 中间人攻击</h2><h2 id="9-2-对单向散列函数的攻击"><a href="#9-2-对单向散列函数的攻击" class="headerlink" title="9.2 对单向散列函数的攻击"></a>9.2 对单向散列函数的攻击</h2><p>数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。</p><h2 id="9-3-利用数字签名攻击公钥密码"><a href="#9-3-利用数字签名攻击公钥密码" class="headerlink" title="9.3 利用数字签名攻击公钥密码"></a>9.3 利用数字签名攻击公钥密码</h2><p>将密文以邮件方式发送给可以解密者，诱导其帮忙解密。（博主认为，这属于社会工程学范畴）<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/9_5.png" alt></p><h1 id="10-各种密码技术的对比"><a href="#10-各种密码技术的对比" class="headerlink" title="10 各种密码技术的对比"></a>10 各种密码技术的对比</h1><h2 id="10-1-消息认证码与数字签名"><a href="#10-1-消息认证码与数字签名" class="headerlink" title="10.1 消息认证码与数字签名"></a>10.1 消息认证码与数字签名</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">对称密码</th><th style="text-align:left">公钥密码</th></tr></thead><tbody><tr><td style="text-align:center">发送者</td><td style="text-align:center">用共享秘钥加密</td><td style="text-align:left">用公钥加密</td></tr><tr><td style="text-align:center">接收者</td><td style="text-align:center">用共享秘钥解密</td><td style="text-align:left">用私钥解密</td></tr><tr><td style="text-align:center">秘钥配送问题</td><td style="text-align:center">存在</td><td style="text-align:left">不存在，但公钥需要另外认证</td></tr><tr><td style="text-align:center">机密性</td><td style="text-align:center">✔️</td><td style="text-align:left">✔️</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">消息认证码</th><th style="text-align:left">数字签名</th></tr></thead><tbody><tr><td style="text-align:center">发送者</td><td style="text-align:center">用共享秘钥计算 MAC 值</td><td style="text-align:left">用私钥生成签名</td></tr><tr><td style="text-align:center">接收者</td><td style="text-align:center">用共享秘钥计算 MAC 值</td><td style="text-align:left">用公钥验证签名</td></tr><tr><td style="text-align:center">秘钥配送问题</td><td style="text-align:center">存在</td><td style="text-align:left">不存在，但公钥需要另外认证</td></tr><tr><td style="text-align:center">完整性</td><td style="text-align:center">✔️</td><td style="text-align:left">✔️</td></tr><tr><td style="text-align:center">认证</td><td style="text-align:center">✔️（仅限通信对象双方）</td><td style="text-align:left">✔️（可适用于任何第三方）</td></tr><tr><td style="text-align:center">防止否认</td><td style="text-align:center">✘</td><td style="text-align:left">✔️</td></tr></tbody></table><h2 id="10-2-混合密码系统与散列值签名"><a href="#10-2-混合密码系统与散列值签名" class="headerlink" title="10.2 混合密码系统与散列值签名"></a>10.2 混合密码系统与散列值签名</h2><p>在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的秘钥是用公钥密码加密的，即在这里对称密码的秘钥就相当于消息。<br>另一方面，数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值，然后再对散列值进行签名，在这里散列值就相当于消息。<br>即：<strong>对称密码的秘钥是机密性的精华</strong>，<strong>单向散列函数的散列值是完整性的精华</strong>。</p><h1 id="11-数字签名无法解决的问题"><a href="#11-数字签名无法解决的问题" class="headerlink" title="11 数字签名无法解决的问题"></a>11 数字签名无法解决的问题</h1><p>用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及防止否认。<br>然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的<strong>公钥必须属于真正的发送者</strong>。<br>现在由陷入了一个死循环，数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。<br>为了能够确认自己得到的公钥是否合法，我们需要使用<strong>证书</strong>。所谓证书，就是讲公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。   </p><p>但是这只是把问题转移了。为了对证书上施加的数字签名进行校验，我们必定需要另一个公钥，那么如何才能构建一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即<strong>公钥基础设施（Public Key Intrastructure）</strong>，简称 PKI，关于证书和 PKI 将在第十章详解。</p><h1 id="12-本章小结"><a href="#12-本章小结" class="headerlink" title="12 本章小结"></a>12 本章小结</h1><p>本章介绍了，如何逆向使用公钥密码来实现数字签名，并使用 RSA 具体实践了数字签名的生成和验证。此外讨论了数字签名的攻击方法以及数字签名与消息认证码之间的关系。<br>通过数字签名可以识别篡改和伪装，还可以防止否认，但前提是用于验证严明的发送者的公钥没有被伪造。</p><h1 id="13-小测验"><a href="#13-小测验" class="headerlink" title="13 小测验"></a>13 小测验</h1><ol><li>要验证数字签名，需要使用签名者的私钥。</li><li>RSA 可以用作数字签名算法。</li><li>使用数字签名可以保护消息的机密性，不用担心被窃听。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八、消息认证码</title>
      <link href="/2017/11/19/graphic2cryptography/8.html/"/>
      <url>/2017/11/19/graphic2cryptography/8.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>使用消息认证码可以确认自己受到的消息是否就是发送者的本意，也就是说，使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。<br>消息认证码是密码学家工具箱中 6 个重要的工具之一。这 6 个重要工具分别是：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。</p><h1 id="2-消息认证码"><a href="#2-消息认证码" class="headerlink" title="2 消息认证码"></a>2 消息认证码</h1><h2 id="2-1-汇款请求是正确的吗"><a href="#2-1-汇款请求是正确的吗" class="headerlink" title="2.1 汇款请求是正确的吗"></a>2.1 汇款请求是正确的吗</h2><p>我们需要关注汇款请求的“完整性”和“认证”这两个性质。即汇款的内容以及汇款请求是否是正确的人发送的请求。<br>消息的完整性（integrity），就是我们在第七章介绍过的“消息没有被篡改”这一性质，完整性也叫一致性。如果消息完整，也就意味着消息没有被篡改。<br>消息的认证（authentication）指的是“消息来自正确的发送者”这一性质，如果能够确认汇款请求确实来自 Alice，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。<br>本章中介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。</p><h2 id="2-2-什么是消息认证码"><a href="#2-2-什么是消息认证码" class="headerlink" title="2.2 什么是消息认证码"></a>2.2 什么是消息认证码</h2><p>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称为 <strong>MAC</strong>。<br>消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的秘钥，它可以输出固定长度的数据，这个数据称为 MAC 值。<br>根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值不需要秘钥，而消息认证码则需要使用发送者和接收者之间共享的秘钥。<br>要计算 MAC 必须持有共享秘钥，没有共享秘钥的人就无法计算 MAC 值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生 1 比特的变化， MAC 值也会产生变化，消息认证码正是利用这一性质来确认完整性的。  </p><p>后面我们会讲到，消息认证码有很多实现方法，大家可以暂且这样理解：<strong>消息认证码是一种与秘钥相关联的单向散列函数</strong>。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_1.png" alt></p><h2 id="2-3-消息认证码的使用步骤"><a href="#2-3-消息认证码的使用步骤" class="headerlink" title="2.3 消息认证码的使用步骤"></a>2.3 消息认证码的使用步骤</h2><p>以 Alice 银行和 Bob 银行的故事为例，来讲解一下消息认证码的使用步骤。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_2.png" alt>  </p><ol><li>发送者 Alice 与接收者 Bob 事先共享秘钥。</li><li>发送者 Alice 根据汇款请求消息计算 MAC 值（使用共享秘钥）。</li><li>发送者 Alice 将汇款请求消息和 MAC 值两者发送给接收者 Bob。</li><li>接收者 Bob 根据接收到的汇款请求消息计算 MAC 值（使用共享秘钥）</li><li>接收者 Bob 将自己计算的 MAC 值与从 Alice 处收到的 MAC 值进行对比。</li><li>如果两个 MAC 值一致，则接收者 Bob 就可以断定汇款请求的确来自 Alice（认证成功）；否则认证失败。</li></ol><h2 id="2-4-消息认证码的秘钥配送问题"><a href="#2-4-消息认证码的秘钥配送问题" class="headerlink" title="2.4 消息认证码的秘钥配送问题"></a>2.4 消息认证码的秘钥配送问题</h2><p>发送者和接收者需要共享秘钥，这一点和我们在第三章中介绍的对称密码很相似。实际上，对称密码的秘钥配送问题在消息认证码中也同样会发生。要解决秘钥配送问题，我们需要像对称密码一样使用一些共享秘钥的方法，例如公钥密码、Diffie-Hellman 秘钥交换、秘钥分配中心，或者使用其它安全的方式发送秘钥等。</p><h1 id="3-消息认证码的应用实例"><a href="#3-消息认证码的应用实例" class="headerlink" title="3 消息认证码的应用实例"></a>3 消息认证码的应用实例</h1><h2 id="3-1-SWIFT"><a href="#3-1-SWIFT" class="headerlink" title="3.1 SWIFT"></a>3.1 SWIFT</h2><p>SWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），其目的是为国际银行间的交易保驾护航。银行和银行之间是通过 SWIFT 来传递交易消息的。而为了确认消息的完整性以及对消息进行验证， SWIFT 中使用了消息认证码。<br>在使用公钥密码进行秘钥交换之前，消息认证码所使用的共享秘钥都是由人来进行配送的。</p><h2 id="3-2-IPsec"><a href="#3-2-IPsec" class="headerlink" title="3.2 IPsec"></a>3.2 IPsec</h2><p>IPsec 是对互联网基本通信协议——IP协议（Internet Protocol）增加安全性的一种方式。在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。</p><h2 id="3-3-SSL-TLS"><a href="#3-3-SSL-TLS" class="headerlink" title="3.3 SSL/TLS"></a>3.3 SSL/TLS</h2><p>SSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码，将在第十四章详解。</p><h1 id="4-消息认证码的实现方法"><a href="#4-消息认证码的实现方法" class="headerlink" title="4 消息认证码的实现方法"></a>4 消息认证码的实现方法</h1><h2 id="4-1-使用单向散列函数实现"><a href="#4-1-使用单向散列函数实现" class="headerlink" title="4.1 使用单向散列函数实现"></a>4.1 使用单向散列函数实现</h2><p>使用 SHA-1、MD5 之类的<strong>单向散列函数</strong>可以实现消息认证码，其中一种实现方法称为 HMAC，具体将在下节介绍。</p><h2 id="4-2-使用分组密码实现"><a href="#4-2-使用分组密码实现" class="headerlink" title="4.2 使用分组密码实现"></a>4.2 使用分组密码实现</h2><p>使用 DES、AES 之类的<strong>分组密码</strong>可以实现消息认证码。<br>将分组密码的秘钥作为消息认证码的共享秘钥来使用。</p><h2 id="4-3-其它实现方法"><a href="#4-3-其它实现方法" class="headerlink" title="4.3 其它实现方法"></a>4.3 其它实现方法</h2><p>使用流密码和公钥密码等也可以实现消息认证码。</p><h1 id="5-HMAC-的详细介绍"><a href="#5-HMAC-的详细介绍" class="headerlink" title="5 HMAC 的详细介绍"></a>5 HMAC 的详细介绍</h1><h2 id="5-1-什么是-HMAC"><a href="#5-1-什么是-HMAC" class="headerlink" title="5.1 什么是 HMAC"></a>5.1 什么是 HMAC</h2><p>HMAC 是一种使用单向散列函数来构造消息认证码的方法，其中的 HMAC 的 H 就是 Hash 的意思。<br>HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，如果将来设计出新的单向散列函数，同样可以使用。<br>使用 SHA-1、MD5、RIPEMD-160 所构造的 HMAC，分别称为 HMAC-SHA-1、HMAC-MD5 和 HMAC-RIPEMD。</p><h2 id="5-2-HMAC-的步骤"><a href="#5-2-HMAC-的步骤" class="headerlink" title="5.2 HMAC 的步骤"></a>5.2 HMAC 的步骤</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_3.png" alt>  </p><h3 id="1-秘钥填充"><a href="#1-秘钥填充" class="headerlink" title="1.秘钥填充"></a>1.秘钥填充</h3><p>如果秘钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到其长度达到单向散列函数的分组长度为止。<br>如果秘钥比分组长度要长，则要用单向散列函数求出秘钥的散列值，然后将这个散列值用作 HMAC 的秘钥。 HMAC-SHA-1 的分组长度为 516 比特。</p><h3 id="2-填充后的秘钥与-ipad-的-XOR"><a href="#2-填充后的秘钥与-ipad-的-XOR" class="headerlink" title="2.填充后的秘钥与 ipad 的 XOR"></a>2.填充后的秘钥与 ipad 的 XOR</h3><p>将填充后的秘钥与被称为 ipad 的比特序列进行 XOR 运算。ipad 是将 001100110 这一比特序列（即 16 进制的 36）不断循环反复直到达到分组长度所形成的比特序列，其中 ipad 的 i 是 inner 的意思。<br>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且<strong>和秘钥相关的比特序列</strong>。这里我们将这个比特序列称为 ipadkey。</p><h3 id="3-与消息组合"><a href="#3-与消息组合" class="headerlink" title="3.与消息组合"></a>3.与消息组合</h3><p>随后，将 ipadkey 与消息进行组合，也就是将和秘钥相关的比特序列（ipadkey）附加在消息的开头。</p><h3 id="4-计算散列值"><a href="#4-计算散列值" class="headerlink" title="4.计算散列值"></a>4.计算散列值</h3><p>将第三步的结果输入单向散列函数，并计算出散列值。</p><h3 id="5-填充后的秘钥与-opad-的-XOR"><a href="#5-填充后的秘钥与-opad-的-XOR" class="headerlink" title="5.填充后的秘钥与 opad 的 XOR"></a>5.填充后的秘钥与 opad 的 XOR</h3><p>将填充后的秘钥与被称为 opad 的比特序列进行 XOR 运算。opad 是将 01011100 这一比特序列（即 16 禁止的 5C）不断循环反复直到达到分组长度所形成的比特序列，其中 opad 的 o 是 outer 的意思。<br>XOR 运算所得到的结果也是一个和单向散列函数的分组长度相同，且和秘钥相关的比特序列。我们将这个比特序列称为 opadkey。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_4.png" alt></p><h3 id="6-与散列值组合"><a href="#6-与散列值组合" class="headerlink" title="6. 与散列值组合"></a>6. 与散列值组合</h3><p>将第四步的散列值拼在 opadkey 后面。</p><h3 id="7-计算散列值"><a href="#7-计算散列值" class="headerlink" title="7.计算散列值"></a>7.计算散列值</h3><p>将第六步的结果输入单向散列函数，并计算出散列值，这个散列值就是最终的 MAC 值。<br>通过上述流程我们可以看出，最后得到的 MAC 值，一定是一个和输入的消息以及秘钥都相关的长度固定的比特序列。</p><h1 id="6-对消息认证码的攻击"><a href="#6-对消息认证码的攻击" class="headerlink" title="6 对消息认证码的攻击"></a>6 对消息认证码的攻击</h1><h2 id="6-1-重放攻击"><a href="#6-1-重放攻击" class="headerlink" title="6.1 重放攻击"></a>6.1 重放攻击</h2><p>Mallory 想到可以通过将事先保存的正确 MAC 值不断重放来发动攻击，如果这种攻击成功的话，就可以让 100 万元滚雪球到 1 亿元。  </p><ol><li>Mallory 到 Alice 银行向自己在 Bob 银行中的账户 汇款 100 万元。于是 Alice 银行为该汇款请求消息计算出正确的 MAC 值，然后将 MAC 和消息一起发送给 Bob 银行。</li><li>Bob 银行用收到的消息自行计算 MAC 值，并与收到的 MAC 值进行对比，由于两个值相等，因此 Bob 银行向 Mallory 的账户汇款 100 万元。</li><li>Mallory 窃听了 Alice 银行发给 Bob 银行的汇款请求消息以及 MAC 值，并保存在自己的计算机中。</li><li>Mallory 将刚刚保存下来的汇款请求消息以及 MAC 值再次发给 Bob 银行。</li><li>Bob 银行重复第二步，于是给 Mallory 的账户汇款 100 万元。</li><li>Mallory 继续重复第四步。</li><li>Bob 银行重复第五步。</li></ol><p>有几种方法可以防御重放攻击。</p><h3 id="1-序号"><a href="#1-序号" class="headerlink" title="1.序号"></a>1.序号</h3><p>约定每次都对发送的消息赋予一个递增的序号，并且在计算 MAC 值时将序号也包含在消息中。这样，由于 Mallory 无法计算序号递增之后的 MAC 值，因此就可以防御重放攻击。这个方法有效，但是对每个通信对象都需要记录最后一个消息的序号。</p><h3 id="2-时间戳"><a href="#2-时间戳" class="headerlink" title="2.时间戳"></a>2.时间戳</h3><p>约定在发送消息时包含当前的时间，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。</p><h3 id="3-nonce"><a href="#3-nonce" class="headerlink" title="3.nonce"></a>3.nonce</h3><p>在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。虽然有效，但通信的数据量会有所增加。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/8_5.png" alt></p><h2 id="6-2-密码推测攻击"><a href="#6-2-密码推测攻击" class="headerlink" title="6.2 密码推测攻击"></a>6.2 密码推测攻击</h2><p>和对单向散列函数的攻击一样，对消息认证码也可以进行<strong>暴力破解</strong>以及<strong>生日攻击</strong>（7.6.2节）。<br>对于消息认证码来说，应保证<strong>不能根据 MAC 值推测出通信双方所使用的秘钥</strong>。如果 Mallory 能够从 MAC 值反算出秘钥，就可以进行篡改、伪装等攻击。例如 HMAC 中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC 值推测出秘钥的。<br>此外，在生成消息认证码所使用的秘钥，必须用高强度的伪随机数生成器。</p><h1 id="7-消息认证码无法解决的问题"><a href="#7-消息认证码无法解决的问题" class="headerlink" title="7 消息认证码无法解决的问题"></a>7 消息认证码无法解决的问题</h1><h2 id="7-1-对第三方证明"><a href="#7-1-对第三方证明" class="headerlink" title="7.1 对第三方证明"></a>7.1 对第三方证明</h2><p>假设 Bob 想要向第三方验证着 Victor 证明这条消息的却是 Alice 发送的，但是用消息认证码无法进行这样的证明，因为，Victor 要校验 MAC 值，就需要知道 Alice 和 Bob 之间共享的秘钥，假设 Bob 将秘钥告诉 Victor，但是 Victor 有理由相信，这条消息有可能是 Bob 伪装 Alice 发送的。使用第九章的数字签名就可以实现对第三方的证明。</p><h2 id="7-2-防止否认"><a href="#7-2-防止否认" class="headerlink" title="7.2 防止否认"></a>7.2 防止否认</h2><p>假设 Bob 收到了包含 MAC 值得消息，这个 MAC 值是用 Alice 和 Bob 共享的秘钥计算出来的，因此 Bob 能够判断这条消息的确来自 Alice。但是， Alice 可以说“这条消息是 Bob 自己编的吧”，说白了，就是 Alice 和 Bob 吵起来了。<br>即便 Bob 拿 MAC 值举证，Victor 也无法判断 Alice 和 Bob 谁才是正确的，也就是说，用消息认证码无法<strong>防止否认</strong>（nonrepudiation）。这种情况，数字签名同样可以实现防止否认。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>本章介绍的消息认证码，是对消息进行认证并确认其完整性的技术，通过使用发送者和接收者之间共享的秘钥，就可以识别出是否存在伪装和篡改行为。<br>其可以使用单向散列函数和对称密码等技术来实现，本章重点介绍了通过单向散列函数来实现的 HMAC。<br>消息认证码的缺点在于，由于发送者和接收者共享相同的秘钥，因此会产生无法对第三方证明以及无法否认等问题。<br>下一章的数字签名可以解决这些问题。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><ol><li>使用消息认证码能够确保消息的机密性。注：消息本身的机密性不是由消息认证码决定的。</li><li>使用消息认证码能够识别出篡改行为。</li><li>使用消息认证码需要发送者和接收者之间共享的秘钥。</li><li>使用消息认证码能够防止否认。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>七、单向散列函数（获取消息的“指纹”）</title>
      <link href="/2017/11/19/graphic2cryptography/7.html/"/>
      <url>/2017/11/19/graphic2cryptography/7.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”即可。<br>本章中，使用单向散列函数就可以获取消息的“指纹”，通过对比“指纹”，就能够知道两条消息是否一致。<br>我们将详细介绍现在使用非常广泛的 SHA-1 单向散列函数，并思考对单向散列函数的攻击方法。</p><h1 id="2-什么是单向散列函数"><a href="#2-什么是单向散列函数" class="headerlink" title="2 什么是单向散列函数"></a>2 什么是单向散列函数</h1><h2 id="2-1-这个文件是不是真的呢"><a href="#2-1-这个文件是不是真的呢" class="headerlink" title="2.1 这个文件是不是真的呢"></a>2.1 这个文件是不是真的呢</h2><p>Alice 终于完成了一个软件开发，接下来只要把文件从 Alice 的硬盘中拷贝到 CD 上就可以了。不过，把文件写到 CD 上非常耗时， Alice 已经很累了，她决定今天晚上早上回家休息，明天再继续弄。<br>第二天， Alice 来到公司准备把文件写入 CD ，但她忽然产生了这样的疑问：<br>“这个文件和我昨天晚上生成的文件是一样的吗？”<br>Alice 的疑问是这样的——会不会有人操作 Alice 的计算机，将文件改写了呢？也有可能通过网络入侵 Alice 的计算机。或者，也许 Alice 的计算机感染了病毒，造成文件被篡改……在这里，我们姑且把篡改文件的这个主体称为“主动攻击者 Mallory”。总而言之，Alice 需要知道从昨天到今天这段时间内， Mallor有 是否篡改了文件的内容。  </p><p>也就是说，Alice 需要确定自己的文件的完整性（integrity）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_1.png" alt><br>稍微想一想我们就能找一种确认文件完整性的简单方法——在回家之前先把文件拷贝到一个安全的地方保存，第二天在用这个文件工作之前，先将其和事先保存的文件进行对比就可以了。如果两者一致，那就说明文件没有被篡改。<br>不过，下图这种确认完整性的方法，其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_2.png" alt><br>这里还存在一个效率问题。如果需 需要确认完整性的文件非常巨大，那么文件的拷贝、保存以及比较都将非常耗时。<br>我们能不能获取到 Alice 所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_3.png" alt><br>本章要介绍的单向散列函数，就是一种采集文件指纹的技术。单向散列函数所生成的散列值，就相当于消息的指纹。</p><h2 id="2-2-什么是单向散列函数"><a href="#2-2-什么是单向散列函数" class="headerlink" title="2.2 什么是单向散列函数"></a>2.2 什么是单向散列函数</h2><p>单向散列函数（one-way hash function）有一个输入和一个输出，其中输入称为消息（message），输出称为散列值（hash value）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_4.png" alt><br>这里的消息可以是任何形式的消息，图像、声音、视频。因为无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。<br>散列值的长度和消息的长度无关。以 SHA-1 单向散列函数为例，它所计算出的散列值的长度永远是 160 比特（20字节）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_5.png" alt><br>由于散列值很短，因此很容易处理和使用。  </p><p>回家之前，Alice 用单向散列函数计算文件的散列值：<br>35 36 37 38 39 A1 D2 F4 J5 5B 9J 35 36 37 38 39 A1 D2 F4 J5<br>单向散列函数所输出的散列值的长度是固定的（在这个例子中是 20 字节），无论 Alice 的文件大小是多大，散列值永远都是 20 字节（160比特）。Alice 可以将这个值打印出来，保存，或者拿回家藏在枕头下面~<br>第二天早上，Alice 再次计算硬盘中文件的散列值，如果再次计算出的散列值和昨晚的散列值相同，就可以判断这个文件是真的，否则就是不一样的。</p><h2 id="2-3-单向散列函数的性质"><a href="#2-3-单向散列函数的性质" class="headerlink" title="2.3 单向散列函数的性质"></a>2.3 单向散列函数的性质</h2><h3 id="1-根据任意长度的消息计算出固定长度的散列值"><a href="#1-根据任意长度的消息计算出固定长度的散列值" class="headerlink" title="1. 根据任意长度的消息计算出固定长度的散列值"></a>1. 根据任意长度的消息计算出固定长度的散列值</h3><h3 id="2-能够快速计算出散列值"><a href="#2-能够快速计算出散列值" class="headerlink" title="2.能够快速计算出散列值"></a>2.能够快速计算出散列值</h3><h3 id="3-消息不同散列值也不同"><a href="#3-消息不同散列值也不同" class="headerlink" title="3.消息不同散列值也不同"></a>3.消息不同散列值也不同</h3><p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为<strong>碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被认为地发现碰撞。<br>难以发现碰撞的性质称为<strong>抗碰撞性（collision resistance）</strong>。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。<br>我们以 Alice 用单向散列函数来检查文件完整性的场景为例，现在，我们假设 Alice 所使用的单向散列函数不具备抗碰撞性。<br>Alice 在回家之前得到了散列值，Alice 在睡觉的时候，Mallory 入侵了 Alice 的计算机，并改写了 Alice 的文件。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_6.png" alt><br>由于假设 Alice 的单向散列函数不具备抗碰撞性，因此 Mallory 能够找到一种改写文件的方法，使得改写后文件的散列值不会发生变化，因此 Alice 将 Mallory 改写后的文件写入了 CD。  </p><p>这里所说的抗碰撞性，指的是难以找到另外一条具备特定散列值的消息。当给定某条消息的散列值时，单向散列函数必须确保<strong>要找到和该条消息具有相同散列值的另外一条消息是非常困难的</strong>。这一性质称为<strong>弱抗碰撞性</strong>。单向散列函数都必须具备弱抗碰撞性。  </p><p>和弱抗碰撞性相对的，还有<strong>强抗碰撞性</strong>。所谓强抗碰撞性，是指<strong>要找到散列值相同的两条不同的消息是非常困难的</strong>这一性质。在这里，散列值可以是任意值。  </p><p>密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p><h3 id="4-具备单向性"><a href="#4-具备单向性" class="headerlink" title="4. 具备单向性"></a>4. 具备单向性</h3><h2 id="2-4-关于术语"><a href="#2-4-关于术语" class="headerlink" title="2.4 关于术语"></a>2.4 关于术语</h2><p><strong>单向散列函数</strong>也称为<strong>消息摘要函数（message digest function）</strong>、<strong>哈希函数</strong>或者<strong>杂凑函数</strong>。<br>输入单向散列函数的消息也称为<strong>原像（pre-image）</strong>。<br>单向散列函数输出的<strong>散列值</strong>也称为<strong>消息摘要（message digest）</strong>或者指纹（fingerprint）**。<br>完整性也称为一致性。<br>“散列”的英文 “hash” 一词，原意是“斧子”，后来被引申为“剁碎的肉末”。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。</p><h1 id="3-单向散列函数的实际应用"><a href="#3-单向散列函数的实际应用" class="headerlink" title="3 单向散列函数的实际应用"></a>3 单向散列函数的实际应用</h1><h2 id="3-1-检测软件是否被篡改"><a href="#3-1-检测软件是否被篡改" class="headerlink" title="3.1 检测软件是否被篡改"></a>3.1 检测软件是否被篡改</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/7_7.png" alt></p><h2 id="3-2-基于口令的加密"><a href="#3-2-基于口令的加密" class="headerlink" title="3.2 基于口令的加密"></a>3.2 基于口令的加密</h2><p>单向散列函数也被用于基于口令的加密（Password Based Encryption，PBE）。<br>PBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算起散列值，然后将这个散列值用作加密的秘钥。通过这样的方法能够防御针对口令的字典攻击，将在第十一章详解。</p><h2 id="3-3-消息认证码"><a href="#3-3-消息认证码" class="headerlink" title="3.3 消息认证码"></a>3.3 消息认证码</h2><p>使用单向散列函数可以构造消息认证码。<br>消息认证码是将“发送者和消息接收者之间的共享秘钥”和“消息”进行混合后计算出的散列值，使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。<br>消息认证码在 SSL/TLS 中也得到了运用，将在第十四章详解。</p><h2 id="3-4-数字签名"><a href="#3-4-数字签名" class="headerlink" title="3.4 数字签名"></a>3.4 数字签名</h2><p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名，将在第九章详解。</p><h2 id="3-5-伪随机数生成器"><a href="#3-5-伪随机数生成器" class="headerlink" title="3.5 伪随机数生成器"></a>3.5 伪随机数生成器</h2><p>使用单向散列函数可以构造伪随机数生成器。<br>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性，将在第十二章详解。</p><h2 id="3-6-一次性口令"><a href="#3-6-一次性口令" class="headerlink" title="3.6 一次性口令"></a>3.6 一次性口令</h2><p>一次性口令（one-time password），经常被用于服务器对客户端的合法性认证，在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p><h1 id="4-单向散列函数的具体例子"><a href="#4-单向散列函数的具体例子" class="headerlink" title="4 单向散列函数的具体例子"></a>4 单向散列函数的具体例子</h1><h2 id="4-1-MD4、MD5"><a href="#4-1-MD4、MD5" class="headerlink" title="4.1 MD4、MD5"></a>4.1 MD4、MD5</h2><p>MD4 是由 Rivest 于 1990 年设计的单向散列函数，能够产生 128 比特的散列值，由于寻找到了 MD4 散列碰撞的方法，因此现在它已经不安全了。<br>MD5 是由 Rivest 于 1991 年设计的单向散列函数，能够产生 128 比特的散列值，由于 MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具有相同散列值的两条不同的消息，因此它也已经不安全了。<br>MD 是消息摘要（Message Digest）的缩写。</p><h2 id="4-2-SHA-1、SHA-256、SHA-384、SHA-512"><a href="#4-2-SHA-1、SHA-256、SHA-384、SHA-512" class="headerlink" title="4.2 SHA-1、SHA-256、SHA-384、SHA-512"></a>4.2 SHA-1、SHA-256、SHA-384、SHA-512</h2><p>SHA-1 是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数。<br>SHA-256、SHA-384、SHA-512 都是由 NIST 设计的单向散列函数，它们的散列值长度分别为 256 比特、384 比特、512 比特。统称为 SHA-2。<br>它们的消息长度都存在上限。SHA-1 的强抗碰撞性已于 2005 年被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。</p><h2 id="4-3-RIPEMD-160"><a href="#4-3-RIPEMD-160" class="headerlink" title="4.3 RIPEMD-160"></a>4.3 RIPEMD-160</h2><p>RIPEMD-160 是 1996 年设计的一种能够产生 160 比特的散列值的单向散列函数。RIPEMD 的强抗碰撞性已于 2004 年被攻破，但 RIPEMD-160 还尚未被攻破。</p><h2 id="4-4-AHS（Advanced-Hash-Standard）与-SHA-3"><a href="#4-4-AHS（Advanced-Hash-Standard）与-SHA-3" class="headerlink" title="4.4 AHS（Advanced Hash Standard）与 SHA-3"></a>4.4 AHS（Advanced Hash Standard）与 SHA-3</h2><p>在 2005 年 SHA-1 的强抗碰撞性被攻破的背景下， NIST 开始着手制定用于取代 SHA-1 的下一代单向散列函数 SHA-3 。SHA-3 和 AES 一样采用公开竞赛的方式进行标准化。</p><h1 id="5-单向散列函数-SHA-1"><a href="#5-单向散列函数-SHA-1" class="headerlink" title="5 单向散列函数 SHA-1"></a>5 单向散列函数 SHA-1</h1><p>此章主要讲解其具体算法，有感兴趣者请看原书。</p><h1 id="6-对单向散列函数的攻击"><a href="#6-对单向散列函数的攻击" class="headerlink" title="6 对单向散列函数的攻击"></a>6 对单向散列函数的攻击</h1><h2 id="6-1-暴力破解（攻击故事-1-）"><a href="#6-1-暴力破解（攻击故事-1-）" class="headerlink" title="6.1 暴力破解（攻击故事 1 ）"></a>6.1 暴力破解（攻击故事 1 ）</h2><p>Alice 在计算机上写了一份合同。晚上，攻击者 Mallory 入侵了计算机，他想将其中的：</p><blockquote><p>Alice 要支付的金额为 100 万元。</p></blockquote><p>改成：</p><blockquote><p>Alice 要支付的金额为 1 亿元。</p></blockquote><p>不过，不仅要修改合同内容，还要不能改变散列值。<br>Mallory 可以从文档文件所具有的<strong>冗余性</strong>入手。所谓文档文件的冗余性，是指在不改变文档意思的前提下能够对文件的内容进行修改的程度。<br>举个例子，下面的这些句子基本上说的都是一个意思：<br>Alice 要支付的金额为 1 亿元。<br>Alice 要支付的金额为壹亿元。<br>Alice 要支付的金额为 100000000 元。<br>Alice 应支付 1 亿元。<br>作为报酬， Alice 需要支付 1 亿元。  </p><p>除此之外，还有一些通过机器来进行修改的方法。例如，可以在文件的末尾添加 1 个、2 个、3 个甚至更多的空格，或者还可以对文档中的每一个字稍微改变一些颜色，这都不会影响文档的意思。在这里需要注意的是，即便我们对文件所进行的修改是无法被人类察觉的，但只要是对文件进行了修改，单向散列函数就会产生不同的散列值。  </p><p>于是，Mallory 利用文档的冗余性，通过机器生成了一大推“支付一亿元的合同”。如果在这一大推合同中，能够找到一个合同和 Alice 原本的“ 100 万元合同”恰好产生相同的散列值，那 Mallory 就算是成功了。<br>在这里，Mallory 所进行的攻击就是<strong>暴力攻击</strong>。正如对密码可以进行暴力破解一样，对单向散列函数也可以进行暴力破解。这相当于一种<strong>试图破解单向散列函数的“弱抗碰撞性”的攻击</strong>。在这种情况下，暴力破解需要尝试的次数可以根据散列值得长度计算出来。以 SHA-1 为例，由于它的散列值长度为 160 比特，因此最多只要尝试 2160 次就能够找到目标消息了。（这里不懂为什么是 2160 次）</p><h2 id="6-2-生日攻击（攻击故事-2-）"><a href="#6-2-生日攻击（攻击故事-2-）" class="headerlink" title="6.2 生日攻击（攻击故事 2 ）"></a>6.2 生日攻击（攻击故事 2 ）</h2><p>编写合同的人不是 Alice 而是主动攻击者 Mallory 。 Mallory 事先准备两份具备相同散列值的“100 万元合同”和“一亿元合同”，然后将“100  万元合同”交给 Alice 让她计算散列值。随后， Mallory 再像故事 1 中一样， 掉包合同。<br>这里 Mallory 所进行的攻击不是寻找生成特定散列值的消息，而是要找到散列值相同的两条消息，而散列值可以是任意值。这样的攻击，一般称为<strong>生日攻击（birthday attack）</strong>，这是一种<strong>试图破解单向散列函数的“强抗碰撞性”的攻击。</strong><br>这里存在一个生日驳论的数学思想，有兴趣的请自行谷歌。</p><h1 id="7-单向散列函数无法解决的问题"><a href="#7-单向散列函数无法解决的问题" class="headerlink" title="7 单向散列函数无法解决的问题"></a>7 单向散列函数无法解决的问题</h1><p>假如，攻击者 Mallory 伪装成 Alice ，向 Bob 同时发送了消息和散列值。Bob 通过单向散列函数检查消息的完整性，但是无法检查出发送者的身份是否被 Mallory 进行了伪装。也就是说，<strong>单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。</strong><br>因此我们还需要进行<strong>认证</strong>，用于认证的技术包括<strong>消息认证码</strong>和<strong>数字签名</strong>。消息认证码能够向通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。<br>认证需要使用秘钥，也就是通过对消息附加 Alice 的秘钥（只有 Alice 才知道的密码信息）来确保消息真的属于 Alice。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>本章学习了用于确认消息完整性的单向散列函数，其能够根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。这种技术对辨别篡改非常有效。<br>以及学习了代表性的单向散列函数——SHA-1的实现方法以及破解方法——暴力破解和生日攻击。<br>但是，单向散列函数，虽然可以辨别出篡改，但无法辨别伪装。要解决这个问题，我们需要消息验证码和数字签名。将在下一章介绍消息验证码。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><ol><li>MD5 是一种能够将任意长度的数据转换为 128 比特的对称密码算法。</li><li>要找出和某条消息具备相同散列值的另一条消息是非常困难的。</li><li>要找出具有相同散列值但互不相同的两条消息是非常困难的。</li><li>SHA-1 的散列值长度为 20字节。</li><li>如果消息仅被改写了 1 比特，则散列值也仅发生 1 比特的改变。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六、混合密码系统</title>
      <link href="/2017/11/18/graphic2cryptography/6.html/"/>
      <url>/2017/11/18/graphic2cryptography/6.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-混合动力汽车"><a href="#1-混合动力汽车" class="headerlink" title="1 混合动力汽车"></a>1 混合动力汽车</h1><p>在介绍混合密码系统之前，我们先来说说混合动力汽车。混合动力汽车同时装备了电动机和发动机两种动力系统。<br>电动机由电池驱动，发动机由汽油驱动。当速度较慢时，汽车由电动机驱动，能够安静地行驶。当速度加快时，动力切换到发动机，以便输出更强的动力。<br>当踩下刹车时，损失的能量中的一部分能够被回收并用来对电池进行充电。  </p><p>混合动力汽车将电动机和发动机两种不同的动力融合在一起，从而发挥了两种动力各自的优势。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>本章将学习由对称密码和公钥密码相结合的混合密码系统。  </p><p>混合密码系统由对称密码来加密明文，用公钥密码来加密对称密码中所使用的密码。通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。</p><h1 id="3-混合密码系统"><a href="#3-混合密码系统" class="headerlink" title="3 混合密码系统"></a>3 混合密码系统</h1><h1 id="3-1-对称密码和公钥密码"><a href="#3-1-对称密码和公钥密码" class="headerlink" title="3.1 对称密码和公钥密码"></a>3.1 对称密码和公钥密码</h1><p>对称密码存在秘钥配送问题，而公钥密码虽然解决了秘钥配送问题，但是还有两个很大的问题：  </p><ol><li>公钥密码的处理速度远远低于对称密码</li><li>公钥密码难以抵御中间人攻击  </li></ol><p>本章介绍的混合密码系统就是解决问题 1 。而解决问题 2 则需要对公钥进行认证，将在第十章进行介绍</p><h2 id="3-2-混合密码系统"><a href="#3-2-混合密码系统" class="headerlink" title="3.2 混合密码系统"></a>3.2 混合密码系统</h2><ol><li>用对称密码加密信息</li><li>通过伪随机数生成器生成对称密码的会话秘钥</li><li>通过公钥密码加密会话秘钥</li><li>从混合密码系统外部赋予公钥密码加密时使用的秘钥</li></ol><p>混合密码系统运行了伪随机数生成器、对称密码和公钥密码这三种密码技术。正是通过这三种密码技术的结合，才创造出了一种兼具对称密码和公钥密码优点的密码方式。<br>即利用了对称密码的解密速度，公钥密码的机密性。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_1.png" alt></p><h2 id="3-3-加密"><a href="#3-3-加密" class="headerlink" title="3.3 加密"></a>3.3 加密</h2><p>流程图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_2.png" alt>  </p><h3 id="1-明文、秘钥、密文"><a href="#1-明文、秘钥、密文" class="headerlink" title="1. 明文、秘钥、密文"></a>1. 明文、秘钥、密文</h3><p>首先看中间虚线围成的大方框，这里就是混合密码系统的加密部分。<br>上面标有“消息”的方框就是混合密码系统中的明文，左边标有“接收者的公钥”的方框就是混合密码系统中的秘钥，而下面标有“用公钥密码加密加密的会话秘钥”和<br>“用对称密码加密的消息”所组成的方框，就是混合密码系统中的密文。</p><h3 id="2-加密消息"><a href="#2-加密消息" class="headerlink" title="2. 加密消息"></a>2. 加密消息</h3><p>中间的大虚线方框分成左右两部分。<br>右半部分是“加密消息”的部分（对称密码），左半部分是“加密会话秘钥”的部分（公钥密码）。<br>消息的加密方法和对称密码的一般加密方法相同，当消息很长时，则需要使用第四章介绍的分组密码 的模式。即便是非常长的消息，也可以通过对称密码快速完成加密。<br>这就是右半部分所进行的处理。</p><h3 id="3-加密会话秘钥"><a href="#3-加密会话秘钥" class="headerlink" title="3. 加密会话秘钥"></a>3. 加密会话秘钥</h3><p>左半部分进行的是会话秘钥的生成和加密操作。<br>会话秘钥（session key）是指为本次通信而生成的临时秘钥，它一般是通过伪随机数生成器产生的。伪随机数生成器所产生的会话秘钥同时也会被传递给右半部分，<br>作为对称密码的秘钥使用。<br>接下来，通过公钥密码对会话秘钥进行加密，公钥密码加密所使用的秘钥是接收者的公钥。  </p><p><strong>会话秘钥是对称密码的秘钥，同时也是公钥密码的明文</strong>。请大家一定要理解会话秘钥的双重性！</p><h3 id="4-组合"><a href="#4-组合" class="headerlink" title="4. 组合"></a>4. 组合</h3><p>如何上面的内容都理解了，剩下的就简单多了。<br>我们从右半部分可以得到“用对称密码加密的消息”，从左半部分可以得到“用公钥密码加密的会话秘钥”，然后我们将两者组合起来。所谓组合，就是把它们按顺序拼在一起。<br>组合之后的数据就是混合密码系统整体的密文。</p><h2 id="3-4-解密"><a href="#3-4-解密" class="headerlink" title="3.4 解密"></a>3.4 解密</h2><p>流程图如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_3.png" alt></p><h3 id="1-分离"><a href="#1-分离" class="headerlink" title="1. 分离"></a>1. 分离</h3><p>只要发送者和接收者事先先约定好密文的结构，将“用公钥密码加密的会话秘钥”和“用对称密码加密的消息”分离的操作就很容易完成。</p><h3 id="2-解密会话秘钥"><a href="#2-解密会话秘钥" class="headerlink" title="2. 解密会话秘钥"></a>2. 解密会话秘钥</h3><p>会话秘钥可以用公钥密码进行解密，为此我们就需要解密秘钥，也就是接收者的私钥。除了持有私钥的人以外，其他人都不能够解密会话秘钥。<br>解密后的会话秘钥将被用作解密消息的秘钥。</p><h3 id="3-解密消息"><a href="#3-解密消息" class="headerlink" title="3. 解密消息"></a>3. 解密消息</h3><p>消息可以使用对称密码进行解密，解密的秘钥就是刚刚用公钥解密的会话秘钥。<br>上述流程正好是“混合密码系统的加密”的逆操作。</p><h2 id="3-5-混合密码系统的具体例子"><a href="#3-5-混合密码系统的具体例子" class="headerlink" title="3.5 混合密码系统的具体例子"></a>3.5 混合密码系统的具体例子</h2><p>混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的秘钥配送问题。<br>著名的密码软件 PGP、 以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码系统，具体在第十三章探讨。</p><h1 id="4-怎样才是高强度的混合密码系统"><a href="#4-怎样才是高强度的混合密码系统" class="headerlink" title="4 怎样才是高强度的混合密码系统"></a>4 怎样才是高强度的混合密码系统</h1><h2 id="4-1-伪随机数生成器"><a href="#4-1-伪随机数生成器" class="headerlink" title="4.1 伪随机数生成器"></a>4.1 伪随机数生成器</h2><p>混合密码系统中，随机数生成器被用于产生会话秘钥。如果伪随机数生成器的算法很差，生成的会话秘钥就有可能被攻击者推测出来。<br>会话秘钥中哪怕只有部分比特被推测出来也是很危险的，因为会话秘钥的秘钥空间不大。很容易通过暴力破解来发动攻击。关于针对伪随机数生成器的<br>攻击方法，将在第十二章详解。</p><h2 id="4-2-对称密码"><a href="#4-2-对称密码" class="headerlink" title="4.2 对称密码"></a>4.2 对称密码</h2><p>混合密码系统中，对称密码被用于加密消息。当然，我们还需要使用高强度的对称密码算法，并确保秘钥具有足够的长度。此外，我们还需要选择合适的分组密码模式。</p><h2 id="4-3-公钥密码"><a href="#4-3-公钥密码" class="headerlink" title="4.3 公钥密码"></a>4.3 公钥密码</h2><p>混合密码系统中，公钥密码被用于加密会话秘钥。我们需要使用高强度的公钥密码算法，并确保秘钥具有足够的长度。</p><h2 id="4-4-秘钥长度的平衡"><a href="#4-4-秘钥长度的平衡" class="headerlink" title="4.4 秘钥长度的平衡"></a>4.4 秘钥长度的平衡</h2><p>对称密码和公钥密码的秘钥长度必须具备同等的强度。<br>然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话秘钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就能够被破译了。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/6_4.png" alt></p><h1 id="5-密码技术的组合"><a href="#5-密码技术的组合" class="headerlink" title="5 密码技术的组合"></a>5 密码技术的组合</h1><p>本章介绍的混合密码系统是将对称密码和公钥密码的结合，从而构建出一种同时发挥两者优势的系统。密码技术的组合经常被用于构建一些实用的系统。<br>例如，第四章中介绍的<strong>分组密码模式</strong>，就是将只能加密固定长度的数据的 分组密码进行组合，从而使其能够对更长的明文进行加密的方法。通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。  </p><p><strong>三重 DES</strong>是将 3 个 DES 组合在一起，从而形成一种秘钥比 DES 更长的对称密码。通过加密-解密-加密这样的连接方式，不但可以维持和 DES 的兼容性，同时还能够选择性地使用 DES-DES2 这种秘钥长度较短的密码。  </p><p>对称密码的内部也存在一些有趣的节后。例如第三章中介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。<br>在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做一个简单的介绍。  </p><p>数字签名，是由单向散列函数和公钥密码组合而成的。<br>证书，是由公钥和数字签名组合而成的。<br>消息认证码，是由单向散列函数和秘钥组合而成的，也可以通过对称密码来生成。<br>伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。<br>还有一些很神奇的系统，例如电子投票、电子货币、能够在不知道内容的情况下签名的盲签名（zero-knowledge proof）等。</p><h1 id="6-本章小结"><a href="#6-本章小结" class="headerlink" title="6 本章小结"></a>6 本章小结</h1><p> 本章中我们学习了将对称密码和公钥密码的优势相结合而成的混合密码系统。<br>到此为止，我们已经了解了密码这一保证机密性的技术，然而，密码技术所保护的不仅仅是机密性。<br>从下一章开始，我们将学习确认消息完整性、进行认证以及防止否认的技术。</p><h1 id="7-小测验"><a href="#7-小测验" class="headerlink" title="7 小测验"></a>7 小测验</h1><ol><li>混合密码系统是用对称密码对消息进行加密的。</li><li>混合密码系统是用公钥密码的私钥对对称密码的秘钥进行加密的。</li><li>由于会话秘钥已经通过公钥密码进行了加密，因此会话秘钥的长度较短也没有问题。</li><li>混合密码系统的解密过程是按照“公钥密码解密”-&gt;“对称密码解密”的顺序来进行处理的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、公钥密码</title>
      <link href="/2017/11/15/graphic2cryptography/5.html/"/>
      <url>/2017/11/15/graphic2cryptography/5.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-投币寄物柜的使用方法"><a href="#1-投币寄物柜的使用方法" class="headerlink" title="1 投币寄物柜的使用方法"></a>1 投币寄物柜的使用方法</h1><p>介绍公钥密码之前，先说说投币寄物柜：将物品放入寄物柜中，然后投入硬币并拔出钥匙，就可以将寄物柜关闭了。关闭后的寄物柜，没有钥匙是无法打开的。<br>只要有硬币，任何人都可以关闭寄物柜，但寄物柜一旦被关闭，只有使用钥匙才能打开，而不是硬币。  </p><p>因此我们可以说，硬币是关闭寄物柜的密钥，而钥匙则是打开寄物柜的密钥。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用<br>公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。  </p><p>本章先探讨一下密钥配送问题，然后再讲解公钥密码是如何解决密钥配送问题的。最后，将介绍一种最常用的公钥密码——RSA。</p><h1 id="3-密钥配送问题"><a href="#3-密钥配送问题" class="headerlink" title="3 密钥配送问题"></a>3 密钥配送问题</h1><h2 id="3-1-什么是密钥配送问题"><a href="#3-1-什么是密钥配送问题" class="headerlink" title="3.1 什么是密钥配送问题"></a>3.1 什么是密钥配送问题</h2><p>在现实世界中使用对称密码时，我们一定会遇到密钥配送问题。由于密码算法本来就应该是以公开为前提的，隐蔽式安全性（security by obscurity）是<br>非常危险的。  </p><p>密钥必须要发送，但又不能发送，这就是对称密码的密钥配送问题，解决密钥配送问题的方法有以下几种：  </p><ol><li>通过事先共享密钥来解决</li><li>通过密钥分配中心来解决</li><li>通过 Diffie-Hellman 密钥交换来解决</li><li>通过公钥密码来解决</li></ol><h2 id="3-2-通过事先共享密钥来解决"><a href="#3-2-通过事先共享密钥来解决" class="headerlink" title="3.2 通过事先共享密钥来解决"></a>3.2 通过事先共享密钥来解决</h2><p>事先用安全的方式将密钥交给对方，这称为密钥的事先共享。但是有一定的局限性，如果是网上认识的抑或需要邮寄的，都有可能被别人窃取。以及，如果一个<br>公司的 1000 名员工需要彼此进行加密通信，则需要 1000 * 999 / 2 = 499500 个密钥！</p><h1 id="3-3-通过秘钥分配中心来解决"><a href="#3-3-通过秘钥分配中心来解决" class="headerlink" title="3.3 通过秘钥分配中心来解决"></a>3.3 通过秘钥分配中心来解决</h1><p>公司存在一台专门负责秘钥分配的计算机，它保存了所有员工的秘钥，当有新员工入职时，秘钥分配中心会为该员工生成一个新的秘钥，并保存。而新员工则会<br>从入职时从秘钥分配中心的计算机上领取自己的秘钥。<br>这样一来，秘钥分配中心就拥有所有员工的秘钥，而每个员工则拥有自己的秘钥。  </p><p>那么 Alice 再向 Bob 发送加密邮件时，就需要进行以下步骤：  </p><ol><li>Alice 向秘钥分配中心发出希望与 Bob 进行通信的请求</li><li>秘钥分配中心通过伪随机数生成器生成一个会话秘钥，这个秘钥是供 Alice 与 Bob 在本次通信中使用的临时秘钥</li><li>秘钥分配中心从数据库中取出 Alice 的秘钥和 Bob 的秘钥</li><li>秘钥分配中心用 Alice 的秘钥对会话秘钥进行加密，并发送给 Alice</li><li>秘钥分配中心用 Bob 的秘钥对会话秘钥进行加密，并发送给 Bob</li><li>Alice 对来自秘钥分配中心的会话秘钥（已使用 Alice 的秘钥加密）进行解密，得到会话秘钥</li><li>Alice 用会话秘钥对邮件进行加密，并将邮件发送给 Bob</li><li>Bob 对来自秘钥分配中心的会话秘钥（已使用 Bob 的秘钥加密）进行解密，得到会话秘钥</li><li>Bob 用会话秘钥对来自 Alice 的密文进行解密</li><li>Alice 和 Bob 删除会话秘钥  </li></ol><p>以上就是通过秘钥分配中心完成 Alice 与 Bob 的通信过程，缺点显而易见：  </p><ol><li>随着员工增加，秘钥分配中心负荷增大</li><li>如果秘钥分配中心计算机发生故障，全公司的加密通信就会瘫痪</li><li>攻击者直接对秘钥分配中心下手，盗取秘钥数据库，后果十分严重</li></ol><h2 id="3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题"><a href="#3-4-通过-Diffie-Hellman-秘钥交换来解决秘钥配送问题" class="headerlink" title="3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题"></a>3.4 通过 Diffie-Hellman 秘钥交换来解决秘钥配送问题</h2><p>解决秘钥配送问题的第三种方法，称为 Diffie-Hellman 秘钥交换。这里的交换，指的是发送者和接收者之间相互传递信息的意思。<br>根据交换的信息， Alice 和 Bob 可以生成相同的秘钥，而窃听者就算得到交换的信息，也无法生成相同的秘钥，将在第十一章详解。</p><h2 id="3-5-通过公钥密码来解决秘钥配送问题"><a href="#3-5-通过公钥密码来解决秘钥配送问题" class="headerlink" title="3.5 通过公钥密码来解决秘钥配送问题"></a>3.5 通过公钥密码来解决秘钥配送问题</h2><p>第四种方法，就是公钥密码。  </p><p>在公钥密码中，加密秘钥和解密秘钥不同，只要拥有加密秘钥，任何人都可以进行加密，但没有解密秘钥是无法解密的。因此，公钥密码的重要特性是，只有拥有<br>解密秘钥的人才能够进行解密。  </p><p>接受者事先将加密秘钥发送给发送者，这个加密秘钥即使被窃听获取也没问题。发送者使用加密秘钥对通信内容进行加密并发送给接收者，而只要拥有解密秘钥<br>的人（即发送者本人）才能够解密。这样，就不用讲解密秘钥配送给接收者了，也就是说，对称密码的秘钥配送问题，可以通过使用公钥密码来结局。</p><h1 id="4-公钥密码"><a href="#4-公钥密码" class="headerlink" title="4 公钥密码"></a>4 公钥密码</h1><h2 id="4-1-什么是公钥密码"><a href="#4-1-什么是公钥密码" class="headerlink" title="4.1 什么是公钥密码"></a>4.1 什么是公钥密码</h2><p>公钥密码（public-key cryptography）中，秘钥分为加密秘钥和解密秘钥两种。加密秘钥是发送者加密时使用的，而解密秘钥则是接收者解密时使用的。<br>加密秘钥和解密秘钥的区别：  </p><ol><li>发送者只需要加密秘钥</li><li>接收者只需要解密秘钥</li><li>解密秘钥不可以被窃听者获取</li><li>加密秘钥被窃听者获取也没问题</li></ol><p>也就是说，解密秘钥从一开始就是由接收者自己保管的，因此只要将加密秘钥发送给发送者就可以解决秘钥配送问题了，根本不需要配送解密秘钥。  </p><p>公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。</p><h2 id="4-2-公钥密码的历史"><a href="#4-2-公钥密码的历史" class="headerlink" title="4.2 公钥密码的历史"></a>4.2 公钥密码的历史</h2><ol><li>1976年发表了关于公钥密码的设计思想，即将加密秘钥和解密秘钥分开。  </li><li>1977年设计了一种具体的公钥密码算法，但后来被发现并不安全。</li><li>1978年发表了一种公钥密码算法——RSA，可以说是现在公钥密码的事实标准。</li></ol><h2 id="4-3-公钥通信的流程"><a href="#4-3-公钥通信的流程" class="headerlink" title="4.3 公钥通信的流程"></a>4.3 公钥通信的流程</h2><p>Alice 是发送者， Bob 是接收者， Eve 是窃听者。在公钥密码通信中，通信过程是由接收者 Bob 来启动的：  </p><ol><li>Bob 生成一个包含公钥和私钥的密钥对。私钥由 Bob 自行妥善保管。</li><li>Bob 将自己的公钥发送给 Alice 。公钥被 Eve 获得。</li><li>Alice 用 Bob 的公钥对消息进行加密。</li><li>Alice 将密文发送给 Bob 。密文被 Eve 获得。</li><li>Bob 用自己的私钥对密文进行解密。</li></ol><h2 id="4-4-公钥密码无法解决的问题"><a href="#4-4-公钥密码无法解决的问题" class="headerlink" title="4.4 公钥密码无法解决的问题"></a>4.4 公钥密码无法解决的问题</h2><p>我们需要判断所得到的公钥是否正确合法，这个问题被称为<strong>公钥认证</strong>问题。这个问题随后将通过对中间人攻击的讲解来探讨。<br>同时，公钥密码的处理速度只有对称密码的几百分之一，随后在下节详解。</p><h1 id="5-时钟算法"><a href="#5-时钟算法" class="headerlink" title="5 时钟算法"></a>5 时钟算法</h1><p>在讲解公钥密码的代表 RSA 之前，我们需要做一些数学方面的准备工作。</p><h2 id="5-1-加法"><a href="#5-1-加法" class="headerlink" title="5.1 加法"></a>5.1 加法</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_1.png" alt><br>指针从 11 在转就回变成 0 。即，如果当前是 5 点， 11 个小时后为：x = 5 + 11%12 = 5 - 1 = 4 。  </p><p>因此加法就变成了求余数运算，即 mod 运算。</p><h2 id="5-2-减法"><a href="#5-2-减法" class="headerlink" title="5.2 减法"></a>5.2 减法</h2><p>减法是加法的逆运算：如果当前是 5 点， 11 个小时之前是：x + 11%12 = 5 =&gt; x = 6。</p><h2 id="5-3-乘法"><a href="#5-3-乘法" class="headerlink" title="5.3 乘法"></a>5.3 乘法</h2><p>乘法即多个加法：如果当前是 5 点， 乘以 3： 5 + 5%12 + 5%12 = -9 =&gt; -9 + 12 = 3。</p><h2 id="5-4-除法"><a href="#5-4-除法" class="headerlink" title="5.4 除法"></a>5.4 除法</h2><p>除法是乘法的逆运算：但是，由于时钟只能是整数，因此并不是所有的数都能当被除数，要保证被除后是一个整数。</p><h2 id="5-5-乘方"><a href="#5-5-乘方" class="headerlink" title="5.5 乘方"></a>5.5 乘方</h2><p>7^4：7^4 mod 12 = 2401 mod 12 = 1</p><h2 id="5-6-对数"><a href="#5-6-对数" class="headerlink" title="5.6 对数"></a>5.6 对数</h2><p>即乘方的逆运算：7^X = Y ，已知 Y 求 X。<br>在时钟运算中的对数称为离散对数。例如：<br>7^X mod 12 = 8，<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_2.png" alt><br>得到结果为 9 。当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没有被发现。</p><h2 id="5-7-从时钟指针到-RSA"><a href="#5-7-从时钟指针到-RSA" class="headerlink" title="5.7 从时钟指针到 RSA"></a>5.7 从时钟指针到 RSA</h2><p>我们知道了 7^4 mod 12 代表的含义，那么就为理解 RSA 做好准备了，因为 RSA 的加密和解密过程中所进行的正是这样的运算。</p><h1 id="6-RSA"><a href="#6-RSA" class="headerlink" title="6 RSA"></a>6 RSA</h1><h2 id="6-1-什么是-RSA"><a href="#6-1-什么是-RSA" class="headerlink" title="6.1 什么是 RSA"></a>6.1 什么是 RSA</h2><p>RSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、 Adi Shamir 和 Leonard Adleman 的姓氏首字母组成的。<br>RSA 可以被用于公钥密码和数字签名，数字签名将在第九章详解。<br>RSA 在 1983年取得了专利，但现在专利已经过期。</p><h2 id="6-2-RSA-加密"><a href="#6-2-RSA-加密" class="headerlink" title="6.2 RSA 加密"></a>6.2 RSA 加密</h2><p>在 RSA 中，<strong>明文、秘钥和密文都是数字</strong>， RSA 的加密过程可以用下列公式来表示：  </p><h4 id="密文-明文-E-mod-N"><a href="#密文-明文-E-mod-N" class="headerlink" title="密文 = 明文 ^ E mod N"></a>密文 = 明文 ^ E mod N</h4><p>也就是说， RSA 的密文是对代表明文的数字的 E 次方求 mod N 结果。换句话说，就是将明文和自己做 E 次乘法，然后将其结果除以 N 求余数，这个余数就是密文。<br>就是这么简单。<br>其中 E 和 N 时 RSA 加密的秘钥，也就是说， E 和 N 的组合就是公钥。注意：E 和 N 并不是密钥对，“公钥是（E，N）”这种写法。<br>现在大家应该已经知道， RSA 的加密就是“求 E 次方的 mod N”。</p><h2 id="6-3-RSA-解密"><a href="#6-3-RSA-解密" class="headerlink" title="6.3 RSA 解密"></a>6.3 RSA 解密</h2><h4 id="明文-密文-D-mod-N"><a href="#明文-密文-D-mod-N" class="headerlink" title="明文 = 密文 ^ D mod N"></a>明文 = 密文 ^ D mod N</h4><p>也就是说，对表示密文的数字的 D 次方求 mod N 就可以得到明文。  </p><p>RSA 的加密和解密整理如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_3.png" alt><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_4.png" alt></p><h2 id="6-4-生成密钥对"><a href="#6-4-生成密钥对" class="headerlink" title="6.4 生成密钥对"></a>6.4 生成密钥对</h2><p>由于 E 和 N 是公钥，D 和 N 是私钥，因此求 E、D 和 N 这三个数就是生成秘钥对。步骤如下：  </p><ol><li>求 N</li><li>求 L（中间值）</li><li>求 E</li><li>求 D</li></ol><p>注：由于博主并不深究生成过程，只需要知道使用到了最大公约数以及质数的特性即可，有需要深究具体生成的请自行 Google。</p><h1 id="7-对-RSA-的攻击"><a href="#7-对-RSA-的攻击" class="headerlink" title="7 对 RSA 的攻击"></a>7 对 RSA 的攻击</h1><p>RSA 的加密是求 “E 次方的 mod N”，解密时求 “D 次方的 mod N”,原理非常简单。<br>破译者知道的信息：密文、E、N。<br>破译者不知道的信息：明文、D、一些密码算法所使用的中间变量。</p><h2 id="7-1-通过密文来求得明文"><a href="#7-1-通过密文来求得明文" class="headerlink" title="7.1 通过密文来求得明文"></a>7.1 通过密文来求得明文</h2><p>密文 = 明文 ^ E mod N<br>如果没有 mod N运算，只有 密文 = 明文 ^ E ，就很简单，即求对数的问题。但是如果加上 mod N运算，就变成求离散对数的问题，这是非常困难，<br>因为人类还没有发现求离散对数的高效算法。</p><h2 id="7-2-通过暴力破解来找出-D"><a href="#7-2-通过暴力破解来找出-D" class="headerlink" title="7.2 通过暴力破解来找出 D"></a>7.2 通过暴力破解来找出 D</h2><p>由于暴力破解的难度会随 D 的长度增加而变大，因此 D 到达 1024 比特以上，暴力破解就很难在现实的时间内通过暴力破解找出数 D。</p><h2 id="7-3-通过-E-和-N-求出-D"><a href="#7-3-通过-E-和-N-求出-D" class="headerlink" title="7.3 通过 E 和 N 求出 D"></a>7.3 通过 E 和 N 求出 D</h2><p>既然 D 本身是通过 E 和 N 求出，因此破译者也可以尝试，但是由于涉及到质数分解的问题，这样的方法目前还没有出现，而且我们也不知道是否真的存在这个方法。</p><h2 id="7-4-中间人攻击"><a href="#7-4-中间人攻击" class="headerlink" title="7.4 中间人攻击"></a>7.4 中间人攻击</h2><p>下面介绍一种名为中间人攻击（man-in-the-middle attack）的攻击方法。这种方法虽然不能破译 RSA，但却是一种针对机密性的有效攻击。  </p><p>假设发送者 Alice 准备向接收者 Bob 发送一封邮件，为了解决密钥配送问题，他们使用了公钥密码。  </p><ol><li>Alice 向 Bob 发送邮件索要公钥</li><li>Mallory 通过窃听发现 Alice 在向 Bob 索要公钥。</li><li>Bob 看到 Alice 的邮件，并将自己的公钥发送给 Alice。</li><li>Mallory 拦截 Bob 的邮件，使其无法发送给 Alice 。然后，他悄悄地将 Bob 的公钥保存起来。</li><li>Mallory 拦伪装成 Bob，将自己的公钥发送给 Alice。</li><li>Alice 将自己的消息用 Bob 的公钥（其实是 Mallory 的公钥）进行加密并发送给 Bob。</li><li>Mallory 拦截 Alice 的加密邮件。用 Mallory 的私钥解密，得到明文。</li><li>Mallory 伪装成 Alice 给 Bob 写一封假邮件并用保存起来的 Bob 的公钥加密发送给 Bob。  </li></ol><p>Mallory 不仅可以篡改 Alice 消息，还可以篡改 Bob 的消息。中间人攻击进不仅针对 RSA，而是针对在座的各位公钥密码！  </p><p>我们用公钥密码解决了密钥配送问题，但是又出现新的问题，<strong>如何判断收到的公钥是否来自于正确的接收者</strong>，即是否来自于 Bob 。解决这个问题成为认证，<br>将在第十章详解。</p><h1 id="8-其它公钥密码"><a href="#8-其它公钥密码" class="headerlink" title="8 其它公钥密码"></a>8 其它公钥密码</h1><p>RSA 是现在最为普及的一种公钥密码算法，但除了 RSA 之外，还有其它的公钥密码。下面介绍一下 EIGamal 方式、Rabin 方式以及椭圆曲线密码。<br>这些密码都可以被用于一般的加密和数字签名。</p><h2 id="8-1-EIGamal-方式"><a href="#8-1-EIGamal-方式" class="headerlink" title="8.1 EIGamal 方式"></a>8.1 EIGamal 方式</h2><p>RSA 利用了质因数分解的困难度，而 EIGamal 方式利用了 mod N 下求离散对数的困难度。它的缺点是，密文是明文的两倍。</p><h2 id="8-2-Rabin-方式"><a href="#8-2-Rabin-方式" class="headerlink" title="8.2 Rabin 方式"></a>8.2 Rabin 方式</h2><p>Rabin 利用了 mod N 求平方根的困难度。</p><h2 id="8-3-椭圆曲线密码"><a href="#8-3-椭圆曲线密码" class="headerlink" title="8.3 椭圆曲线密码"></a>8.3 椭圆曲线密码</h2><p>椭圆曲线密码（Elliptic Curve Cryptosystems，ECC）是最近备受关注的一种公钥密码算法。它的特点是所需的密钥长度比 RSA 短。<br>它通过将椭圆曲线上特定点进行特殊的乘法运算来实现的，利用了这种乘法运算的逆运算非常困难这一特性。</p><h1 id="9-关于公钥密码的问答"><a href="#9-关于公钥密码的问答" class="headerlink" title="9 关于公钥密码的问答"></a>9 关于公钥密码的问答</h1><p>主要选择一些容易被误解的点解答疑问。</p><h2 id="9-1-公钥密码的机密性"><a href="#9-1-公钥密码的机密性" class="headerlink" title="9.1 公钥密码的机密性"></a>9.1 公钥密码的机密性</h2><p>公钥密码比对称密码的机密性更高吗？<br>这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。</p><h2 id="9-2-公钥密码与对称密码的密钥长度"><a href="#9-2-公钥密码与对称密码的密钥长度" class="headerlink" title="9.2 公钥密码与对称密码的密钥长度"></a>9.2 公钥密码与对称密码的密钥长度</h2><p>采用 1024 比特的密钥的公钥密码，和采用 128 比特的密钥的对称密码中，是密钥更长的公钥密码更安全吗？<br>不是。公钥密码的密钥长度不能与对称密码的密钥长度进行直接比较，如下是一张密钥长度的比较表（摘自《应用密码学》），看出， 1024 比特的公钥密码与<br> 128 比特的对称密码相反，反而是 128 比特的对称密码抵御暴力破解的能力更强。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/5_5.png" alt></p><h2 id="9-3-对称密码的未来"><a href="#9-3-对称密码的未来" class="headerlink" title="9.3 对称密码的未来"></a>9.3 对称密码的未来</h2><p>因为已经有了公钥密码，今后对称密码会消失吗？<br>不会。一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。因此，公钥密码不适合用来对很长的消息内容进行加密。<br>根据目的的不同，可能会配合使用对称密码和公钥密码，将在第六章介绍的混合密码系统详解。</p><h2 id="9-4-RSA-和质数"><a href="#9-4-RSA-和质数" class="headerlink" title="9.4 RSA 和质数"></a>9.4 RSA 和质数</h2><p>随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光？<br>512 比特能够容纳的质数的数量大概是10^150。假设世界上有 100 亿人，每人每秒生成 100 亿个密钥对，经过 100 亿年后：<br>100亿人<em>100亿个</em>31622400秒*100亿年 &lt; 10^39。<br>另外，理论上质数组合偶然撞车的可能性，事实上也可以认为是没有的。</p><h2 id="9-5-RSA-与质因数分解"><a href="#9-5-RSA-与质因数分解" class="headerlink" title="9.5 RSA 与质因数分解"></a>9.5 RSA 与质因数分解</h2><p>RSA 的破译与大整数的质因数分解是等价的吗？<br>不清楚是否是等价的。但是，只要能够快速完成质因数分解，就能够破译 RSA。</p><h2 id="9-6-RSA-的长度"><a href="#9-6-RSA-的长度" class="headerlink" title="9.6 RSA 的长度"></a>9.6 RSA 的长度</h2><p>要抵御质因数分解，N 的长度需要达到多少比特呢？<br>N 无论多长，总有一天能够被质因数分解。在 1999年 521比特的证书由 292台计算机话费 5.2 个月完成了质因数分解。</p><h1 id="10-本章小结"><a href="#10-本章小结" class="headerlink" title="10 本章小结"></a>10 本章小结</h1><p>本章学习了公钥密码以及其代表性的实现方法——RSA。<br>使用公钥密码能够解决秘钥配送问题。公钥密码是密码学界的一项革命性的发明！<br>对称密码通过将明文转换为复杂的形式来保证其机密性，相对的，公钥密码则是局域数学上困难的问题来保证机密性的。例如 RSA 就利用了大整数的质因数分解<br>问题的难度。因此，对称密码和公钥密码源于两个根本不同的思路。  </p><p>尽管公钥密码解决了秘钥配送问题，但针对公钥密码能够进行中间人攻击。要防御这种攻击，就需要回答“这个公钥是否属于合法的通信对象”这一问题，这个问题<br>将在第九章和第十章详解。  </p><p>即使已经有了公钥密码，对称密码也不会消失。公钥密码的运行速度远远低于对称密码，因此在一般的通信过程中，往往会配合使用这两种密码，即用对称密码<br>提高处理速度，用公钥密码解决秘钥配送问题，这种方式称为混合密码系统，将在下一章详解。</p><h1 id="11-小测验"><a href="#11-小测验" class="headerlink" title="11 小测验"></a>11 小测验</h1><ol><li>秘钥分配中心的处理：当 Alice 发出希望与 Bob 进行通信的请求时，秘钥分配中心会生成一个全新的会话秘钥，并将其加密后发送给 Alice 。<br>为什么秘钥分配中心不直接将 Bob 的秘钥用 Alice 的秘钥加密之后发送给 Alice 呢？</li><li>要对用公钥密码加密的密文进行解密，需要公钥密码的私钥。</li><li>公钥密码的私钥需要和加密后的消息一起被发送给接收者。</li><li>一般来说，对称密码的速度比公钥密码要快。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>电影《内在美》有感~</title>
      <link href="/2017/11/15/talker/1.html/"/>
      <url>/2017/11/15/talker/1.html/</url>
      
        <content type="html"><![CDATA[<p>看完这部电影，不得不说，最后被男主拿出的戒指感动到了~戒指没有不见，它一直在那里。<br>回想女主第一次拒绝结婚的理由让人熟悉而又无奈，这不是我们每个男生都害怕听到的理由吗？  </p><blockquote><p><strong>我还没有准备好</strong>   </p></blockquote><p>幸好，最后结局有情人终成眷属了。回想起剧情，就像溪水，可能会流的慢，但是总会流到那里。  </p><p>最后女主结婚的理由才像她自己：</p><blockquote><p>我害怕世人眼光，但更害怕没有你的日子~</p></blockquote><p>啊~我需要买一个桌子，带音响的那种。</p><hr><p>男主默默的制作家具，给人一种非常沉稳优雅的气质，不得不说，这个职业非常非常适合这个角色，在捷克依然孤独的与家居为伴，<br>这不是真是我们吗？终日与代码为伴，但是我们也要沉稳、也要优雅</p><blockquote><p>优雅的代码千篇一律，给人赏心悦目；肮脏代码各有不同，总会让你感叹，代码还能这么脏？！  </p></blockquote><hr><p>code also can be elegant。</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、对称密码</title>
      <link href="/2017/11/12/graphic2cryptography/3.html/"/>
      <url>/2017/11/12/graphic2cryptography/3.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-炒鸡蛋与对称密码"><a href="#1-炒鸡蛋与对称密码" class="headerlink" title="1 炒鸡蛋与对称密码"></a>1 炒鸡蛋与对称密码</h1><p>鸡蛋炒好之后就完全分不清原来的蛋黄和蛋白了，使用对称密码进行加密，和炒鸡蛋有着异曲同工之妙。炒鸡蛋搅拌的是鸡蛋，而密文打乱的则是比特序列。<br>然后，它们最大的不同是，炒鸡蛋无法还原成原来的鸡蛋，但密文却必须能够让接收者正确解密才行。<br>因此，如果只是随意地搅拌和混合，则不能称之为加密，而必须仔细设计出一种能够还原的混合方式。</p><h1 id="2-本章概要"><a href="#2-本章概要" class="headerlink" title="2 本章概要"></a>2 本章概要</h1><p>学习比特序列运算和 XOR 运算。以及介绍一种称为一次性密码本的密码系统。<br>具体介绍几种对称密码算法，包括 DES、三重DES、AES以及其它一些密码算法。<br>需要注意的是，密码算法有时候会设计开发者的专利和授权等问题，记得先调查一下该算法的专利和授权信息。</p><h1 id="3-从文字密码到比特序列密码"><a href="#3-从文字密码到比特序列密码" class="headerlink" title="3 从文字密码到比特序列密码"></a>3 从文字密码到比特序列密码</h1><h2 id="3-1-编码"><a href="#3-1-编码" class="headerlink" title="3.1 编码"></a>3.1 编码</h2><p>计算机操作对象并不是文字，而是由 0 和 1 排列而成的<strong>比特序列</strong>。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p><h2 id="3-2-XOR"><a href="#3-2-XOR" class="headerlink" title="3.2 XOR"></a>3.2 XOR</h2><p>XOR 的全称是 exclusive or ，中文叫作<strong>异或</strong>。</p><h3 id="1-一个比特的-XOR"><a href="#1-一个比特的-XOR" class="headerlink" title="1. 一个比特的 XOR"></a>1. 一个比特的 XOR</h3><p>0 XOR 0 = 0<br>0 XOR 1 = 1<br>1 XOR 0 = 1<br>1 XOR 1 = 0<br>可以理解为硬币翻转：<br>不翻转 + 不翻转 = 不翻转<br>不翻转 + 翻转   = 翻转<br>翻转   + 不翻转 = 翻转<br>翻转   + 翻转   = 不翻转</p><h3 id="2-比特序列的-XOR"><a href="#2-比特序列的-XOR" class="headerlink" title="2. 比特序列的 XOR"></a>2. 比特序列的 XOR</h3><p>A  XOR B = AB<br>AB XOR B = A<br>这是因为两个相同的数进行 XOR 运算的结果一定为 0 ，因此 A XOR B XOR B = A。这不就和加密、界面的步骤非常相似么，如下：  </p><ul><li>将明文 A 用密钥 B 进行加密，得到密文 AB。  </li><li>将密文 AB 用密钥 B 进行解密，得到明文 A。  </li></ul><p>实际上，只要选择一个合适的 B，仅仅使用 XOR 就可以实现一个高强度的密码。<br>对同一个比特序列进行两次 XOR 之后就会回到最初的状态。我们不妨来看看一副由很多点组成的图像。如果将白色的点作为 0 ，黑色的点作为 1 ，<br>那么一副黑白图像就可以表示为 0 和 1 的比特序列。我们转呗两幅图像，一幅画是英文字母 D，另一幅是用 0 和 1 交替排列形成的图像（蒙版），<br>并进行如下操作：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_1.png" alt><br>如果所使用的蒙版是完全随机的比特序列，则使用 XOR 就可以将原来的图像掩盖起来。但如果蒙版中的比特序列是可以被推测出来的，那么实质上图像就<br>没有被真正的掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特<br>序列就称为<strong>随机数</strong>。将在第十二章详解。</p><h1 id="4-一次性密码本——绝对不会被破译的密码"><a href="#4-一次性密码本——绝对不会被破译的密码" class="headerlink" title="4 一次性密码本——绝对不会被破译的密码"></a>4 一次性密码本——绝对不会被破译的密码</h1><h2 id="4-1-什么是一次性密码本"><a href="#4-1-什么是一次性密码本" class="headerlink" title="4.1 什么是一次性密码本"></a>4.1 什么是一次性密码本</h2><p>只要通过暴力破解对密钥空间进行遍历，无论任何密文总有一天都能够被破译。然后，本节中将要介绍的一次性密码本（one-time pad）却是一个例外。<br>即便用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。</p><h2 id="4-2-一次性密码本的加密"><a href="#4-2-一次性密码本的加密" class="headerlink" title="4.2 一次性密码本的加密"></a>4.2 一次性密码本的加密</h2><p>它的原理是“将明文与一串随机的比特序列进行 XOR 运算”。如果将硬币的正面设为 0 ，反面设为 1 ，则通过不断掷硬币就能够产生这样一串随机的比特序列。<br>下面我们将明文 midnight 这个字符串通过 ASCII 进行编码并产生一串比特序列。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_2.png" alt>  </p><p>接着，我们掷 64 次硬币产生 64 比特的随机比特序列：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_3.png" alt>  </p><p>下面我们将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结构也就是一次性密码本的密文。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_4.png" alt>  </p><p>这样产生的比特序列如果硬要显示在计算上，那么显示结果看上去就像是乱码一样（其实是加密），因此密文通常不会被还原为字符，而是被作为二进制数据来处理。</p><h2 id="4-3-一次性密码本的解密"><a href="#4-3-一次性密码本的解密" class="headerlink" title="4.3 一次性密码本的解密"></a>4.3 一次性密码本的解密</h2><p>用密文和密钥进行 XOR 运算，就可以得到明文：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_5.png" alt><br>这样显示在计算上就会是正常的文本： midnight。</p><h2 id="4-4-一次性密码本是无法破译的"><a href="#4-4-一次性密码本是无法破译的" class="headerlink" title="4.4 一次性密码本是无法破译的"></a>4.4 一次性密码本是无法破译的</h2><p>为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是，<br>即便我们能够解密出 midnight 这个字符串，我们也<strong>无法判断它是否是正确的明文</strong>。  </p><p>因为在解密过程中，所有的 64 比特的排列组合都会出现，包括像 aaaaaaaa、bbbbbbbb、ZZZZZZZZ 这样的规则字符串，也会包含 midnight、onenight、<br>mistress 等英文单词，还会包含乱码看不懂的组合。由于明文中又有的可能排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个<br>密钥才能够正确解密）。  </p><p>所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文，<br>因此一次性密码本是无法破译的。  </p><p>一次性密码本无法破译的这一特性是由香农于 1949 年通过数学方法加以证明的。<strong>一次性密码本是无条件安全（unconditionally secure）的，<br>在理论上是无法破译的（theoretically unbreakable）</strong>。</p><h2 id="4-5-一次性密码本为什么没有被使用"><a href="#4-5-一次性密码本为什么没有被使用" class="headerlink" title="4.5 一次性密码本为什么没有被使用"></a>4.5 一次性密码本为什么没有被使用</h2><h3 id="1-秘钥的配送"><a href="#1-秘钥的配送" class="headerlink" title="1. 秘钥的配送"></a>1. 秘钥的配送</h3><p>最大的问题在于秘钥的配送。<br>接受者 Bob 收到了 Alice 发来的密文。 Bob 要想进行解密，就必须使用和 Alice 进行加密时相同的秘钥，因此 Alice 必须将秘钥也发送给 Bob ，<br>且该秘钥的长度和密文是相等的。但这样就产生了一个矛盾——如果能够有一种方法将秘钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？</p><h3 id="2-秘钥的保存"><a href="#2-秘钥的保存" class="headerlink" title="2. 秘钥的保存"></a>2. 秘钥的保存</h3><p>既然能保存和明文一样长度的秘钥，那么不也就有办法安全保存明文本身了吗？也就是说，从一开始我们根本就不需要密码。也就是说，我们只是将“保护明文”<br>这一命题替换成了“保护和明文一样的秘钥”而已，问题并没有得到实质性的解决。</p><h3 id="3-秘钥的重用"><a href="#3-秘钥的重用" class="headerlink" title="3. 秘钥的重用"></a>3. 秘钥的重用</h3><p>此外，在一次性密码本中是绝对不能重用过去用过的随机比特序列的，一次性密码本中的“一次性”也正是由此而来。这是因为作为秘钥的比特序列一旦泄露，<br>过去所有的机密通信内容将全部被解密（假设窃听者 Eve 保存了过去所有的通信内容）。</p><h3 id="4-秘钥的同步"><a href="#4-秘钥的同步" class="headerlink" title="4. 秘钥的同步"></a>4. 秘钥的同步</h3><p>如果明文是一个大小为 100MB 的文件，则秘钥的大小也一定是 100MB 。而且在通信过程中，发送者和接受者的秘钥的比特序列不允许有任何错位，否则错位<br>后的比特的所有信息都将无法解密。</p><h3 id="5-秘钥的生成"><a href="#5-秘钥的生成" class="headerlink" title="5. 秘钥的生成"></a>5. 秘钥的生成</h3><p>在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。因此，能够使用一次性密码本的，只有那些机密性重过一切，且可以<br>话费大量财力和人力来生成并配送秘钥的场合。  </p><p>综上所述，一次性密码本是一种几乎没有实用性的密码。但是，一次性密码本的思路却孕育出了流密码（stream cipher）。流密码使用的不是真正的随机比特序列，<br>而是伪随机数生成器产生的比特序列。流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。</p><h1 id="5-DES"><a href="#5-DES" class="headerlink" title="5 DES"></a>5 DES</h1><h2 id="5-1-什么是-DES"><a href="#5-1-什么是-DES" class="headerlink" title="5.1 什么是 DES"></a>5.1 什么是 DES</h2><p>DES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。由于其在 1999 年只用了 22 小时就可破译，<br>因此除了用它来解密以前的密文以外，现在我们不应该再使用 DES 了。</p><h2 id="5-2-加密和解密"><a href="#5-2-加密和解密" class="headerlink" title="5.2 加密和解密"></a>5.2 加密和解密</h2><p>DES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于<br>每隔 7 比特 会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。  </p><p>DES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的算法密码称为分组密码<br>（block cipher），DES 就是分组密码的一种。  </p><p>DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代（反复），而迭代的具体方式就称为模式（mode），关于模式会在第四章详解。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_6.png" alt></p><h2 id="5-3-DES-的结构（Feistel网络）"><a href="#5-3-DES-的结构（Feistel网络）" class="headerlink" title="5.3 DES 的结构（Feistel网络）"></a>5.3 DES 的结构（Feistel网络）</h2><p>在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。如下是 Feistel 网络中一轮的计算流程。而 DES 是<br>一种 16 轮循环的 Feistel 网络。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_7.png" alt>  </p><h3 id="1-Feistel-网络的加密"><a href="#1-Feistel-网络的加密" class="headerlink" title="1. Feistel 网络的加密"></a>1. Feistel 网络的加密</h3><p>输入的数据被分为左右两半分别进行处理，中间的“子密钥”指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。<br>由于子密钥只在一轮中使用，它只是一个局部密钥，因此才成为<strong>子密钥</strong>。<br><strong>轮函数</strong>的作用是根据“右侧”和子密钥一起生成中间密钥，这个中间密钥对“左侧”进行加密，轮函数是该密码系统的核心。一轮的步骤总结如下：  </p><ol><li>将输入的数据等分位左右两部分</li><li>将输入的右侧直接发送到输入的右侧</li><li>将输入的右侧发送到轮函数</li><li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列</li><li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧  </li></ol><p>这样一来，“右侧”根本就没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调</p><h3 id="2-Feistel-网路的解密"><a href="#2-Feistel-网路的解密" class="headerlink" title="2. Feistel 网路的解密"></a>2. Feistel 网路的解密</h3><p>我们尝试一次下将一轮加密的输出结果用相同的子密钥重新运行一次，结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文<br>正确地还原为明文。关于这一点，可以从 XOR 的性质（两个相同的数进行 XOR 的结果一定为 0 ）进行思考。  </p><p>有多个轮的情况下也是一样的。也就是说， Feistel 网络的解密操作只要按照相反的熟悉怒来使用子密钥就可以完成了。下图是三轮加密图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_8.png" alt><br>下图是解密示意图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_9.png" alt></p><h3 id="3-Feistel-网络的性质"><a href="#3-Feistel-网络的性质" class="headerlink" title="3. Feistel 网络的性质"></a>3. Feistel 网络的性质</h3><p>Feistel 网络的轮数可以任意增加。无论运行多少轮的加密计算，都不会发生无法解密的情况。以及加密时无论使用任何函数作为轮函数都可以正确解密。<br>最后是加密和解密可以用完全相同的结构来实现。在 Feistel 网络的一轮中，右半部分实际上没有任何处理，这在加密算法中看起来是一种浪费，<br>但却保证了可解密性。 </p><h1 id="6-三重-DES"><a href="#6-三重-DES" class="headerlink" title="6 三重 DES"></a>6 三重 DES</h1><p>现在 DES 已经可以在限时的时间内被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。</p><h2 id="6-1-什么是三重-DES"><a href="#6-1-什么是三重-DES" class="headerlink" title="6.1 什么是三重 DES"></a>6.1 什么是三重 DES</h2><p>三重 DES（triple-DES）是为了增加 DES 的强度，将 DES 重复 3 次所得到的一种密码算法。</p><h2 id="6-2-三重-DES-的加密"><a href="#6-2-三重-DES-的加密" class="headerlink" title="6.2 三重 DES 的加密"></a>6.2 三重 DES 的加密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_10.png" alt><br>经过三次 DES 处理CIA能变成最后的密文，由于 DES 秘钥的长度实质上是 56 比特，因此三重 DES 的秘钥长度就是 56 * 3 = 168 比特。<br>从上图中，我们发现，三重 DES 并不是进行三次 DES 加密，而是加密-解密-加密的过程，实际上这是 IBM 公司设计出来的，目的是为了让三重 DES<br>能够兼容普通的 DES。当三重 DES 所有秘钥都相同的时候就相当于普通的 DES 了。因此，以前用 DES 加密的密文，就可以通过这种方式用三重 DES<br>来进行解密。也就是说三重 DES 对 DES 具备向下兼容性。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_11.png" alt></p><h2 id="6-3-三重-DES-的解密"><a href="#6-3-三重-DES-的解密" class="headerlink" title="6.3 三重 DES 的解密"></a>6.3 三重 DES 的解密</h2><p>解密过程与加密过程顺序相反。</p><h2 id="6-4-三重-DES-的现状"><a href="#6-4-三重-DES-的现状" class="headerlink" title="6.4 三重 DES 的现状"></a>6.4 三重 DES 的现状</h2><p>其处理速度不高，而且在安全性方面也逐渐显现了一些问题，但还被银行等机构使用。</p><h1 id="7-AES-的选定过程"><a href="#7-AES-的选定过程" class="headerlink" title="7 AES 的选定过程"></a>7 AES 的选定过程</h1><h2 id="7-1-什么是-AES"><a href="#7-1-什么是-AES" class="headerlink" title="7.1 什么是 AES"></a>7.1 什么是 AES</h2><p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码。全世界的企业和密码学家提交了多个对称密码算法<br>作为 AES 的候选，最终在 2000 年选出了一种名为 Rijndael 的对称密码算法，并将其确定为了 AES。</p><h2 id="7-2-AES-的选定过程"><a href="#7-2-AES-的选定过程" class="headerlink" title="7.2 AES 的选定过程"></a>7.2 AES 的选定过程</h2><p>组织 AES 公开竞选活动的，是美国的一个标准化机构——NIST，参加 AES 竞选的条件是：被选为 AES 的密码算法必须无条件地免费供全世界使用。<br>此外，参与者还必须提交密码算法的详细规格书、以 ANSIC 和 Java 编写的实现代码以及抗密码破译强度的评估等材料。因此，在提交了详细设计和程序代码<br>完全公开的情况下，就杜绝了隐蔽式安全性（security by obscurity）。  </p><p>评审者也是参与者，通过发现别人的弱点，实现竞争，最终实现标准化，正是密码算法选定的正确方式。只有由世界最高水平的密码学家共同尝试破译，依然未能<br>找到弱点，这样才能够证明一种密码算法的强度。</p><h2 id="7-3-AES-最终候选算法的确定与-AES-的最终确定"><a href="#7-3-AES-最终候选算法的确定与-AES-的最终确定" class="headerlink" title="7.3 AES 最终候选算法的确定与 AES 的最终确定"></a>7.3 AES 最终候选算法的确定与 AES 的最终确定</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/3_12.png" alt></p><h1 id="8-Rijndael"><a href="#8-Rijndael" class="headerlink" title="8 Rijndael"></a>8 Rijndael</h1><h2 id="8-1-什么是-Rijndael"><a href="#8-1-什么是-Rijndael" class="headerlink" title="8.1 什么是 Rijndael"></a>8.1 什么是 Rijndael</h2><p>由比利时密码学家 Joan Daemon 和 Vincent Rijmen 设计的分组密码算法。</p><h2 id="8-2-Rijndael-的加密和解密"><a href="#8-2-Rijndael-的加密和解密" class="headerlink" title="8.2 Rijndael 的加密和解密"></a>8.2 Rijndael 的加密和解密</h2><p>和 DES 一样， Rijndael 算法也是由多个轮所构成，但是 Rijndael 使用了 SPN 结构，Rijndael 的输入分组为 128 比特，也就是 16字节。<br>首先，需要逐个字节地对 16 字节地输入数据进行 SubBytes 处理，即将一个 1 字节地值替换成另一个 1 字节地值，可以想象成简单替换密码。<br>SubBytes 之后进行 ShiftRows处理，即将 SubBytes 的输出以字节单位进行打乱处理，这种打乱是有规律的。然后进行 MixColumns 处理，即对<br>一个 4 字节地值进行比特运算，将其变成另一个 4 字节值，最后与轮秘钥进行 XOR ，进行 AddRoundkey处理。这就是一轮。<br>实际上，在 Rijndael 需要重复进行 10 ~ 14 次计算。<br>![][14]<br>它在一轮使用了 SubBytes、ShiftRows、MixColumns 分别存在反向运算 InvSubBytes、InvShiftRows、InvMixColumns，分别按字节、行、列进行并行计算。</p><h2 id="8-3-Rijndael-的破译"><a href="#8-3-Rijndael-的破译" class="headerlink" title="8.3 Rijndael 的破译"></a>8.3 Rijndael 的破译</h2><p>对 Rijndael 来说，可能会出现以前并不存在的新的攻击方法。它的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公司来表达。  </p><p>这只是一种假设而已，到现在为止，还没有出现针对 Rijndael 的有效攻击。</p><h2 id="8-4-应该使用哪种对称密码呢"><a href="#8-4-应该使用哪种对称密码呢" class="headerlink" title="8.4 应该使用哪种对称密码呢"></a>8.4 应该使用哪种对称密码呢</h2><p>介绍了 DES、三重 DES、和 AES 等对称密码。那么我们到底用哪种呢？<br>一般来说不应该使用任何<strong>任何自制的密码算法</strong>，而是应该使用 AES。</p><h1 id="9-本章小结"><a href="#9-本章小结" class="headerlink" title="9 本章小结"></a>9 本章小结</h1><p>本章介绍了对称密码，以及 DES、三重 DES、AES密码算法。  </p><p>使用一种秘钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的秘钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他<br>类型的攻击。  </p><p>然后用对称密码进行通信时，还会出现秘钥的配送问题。为了解决秘钥配送问题，我们需要公钥密码技术，将在第五章详解。<br>本章所介绍的几乎所有的密码算法，都只能讲一个固定长度的分组进行加密。当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。下一章将<br>探讨对分组密码进行迭代的方法。</p><h1 id="10-小测验"><a href="#10-小测验" class="headerlink" title="10 小测验"></a>10 小测验</h1><ol><li>一次性密码本的秘钥可以进行压缩变短。</li><li>对称密码中，加密的秘钥和解密的秘钥是相等的。</li><li>如果秘钥长度为 56 比特，那么用暴力破解找到正确秘钥需要平均尝试约 2^28 次。</li><li>三重 DES 的秘钥空间是 DES 秘钥空间的三倍大。</li><li>现在 DES 可以在限时的时间内被破译。</li><li>AES 标准选定的密码算法叫 Rijndael。  </li></ol><blockquote><p>注：秘钥长度为 56 比特，则秘钥空间（秘钥总数）是 2^56，平均时间除以 2 ，为 2^55。<br>压缩算法在于：重复。  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、历史上的密码，写一篇别人看不懂的文章</title>
      <link href="/2017/11/11/graphic2cryptography/2.html/"/>
      <url>/2017/11/11/graphic2cryptography/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>本章将介绍历史上几种著名的密码：</p><ol><li>凯撒密码</li><li>简单替换密码</li><li>Enigma  </li></ol><p>此外，还介绍两种破译密码的方法：</p><ol><li>暴力攻击</li><li>频率分析  </li></ol><p>最后，我们还将思考密码算法与密钥之间的关系。<br>本章所介绍的密码在现在都已经不再适用了，但在寻找密码弱点的方法、破译密码的思路以及密码算法与密钥的关系等方面，这些密码与现在密码技术依然是相通的。</p><h1 id="2-凯撒密码"><a href="#2-凯撒密码" class="headerlink" title="2 凯撒密码"></a>2 凯撒密码</h1><h2 id="2-1-什么是凯撒密码"><a href="#2-1-什么是凯撒密码" class="headerlink" title="2.1 什么是凯撒密码"></a>2.1 什么是凯撒密码</h2><p>凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_1.png" alt></p><h2 id="2-2-凯撒密码的加密"><a href="#2-2-凯撒密码的加密" class="headerlink" title="2.2 凯撒密码的加密"></a>2.2 凯撒密码的加密</h2><p>例如，将 yoshiko 这个女性的名字，加密：<br>y -&gt; B<br>o -&gt; R<br>s -&gt; V<br>h -&gt; K<br>i -&gt; L<br>k -&gt; N<br>o -&gt; R<br>这样，明文 yoshiko 就被加密为了密文BRVKLNR。凯撒密码中，将字母表中的字母平移这个操作就是密码的算法，而平移的字母数量则相当于密钥。<br>在本例中，密钥为3：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_2.png" alt></p><h2 id="2-3-凯撒密码的解密"><a href="#2-3-凯撒密码的解密" class="headerlink" title="2.3 凯撒密码的解密"></a>2.3 凯撒密码的解密</h2><p>我们只需要反向平移3个字母就可以解密了：<br>B -&gt; y<br>R -&gt; o<br>V -&gt; s<br>K -&gt; h<br>L -&gt; i<br>N -&gt; k<br>R -&gt; o<br>这样就得到了明文 yoshiko，但是密钥 3 必须由发送者和接受者事先约定好。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_3.png" alt>  </p><h2 id="2-4-用暴力破解来破译密码"><a href="#2-4-用暴力破解来破译密码" class="headerlink" title="2.4 用暴力破解来破译密码"></a>2.4 用暴力破解来破译密码</h2><p>通过上面的讲解，我们知道对于发送者用凯撒密码加密过的密文，接受者是能够进行解密的，但是接受者以为的人在看到密文 BRVKLNR ，是否能够进行破译<br>得到明文呢？在凯撒密码中，密钥就是字母表平移的字数。因此可以按顺序将这 26 种密钥都尝试一遍：<br>BRVKLNR -&gt; 用密钥 0 解密 -&gt; brvklnr<br>BRVKLNR -&gt; 用密钥 1 解密 -&gt; aqujkmq<br>BRVKLNR -&gt; 用密钥 2 解密 -&gt; zptijlp<br>BRVKLNR -&gt; 用密钥 3 解密 -&gt; yoshiko<br>……<br>BRVKLNR -&gt; 用密钥 25 解密 -&gt; cswlmos<br>尝试一遍都，发现当密钥为 3 时，可以解密出有意义的字符串 yoshiko 。这就意味着我们仅仅根据密文就推测除了密钥和明文，这样的密码有什么用呢？<br>凯撒密码实在是太脆弱了，无法保护重要的密码。  </p><p>上面介绍的这种密码破译方法，就是讲所有可能的密钥全部尝试一遍，这种方法称为暴力破解（brute-force attack）。由于这种方法的本质是从所有的密钥<br>中找出正确的密钥，因此又称为穷举搜索（exhausive search）。  </p><h1 id="3-简单替换密码"><a href="#3-简单替换密码" class="headerlink" title="3 简单替换密码"></a>3 简单替换密码</h1><h2 id="3-1-什么是简单替换密码"><a href="#3-1-什么是简单替换密码" class="headerlink" title="3.1 什么是简单替换密码"></a>3.1 什么是简单替换密码</h2><p>将明文中所使用的字母表替换为另一套字母表的密码，如下图就是一个简单替换密码的对应表：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_4.png" alt></p><h2 id="3-2-简单替换密码的加密"><a href="#3-2-简单替换密码的加密" class="headerlink" title="3.2 简单替换密码的加密"></a>3.2 简单替换密码的加密</h2><p>按照上图的替换表，对明文 yoshiko　进行加密：<br>y -&gt; K<br>o -&gt; B<br>s -&gt; L<br>h -&gt; T<br>i -&gt; J<br>k -&gt; S<br>o -&gt; B<br>就得到密文：KBLTJSB。</p><h2 id="3-3-简单替换密码的解密"><a href="#3-3-简单替换密码的解密" class="headerlink" title="3.3 简单替换密码的解密"></a>3.3 简单替换密码的解密</h2><p>需要根据使用的替换表进行解密。</p><h2 id="3-4-简单替换密码的密钥空间"><a href="#3-4-简单替换密码的密钥空间" class="headerlink" title="3.4 简单替换密码的密钥空间"></a>3.4 简单替换密码的密钥空间</h2><p>yoshiko 用凯撒密码（密钥为 3 ）加密后的密文是 BRVKLNR ，二用简单替换密码（密钥为上图）加密后的密文则是 KBLTJSB。单从密文上来看，我们无法<br>判断出凯撒密码和简单替换密码到底哪一种更难破解。  </p><p><strong>凯撒密码可以通过暴力破解来破译，但简单替换密码很难通过暴力破解来破译</strong>。这是因为简单替换密码中可以使用的密钥数量，比凯撒密码要多得多。  </p><p>为了确定这一点，我们计算一下简单替换密码中可以使用的密钥总数。一种密码能够使用的“所有密钥的集合”称为密钥空间（keyspace），所有可用密钥的总数就是密钥空间的<br>大小。密钥空间越大，暴力破解就越困难。  </p><p>简单替换密码中，明文字母表中的 a 可以对应A，B，C，…，Z 这 26 个字母中的任意一个，b 可以对应除了 a 所对应的字母以为的剩余 25 个字母中的任意一个。<br>以此类推，我们可以计算出简单替换密码的密钥总数为：<br>26 * 25 * 24 * 23 * … * 1 = 403291461126605635584000000<br>即使美妙能够遍历 10 亿个密钥，也要花费 120 亿年的时间。</p><h2 id="3-5-用频率分析来破译密码"><a href="#3-5-用频率分析来破译密码" class="headerlink" title="3.5 用频率分析来破译密码"></a>3.5 用频率分析来破译密码</h2><p>频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。例如：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_5.png" alt>  </p><p>首先，我们统一一下这段密文中<strong>每个字母出现的频率</strong>：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_6.png" alt>  </p><p>为了找到破译的线索，我们再来看一下英语文章中所使用的字母的频率，一般的英语文章中出现频率最高的字母是 e 。而上图中出现频率最高的两个字母是 I 和 Y，<br>我们假设它们中的其中一个是 e 。然后将密文中的 Y 全部替换成 e ，替换后的密文如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_7.png" alt><br>英语中出现最多的单词是 the ，因此我们可以寻找一下以 e 结尾的 3 个字母的组合，结果我们发现 MEe 这3个字母的组合是最常出现的，而且 MEe 出现在<br>密文的开头，因此 MEe 很可能就是 the 。于是，我们再假设 M -&gt; t，E -&gt; h。得到如下图的表：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_8.png" alt><br>让我们动员自己所有的英文词汇，在上面的文字中继续寻找可能的组合。我们发现中间有一个词 thPee 比较可以，这个词不会就是 three 吧（P -&gt; r）？<br>除了高频字母以外，密文中的低频字母 Q 也可以找到一些相关的组合。直到得到最后通顺的明文，有以下结论：</p><ul><li>除了高频字母以外，低频字母也能够成为线索。</li><li>搞清开头和结尾能够称为线索，搞清单词之间的分隔也能够成为线索。</li><li>密文越长越容易破译。</li><li>同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）。</li><li>破译的速度会越来越快。</li></ul><h1 id="4-Enigma"><a href="#4-Enigma" class="headerlink" title="4 Enigma"></a>4 Enigma</h1><h2 id="4-1-什么是-Enigma"><a href="#4-1-什么是-Enigma" class="headerlink" title="4.1 什么是 Enigma"></a>4.1 什么是 Enigma</h2><p>Enigma 是由德国人于 20 世纪初发明的一种能够进行加密与解密操作的机器。Enigma 这个名字在德语里是“谜”的意思。</p><h2 id="4-2-用-Enigma-进行加密通信"><a href="#4-2-用-Enigma-进行加密通信" class="headerlink" title="4.2 用 Enigma 进行加密通信"></a>4.2 用 Enigma 进行加密通信</h2><p>Enigma 是一种由键盘、齿轮、电池和灯泡所组成的机器，通过这一台机器就可以完成加密和解密两种操作。  </p><p>发送者和接收者各自拥有一台 Enigma。发送者用 Enigma 将明文加密，将生成的密文通过无线电发送给接收者。接收者将接收到的密文用自己的 Enigma 解密。  </p><p>由于发送者和接收者必须使用相同的密钥才能完成密码通信，因此发送者和接收者会事先收到一份叫<strong>国防军密码本</strong>的册子。发送者和接收者按照册子指示来设置 Enigma。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_9.png" alt></p><h2 id="4-3-Enigma-的构造"><a href="#4-3-Enigma-的构造" class="headerlink" title="4.3 Enigma 的构造"></a>4.3 Enigma 的构造</h2><p>Enigma 的构造如下图。它能对字母表中的 26 个字母进行加密和解密操作，这里将字母的数量简化为 4 个：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_10.png" alt><br>每当按下 Enigma 上的一个键，就会点亮一个灯泡。而接线板和轮子在每次输入的时候都会变化，这样的组合让 Enigma 看起来像是一个能够动态变化的操作。</p><h2 id="4-4-Enigma-的加密"><a href="#4-4-Enigma-的加密" class="headerlink" title="4.4 Enigma 的加密"></a>4.4 Enigma 的加密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_11.png" alt><br>在进行通信之前，发送者金和接收者双方都需要持有国防军密码本，国防军密码本中记载了发送者和接收者需要使用的每日密码。</p><h3 id="1-设置-Enigma"><a href="#1-设置-Enigma" class="headerlink" title="1.设置 Enigma"></a>1.设置 Enigma</h3><p>发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。具体来说，就是接线板和转子排列。</p><h3 id="2-加密通信密码"><a href="#2-加密通信密码" class="headerlink" title="2. 加密通信密码"></a>2. 加密通信密码</h3><p>接下来，发送者需要想出 3 个字母，并将其加密。这 3 个字母称为通信密码。<br>通信密码的加密也是通过 Enigma 完成的。假设发送者选择的通信密码为 psv，则发送者需要在 Enigma 的键盘上输入两次该通信密码，也就是说需要输入<br>psvpsv 这 6 个字母。  </p><p>发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输入全部 6 个字母之后，发送者就记下了它们所对应的密文，<br>假设密文是 ATCDVT（密文用大写字母来表示）。</p><h3 id="3-重新设置-Enigma"><a href="#3-重新设置-Enigma" class="headerlink" title="3. 重新设置 Enigma"></a>3. 重新设置 Enigma</h3><p>接下来，发送者根据通信密码重新设置 Enigma。通信密码中的 3 个字母实际上代表了三个转子的初始位置。每一个转子的上面都印有字母，可以根据字母<br>来设置转子的初始位置。通信密码 psv 就表示需要将转子 1、2、3 分别转到 p、s、v 所对应的位置。</p><h3 id="4-加密消息"><a href="#4-加密消息" class="headerlink" title="4. 加密消息"></a>4. 加密消息</h3><p>接下来，发送者对消息进行加密。发送者将明文逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。例如输入 nacht ，记录下对应的 KXNWP 。</p><h3 id="5-拼接"><a href="#5-拼接" class="headerlink" title="5. 拼接"></a>5. 拼接</h3><p>接下来，发送者将“加密后的通信密码” ATCDVT 与 “加密后的消息” KXNWP 进行拼接，将 ATCDVTKXNWP 作为电文通过无线电发出。  </p><p>上面就是用 Enigma 进行加密的操作步骤，看来还真是挺麻烦的。</p><h2 id="4-5-每日密码与通信密码"><a href="#4-5-每日密码与通信密码" class="headerlink" title="4.5 每日密码与通信密码"></a>4.5 每日密码与通信密码</h2><p>每日密码在这里不是用来加密消息的，而是用来加密通信密码的。也就是说，每日密码是一种用来加密密钥的密钥，这种密钥，一般称为密钥加密密钥（Key Encrypting Key，KEY）。</p><h2 id="4-6-避免通信错误"><a href="#4-6-避免通信错误" class="headerlink" title="4.6 避免通信错误"></a>4.6 避免通信错误</h2><p>在通信密码的加密中，我们需要将通信密码 psv 连续输入两次，即 psvpsv。这是因为接收者可以对通信密码进行校验，避免错误。</p><h2 id="4-7-Enigma-的解密"><a href="#4-7-Enigma-的解密" class="headerlink" title="4.7 Enigma 的解密"></a>4.7 Enigma 的解密</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/2_12.png" alt>  </p><h3 id="1-分解"><a href="#1-分解" class="headerlink" title="1.分解"></a>1.分解</h3><p>接收者将接受到的电文分解为两部分，即开头的 6 个字母 ATCDVT 和剩下的字母 KXNWP。</p><h3 id="2-设置-Enigma"><a href="#2-设置-Enigma" class="headerlink" title="2. 设置 Enigma"></a>2. 设置 Enigma</h3><p>接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，这一步和发送者进行的操作是相同的。</p><h3 id="3-解密通信密码"><a href="#3-解密通信密码" class="headerlink" title="3. 解密通信密码"></a>3. 解密通信密码</h3><p>接下来，接收者将加密后的通信密码 ATCDVT 进行解密。接收者在 Enigma 的键盘上输入 ATCDVT 这 6 个字母，然后将亮起的灯泡对应的字母 psvpsv 记下来。<br>因为是 psv 重复两次的形式，所以接收者可以判断在通信过程中没有发生错误。</p><h3 id="4-重新设置-Enigma"><a href="#4-重新设置-Enigma" class="headerlink" title="4. 重新设置 Enigma"></a>4. 重新设置 Enigma</h3><p>接下来，接收者根据通信密码 psv 重新设置 Enigma。</p><h3 id="5-解密消息"><a href="#5-解密消息" class="headerlink" title="5. 解密消息"></a>5. 解密消息</h3><p>接下里，接收者将电文中的剩余部分 KXNWP 逐一输入，将灯泡的结果记下来，得到了 nacht。</p><h2 id="4-8-Enigma-的弱点"><a href="#4-8-Enigma-的弱点" class="headerlink" title="4.8 Enigma 的弱点"></a>4.8 Enigma 的弱点</h2><h3 id="1-将通信密码连续输入两次并加密"><a href="#1-将通信密码连续输入两次并加密" class="headerlink" title="1. 将通信密码连续输入两次并加密"></a>1. 将通信密码连续输入两次并加密</h3><p>这样密码破译者知道密文开头的 6 个字母被解密后的明文一定是 3 个字母重复两次的形式</p><h3 id="2-通信密码是人为选定的"><a href="#2-通信密码是人为选定的" class="headerlink" title="2. 通信密码是人为选定的"></a>2. 通信密码是人为选定的</h3><p>有可能使用 aaa、bbb 或者生日，女朋友的名字当做密码。密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。</p><h3 id="3-必须派发国防军密码本"><a href="#3-必须派发国防军密码本" class="headerlink" title="3. 必须派发国防军密码本"></a>3. 必须派发国防军密码本</h3><p>如果落到敌人手里，就会带来大麻烦。如果现在所使用的国防军密码本被敌人得到，哪怕只泄漏了一本，也必须重新制作新的密码本并发到全军。<br>必须配送密钥这个问题，将在第五章详解。</p><h2 id="4-9-Enigma-的破译"><a href="#4-9-Enigma-的破译" class="headerlink" title="4.9 Enigma 的破译"></a>4.9 Enigma 的破译</h2><p>即使得到了 Enigma 的构造，但是由于 Enigma 的设计并不依赖于“隐蔽式安全性”，只要不知道 Enigma的设置（密钥），就无法破译密码。但是，<br>每日密码在一天之内不会变，即一天内截获的所有通信，都是用同一个密码进行加密的；以及通信密码都会重复两次。以 ATCDVT 为例，即知道第一个字母和<br>第四个字母，都是由相同的明文加密得到的；另外，由于一个轮子只有26个可能。最终经过了许多密码专家的破译，包括现代计算机之父阿兰图灵，最终破译了这个密码。</p><h1 id="5-思考"><a href="#5-思考" class="headerlink" title="5 思考"></a>5 思考</h1><h2 id="5-1-为什么吗要将密码算法和密钥分开呢"><a href="#5-1-为什么吗要将密码算法和密钥分开呢" class="headerlink" title="5.1 为什么吗要将密码算法和密钥分开呢"></a>5.1 为什么吗要将密码算法和密钥分开呢</h2><p>我们来列举一下本章介绍过的密码系统的“密码算法”和“密钥”。</p><table><thead><tr><th style="text-align:left">密码系统</th><th style="text-align:left">密码算法</th><th style="text-align:left">密钥</th></tr></thead><tbody><tr><td style="text-align:left">凯撒密码</td><td style="text-align:left">将明文中的各个字母按照指定的字母数平移</td><td style="text-align:left">平移的字母数量</td></tr><tr><td style="text-align:left">简单替换密码</td><td style="text-align:left">按照替换表对字母表进行替换</td><td style="text-align:left">替换表</td></tr><tr><td style="text-align:left">Enigma（通信密码的加密）</td><td style="text-align:left">使用Enigma密码机，通过接线板的接线方式、三个转子的顺序、每个转子的旋转位置对字母进行替换</td><td style="text-align:left">接线板的接线方式、转子的顺序、转子的旋转位置</td></tr><tr><td style="text-align:left">Enigma（通信电文的加密）</td><td style="text-align:left">使用接线板的接线方式和三个转子的顺序固定的Enigma密码机，按照每个转子的旋转位置对字母进行替换</td><td style="text-align:left">每个转子的旋转位置</td></tr></tbody></table><p>仔细研究一下每一对密码算法和密钥的组合就会发现，在密码算法中必然存在可变部分，而这些可变部分就相当于密钥。当密码算法和密钥都确定时，加密的方法也就确定了。<br>如果每次加密都必须产生一个新的密码算法，那真是太诡异了。对于已经开发出的一种密码算法，我们总是希望能够重复使用。  </p><p>将密码算法和密钥分开的意义正在于此。密码算法是需要重复使用的，但在重复使用同一种算法的过程中，该算法被破译的可能性也在逐渐增大。因此，<br>我们就在密码算法中准备了一些可变部分，并在每次通信时都对这部分进行改变，而这一可变部分就是密钥。  </p><p>将密码算法和密钥分开考虑，就解决了<strong>希望重复使用，但重复使用会增加风险</strong>这个难题。  </p><p>密钥才是秘密的精华。因此，在密码技术中，如何管理密钥是一个重要的课题。这将在第十一章详解。  </p><blockquote><p>每个人都可以拥有相同品牌的锁，但每个人都有不同的钥匙。锁的设计师公开的——锁匠都带有详细图的书，而且绝大多数好的设计方案都在公开专利<br>中进行了描述——但是钥匙是秘密的。</p></blockquote><h1 id="6-本章小结"><a href="#6-本章小结" class="headerlink" title="6 本章小结"></a>6 本章小结</h1><p>密码系统：凯撒密码、简单替换密码以及 Enigma。<br>密码破译：暴力破解、字母频率分析。</p><h1 id="7-小测验"><a href="#7-小测验" class="headerlink" title="7 小测验"></a>7 小测验</h1><ol><li>凯撒密码中，如果存在如 c -&gt; C， q -&gt; Q这样，明文中的字母被替换成了相同字母的密文的情况。于是Alice就想：如果替换表中不出现这种被替换<br>为相同字母的情况，那么密文应该会更难被破译吧？请问 Alice 的想法正确吗？ </li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、环游密码世界</title>
      <link href="/2017/11/10/graphic2cryptography/1.html/"/>
      <url>/2017/11/10/graphic2cryptography/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本章概要"><a href="#1-本章概要" class="headerlink" title="1 本章概要"></a>1 本章概要</h1><p>从整体上了解密码世界的模样。</p><h1 id="2-密码"><a href="#2-密码" class="headerlink" title="2 密码"></a>2 密码</h1><h2 id="2-1-Alice-与-Bob"><a href="#2-1-Alice-与-Bob" class="headerlink" title="2.1 Alice 与 Bob"></a>2.1 Alice 与 Bob</h2><p>要讲解密码，需要给参与信息交互的人和计算机起几个名字，如下表：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Alice</td><td style="text-align:center">一般角色</td></tr><tr><td style="text-align:center">Bob</td><td style="text-align:center">一般角色</td></tr><tr><td style="text-align:center">Eve</td><td style="text-align:center">窃听者，可窃听通信内容</td></tr><tr><td style="text-align:center">Mallory</td><td style="text-align:center">主动攻击者，可妨碍正常通信、伪造消息等</td></tr><tr><td style="text-align:center">Trent</td><td style="text-align:center">可信的第三方</td></tr><tr><td style="text-align:center">Victor</td><td style="text-align:center">验证者</td></tr></tbody></table><h2 id="2-2-发送者、接受者和窃听者"><a href="#2-2-发送者、接受者和窃听者" class="headerlink" title="2.2 发送者、接受者和窃听者"></a>2.2 发送者、接受者和窃听者</h2><p>Alice 向 Bob 发送消息，Alice 作为 Sender，Bob 作为 Receiver，消息作为 Message。在互联网中，消息会经过许多台计算机和通信设备做中转，<br>在这个过程中，就存在被恶意窃听者（eavesdropper）偷看的可能。作为监听者，我们给它起名为Eve，它可能是人类也有可能是某些程序软件。</p><h2 id="2-3-加密与解密"><a href="#2-3-加密与解密" class="headerlink" title="2.3 加密与解密"></a>2.3 加密与解密</h2><p>Alice 不想让别人看到她传递消息的内容，因为它决定将消息加密（encrypt） 后再发送出去，加密之前的是明文（plaintext），加密之后的消息称为<br>密文（ciphertext）。  </p><p>Bob 收到了 Alice 的加密消息后，他需要进行解密（decrypt）之后再查阅，即将密文恢复成明文的过程。这样，窃听者在网络上得到的只是密文。</p><h2 id="2-4-破译"><a href="#2-4-破译" class="headerlink" title="2.4 破译"></a>2.4 破译</h2><p>Eve 得到了密文，试图将密文还原为明文，被称为密码破译（cryptanalysis），简称破译，或者密码分析。</p><h1 id="3-对称密码与公钥密码"><a href="#3-对称密码与公钥密码" class="headerlink" title="3 对称密码与公钥密码"></a>3 对称密码与公钥密码</h1><h2 id="3-1-密码算法"><a href="#3-1-密码算法" class="headerlink" title="3.1 密码算法"></a>3.1 密码算法</h2><p>用于解决复杂问题的步骤，通常称为算法（algorithm），明文生成密文的步骤，被称为“加密算法”；而解密的步骤被称为“解密算法”，它们两统称为密码算法。</p><h2 id="3-2-密钥"><a href="#3-2-密钥" class="headerlink" title="3.2 密钥"></a>3.2 密钥</h2><p>密码算法中需要密钥（key）。如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_1.png" alt><br>无论是在加密还是解密时，都需要知道密钥。</p><h2 id="3-3-对称密钥与公钥密码"><a href="#3-3-对称密钥与公钥密码" class="headerlink" title="3.3 对称密钥与公钥密码"></a>3.3 对称密钥与公钥密码</h2><p>根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。</p><ol><li>对称密码（symmetric cryptography）是指在加密和解密时使用同一密钥的方式。</li><li>公钥密码（public-key cryptography）则是在加密和解密时使用不同密钥的方式，也称非对称密码（asymmetric cryptography）。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_2.png" alt></li></ol><h2 id="3-4-混合密码系统"><a href="#3-4-混合密码系统" class="headerlink" title="3.4 混合密码系统"></a>3.4 混合密码系统</h2><p>将对称密码和公钥密码结合起来的密码方式。</p><h1 id="4-其它密码技术"><a href="#4-其它密码技术" class="headerlink" title="4 其它密码技术"></a>4 其它密码技术</h1><h2 id="4-1-单向散列函数"><a href="#4-1-单向散列函数" class="headerlink" title="4.1 单向散列函数"></a>4.1 单向散列函数</h2><p>为了防止下载的软件被篡改，有安全意思的软件发布者会步的散列值。散列值就是用单向散列函数（one-way hash function）计算出来的数值。  </p><p>单向散列函数所保证的并不是机密性，而是完整性（integrity），即“数据是正牌的而不是伪造的”。第七章，详细讲解。</p><h2 id="4-2-消息认证码"><a href="#4-2-消息认证码" class="headerlink" title="4.2 消息认证码"></a>4.2 消息认证码</h2><p>为了确认消息是否来自所期望的通信对象，可以使用消息认证码（message authentication code）技术，不仅能保证完整性还能提供认证（authentication）机制。</p><h2 id="4-3-数字签名"><a href="#4-3-数字签名" class="headerlink" title="4.3 数字签名"></a>4.3 数字签名</h2><p>验证消息是否被篡改，能够确保完整性、提供认证并防止否认的密码机制。将第九章详解。</p><h2 id="4-4-伪随机数生成器"><a href="#4-4-伪随机数生成器" class="headerlink" title="4.4 伪随机数生成器"></a>4.4 伪随机数生成器</h2><p>伪随机数生成器（Pseudo Random Number Generator，PRNG）是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这么说可能会感到意外，<br>但实际上随机数确实承担着密钥生成的重要职责。例如在 Web 中进行 SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥<br>就是基于伪随机数生成的。将在第十二章详解。</p><h1 id="5-密码学家的工具箱"><a href="#5-密码学家的工具箱" class="headerlink" title="5 密码学家的工具箱"></a>5 密码学家的工具箱</h1><p>在以上内容中，已经出现了很多种类的密码技术，其中以下六种发挥尤其重要的作用：</p><ol><li>对称密码</li><li>公钥密码（非对称密码）</li><li>单向散列函数</li><li>消息认证码</li><li>数字签名</li><li>伪随机数生成器</li></ol><p>在本书中，将上述六种技术统称为密码学家的工具箱。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/graphic2cryptography/1_3.png" alt></p><h1 id="6-隐写术与数字水印"><a href="#6-隐写术与数字水印" class="headerlink" title="6 隐写术与数字水印"></a>6 隐写术与数字水印</h1><p>上面讲过，密码是一种能够让消息内容变得无法解读的技术，即 cryptography。除此之外，还有另外一种技术，它不是让消息内容变得无法解读，而是能够<br>隐藏消息本身，这种技术称为隐写术（steganography）。例如：<br><strong>我</strong>们先准备一段话，<br><strong>很</strong>容易看懂的就可以，<br><strong>喜</strong>闻乐见的当然更好，<br><strong>欢</strong>迎你尝试将另一句话嵌在这段话中，<br><strong>你</strong>会发现这其实就是一种隐写术。  </p><p>这样，就发现这段话还隐藏着另一句话“我很喜欢你”。<br>隐写术在计算机中，用于数字水印技术，它是一种将著作权拥有者及购买者的信息嵌入文本中的技术。但是仅凭数字水印技术时无法对信息进行加密的，因此需要<br>和其它技术配合使用。  </p><p>例如，将密码技术和隐写术相结合的方法就很常见。首先，我们将要嵌入的文章进行加密并生成密文，然后再通过隐写术将密文隐藏到图片中。这样一来，<br>即便有人发现了密文的存在，也无法读取出所嵌入的文章的内容。<br>密码隐藏的是内容，隐写术隐藏的是消息本身。</p><h1 id="7-密码与信息安全常识"><a href="#7-密码与信息安全常识" class="headerlink" title="7 密码与信息安全常识"></a>7 密码与信息安全常识</h1><h2 id="7-1-不要使用保密的密码算法"><a href="#7-1-不要使用保密的密码算法" class="headerlink" title="7.1 不要使用保密的密码算法"></a>7.1 不要使用保密的密码算法</h2><p>我们不应该制作或使用任何保密的密码算法，而是应该使用那些已经公开的、被公认为强度较高的密码算法，原因如下：</p><ol><li>密码算法的秘密早晚会公诸于世。</li><li>开发高强度的密码算法是非常困难的。而试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（security by obscurity），这是危险且愚蠢的行为。</li></ol><h2 id="7-2-使用低强度的密码比不进行任何加密更危险"><a href="#7-2-使用低强度的密码比不进行任何加密更危险" class="headerlink" title="7.2 使用低强度的密码比不进行任何加密更危险"></a>7.2 使用低强度的密码比不进行任何加密更危险</h2><p>对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，这通常会导致用户在处理一些机密信息的时候麻痹大意。</p><h2 id="7-3-任何密码总会有一天都会被破解"><a href="#7-3-任何密码总会有一天都会被破解" class="headerlink" title="7.3 任何密码总会有一天都会被破解"></a>7.3 任何密码总会有一天都会被破解</h2><p>无论使用任何密码算法锁生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的<br>价值之间的权衡就显得非常重要。严格来说，绝对不会被破解的密码其实是存在的，这种算法称为一次性密码本（one-time pad），将在3.4节详解。<br>此外，还有另一种技术被认为有可能早就完美的密码技术，那就是量子密码，将在15.3.1节详解。</p><h2 id="7-4-密码只是信息安全的一部分"><a href="#7-4-密码只是信息安全的一部分" class="headerlink" title="7.4 密码只是信息安全的一部分"></a>7.4 密码只是信息安全的一部分</h2><p>社会工程学（social engineering）。最脆弱的环节并不是密码，而是人类自己。</p><h1 id="8-本章小结"><a href="#8-本章小结" class="headerlink" title="8 本章小结"></a>8 本章小结</h1><p>主要浏览了密码世界中的一些主要技术。</p><h1 id="9-小测验"><a href="#9-小测验" class="headerlink" title="9 小测验"></a>9 小测验</h1><p>下面说法是否正确？  </p><ol><li>将明文转换为密文的过程称为加密。</li><li>明文是供人类读取的数据，而密文则是供计算机读取的数据。</li><li>只要检查邮件发送者（From:）一栏的内容，就能够正确判断邮件是谁发出的。</li><li>在对称密码中，加密用的密钥和解密用的密钥是相同的。</li><li>公开的密码算法容易遭到坏人的攻击，因此使用自己公司开发的保密的密码算法更加安全。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 图解密码技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、Java中的锁</title>
      <link href="/2017/11/07/concurrent-art/5.html/"/>
      <url>/2017/11/07/concurrent-art/5.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Lock-接口"><a href="#1-Lock-接口" class="headerlink" title="1 Lock 接口"></a>1 Lock 接口</h1><h1 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2. 队列同步器"></a>2. 队列同步器</h1><p>队列同步器 AbstractQueueSynchronizer （简称同步器），是用来构建锁或者其它同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，<br>通过内置的 FIFO 队列完成资源获取线程的排队工作。  </p><h2 id="2-1-队列同步器的接口与示例"><a href="#2-1-队列同步器的接口与示例" class="headerlink" title="2.1 队列同步器的接口与示例"></a>2.1 队列同步器的接口与示例</h2><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，<br>它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。<br>锁和同步器很好地隔离了使用者和实现者所需关注的领域。  </p><p>只有掌握了同步器的工作原理才能更加深入地理解并发包中其它的并发组件，所以下面通过一个独占锁的实例来深入了解一下同步器的工作原理。  </p><p>独占锁就是在同一时刻只能由一个线程获取到锁，而其它获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁，代码5-2如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-队列同步器的实现分析"><a href="#2-2-队列同步器的实现分析" class="headerlink" title="2.2 队列同步器的实现分析"></a>2.2 队列同步器的实现分析</h2><p>分析同步器如何完成线程同步的，包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模块方法。</p><h3 id="2-2-1-同步队列"><a href="#2-2-1-同步队列" class="headerlink" title="2.2.1 同步队列"></a>2.2.1 同步队列</h3><p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点 （Node） 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，<br>会把首节点中的线程唤醒，使其再次尝试获取同步状态。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_1.png" alt><br>试想，当一个线程成功地获取了同步状态（锁），其它线程将无法获取到同步状态，转而被构造称为节点并加入到同步队列中，而这个加入队列的过程必须要<br>保证线程安全，因此同步器提供了一个基于 CAS 线程的设置尾节点的方法： <code>compareAndSetTail(Node expect, Node update)</code> ，它需要传递当前“认为”<br>的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_2.png" alt><br>首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_3.png" alt><br>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证。</p><h3 id="2-2-2-独占式同步状态获取与释放"><a href="#2-2-2-独占式同步状态获取与释放" class="headerlink" title="2.2.2 独占式同步状态获取与释放"></a>2.2.2 独占式同步状态获取与释放</h3><p>通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程<br>进行中断操作时，线程不会从同步队列中移出，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3 重入锁"></a>3 重入锁</h1><p>ReenTrantLock，支持重入的锁。</p><h2 id="3-1-实现重进入"><a href="#3-1-实现重进入" class="headerlink" title="3.1 实现重进入"></a>3.1 实现重进入</h2><p>这个特性需要解决两个问题：</p><ol><li>线程再次获取锁。锁需要去识别获取锁额线程是否为当前占据锁的线程，如果是，则再次成功获取。</li><li>锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放锁后，其它线程能够获取到锁。要求对获取进行计数自增，释放时计数自减。  </li></ol><p>获取锁源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>释放锁源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-2-公平与非公平获取锁的区别"><a href="#3-2-公平与非公平获取锁的区别" class="headerlink" title="3.2 公平与非公平获取锁的区别"></a>3.2 公平与非公平获取锁的区别</h2><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。<br>源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中相对于非公平锁的获取，多了一个 <code>hasQueuedPredecessors()</code> 判断，判断是否当前节点是否有前驱节点的判断。  </p><p>如果有 n 个线程争夺锁。对于公平锁来说，保证了每个线程都可以获取锁，即有 n 次线程切换。而对于非公平锁来说，有可能有的线程能获取多次锁，<br>有的线程根本获取不到锁，线程切换次数是小于 n 的。因此减去上下文的切换时间，非公平锁的效率更高，所以 <code>ReentrantLock</code> 默认为非公平锁。 </p><h1 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4 读写锁"></a>4 读写锁</h1><p>在没有读写锁支持的时候（Java5之前），使用 Java 的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并行通知后，<br>所有等待的读操作才能继续执行（写操作之间依靠 synchronized 关键字进行同步）。  </p><p>一般来说，读写锁的性能都会比排他锁好（ReentrantLock 也是一种排他锁），因为大多数场景读是多于写的。Java并发包提供读写锁的实现是 <code>ReentrantReadWriteLock</code>。</p><h2 id="4-1-读写锁的接口与示例"><a href="#4-1-读写锁的接口与示例" class="headerlink" title="4.1 读写锁的接口与示例"></a>4.1 读写锁的接口与示例</h2><p>通过缓存示例说明读写锁的使用方式，代码5-16：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock r = rwl.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用非线程安全的 <code>HashMap</code> 作为缓存的实现。使用读写锁提升读操作的并发性，并简化了编程方式。</p><h2 id="4-2-读写锁的实现分析"><a href="#4-2-读写锁的实现分析" class="headerlink" title="4.2 读写锁的实现分析"></a>4.2 读写锁的实现分析</h2><h3 id="4-2-1-读写状态的设计"><a href="#4-2-1-读写状态的设计" class="headerlink" title="4.2.1 读写状态的设计"></a>4.2.1 读写状态的设计</h3><p>读写锁依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态<br>（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。  </p><p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/5_4.png" alt><br>当前图的同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。<br>假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF（将高16位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1,，<br>当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。  </p><p>根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h3 id="4-2-2-写锁的获取与释放"><a href="#4-2-2-写锁的获取与释放" class="headerlink" title="4.2.2 写锁的获取与释放"></a>4.2.2 写锁的获取与释放</h3><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，<br>则当前线程进入等待状态，获取锁的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-3-读锁的获取与释放"><a href="#4-2-3-读锁的获取与释放" class="headerlink" title="4.2.3 读锁的获取与释放"></a>4.2.3 读锁的获取与释放</h3><p>读锁是一个支持重进入的共享锁，能被多个线程同时获取，在没有其它写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。<br>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如<br><code>getReadHoldCount()</code> 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的综合，而每个线程各自获取读锁的次数只能选择<br>保存在 <code>ThreadLocal</code> 中，由线程自身维护，这使得获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果其它线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，成功获取读锁。</p><h3 id="4-2-4-锁降级"><a href="#4-2-4-锁降级" class="headerlink" title="4.2.4 锁降级"></a>4.2.4 锁降级</h3><p>锁降级指的是写锁降级称为读锁。获取写锁-释放写锁-获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指：获取写锁-获取读锁-释放写锁。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八、Java中的并发工具类</title>
      <link href="/2017/11/07/concurrent-art/8.html/"/>
      <url>/2017/11/07/concurrent-art/8.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-等待多线程完成的-CountDownLatch"><a href="#1-等待多线程完成的-CountDownLatch" class="headerlink" title="1 等待多线程完成的 CountDownLatch"></a>1 等待多线程完成的 CountDownLatch</h1><p>例如：解析一个 Excel 里多个 sheet 的数据，如果使用多线程，每个线程解析一个 sheet 里的数据，等到所有的 sheet 都解析完之后，程序提示解析完成。  </p><p>即，需要主线程等待所有线程完成 sheet 的解析操作，最简单的做法是使用 join() 方法，代码8-1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"parser1 finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"parser2 finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        parser1.start();</span><br><span class="line">        parser2.start();</span><br><span class="line">        parser1.join();</span><br><span class="line">        parser2.join();</span><br><span class="line">        System.out.println(<span class="string">"all parser finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>join 用于让当前执行线程等待 join 线程执行结束。其实现原理是不听检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。  </p><p>CountDownLacth 内部维护一个 int 类型的参数作为计数器，每次执行 countDown() 都会让计数器减1，await()只有当计数器为0的时候，才不会阻塞当前线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-同步屏障-CyclicBarrier"><a href="#2-同步屏障-CyclicBarrier" class="headerlink" title="2 同步屏障 CyclicBarrier"></a>2 同步屏障 CyclicBarrier</h1><h2 id="2-1-CyclicBarrier-简介"><a href="#2-1-CyclicBarrier-简介" class="headerlink" title="2.1 CyclicBarrier 简介"></a>2.1 CyclicBarrier 简介</h2><p>字面意思：可循环使用（cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，<br>屏障才会开门，所有被屏障拦截的线程才会继续运行。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread s = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 设置睡眠，输出：321，如果不设置，可能会是312</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        s.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-CyclicBarrier-的应用场景"><a href="#2-2-CyclicBarrier-的应用场景" class="headerlink" title="2.2 CyclicBarrier 的应用场景"></a>2.2 CyclicBarrier 的应用场景</h2><p>用于多线程计算数据，最后合并计算结果的场景。例如，用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个账户近一年的每笔银行流水，<br>现在需要统计用户的日均银行流水，先多线程处理每个 Sheet 的银行流水，都执行完之后，再用 barrierAction 计算线程结果。代码8-5如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lwg.current_art;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 4 个屏障，当运行了 4 个await()后，才会运行第二参数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4 个sheet，创建 4 个线程的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存每个线程的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; sheetBankWaterCount = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    sheetBankWaterCount.put(Thread.currentThread().getName(), <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"size:"</span> + sheetBankWaterCount.size());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        c.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; sheet: sheetBankWaterCount.entrySet())&#123;</span><br><span class="line">            result += sheet.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        sheetBankWaterCount.put(<span class="string">"result"</span>, result);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        BankWaterService bankWaterService = <span class="keyword">new</span> BankWaterService();</span><br><span class="line">        bankWaterService.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-3-CyclicBarrier-和-CountDownLatch-的区别"><a href="#2-3-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="2.3 CyclicBarrier 和 CountDownLatch 的区别"></a>2.3 CyclicBarrier 和 CountDownLatch 的区别</h2><p>CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务。<br>一些 API 用法如下代码8-6：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-3-控制并发线程数的-Semaphore"><a href="#2-3-控制并发线程数的-Semaphore" class="headerlink" title="2.3 控制并发线程数的 Semaphore"></a>2.3 控制并发线程数的 Semaphore</h2><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。  </p><p>把 Semaphore 比作是控制流量的红绿灯。比如xx马路要限制流量，只允许同时有一百辆车在这条路上行驶，其它的都必须在路口等待，所以前一百辆车会看到绿灯，<br>可以开进这条马路，后面的车会看到红灯，不能驶入xx马路，但是如果前一百辆中有5辆车已经离开了xx马路，那么后面就允许有5辆车驶入xx马路，<br>即车就是线程，驶入马路就是线程执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞。</p><h3 id="2-3-1-应用场景"><a href="#2-3-1-应用场景" class="headerlink" title="2.3.1 应用场景"></a>2.3.1 应用场景</h3><p>Semaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假设有一个需求，要读取几万个文件的数据，因为都是IO密集型人物，<br>我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，<br>否则会报错无法获取数据库连接。这个时候可以使用 Semaphore 做流量控制，如下代码8-7：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-线程间交换数据的-Exchanger"><a href="#4-线程间交换数据的-Exchanger" class="headerlink" title="4 线程间交换数据的 Exchanger"></a>4 线程间交换数据的 Exchanger</h1><p>Exchanger 提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。如果第一个线程执行 exchange() 方法，它就会一直等待第二个线程也执行 exchange 方法，<br>当两个线程都到达同步点时，这时就可以交换数据。</p><h2 id="4-1-应用场景"><a href="#4-1-应用场景" class="headerlink" title="4.1 应用场景"></a>4.1 应用场景</h2><ol><li>遗传算法：选出两个人作为交配对象，交换两人的数据，并使用交叉规则得出2个交配结果。</li><li>校对工作：对两个人工录入的文件进行校对。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>;</span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>;</span><br><span class="line">                    String A = exgr.exchange(B);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">".A录入的是："</span> + A + <span class="string">".B录入的是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="5-本章小结"><a href="#5-本章小结" class="headerlink" title="5 本章小结"></a>5 本章小结</h1><ol><li>CountDownLatch-&gt;CyclicBarrier：都是等待某些运行到某个点后，才执行后面的方法，但是 CyclicBarrier提供的 API 更多适合更复杂的场景。</li><li>Semaphore：控制并发数，即创建了30个线程，但是并发最多可以设置为10。</li><li>Exchanger：线程间交换数据，在同步点处，A线程可以获得B线程的数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六、Java并发容器和框架</title>
      <link href="/2017/11/07/concurrent-art/6.html/"/>
      <url>/2017/11/07/concurrent-art/6.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ConcurrentHashMap-的实现原理与使用"><a href="#1-ConcurrentHashMap-的实现原理与使用" class="headerlink" title="1 ConcurrentHashMap 的实现原理与使用"></a>1 ConcurrentHashMap 的实现原理与使用</h1><h2 id="1-1-为什么要使用-ConcurrentHashMap"><a href="#1-1-为什么要使用-ConcurrentHashMap" class="headerlink" title="1.1 为什么要使用 ConcurrentHashMap"></a>1.1 为什么要使用 ConcurrentHashMap</h2><ol><li>线程不安全的 HashMap ，在多线程下 HashMap 的 Entry 链表导致形成环形数据结构， Entry 的 next 节点永远不为空，就会产生死循环获取 Entry 。</li><li>效率低下的 HashTable ，使用 synchronized 保证线程安全。</li><li>ConcurrentHashMap 的锁分段技术有效提升并发访问率。 HashTable 效率低下是因为所有访问 HashTable 的线程都必须竞争同一把锁，如果容器里<br>有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程就不会存在锁竞争。</li></ol><h2 id="1-2-ConcurrentHashMap-的结构"><a href="#1-2-ConcurrentHashMap-的结构" class="headerlink" title="1.2 ConcurrentHashMap 的结构"></a>1.2 ConcurrentHashMap 的结构</h2><p>ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁（ReentrantLock）， Segment的结构和 HashMap<br>结构类似。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_1.png" alt></p><h2 id="1-3-ConcurrentHashMap-的初始化"><a href="#1-3-ConcurrentHashMap-的初始化" class="headerlink" title="1.3 ConcurrentHashMap 的初始化"></a>1.3 ConcurrentHashMap 的初始化</h2><ol><li>初始化 segments 数组</li><li>初始化 segmentShift 和 segmentMask。用于散列算法的一些值。</li><li>初始化每个 segment，包括容量以及负载因子。</li></ol><h2 id="1-4-ConcurrentHashMap-的操作"><a href="#1-4-ConcurrentHashMap-的操作" class="headerlink" title="1.4 ConcurrentHashMap 的操作"></a>1.4 ConcurrentHashMap 的操作</h2><h3 id="1-4-1-get-操作"><a href="#1-4-1-get-操作" class="headerlink" title="1.4.1 get 操作"></a>1.4.1 get 操作</h3><p>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空才会加锁重读。如何保证不加锁？原因在于它的 get 方法里将要使用的共享变量都<br>定义成 volatile 类型，如用于统计当前 Segment 大小的 count 字段和用于存储值的 HashEntry 的 value 。但只能被单线程写（有一种情况可以被<br>多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value ，所以不需要加锁。即使两个线程同时修改和获取<br> volatile 变量， get 操作也能拿到最新的值，这是用 volatile 替换锁的经典应用场景。</p><h3 id="1-4-2-put-操作"><a href="#1-4-2-put-操作" class="headerlink" title="1.4.2 put 操作"></a>1.4.2 put 操作</h3><p>必须加锁。先定位到 Segment ，然后在 Segment 里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对 Segment 里的 HashEntry 数组<br>进行扩容，第二步定位添加元素的位置，然后将其放在 HashEntry 数组里。</p><ol><li>是否需要扩容：插入元素前会判断 Segment 里的 HashEntry 数组是否超过容量，如果超过阈值，则对数组进行扩容。</li><li>如何扩容：先创建一个容量是原来容量两倍的数组，然后将原数组里元素进行散列后插入到新的数组里。为了高效， 只会对某个 Segment 进行扩容。</li></ol><h3 id="1-4-3-size-操作"><a href="#1-4-3-size-操作" class="headerlink" title="1.4.3 size 操作"></a>1.4.3 size 操作</h3><p>每个 Segment 的count 是 valatile 变量，但是累加过程中有可能 count 发生变化，最安全的做法是在统计 size 的时候把所有 Segment 的 put、<br>remove 和 clean 方法全部锁住，但是非常低效。所以 ConcurrentHashMap 的做法是尝试 2 次通过不锁住 Segment 的方式来统计累和，如果 count<br>发生变化，再采用加锁方式统计。如果判断count 发生变化呢？使用 modCount 变量。</p><h1 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2 ConcurrentLinkedQueue"></a>2 ConcurrentLinkedQueue</h1><p>实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。前者可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队<br>用不同的锁）等方式实现。非阻塞的实现则可以使用循环 CAS 的方式来实现。</p><h2 id="2-1-ConcurrentLinkedQueue-的结构"><a href="#2-1-ConcurrentLinkedQueue-的结构" class="headerlink" title="2.1 ConcurrentLinkedQueue 的结构"></a>2.1 ConcurrentLinkedQueue 的结构</h2><p>由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成。默认情况下 head 节点存储的元素为空，<br>tail 节点等于 head 节点。</p><h2 id="2-2-入队列"><a href="#2-2-入队列" class="headerlink" title="2.2 入队列"></a>2.2 入队列</h2><h3 id="2-2-1-入队列的过程"><a href="#2-2-1-入队列的过程" class="headerlink" title="2.2.1 入队列的过程"></a>2.2.1 入队列的过程</h3><ol><li>添加元素1。队列更新 head 节点的 next 节点为元素1节点，又因为 tail 节点默认情况下等于 head 节点，所以它们的 next 节点都指向元素1节点。  </li><li>添加元素2。队列首先设置元素1节点的 next 节点为元素2节点，然后更新 tail 节点指向元素2节点。</li><li>添加元素3。设置 tail 节点的 next 节点为元素3节点。</li><li>添加元素4。设置元素3的 next 节点为元素4节点，然后将 tail 节点指向元素4节点。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_2.png" alt><br>入队主要做两件事：一是将入队节点设置成当前队列尾节点的下一个节点；二是更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成<br>tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点。  </li></ol><p>在代码中，入队主要做两件事：一是定位出尾节点（通过 tail 的 next 是否为空）；二是使用 CAS 算法将入队队列设置成尾节点的 next 节点，如不成功则重试。<br>（进行 tail 的 next 判断是否为空时，如果循环两次都不为空，则重新进行队列，因为肯定有别的线程加了尾）。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">        Node&lt;E&gt; p = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                    casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = succ(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-2-定位尾节点"><a href="#2-2-2-定位尾节点" class="headerlink" title="2.2.2 定位尾节点"></a>2.2.2 定位尾节点</h3><p>通过判断 tail 节点和 tail 节点的 next 节点。</p><h3 id="2-2-3-HOPS-的设计意图"><a href="#2-2-3-HOPS-的设计意图" class="headerlink" title="2.2.3 HOPS 的设计意图"></a>2.2.3 HOPS 的设计意图</h3><p>用如下实现是否可行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让 tail 节点永远作为队列的尾节点，这样实现代码量非常少。但是有个缺点是，每次都要更新 tail 节点为尾节点，而使用 HOPS 常量，进行判断，如果<br>当 tail 节点和尾节点的距离大于等于常量 HOPS 的值（默认等于1）时才更新 tail 节点，来通过增加对 volatile 变量的读操作来减少对 volatile 变量<br>的写操作，入队效率提升。</p><h2 id="2-3-出队列"><a href="#2-3-出队列" class="headerlink" title="2.3 出队列"></a>2.3 出队列</h2><p>只有当 head 节点里没有元素时，出队操作才会更新 head 节点。这种做法也是通过 hops 变量来减少使用 CAS 更新 head 节点的消耗，从而提高出队效率。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_3.png" alt></p><h1 id="3-Java-中的阻塞队列"><a href="#3-Java-中的阻塞队列" class="headerlink" title="3 Java 中的阻塞队列"></a>3 Java 中的阻塞队列</h1><h2 id="3-1-什么是阻塞队列"><a href="#3-1-什么是阻塞队列" class="headerlink" title="3.1 什么是阻塞队列"></a>3.1 什么是阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ol><li>支持阻塞的插入方法：意思当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li><li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</li></ol><h2 id="3-2-Java-里的阻塞队列"><a href="#3-2-Java-里的阻塞队列" class="headerlink" title="3.2 Java 里的阻塞队列"></a>3.2 Java 里的阻塞队列</h2><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ArrayBlockingQueue</td><td style="text-align:left">一个由数组结构组成的有界阻塞队列</td></tr><tr><td style="text-align:left">LinkedBlockingQueue</td><td style="text-align:left">一个由链表结构组成的有界阻塞队列</td></tr><tr><td style="text-align:left">PriorityBlockingQueue</td><td style="text-align:left">支持优先级排序的无界阻塞队列</td></tr><tr><td style="text-align:left">DelayQueue</td><td style="text-align:left">使用优先级队列实现的无界阻塞队列</td></tr><tr><td style="text-align:left">SynchronousQueue</td><td style="text-align:left">不存储元素的阻塞队列</td></tr><tr><td style="text-align:left">LinkedTransferQueue</td><td style="text-align:left">由链表结构组成的无界阻塞队列</td></tr><tr><td style="text-align:left">LinkedBlockingDeque</td><td style="text-align:left">由链表结构组成的双向阻塞队列</td></tr></tbody></table><h2 id="3-3-阻塞队列的实现原理"><a href="#3-3-阻塞队列的实现原理" class="headerlink" title="3.3 阻塞队列的实现原理"></a>3.3 阻塞队列的实现原理</h2><h3 id="3-3-1-使用通知模式实现"><a href="#3-3-1-使用通知模式实现" class="headerlink" title="3.3.1 使用通知模式实现"></a>3.3.1 使用通知模式实现</h3><p>即当生产者往满的队列里添加元素时会阻塞住消费者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><h1 id="4-Fork-Join-框架"><a href="#4-Fork-Join-框架" class="headerlink" title="4 Fork/Join 框架"></a>4 Fork/Join 框架</h1><h2 id="4-1-什么是-Fork-Join-框架"><a href="#4-1-什么是-Fork-Join-框架" class="headerlink" title="4.1 什么是 Fork/Join 框架"></a>4.1 什么是 Fork/Join 框架</h2><p>Fork 就是把一个大任务切分为若干子任务并行的执行， Join 就是合并这些子任务的执行结果。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/6_4.png" alt></p><h2 id="4-2-工作窃取算法"><a href="#4-2-工作窃取算法" class="headerlink" title="4.2 工作窃取算法"></a>4.2 工作窃取算法</h2><p>某个线程先把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理，这时候，完成任务的线程去做还有任务的线程的任务。  </p><ol><li>优点：充分利用线程进行并行计算，减少线程间的竞争。</li><li>缺点：如果只有一个任务时，还是会有竞争。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端队列。</li></ol><h2 id="4-3-Fork-Join-框架的设计"><a href="#4-3-Fork-Join-框架的设计" class="headerlink" title="4.3 Fork/Join 框架的设计"></a>4.3 Fork/Join 框架的设计</h2><ol><li>分割任务：首先我们需要由一个 fork 类来把大任务分割成小任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li><li>执行任务并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，<br>启动一个线程从队列里里拿数据，然后合并这些数据。  </li></ol><p>Fork/Join 使用两个类来完成以上两件事。  </p><ol><li>ForkJoinTask：我们要使用 ForkJoin框架，必须首先创建一个 Fork/Join 任务。它提供在任务中执行 fork() 和 join() 操作的机制。通常情况下，<br>我们只需要继承它的子类，而 Fork/Join 框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务； RecursiveTask：用于有返回结果的任务。  </li><li>ForkJoinPool：ForkJoinTask 需要通过 ForkJoinPool 来执行：任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。<br>当一个工作线程的队列里暂时没有任务时，它会随机从其它工作线程的队列的尾部 获取一个任务。</li></ol><h2 id="4-4-使用-Fork-Join-框架"><a href="#4-4-使用-Fork-Join-框架" class="headerlink" title="4.4 使用 Fork/Join 框架"></a>4.4 使用 Fork/Join 框架</h2><p>需求：计算1+2+3+4的结果。<br>如果希望每个子任务最多执行两个数的相加，我们设置分割的阈值是2，由于是4个数字相加，所以fork成两个子任务，一个计算1+2，一个计算3+4，然后再join两个子任务。<br>由于有结果的任务，因此继承 RecursiveTask。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-5-Fork-Join-框架的实现原理"><a href="#4-5-Fork-Join-框架的实现原理" class="headerlink" title="4.5 Fork/Join 框架的实现原理"></a>4.5 Fork/Join 框架的实现原理</h2><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成， ForkJoinTask 数组负责将存放程序提交给 ForkJoinPool 的任务，<br>而 ForkJoinWorkerThread 数组负责执行这些任务。</p><h3 id="4-5-1-ForkJoinTask-的-fork-方法实现原理"><a href="#4-5-1-ForkJoinTask-的-fork-方法实现原理" class="headerlink" title="4.5.1 ForkJoinTask 的 fork 方法实现原理"></a>4.5.1 ForkJoinTask 的 fork 方法实现原理</h3><p>使用 push 方法，把当前任务存放在 ForkJoinTask 数组队列中，再调用 ForkJoinPool 的 signalWork() 方法唤醒或创建一个工作线程来异步的执行这个任务，<br>然后立即返回结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-5-2-ForkJoinTask-的-join-方法实现原理"><a href="#4-5-2-ForkJoinTask-的-join-方法实现原理" class="headerlink" title="4.5.2 ForkJoinTask 的 join 方法实现原理"></a>4.5.2 ForkJoinTask 的 join 方法实现原理</h3><p>Join 方法主要用于阻塞当前线程并等待获取结果。调用 doJoin() 方法，通过查看任务状态，如果执行完则直接返回任务状态；如果没执行完，<br>则从任务数组里取出任务并执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportException</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL)</span><br><span class="line">        rethrow(getThrowableException());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、Java并发编程基础</title>
      <link href="/2017/11/07/concurrent-art/4.html/"/>
      <url>/2017/11/07/concurrent-art/4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1 线程简介"></a>1 线程简介</h1><h2 id="1-1-什么是线程"><a href="#1-1-什么是线程" class="headerlink" title="1.1 什么是线程"></a>1.1 什么是线程</h2><p>操作系统运行一个程序时，会为其创建一个进程。而操作系统调度的最小单元是线程，也叫轻量级进程（ Light Weight Process），<br>在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。<br>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(threadInfo.getThreadId() + <span class="string">","</span> + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         6,Monitor Ctrl-Break</span></span><br><span class="line"><span class="comment">         5,Attach Listener</span></span><br><span class="line"><span class="comment">         4,Signal Dispatcher</span></span><br><span class="line"><span class="comment">         3,Finalizer</span></span><br><span class="line"><span class="comment">         2,Reference Handler</span></span><br><span class="line"><span class="comment">         1,main</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-为什么要使用多线程"><a href="#1-2-为什么要使用多线程" class="headerlink" title="1.2 为什么要使用多线程"></a>1.2 为什么要使用多线程</h2><h3 id="1-2-1-更多的处理器核心"><a href="#1-2-1-更多的处理器核心" class="headerlink" title="1.2.1 更多的处理器核心"></a>1.2.1 更多的处理器核心</h3><p>程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器<br>核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，<br>就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p><h3 id="1-2-2-更快的响应时间"><a href="#1-2-2-更快的响应时间" class="headerlink" title="1.2.2 更快的响应时间"></a>1.2.2 更快的响应时间</h3><p>编写一些较为复杂的代码，例如，一笔订单的创建，它包括插入订单数据、生成订单快照、发送邮件通知卖家和记录货品销售数量等。这么多业务<br>操作，如何能够让其更快地完成呢？</p><h3 id="1-2-3-更好的编程模型"><a href="#1-2-3-更好的编程模型" class="headerlink" title="1.2.3 更好的编程模型"></a>1.2.3 更好的编程模型</h3><p>Java 为多线程编程提供了良好、考究并且一致的编程模型，使开发人员更加专注于问题的解决。</p><h2 id="1-3-线程优先级"><a href="#1-3-线程优先级" class="headerlink" title="1.3 线程优先级"></a>1.3 线程优先级</h2><p>现代操作系统基于采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程<br>调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器<br>资源的线程属性。  </p><p>在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法<br>来修改优先级，默认优先级是 5 ，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞的线程需要设置较高优先级，<br>而偏重计算（需要较多 CPU 时间或者偏运算）的线程则设置较低的优先级。笔者在 JDK 1.8 的 WIN 10 环境：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> priority = i &lt; <span class="number">5</span> ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</span><br><span class="line">            Job job = <span class="keyword">new</span> Job(priority);</span><br><span class="line">            jobs.add(job);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">"Thread:"</span> + i);</span><br><span class="line">            thread.setPriority(priority);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        notStart = <span class="keyword">false</span>;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        notEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Job job : jobs) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Job Priority："</span> + job.priority + <span class="string">", Count："</span> + job.jobCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> jobCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (notStart) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (notEnd) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                jobCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Job Priority：<span class="number">1</span>, Count：<span class="number">16772</span></span><br><span class="line">Job Priority：<span class="number">1</span>, Count：<span class="number">16761</span></span><br><span class="line">Job Priority：<span class="number">1</span>, Count：<span class="number">16761</span></span><br><span class="line">Job Priority：<span class="number">1</span>, Count：<span class="number">16758</span></span><br><span class="line">Job Priority：<span class="number">1</span>, Count：<span class="number">16757</span></span><br><span class="line">Job Priority：<span class="number">10</span>, Count：<span class="number">756747</span></span><br><span class="line">Job Priority：<span class="number">10</span>, Count：<span class="number">757594</span></span><br><span class="line">Job Priority：<span class="number">10</span>, Count：<span class="number">757263</span></span><br><span class="line">Job Priority：<span class="number">10</span>, Count：<span class="number">759519</span></span><br><span class="line">Job Priority：<span class="number">10</span>, Count：<span class="number">760287</span></span><br></pre></td></tr></table></figure></p><h2 id="1-4-线程的状态"><a href="#1-4-线程的状态" class="headerlink" title="1.4 线程的状态"></a>1.4 线程的状态</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_1.png" alt></p><h2 id="1-5-Daemon-线程"><a href="#1-5-Daemon-线程" class="headerlink" title="1.5 Daemon 线程"></a>1.5 Daemon 线程</h2><p>Daemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候，<br>Java 虚拟机将会退出。可以通过调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程。</p><blockquote><p>Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置。</p></blockquote><p>Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终没有任何的输出，mian 线程在启动了线程 DaemonRunner 之后随着 main 方法执行完毕而终止，而此时 Java 虚拟机中已经灭有非 Daemon 线程，<br>虚拟机需要退出。 Java 虚拟机中的所有 Daemon 线程都需要立即终止，因此 DaemonRunner 立即终止，但是 DaemonRunner 中的 finally 块并没有执行。</p><h1 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2 启动和终止线程"></a>2 启动和终止线程</h1><h2 id="2-1-理解中断"><a href="#2-1-理解中断" class="headerlink" title="2.1 理解中断"></a>2.1 理解中断</h2><p>中断可以理解为线程的一个标识位属性，它标识一个运行中的线程是否被其它线程进行了中断操作。线程通过方法 <code>isInterrupted</code> 来进行判断是否被中断，<br>也可以调用静态方法 <code>Thread.interrupted()</code> 对当前线程的中断标识位进行复位。下面的例子中，创建了两个线程， SleepThread 和 BusyThread ，<br>前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread sleepThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">"SleepThread"</span>);</span><br><span class="line">        sleepThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Thread busyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">"BusyThread"</span>);</span><br><span class="line">        busyThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"SleepThread interrupted is "</span> + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"BusyThread interrupted is "</span> + busyThread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"SleepThread interrupted is "</span> + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"BusyThread interrupted is "</span> + busyThread.isInterrupted());</span><br><span class="line">        <span class="comment">// SleepThread interrupted is false</span></span><br><span class="line">        <span class="comment">// BusyThread interrupted is true</span></span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程 SleepThread 其中断标识位被清除了，而一直忙碌运作的线程 BusyThread ，其中断标识位没有被清除。</p><h2 id="2-2-安全地终止线程"><a href="#2-2-安全地终止线程" class="headerlink" title="2.2 安全地终止线程"></a>2.2 安全地终止线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"countThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        </span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i ;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>Thread.interrupted()</code> 或一个 boolean 来进行中断。</p><h1 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h1><h2 id="3-1-volatile-和-synchronized-关键字"><a href="#3-1-volatile-和-synchronized-关键字" class="headerlink" title="3.1 volatile 和 synchronized 关键字"></a>3.1 volatile 和 synchronized 关键字</h2><p>每个执行的线程拥有一份拷贝，这样做的目的是加速程序的执行，所以程序在执行过程中，一个线程看到的变量并不一定是最新的。  </p><p>关键字 <code>volatile</code> 就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。  </p><p>举个例子：定义一个表示程序是否运行的成员变量 boolean on = true ，另一个线程可能执行了关闭动作 on = false ，这里涉及多个线程对变量的访问，<br>因此需要定义称为 volatile boolean on = true ，这样其他线程对它改变时，所以线程都会感知，因为所有对 on　变量的访问和修改都需要以共享内存<br>为准。  </p><p>关键字 synchronized 主要确保多个线程在同一时刻，只能由一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。  </p><p>使用 javap 工具分析 synchronized 关键字的实现细节，实例4-10：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Synchronized.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>javap -v Synchronized.class</code> :同步块的前面和后面分别有 monitorenter 和 monitorexit 指令，而同步方法依靠方法修饰符 ACC_SYNCHRONIZED 来完成。<br>其本质是对一个对象的监视器(monitor)进行获取，这个获取过程是排他的，即同一时刻只有一个线程获取到由 sychronized 所保护对象的监视器。  </p><p>任意一个对象都拥有自己的监视器，执行方法的线程必须先获取到该对象的监视器，没有获取到的线程将会阻塞在入口处，进入 BLOCKED 状态。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_2.png" alt></p><h2 id="3-2-等待-通知机制"><a href="#3-2-等待-通知机制" class="headerlink" title="3.2 等待/通知机制"></a>3.2 等待/通知机制</h2><p>一个线程修改了一个对象的值，另一个线程感知到了变化，进行相应的操作，整个过程开始于一个线程，最终执行又是另一个线程。前者是生产者，后者就是消费者。<br>在功能上进行了解耦，“做什么”和“怎么做”。在 Java 实现类似的功能：  </p><p>简单的方法就是让消费者线程不断地循环检查变量是否符合预期，如下的消费者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (value != desire) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 防止过快的“无效”尝试</span></span><br><span class="line">&#125;</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure></p><p>存在的问题：</p><ol><li>难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化。</li><li>难以降低开销。如果降低睡眠时间，比如休眠 1 毫秒，这样消费者能更加迅速地发生条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</li></ol><p>可以通过等待/通知的相关方法是任意 Java 对象都具备的，因为这些方法被定义在 Object ，方法和描述如下表所示：</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">notyfy()</td><td style="text-align:left">通知一个在对象上等待的线程，使其从 wait() 方法返回，而返回的前提是该线程获取到了对象的锁</td></tr><tr><td style="text-align:left">notifyAll()</td><td style="text-align:left">通知所有等待在该对象上的线程</td></tr><tr><td style="text-align:left">wait()</td><td style="text-align:left">调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用 wait() 方法后，会释放对象的锁</td></tr><tr><td style="text-align:left">wait(long)</td><td style="text-align:left">超时等待一段时间，也就是等待长达 n 毫秒，如果没有通知就超时返回</td></tr><tr><td style="text-align:left">wait(long, int)</td><td style="text-align:left">对于超时时间更细粒度的控制，可以达到纳秒</td></tr></tbody></table><p>等待/通知机制，是指一个线程A 调用了对象O 的 wait() 方法进入等待状态，而另一个线程B 调用了对象O 的 notify() 或者 notifyAll() 方法，<br>线程A 收到通知后从对象O 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的 wait() 和 notify()/notifyAll()<br>的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 加锁，拥有 lock 的 Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 当条件不满足时，继续 wait ，同时释放了 lock 的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true. wait "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false. running "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 加锁，拥有 lock 的 Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 获取 lock 的锁，然后进行通知，通知时不会释放 lock 的锁</span></span><br><span class="line">                <span class="comment">// 直到当前线程释放了 lock 后， WaitThread 才能从 wait 方法中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock. notify "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock again. sleep "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-3-Thread-join-的使用"><a href="#3-3-Thread-join-的使用" class="headerlink" title="3.3 Thread.join() 的使用"></a>3.3 Thread.join() 的使用</h2><p>如果一个线程A 执行了 thread.join() 语句，即：当前线程A 等待 thread 线程终止之后才从 thread.join() 返回。代码4-13如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 每个线程拥有前一个线程的引用</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" terminate. "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" terminate. "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Thread.join() 源码大概是这样的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span>(isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逻辑结构和等待/通知经典范式一致，即加锁、循环和处理逻辑。</p><h2 id="3-4-ThreadLocal-的使用"><a href="#3-4-ThreadLocal-的使用" class="headerlink" title="3.4 ThreadLocal 的使用"></a>3.4 ThreadLocal 的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次调用 get() 方法会进行初始化，每个线程只会执行一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_threadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_threadLocal.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-线程应用实例"><a href="#4-线程应用实例" class="headerlink" title="4 线程应用实例"></a>4 线程应用实例</h1><h2 id="4-1-等待超时模式"><a href="#4-1-等待超时模式" class="headerlink" title="4.1 等待超时模式"></a>4.1 等待超时模式</h2><p>调用一个方法时等待一段时间，如果该方法能够在给定的时间段之内得到结果，那么将结果立即返回，反之，超时返回默认结果。<br>假设超时时间为 T ，那么在 now + T 之后就会超时。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> future = now + t;</span><br><span class="line">    <span class="keyword">long</span> remaining = t;</span><br><span class="line">    <span class="keyword">while</span> (result == <span class="keyword">null</span> &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-2-一个简单的数据库连接池示例"><a href="#4-2-一个简单的数据库连接池示例" class="headerlink" title="4.2 一个简单的数据库连接池示例"></a>4.2 一个简单的数据库连接池示例</h2><p>主干代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-3-线程池技术"><a href="#4-3-线程池技术" class="headerlink" title="4.3 线程池技术"></a>4.3 线程池技术</h2><p>主干代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORK_NUMBERS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者列表，即保存着所有的消费者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWorkers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  移除工作线程，即移除消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum++);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，即消费者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 允许外界控制是否停止</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    job.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/4_3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、Java内存模型的基础</title>
      <link href="/2017/09/27/concurrent-art/3.html/"/>
      <url>/2017/09/27/concurrent-art/3.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java-内存模型的基础"><a href="#1-Java-内存模型的基础" class="headerlink" title="1 Java 内存模型的基础"></a>1 Java 内存模型的基础</h1><h2 id="1-1-并发编程模型的两个关键问题"><a href="#1-1-并发编程模型的两个关键问题" class="headerlink" title="1.1 并发编程模型的两个关键问题"></a>1.1 并发编程模型的两个关键问题</h2><p>线程之间如何通信<br>线程之间如何同步（这里的线程是指并发执行的活动实体）。<br>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p><p>共享内存。线程之间共享程序的公共状态，通过写读内存中的公共状态进行隐式通信。<br>消息传递。线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。<br>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。<br>在共享内存并发模型里，同步是显式进行的。必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，线程之间的通信对程序员完全透明。如果编写多线程不理解隐式进行的线程之间通信的工作机制，可能会遇到奇怪的内存可见性问题。</p><h2 id="1-2-Java-内存模型的抽象结构"><a href="#1-2-Java-内存模型的抽象结构" class="headerlink" title="1.2 Java 内存模型的抽象结构"></a>1.2 Java 内存模型的抽象结构</h2><p>在 Java 中，所有实例域、静态域、数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量（ Local Variables），方法定义参数和异常处理参数不会在线程之间共享， 它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（简称为 JMM ）控制， JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看， JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。 本地内存是 JMM 的一个抽象概念，并不真实存在。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-1.png" alt></p><p>从上图看，如果线程A 与线程B 之间要通信的话，必须要经过下面 2 个步骤。</p><p>线程A 把本地内存A 更新过的共享变量刷新到主内存中去。<br>线程B 到主内存中去读取线程A 之前已更新过的共享变量。<br>如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-2.png" alt></p><p>本地内存A 和本地内存B 由主内存中共享变量 x 副本。假设初始时，这 3 个内存中的 x 值都为 0 。线程 A 在执行时，把更新后的 x 值（假设值为 1 ） 临时存放在自己的本地内存 A 中。当线程A 和线程B 需要通信时，线程A 首先会把自己本地内存中修改后的 x 值刷新到主内存中的 x 值变为了 1 。随后， 线程B 到主内存中去读取线程A 更新后的 x 值，此时线程B 的本地内存的 x 值也变为了 1 。</p><p>从整体来看，这两个步骤实质上是线程A 在向线程B 发送消息，而且这个通信过程必须要经过主内存。 JMM 通过控制主内存与每个线程的本地内存之间的交互， 来为程序员提供内存可见性保证。</p><h2 id="1-3-从源代码到指令序列的重排序"><a href="#1-3-从源代码到指令序列的重排序" class="headerlink" title="1.3 从源代码到指令序列的重排序"></a>1.3 从源代码到指令序列的重排序</h2><p>执行程序，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种：</p><p>编译器优化的重排序。<br>指令级并行的重排序。<br>内存系统的重排序。<br>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="1-4-并发编程模型的分类"><a href="#1-4-并发编程模型的分类" class="headerlink" title="1.4 并发编程模型的分类"></a>1.4 并发编程模型的分类</h2><p>现在的处理器使用写缓存区临时保存向内存写入的数据。同时，通过以批处理的方式刷新写缓存区，以及合并写缓冲区对统一内存的多次写，减少对内存总线的占用。</p><h2 id="1-5-happens-before-简介"><a href="#1-5-happens-before-简介" class="headerlink" title="1.5 happens-before 简介"></a>1.5 happens-before 简介</h2><p>在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内， 也可以是在不同线程之间。</p><p>与程序员密切相关的 happens-before 规则如下：<br>程序顺序规则： 一个线程中的每个操作， happens-before 于该线程中的任意后续操作。<br>监视器锁规则： 对一个锁的解锁， happens-before 与随后对这个锁的加锁。<br>volatile 变量规则： 对一个 volatile 域的写， happens-before 与任意后续对这个 volatile 域的读。<br>传递性： 如果 A happens-before B ,且 B happens-before C , 那么 A happens-before C 。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-3.png" alt></p><p>一个 happens-before 规则对应一个或多个编译器和处理器重排序规则。它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则。</p><h1 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2 重排序"></a>2 重排序</h1><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    bolean flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;            <span class="comment">// A</span></span><br><span class="line">        flag = <span class="keyword">true</span>;      <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;       <span class="comment">// C</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a; <span class="comment">// D</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程分别执行这两个方法，由于 a 变量和 flag 变量没有 happens-before 关系，因此有以下可能：<br>B-&gt;C-&gt;D-&gt;A。且由于 C 和 D 存在控制依赖关系，因此执行 reader() 方法的县横可以提前读取并计算 a * a ，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。 到为真时，就把该计算结果写入变量 i 中。因此，重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，重排序不会改变执行结果。但是在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h1 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3 顺序一致性"></a>3 顺序一致性</h1><p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。</p><h2 id="3-1-数据竞争与顺序一致性"><a href="#3-1-数据竞争与顺序一致性" class="headerlink" title="3.1 数据竞争与顺序一致性"></a>3.1 数据竞争与顺序一致性</h2><p>JMM 保证，如果程序时正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序的顺序一致性内存模型中的执行结果相同。 这里的同步是指广义上的同步，包括对常用同步原语（synchronized 、 volatile 、 final）的正确使用。</p><h2 id="3-2-顺序一致性内存模型"><a href="#3-2-顺序一致性内存模型" class="headerlink" title="3.2 顺序一致性内存模型"></a>3.2 顺序一致性内存模型</h2><p>顺序一致性内存模型是一个被理想化了的理论参考模型：</p><p>一个线程中的所有操作必须按照程序的顺序来执行。<br>不管程序是否同步，所有线程都只能看到一个单一的曾作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。如下：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-4.png" alt></p><p>这个内存通过一个左右摆动的开关可以连接任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。当多个线程并发执行时，图中的开关装置能把所有下城的所有内存读/写操作串行化。</p><h2 id="3-3-同步程序的顺序一致性效果"><a href="#3-3-同步程序的顺序一致性效果" class="headerlink" title="3.3 同步程序的顺序一致性效果"></a>3.3 同步程序的顺序一致性效果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  <span class="comment">// 获取锁</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;                                     <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;   <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                                     <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序在两个内存模型中执行时序对比图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-5.png" alt></p><p>可以得知， JMM 在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地位编译器和处理器的优化打开方便之门。</p><h2 id="3-4-总线的工作机制"><a href="#3-4-总线的工作机制" class="headerlink" title="3.4 总线的工作机制"></a>3.4 总线的工作机制</h2><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-6.png" alt></p><p>总线保证了处理器之间的串行化</p><h1 id="4-volatile-的内存语义"><a href="#4-volatile-的内存语义" class="headerlink" title="4 volatile 的内存语义"></a>4 volatile 的内存语义</h1><p>实例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> i = <span class="number">0L</span>;     </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.i = i; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设有多个线程分别调用上面程序的 3 个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> i = <span class="number">0L</span>;     </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.i = i; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">long</span> temp = get();              <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>;</span><br><span class="line">        set(temp);                      <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看第二个实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当写一个 volatile 变量时， JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。在读一个 volatile 变量时， JMM 会把该线程对应的本地内存置为无效。如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-7.png" alt></p><p>在读 flag 变量后，本地内存B 包含的值已经被置为无效。此时，线程B 必须从主内存中读取共享变量。线程B 的读取操作将导致本地内存B 与主内存中的共享变量的值一致。 </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/3-8.png" alt></p><p>volatile 内存语义的总结：</p><p>线程A 写一个 volatile 变量，实质上是线程A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所做修改的）消息。<br>线程B 读一个 volatile 变量，实质上是线程B 接收了之前某个线程发出的（在读这个 volatile 变量之前对共享变量所做修改的）消息。<br>线程A 写一个 volatile 变量，随后线程B 读这个 volatile 变量，这个过程实质上是线程A 通过主内存向线程B 发送消息。</p><h2 id="4-1-volatile-内存语义的实现"><a href="#4-1-volatile-内存语义的实现" class="headerlink" title="4.1 volatile 内存语义的实现"></a>4.1 volatile 内存语义的实现</h2><p>下面看看 JMM 如何实现 volatile 写/读的内存语义：</p><p>当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。<br>当第一个操作是 volatile 写时，第二个操作是 volatile 读时，不能重排序。<br>当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。</p><h2 id="4-2-volatile-实践必读：https-www-ibm-com-developerworks-cn-java-j-jtp06197-html"><a href="#4-2-volatile-实践必读：https-www-ibm-com-developerworks-cn-java-j-jtp06197-html" class="headerlink" title="4.2 volatile 实践必读：https://www.ibm.com/developerworks/cn/java/j-jtp06197.html"></a>4.2 volatile 实践必读：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></h2>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、Java并发机制的底层实现原理</title>
      <link href="/2017/09/26/concurrent-art/2.html/"/>
      <url>/2017/09/26/concurrent-art/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-volatile-的应用"><a href="#1-volatile-的应用" class="headerlink" title="1 volatile 的应用"></a>1 volatile 的应用</h1><table><thead><tr><th style="text-align:center">术语</th><th style="text-align:center">英文</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">缓存行</td><td style="text-align:center">Cache line</td><td style="text-align:center">缓存的最小操作单位（例如处理器的一级缓存等）</td></tr><tr><td style="text-align:center">比较并交换</td><td style="text-align:center">Compare And Swap</td><td style="text-align:center">CAS 操作需要输入两个数值，一个旧值和一个新值，在操作期间先比较旧值发生变化没，如果没有变化，才交换成新值</td></tr></tbody></table><h2 id="1-1-volatile-的定义与实现原理"><a href="#1-1-volatile-的定义与实现原理" class="headerlink" title="1.1 volatile 的定义与实现原理"></a>1.1 volatile 的定义与实现原理</h2><p>volatile 变量修饰的共享变量进行写操作的时候，会引发两件事情：</p><p>将当前处理器缓存行（ cache line ）的数据写回到系统内存。<br>这个写回内存的操作会使其它 CPU 里缓存了该内存地址的数据无效。<br>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其它，即一级缓存、二级缓存等）后再进行操作， 但操作完全不知道何时会真正写到内存。而声明了 volatile 的变量进行写操作， JVM 就会向处理器发送一条 Lock 前缀的指令， 将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其它处理器缓存的值还是旧的，再执行计算操作就会有问题。所以， 在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了， 当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候， 会重新从系统内存中把数据读到处理器缓存里。</p><h2 id="1-2-volatile-的使用优化"><a href="#1-2-volatile-的使用优化" class="headerlink" title="1.2 volatile 的使用优化"></a>1.2 volatile 的使用优化</h2><p>在 JDK 1.7 中的 LinkedTransferQueue 使用 volatile 变量时，用一种追加字节的方式来优化队列出队和入队的性能，即将共享变量追加到 64 字节。 一个对象的引用占用 4 个字节，追加 15 个变量（共占 60 个字节），一共 64 个字节。这样 CPU 中缓存行中，最多只有一个队列， 而不会导致有两个队列，操作其中一个队列的时候由于和另一个队列在同一个缓存行中锁住了另一个队列。但是有两种场景下不应该使用这种方式：</p><p>缓存行非 64 字节宽的处理。<br>共享变量不会被频繁的写。<br>但是在 java7 中，它会淘汰或重新排列无用字段，因此需要使用其它追加字节的方式。</p><h1 id="2-synchronized-的实现原理与应用"><a href="#2-synchronized-的实现原理与应用" class="headerlink" title="2 synchronized 的实现原理与应用"></a>2 synchronized 的实现原理与应用</h1><p>作为一个重量级锁，它是存在 Java 对象头里的。并在 Java SE 1.6 对 synchronized 进行了各种优化。<br>Java 中的每一个对象都可以作为锁：</p><p>对于普通同步方法，锁是当前实例对象。<br>对于静态同步方法，锁是当前类的 Class 对象。<br>对于同步方法块，锁是 Synchronized 括号里配置的对象。<br>JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不同。<br>代码块同步是使用 monitorenter 和 monitorexit 指令实现的，而方法同步使用另外一种方法实现，细节在 JVM 规范里并没有详细说明。但是， 方法的同步同样可以使用这两个指令来实现。</p><h2 id="2-1-锁的升级与对比"><a href="#2-1-锁的升级与对比" class="headerlink" title="2.1 锁的升级与对比"></a>2.1 锁的升级与对比</h2><p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：</p><p>无锁状态<br>偏向锁状态<br>轻量级锁状态<br>重量级锁状态<br>这几种状态随着竞争情况逐渐升级。锁可以升级但不能降级，这是为了提高获得锁和释放锁的效率，下文会详细分析。</p><h3 id="2-1-1-偏向锁"><a href="#2-1-1-偏向锁" class="headerlink" title="2.1.1 偏向锁"></a>2.1.1 偏向锁</h3><p>HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。<br>当一个线程访问同步块并获取锁时，会在当前同步块的对象头和栈帧中的锁记录里存储锁偏向的线程 ID ，以后该线程再进入和退出同步块时不需要进行 CAS 操作来加锁和解锁， 只需要简单地测试一下对象头里的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示当前线程已经获得了锁。如果测试失败，则需要再测试一下对象头中偏向锁的标识是否设置成1 （标识当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</p><p>1) 偏向锁的撤销<br>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其它线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点 （在这个时间点上没有正在执行的字节码，GC 可以在这个点进行暂停所有线程进行暂停回收操作）。它会首先暂停拥有偏向锁的线程， 然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录， 栈中的锁记录和对象头，要么重新偏向于其它线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p><p>2) 关闭偏向锁<br>偏向锁在 Java 6 和 Java 7 里是默认启用的，但是它在应用程序启动几秒钟之后才激活，可以使用 -XX:BiasedLockingStartupDelay=0 。 如果你确定应用程序里所有的锁通常情况下处理竞争状态，可以通过 -XX:UseBiasedLocking=false 关闭偏向锁，那么程序默认会进入轻量级锁状态。</p><h3 id="2-1-2-轻量级锁"><a href="#2-1-2-轻量级锁" class="headerlink" title="2.1.2 轻量级锁"></a>2.1.2 轻量级锁</h3><p>1) 轻量级锁加锁<br>线程在执行同步块之前， JVM 会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word 复制到锁记录中，官方称为 Displaced Mark Word 。 然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其它线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p>2) 轻量级锁解锁<br>使用 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<br>当锁处于这个状态下，其它线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><p>3) 锁的优缺点对比</p><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">优 点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁和解锁不需要额外消耗，和执行非同步方法相对仅存在纳秒级的差距</td><td style="text-align:center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td style="text-align:center">适用于只有一个线程访问同步块场景</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高了程序的响应速度</td><td style="text-align:center">如果始终得不到锁竞争的线程，使用自旋会消耗 CPU</td><td style="text-align:center">追求响应时间，同步块内执行速度非常快</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不适用自旋，不会消耗 CPU</td><td style="text-align:center">线程阻塞，响应时间缓慢</td><td style="text-align:center">追求吞吐量，同步块内执行速度较快</td></tr></tbody></table><h1 id="3-原子操作的实现原理"><a href="#3-原子操作的实现原理" class="headerlink" title="3 原子操作的实现原理"></a>3 原子操作的实现原理</h1><h2 id="3-1-处理器使用总线锁保证原子性"><a href="#3-1-处理器使用总线锁保证原子性" class="headerlink" title="3.1 处理器使用总线锁保证原子性"></a>3.1 处理器使用总线锁保证原子性</h2><p>如果多个处理器同时对共享变量进行读改写操作（i++ 就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的， 操作完之后共享变量的值会和期望的不一致。例如：如果 i=1 ,我们进行两次 i++ 操作，期望结果是 3 ，但是有可能结果是 2 。如下图：<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/concurrent_art/2-1.png" alt></p><p>可能是多个处理器同时从各自的缓存中读取变量 i ，分别进行加 1 操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的， 就必须保证 CPU1 读改写共享变量的时候， CPU2 不能操作缓存了该共享变量内存地址的缓存。</p><p>处理器使用总线锁来解决这个问题，即使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞住， 那么该处理器就可以独占共享内存，而其它处理器会直接废弃掉该信号的值，从内存中取，再缓存。</p><h2 id="3-2-处理器使用缓存锁保证原子性"><a href="#3-2-处理器使用缓存锁保证原子性" class="headerlink" title="3.2 处理器使用缓存锁保证原子性"></a>3.2 处理器使用缓存锁保证原子性</h2><p>在同一时刻，我们只需要保证对某个内存地址的操作是原子性即可，但总线锁定把 CPU 和内存之间的通信锁住了，这使得锁定期间，其它处理器不能操作其它内存地址的户数， 所以总线锁定的开销比较大，在某些场合下可以使用缓存锁定代替总线锁定进行优化。</p><p>频繁使用的内存会缓存在处理器的 L1、L2 和 L3 高级缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。所谓“缓存锁定” 是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声明 LOCK# 信号， 而是膝盖内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据， 当其它处理器回写已被锁定的缓存行的数据时，会使缓存行无效。如上图的例子，当 CPU1 修改缓存行中的 i 时使用了缓存锁定，那么 CPU2 就不能同时缓存 i 和缓存行。</p><p>但是有两种情况下处理器不会使用缓存锁定：<br>1：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行，则处理器会调用总线锁定。<br>2：处理器本身不支持缓存锁定。</p><h1 id="4-Java-如何实现原子操作"><a href="#4-Java-如何实现原子操作" class="headerlink" title="4 Java 如何实现原子操作"></a>4 Java 如何实现原子操作</h1><h2 id="4-1-使用循环-CAS-实现原子操作"><a href="#4-1-使用循环-CAS-实现原子操作" class="headerlink" title="4.1 使用循环 CAS 实现原子操作"></a>4.1 使用循环 CAS 实现原子操作</h2><p>使用 JDK 1.5 之后的并发包，里面有一些类来支持原子操作，如 AtomicBoolean 、 AtomicInteger 、 AtomicLong ，还有一些工具了， 如以原子额方式将当前值自增 1 和自减 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Counter cas = <span class="keyword">new</span> Counter();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">600</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        cas.count();</span><br><span class="line">                        cas.safeCount();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cas.i);</span><br><span class="line">        System.out.println(cas.atomicI.get());</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 CAS 实现线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">            <span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, ++i);</span><br><span class="line">            <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-CAS-实现原子操作的三大问题"><a href="#4-2-CAS-实现原子操作的三大问题" class="headerlink" title="4.2 CAS 实现原子操作的三大问题"></a>4.2 CAS 实现原子操作的三大问题</h2><h3 id="4-2-1-ABA-问题"><a href="#4-2-1-ABA-问题" class="headerlink" title="4.2.1 ABA 问题"></a>4.2.1 ABA 问题</h3><p>如果一个值原来是 A ，变成了 B ，又变成了 A ，那么使用 CAS 进行检查时会发现它的值没有变化，但是实际却变化了。<br>解决思路就是使用版本号，即 A-&gt;B-&gt;A 变成 1A-&gt;2B-&gt;3A 。 Atomic 包提供了类 AtomicStampedReference 来解决 ABA 问题。</p><h3 id="4-2-2-循环时间开销大"><a href="#4-2-2-循环时间开销大" class="headerlink" title="4.2.2 循环时间开销大"></a>4.2.2 循环时间开销大</h3><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><h3 id="4-2-3-只能保证一个共享变量的原子操作"><a href="#4-2-3-只能保证一个共享变量的原子操作" class="headerlink" title="4.2.3 只能保证一个共享变量的原子操作"></a>4.2.3 只能保证一个共享变量的原子操作</h3><p>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作， 例如，有两个共享变量 i=2 ，j=a ，合并以下 ij=2a ，然后用 CAS 来操作 ij 。 JDK 1.5 之后提供了 AtomicReference 类来保证引用对象之间的原子性， 就可以把多个变量放在一个对象里来进行 CAS 操作。</p><h2 id="4-3-使用锁机制实现原子操作"><a href="#4-3-使用锁机制实现原子操作" class="headerlink" title="4.3 使用锁机制实现原子操作"></a>4.3 使用锁机制实现原子操作</h2><p>JVM 内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁， JVM 实现锁的方式都用了循环 CAS ，即当一个线程想进入同步块的时候使用循环 CAS 的方式来获取锁， 当它退出同步块的时候使用循环 CAS 释放锁。</p><h1 id="5-本章小结"><a href="#5-本章小结" class="headerlink" title="5 本章小结"></a>5 本章小结</h1><p>volatile 的实现原理，从处理器到 JVM 讲解。<br>synchronized 的实现原理以及三种锁对象以及 JDK 1.6 之后的四种状态锁。<br>原子操作的实现原理，即 CAS 。<br>Java 中的大部分容器和框架都依赖于本章介绍的 volatile 和原子操作的实现原理，了解这些原理对我们进行并发编程会更有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、并发编程的挑战</title>
      <link href="/2017/09/25/concurrent-art/1.html/"/>
      <url>/2017/09/25/concurrent-art/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1 上下文切换"></a>1 上下文切换</h1><p>并发是单核处理器支持多线程执行代码。则 CPU 通过给每个线程分配时间片来实现，线程任务执行的切换，由于在切换 前要保存当前任务的状态，因此从保存再到加载的过程就是一次上下文切换。</p><h2 id="1-1-多线程一定快吗？"><a href="#1-1-多线程一定快吗？" class="headerlink" title="1.1 多线程一定快吗？"></a>1.1 多线程一定快吗？</h2><p>以下为对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">100000001</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        concurrenct();</span><br><span class="line">        serial();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrenct</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    a += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"concurrency: "</span> + time + <span class="string">"ms, b = "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            a += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"serial: "</span> + time + <span class="string">"ms, b = "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">循环次数</th><th style="text-align:center">serial/ms</th><th style="text-align:center">concurrent/ms</th></tr></thead><tbody><tr><td style="text-align:center">一亿</td><td style="text-align:center">91</td><td style="text-align:center">51</td></tr><tr><td style="text-align:center">一千万</td><td style="text-align:center">14</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">一百万</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">十万</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">一万</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h2 id="1-2-如何减少上下文切换"><a href="#1-2-如何减少上下文切换" class="headerlink" title="1.2 如何减少上下文切换"></a>1.2 如何减少上下文切换</h2><p>无锁并发编程：多线程竞争锁时，会引起上下文切换。因此 Hash 算法通过取模分段，不同的线程处理不同段的数据。<br>CAS 算法： Atomic 包使用 CAS 算法来更新数据，而不需要加锁。<br>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p><h1 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的死锁在于，t1拿到锁之后，因为一些异常没有释放锁（或者死循环）。又或者是t1拿到一个数据库锁，释放锁的时候抛出了异常，没有释放掉。 导致t2一直等待t1释放锁。<br>而避免死锁常见方法有：</p><p>避免一个线程同时获取多个锁。<br>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。<br>尝试使用定时锁，使用 lock.tryLock(timeout) 来替代使用内部锁机制。<br>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p><h1 id="3-资源限制的挑战"><a href="#3-资源限制的挑战" class="headerlink" title="3 资源限制的挑战"></a>3 资源限制的挑战</h1><h2 id="3-1-什么是资源限制"><a href="#3-1-什么是资源限制" class="headerlink" title="3.1 什么是资源限制"></a>3.1 什么是资源限制</h2><p>资源限制是指，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的宽带只有 2MB/s ，某个资源的下载速度是 1MB/s ， 系统启动 10 个线程下载资源，下载速度会不会变成 10MB/s ，所以在进行并发编程时，要考虑资源的限制。而硬件资源限制有带宽的上传/下载速度、 硬盘读写速度和 CPU 的处理速度，软件资源限制有数据库的连接数和 socket 连接数等。</p><h2 id="3-2-资源限制引发的问题"><a href="#3-2-资源限制引发的问题" class="headerlink" title="3.2 资源限制引发的问题"></a>3.2 资源限制引发的问题</h2><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分编程并发执行，但是受限于资源，仍然在串行执行，这时候执行的会更慢， 因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发的下载和处理数据，导致 CPU 使用率达到 100% ， 几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。</p><h2 id="3-3-如何解决资源限制的问题"><a href="#3-3-如何解决资源限制的问题" class="headerlink" title="3.3 如何解决资源限制的问题"></a>3.3 如何解决资源限制的问题</h2><p>对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机运行。不同的机器处理不同的数据。</p><p>对于软件资源限制，可以考虑使用资源池将资源复用。例如使用连接池数据库和 Socket 连接复用，或者在调用对方 webservice 接口获取数据时， 只建立一个连接。</p><h1 id="4-本章小结"><a href="#4-本章小结" class="headerlink" title="4 本章小结"></a>4 本章小结</h1><p>本章的并发程序不够严谨，但是够入门，笔者建议多实用 JDK 并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java并发编程的艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六、Zookeeper的典型应用场景</title>
      <link href="/2017/08/30/paxos2zookeeper/6.html/"/>
      <url>/2017/08/30/paxos2zookeeper/6.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据发布-订阅"><a href="#1-数据发布-订阅" class="headerlink" title="1 数据发布/订阅"></a>1 数据发布/订阅</h1><p>数据发布/订阅（Pulish/Subscribe）系统，即所谓的配置中心，顾名思义就是发布者将数据发布到ZooKeeper的一个或一系列节点上，供订阅者进行数据订阅， 进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。</p><p>发布/订阅系统一般有两种设计模式，分别是推（Push）模式和拉（Pull）模式。在推模式中，服务端主动将数据更新发送给所有订阅的客户端；而拉模式则是由 客户端主动发起请求获取最新数据，通常客户端都采用定时进行轮询拉取的方式。ZooKeeper采用的是推拉结合的方式：客户端向服务端注册自己需要关注的 节点，一旦该节点的数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。</p><p>如果将配置信息存放到ZooKeeper上进行集中管理，那么通常情况下，应用在启动的时候都会主动到ZooKeeper服务端上进行一次配置信息的获取，同时， 在指定节点上注册一个Watcher监听，这样一来，但凡配置信息发生变更，服务端都会实时通知到所有订阅的客户端，从而达到实时获取最新配置信息的目的。</p><p>实例：在我们平常的应用系统开发中，经常会碰到这样的需求：系统中需要使用一些通用的配置信息，例如机器列表信息、运行时的开关配置、数据库配置信息等。 这些全局配置信息通畅具备以下3个特性：</p><p>数据量通常比较小。<br>数据内容在运行时会发生动态变化。<br>集群中各机器共享，配置一致。<br>对于这类配置信息，一般的做法通常可以选择将其存储在本地配置文件或是内存变量中。本地配置可以采用JMX方式来实时对系统运行时内存变量的更新。</p><p>但是一旦机器规模变大，且配置信息变更频繁后，就需要寻找一种更为分布式化的解决方案。</p><p>下面以“数据库切换”的应用场景展开，看看如何使用ZooKeeper实现配置管理。</p><h2 id="1-1-配置存储"><a href="#1-1-配置存储" class="headerlink" title="1.1 配置存储"></a>1.1 配置存储</h2><p>进行配置之前，首先初始化配置存储到ZooKeeper上去，例如/app1/databse_config/（以下简称“配置节点”），写入数据节点中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dbcp.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dbcp.dbJDBCUrl=jdbc:mysql://localhost:3306/taokeeper</span><br><span class="line">dbcp.characterEncoding=GBK</span><br><span class="line">dbcp.username=admin</span><br><span class="line">dbcp.password=root</span><br><span class="line">dbcp.maxActive=30</span><br><span class="line">dbcp.maxIdle=10</span><br><span class="line">dbcp.maxWait=10000</span><br></pre></td></tr></table></figure><h2 id="1-2-配置获取"><a href="#1-2-配置获取" class="headerlink" title="1.2 配置获取"></a>1.2 配置获取</h2><p>集群中每台机器在启动初始化阶段，首先会从上面提到的ZooKeeper配置节点上读取数据库信息，同时，客户端还需要在该配置节点上注册一个数据变更的 Water监听，一旦发生节点数据变更，所有订阅的客户端都能够获取到数据变更通知。</p><h2 id="1-3-配置变更"><a href="#1-3-配置变更" class="headerlink" title="1.3 配置变更"></a>1.3 配置变更</h2><p>在系统运行过程中，可能会出现需要机型数据库切换的情况，借助ZooKeeper的Watcher机制，帮我们将数据变更的通知发送到各个客户端，每个客户端在 接收到这个变更通知后，就可以重新进行最新数据的获取。</p><h1 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2 负载均衡"></a>2 负载均衡</h1><p>根据维基百科上的定义，负载均衡（Load Balance）是一种相当常见的计算机网络技术，用来对多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或是 其它资源进行分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间和避免过载的目的。通常负载均衡可以分为硬件和软件负载均衡两种，本节 主要探讨的是ZooKeeper在“软”负载均衡中的应用场景。</p><p>在分布式系统中，负载均衡更是一种普遍的技术，基本上每一个分布式系统都需要使用负载均衡。在本书第一章讲解分布式系统特征的时候，我们提到，分布式系统具有 对等性，为了保证系统的高可用性，通常采用副本的方式来对数据和服务进行部署。而对于消费者而言，则需要在这些对等的服务提供方中选择一个来执行相关的业务 逻辑，其中比较典型的就是DNS服务。在本节中，我们将详细介绍如何使用ZooKeeper来解决负载均衡问题（请看深入分析Java_Web技术的第一章）。</p><h2 id="2-1-一种动态的DNS服务"><a href="#2-1-一种动态的DNS服务" class="headerlink" title="2.1 一种动态的DNS服务"></a>2.1 一种动态的DNS服务</h2><p>DNS是域名系统（Domain Name System）的缩写。DNS系统可以看作是一个超大规模的分布式映射表，用于将域名和IP地址进行一一映射，进而方便人们 通过域名来访问互联网站点。</p><p>通常情况下，我们可以向域名注册服务商申请域名注册，但是这种方式最大的缺陷在于只能注册有限的域名：</p><p>日常开发过程中，经常会碰到这样的情况，在一个Company1公司内部，需要给一个App1应用的服务器集群机器配置一个域名解析。相信有过一线开发 经验的读者一定知道，这个时候通常需要由类似于app1.company1.com的一个域名，其对应的就是一个服务器地址。如果系统数量不多，那么通过 这种传统的DNS配置方式还可以应付，但是，一旦公司规模变大，各类应用层出不穷，那么就很难再通过这种方式来进行统一的管理了。</p><p>因此，在实际开发中，往往使用本地HOST绑定来实现域名解析的工作。具体如何进行本地HOST绑定，因为不是本书的重点，并且互联网上有大量额资料， 因此这里不再多说明。使用本地HOST绑定的方法，可以很容易解决域名紧张的问题，基本上每一个系统都可以自行确定系统的域名与目标IO地址。大大提高了 开发调试效率。（就是修改HOST文件，让域名与IP直接映射，减去解析时间）然而，这种看上去完美的方案，也有其致命的缺陷：</p><p>当应用的机器规模在一定范围内，并且域名的变更不是特别频繁时，本地HOST绑定是非常高效且简单的方式。然而一旦机器规模变大后，就常常 会碰到这样的情况：我们在应用上线的时候，需要在应用的每台机器上去绑定域名，但是在机器规模相当庞大的情况下，这种做法就相当不方便。 另外，如果想要临时更新域名，还需要到每个机器上去逐个进行变更，更消耗大量时间，因此完全无法保证实时性。</p><p>现在，我们来介绍一种基于ZoKeeper实现的动态DNS方案（简称“DDNS”，Dynamic DNS）。</p><h2 id="2-2-域名配置"><a href="#2-2-域名配置" class="headerlink" title="2.2 域名配置"></a>2.2 域名配置</h2><p>首先需要在ZooKeeper上创建一个节点来进行域名配置。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-1.png" alt></p><p>这样，在/DDNS/app1的节点上，将自己的域名配置上去，并支持多个IP</p><h2 id="2-3-域名解析"><a href="#2-3-域名解析" class="headerlink" title="2.3 域名解析"></a>2.3 域名解析</h2><p>在传统的DNS解析中，我们都不需要关系域名的解析过程，所有这些工作都交给了操作系统的域名和IP地址映射机制（本地HOST绑定）或是专门的域名解析 服务器（由域名注册服务商提供）。因此，在这点上，DDNS方案和传统的域名解析有很大的区别————在DDNS中，域名的解析过程都是由每一个应用自己负责的。 通常应用都会首先从域名节点中获取一份IP地址和端口的配置，进行自行解析。同时，每个应用还会在域名节点上注册一个数据变更Watcher监听，以便及时 收到域名变更的通知。</p><h2 id="2-4-域名变更"><a href="#2-4-域名变更" class="headerlink" title="2.4 域名变更"></a>2.4 域名变更</h2><p>在运行过程中，难免会碰上域名对应的IP地址或是端口变更，这个时候就需要进行域名变更操作。在DDNS中，我们只需要对指定的域名节点进行更新操作， ZooKeeper就会向订阅的客户端发送这个事件通知，应用在接收到这个事件通知后，就会再次进行域名配置的获取。</p><p>上面我们介绍了如何使用ZooKeeper来实现一种动态的DNS系统。通过ZooKeeper来实现动态DNS服务，一方面，可以避免域名数量无限增长带来的集中式维护 的成本；另一方面，在域名变更的情况下，也能够避免因逐台机器更新本地HOST而带来的繁琐工作。</p><h2 id="2-5-自动化的DNS服务"><a href="#2-5-自动化的DNS服务" class="headerlink" title="2.5 自动化的DNS服务"></a>2.5 自动化的DNS服务</h2><p>根据上面的讲解，相信读者基本上已经能够使用ZooKeeper来实现一个动态的DNS服务了。但是我们仔细看一下上面的实现就会发现，在域名变更环节中，当 域名对应的I地址发生变更的时候，我们还是需要人为地介入去修改域名节点上的IP地址和端口。接下来我们看看下面这种使用ZooKeeper实现的更为自动化 的DNS服务。自动化的DNS服务系统主要是为了实现服务的自动化定位。  </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-2.png" alt></p><p>首先来介绍整个动态DNS系统的架构体系中比较重要的组件及其职责。</p><ul><li>Register Cluster：负责域名的动态注册。</li><li>Dispatcher Cluster：负责域名解析。</li><li>Scanner Cluster：负责检测以及维护服务状态（探测服务的可用性、屏蔽异常服务节点等）。</li><li>SDK：提供各种语言的系统接入协议，提供服务注册以及查询接口。</li><li>Monitor：负责收集服务信息以及对DDNS自身状态的监控。</li><li>Controller：后台管理的Console，负责授权管理、流量控制、静态配置服务和手动屏蔽服务等功能，运维人员在上面管理Register、Dispatcher和Scanner等Cluster。</li></ul><p>整个系统的核心当然是ZooKeeper集群，负责数据的存储以及一系列分布式协调。下面我们再来详细地看下整个系统是如何运行的。在这个架构模型中，我们 将那些目标IP地址和端口抽象为服务的提供者，而那些需要使用域名解析的客户端则被抽象成服务的消费者。</p><h3 id="2-5-1-域名注册"><a href="#2-5-1-域名注册" class="headerlink" title="2.5.1 域名注册"></a>2.5.1 域名注册</h3><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-3.png" alt></p><p>域名注册主要是针对服务提供者来说的。域名注册过程可以简单地概括为：每个服务提供者在启动的过程中，都会把自己的域名信息注册到Register Cluster中去。</p><p>服务提供者通过SDK提供的API接口，将域名、IP地址和端口发送给Register Cluster。例如，A机器用于提供serverA.xxx.com，于是它就向Register 发送一个“域名-&gt;IP:PORT”的映射：“serverA.xxx.com-&gt;192.168.0.1:8080”。<br>Register获取到域名、IP地址和端口配置后，根据域名将信息写入相对应的ZooKeeper域名节点中。</p><h3 id="2-5-2-域名解析"><a href="#2-5-2-域名解析" class="headerlink" title="2.5.2 域名解析"></a>2.5.2 域名解析</h3><p>域名解析是针对服务消费者来说的，正好和域名注册过程相反：服务消费者在使用域名的时候，会向Dispatcher发出域名解析请求。Dispatcher收到请求后， 会从ZooKeeper上的指定域名节点读取相应的IP:PORT列表，通过一定的策略选取其中一个返回给前端应用。</p><h3 id="2-5-3-域名探测"><a href="#2-5-3-域名探测" class="headerlink" title="2.5.3 域名探测"></a>2.5.3 域名探测</h3><p>域名探测是指DDNS系统需要对域名下所有注册的IP地址和端口的可用性进行检测，俗称“健康度检测”。健康度检测一般有两种方式，第一种是服务端主动发起健康度心跳 检测，这种方式一般需要在服务端和客户端之间建立起一个TCP长链接；第二种则是客户端主动向服务端发起健康度心跳检测。在DDNS架构中的域名探测，使用 的是服务提供者都会定时向Scanner进行状态汇报（即第二种健康度检测方式）的模式，即每个服务提供者后都会定时向Scanner汇报自己的状态。</p><p>Scanner会负责记录每个服务提供者最近一次的状态汇报时间，一旦超过5秒没有收到状态汇报，那么就认为该IP地址和端口已经不可用，于是开始进行域名 清理过程。在域名清理过程中，Scanner会在ZooKeeper中找到该域名对应的域名节点，然后将该IP地址和端口配置从节点内容中移除。</p><h1 id="3-命名服务"><a href="#3-命名服务" class="headerlink" title="3 命名服务"></a>3 命名服务</h1><p>命名服务（Name Service）也是分布式系统中比较常见的一类场景。在分布式系统中，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象等———— 这些我们都可以统称它们为名字（Name），其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表，通过使用命名服务， 客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息等。</p><p>Java语言中的JNDI便是一种典型的命名服务。JNDI是Java命名与目录接口（Java Naming and Directory Interface）的缩写，是J2EE体系中重要的规范之一， 标准的J2EE容器都提供了对JNDI规范的实现。因此，在实际开发中，开发人员常常使用应用服务器自带的JNDI实现来数据源的配置与管理————使用JNDI方式后， 开发人员可以完成不需要关心与数据库相关的任何信息，包括数据库类型、JDBC驱动类型以及数据库账号等。</p><p>ZooKeeper提供的命名服务功能与JNDI技术有相似的地方，都能够帮助应用系统通过一个资源引用的方式来实现对资源的定位与使用。另外，广义上命名服务 的资源定位都不是真正意义的实体资源————在分布式环境中，上层应用仅仅需要一个全局唯一的名字，类似于数据库中的唯一主键。下面我们来看看如何使用 ZooKeeper来实现一套分布式全局唯一ID的分配机制。</p><p>所谓ID，就是一个能够唯一标识某个对象的标识符。在我们熟悉的关系型数据库中，各个表都需要一个主键来唯一标识每条数据库记录，这个主键就是这样的唯一ID。 在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_increment属性来自动为每条数据库记录生成一个唯一的ID，数据库会保证生成的这个ID 在全局唯一。但是随着数据库数据规模的不断增大，分库分表随之出现，而auto_increment属性仅能针对单一表中的记录自动生成ID，因此在这种情况下， 就无法再依靠数据库的auto_increment属性来唯一标识一条记录了。于是，我们必须寻求一种能够在分布式环境下生成全局唯一ID的方法。</p><p>一说起全局唯一ID，相信读者都会联想到UUID。没错，UUID是通用唯一识别码（Universally Unique Identifier）的简称，是一种在分布式系统中广泛 使用的用于唯一标识元素的标准，最典型的实现是GUID（Globally Unique Identifier，全局唯一标识符），主流ORM框架Hibernate有对UUID的直接支持。</p><p>确实，UUID是一个非常不错的全局唯一ID生成方式，能够非常简便地保证分布式环境中的唯一性。一个标准的UUID是一个包含32位字符和4个短线的字符串， 例如“asd321a-sd-sdwds321d5w4a2-w5e4w51d”。UUID的优势自然不必多说，我们重点来看看它的缺陷。</p><p>长度过长：与数据库中的INT类型相比，存储一个UUID需要花费更多得空空间。<br>含义不明：影响问题排查和开发调试的效率。<br>接下来，我们结合一个分布式任务调度系统来看看如何使用ZooKeeper来实现这类全局唯一ID的生成。</p><p>通过ZooKeeper节点创建的API接口可以创建一个顺序节点，并且在API返回值中会返回这个节点的完整名字。利用这个特性，我们就可以借助ZooKeeper来生成全局唯一的ID了。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-4.png" alt></p><p>所有客户端都会根据自己的任务类型，在指定类型的任务下面通过调用create()接口创建一个顺序节点，例如创建“job-”节点。<br>节点创建完毕后，create()接口会返回一个完整的节点名，例如“job-0000000003”。<br>客户端拿到这个返回值后，拼接上type类型，例如“type2-job-0000000003”，这就可以作为一个全局唯一的ID了。<br>在ZooKeeper中，每一个数据节点都能够维护一份子节点的顺序顺列，当客户单对其创建一个顺序子节点的时候ZooKeeper会自动以后缀的形式在其子节点上 添加一个序号，在这个场景中就是利用了ZooKeeper的这个特性。以下为博主测试：  </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-5.png" alt></p><p>另外如果子节点过多，导致连接读取超时，可以适当提高配置中的initLimit以及syncLimit的数值（10倍也是可以的）。</p><h1 id="4-分布式协调-通知"><a href="#4-分布式协调-通知" class="headerlink" title="4 分布式协调/通知"></a>4 分布式协调/通知</h1><p>分布式协调/通知服务是分布系统不可缺少的环节，是将不同的分布式组件有机结合起来的关键所在。对于一个在多台机器上部署运行的应用而言，通常 需要一个协调者（Coordinator）来控制整个系统的运行流程，例如分布式事务的处理、机器间的互相协调等。同时，引入这样一个协调者，便于将分布式协调的职责从 应用中分离出来，从而可以大大减少系统之间的耦合性，而且能够显著提高系统的可扩展性。</p><p>ZooKeeper中特有的Watcher注册与异步通知机制，能够很好地实现分布式环境下不同机器，甚至是不同系统之间的协调与通知，从而实现对数据变更的实时处理。 基于ZooKeeper实现分布式协调与通知功能，通常的做法是不同的客户端都对ZooKeeper上同一个数据节点进行Watcher注册，监听数据节点的变化（包括 数据节点本身及其子节点），如果数据节点发生变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。</p><h2 id="4-1-MySQL数据复制总线：MySQL-Replicator"><a href="#4-1-MySQL数据复制总线：MySQL-Replicator" class="headerlink" title="4.1 MySQL数据复制总线：MySQL_Replicator"></a>4.1 MySQL数据复制总线：MySQL_Replicator</h2><p>MySQL数据复制总线（以下简称“复制总线”）是一个实时数据复制框架，用于在不同的MySQL数据库实例之间进行异步数据复制和数据变化通知。整个系统是一个由 MySQL数据库集群、消息队列系统、任务管理监控平台以及ZooKeeper集群等组件共同构成的一个包含数据生产者、复制管道和数据消息者等部分的数据总线系统。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-6.png" alt></p><p>在该系统中，ZooKeeper主要负责进行一系列的分布式协调工作，在具体的实现上，根据功能将数据复制组件划分为三个核心子模块：Core、Server和Monitor， 每个模块分别为一个单独的进程，通过ZooKeeper进行数据交换。</p><p>Core实现了数据复制的核心逻辑，其将数据复制封装成管道，并抽象出生产者和消费者两个概念，其中生产者通常是MySQL数据库的Binlog日志。<br>Server负责启动和停止复制任务。<br>Monitor负责监控任务的运行状态，如果在数据复制期间发生异常或出现故障会进行告警。<br>三个子模块之间的关系如下图：  </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-7.png" alt></p><p>每个模块作为独立的进程运行在服务端，运行时的数据和配置信息均保存在ZooKeeper上，Web控制台通过ZooKeeper上的数据获取到后台进程的数据，同时发布控制信息。</p><h2 id="4-2-任务注册"><a href="#4-2-任务注册" class="headerlink" title="4.2 任务注册"></a>4.2 任务注册</h2><p>Core进程启动的时候，首先会向/mysql_replicator/tasks节点（以下简称“任务列表节点”）注册任务。例如，对于一个“复制热门商品”的任务，Task 所在机器在启动的时候，会首先在任务列表节点上创建一个子节点，例如/mysql_replicator/tasks/copy_hot_time（以下简称“任务节点”），如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-8.png" alt></p><p>如果在注册过程中发现该子节点已经存在，说明已经有其他Task机器注册了该任务，因此自己不需要再创建该节点了。</p><h2 id="4-3-任务热备份"><a href="#4-3-任务热备份" class="headerlink" title="4.3 任务热备份"></a>4.3 任务热备份</h2><p>为了应对复制任务故障或者复制任务所在主机故障，复制组件采用“热备份”的容灾方式，即将同一个复制任务部署在不同的主机上，我们称这样的机器为“任务机器”， 主、备任务机器通过ZooKeeper互相检测运行健康状况。</p><p>为了实现上述热备方案，无论在第一步中是否创建了任务节点，每台任务机器都需要在/mysql_replicator/tasks/copy_hot_item/instances节点上 将自己的主机名注册上去。注意，这里注册的节点类型很特殊，是一个临时的顺序节点。在注册完这个子节点后，通常一个完整的节点名如下： /mysql_replicator/tasks/copy_hot_item/instances/[Hostname]-1，其中最后的序列号就是临时顺序节点的精华所在。</p><p>在完成该子节点的创建后，每台任务机器都可以获取到自己创建的节点的完成节点名以及所有子节点的列表，然后通过对比判断自己是否是所有子节点中序号最小的。 如果自己是序号最小的子节点，那么就将自己的运行状态设置为RUNNING，其余的任务机器则将自己设置为STANDBY————我们将这样的热备份策略称为“小序号优先”策略。</p><h2 id="4-4-热备切换"><a href="#4-4-热备切换" class="headerlink" title="4.4 热备切换"></a>4.4 热备切换</h2><p>完成运行状态的标识后，任务的客户端机器就能够正常工作了，其中标记为RUNNING的客户端机器进行正常的数据复制，而标记为STANDBY的客户端机器则进入待命状态。 这里所谓待命状态，就是说一旦标记为RUNNING的机器出现故障停止了任务执行，那么就需要在所有标记为STANDBY的客户端机器再次按照“小序号优先”策略来 选出RUNNING机器来执行，具体的做法就是标记为STANDBY的机器都需要在/mysql_replicator/tasks/copy_hot_item/instances节点上注册一个 “子节点列表变更”的Watcher监听，用来订阅所有任务执行机器的变化情况————一旦RUNNING机器宕机与ZooKeeper断开连接后，对应的节点就会消失， 于是其他机器也就接收到了这个变更通知，从而开始新一轮的RUNNING选举。</p><h2 id="4-5-记录执行状态"><a href="#4-5-记录执行状态" class="headerlink" title="4.5 记录执行状态"></a>4.5 记录执行状态</h2><p>既然使用了热备份，那么RUNNING任务机器就需要将运行时的上下文状态保留给STANDBY任务机器。在这个场景中，最主要的上下文状态就是数据复制过程中的 一些进度信息，例如Binlog日志的消费位点，因此需要将这些信息保存到ZooKeeper上以便共享。在Mysql_Replicator的设计中，选择了 /mysql_replicator/tasks/copy_hot_item/lastCommit作为Binlog日志消费位点的存储节点，RUNNING任务机器会定时向这个节点写入当前的Binlog日志消费位点。</p><h2 id="4-6-控制台协调"><a href="#4-6-控制台协调" class="headerlink" title="4.6 控制台协调"></a>4.6 控制台协调</h2><p>在上文中我们主要讲解了Core组件是如何进行分布式任务协调的，接下来我们再看看Server是如何来管理Core组件的。在Mysql_Replicator中，Server主要的 工作就是进行任务的控制，通过ZooKeeper来对不同的任务进行控制与协调。Server会将每个复制任务对应生产者的元数据，即库名、表名、用户名与密码等数据库信息以及 消费者的相关信息以配置的形式写入任务节点/mysql_replicator/tasks/copy_hot_item中去的，以便该任务的所有任务机器都能够共享该复制任务的配置。</p><h2 id="4-7-冷备切换"><a href="#4-7-冷备切换" class="headerlink" title="4.7 冷备切换"></a>4.7 冷备切换</h2><p>到目前为止我们已经基本了解了Mysql_Replicator的工作原理，现在再回过头来看上面提到的热备份。在该热备份方案中，针对一个任务，都会至少分配两台 任务机器来进行热备份，但是在一定规模的大型互联网公司中，往往有许多MySQL实例需要进行数据复制，每个数据库实例都会对应一个复制任务， 如果每个任务都进行双机热备份的话，那么显然需要消耗太多的机器。</p><p>因此我们同时设计了一种冷备份，它和热备份方案的不同点在于，对所有任务进行分组，如下：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-9.png" alt></p><p>和热备份中比较大的区别在于，Core进程被配置了所属Group（组）。举个例子来说，假如一个Core进程被标记了group1，那么在Core进程启动后，会到对应 的ZooKeeper group1节点下面获取所有的Task列表，假如找到了任务“copy_hot_item”之后，就会遍历这个Task列表的instances节点，但凡还没有子节点的， 则会创建一个临时的顺序节点：/mysql_replicator/task-groups/group1/copy_hot_item/instances/[Hostname]-1————当然，在这个过程中，其它 Core进程也会在这个instances节点下创建类似的子节点。和热备份中的“小序号优先”策略一样，顺序小的Core进程将自己标记为RUNNING，不同之处在于，其它Core 进程则会自动将自己创建的子节点删除，然后继续遍历下一个Task节点————我们将这样的过程称为“冷备份扫描”。就这样，所有Core进程在一个扫描周期内不断地对相应 的Group下面的Task进行冷备份扫描。整个过程如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-10.png" alt></p><h2 id="4-8-冷热备份对比"><a href="#4-8-冷热备份对比" class="headerlink" title="4.8 冷热备份对比"></a>4.8 冷热备份对比</h2><p>从上面的讲解中，我们基本对热备份和冷备份两种运行方式都有了一定的了解，现在再来对比下这两种运行方式。在热备份方案中，针对一个任务使用了两台机器进行 热备份，借助ZooKeeper的Watcher通知机制和临时顺序节点的特性，能够非常实时地进行互相协调，但缺陷就是机器资源消耗比较大。而在冷备份方案中，采用了扫描机制， 虽然降低了任务协调的实时性，但是节省了机器资源。（博主总结冷备份与热备份的区别在于，热备份一个运行多个等待，冷备份在于一个运行，系统轮询判断是否有一个 在运行，只要有一个在运行就遍历下个任务，如果一个都没有在运行这个任务就让自己运行）。 ，</p><h2 id="4-9-一种通用的分布式系统机器间通信方式"><a href="#4-9-一种通用的分布式系统机器间通信方式" class="headerlink" title="4.9 一种通用的分布式系统机器间通信方式"></a>4.9 一种通用的分布式系统机器间通信方式</h2><p>在绝大部分的分布式系统中，系统机器间的通信无外乎心跳检测、工作进度汇报和系统调度这三种类型。接下来，我们将围绕这三种类型的机器通信讲解 如何基于ZooKeeper去实现一种分布式系统间的通信方式。</p><h3 id="4-9-1-心跳监测"><a href="#4-9-1-心跳监测" class="headerlink" title="4.9.1 心跳监测"></a>4.9.1 心跳监测</h3><p>机器间的心跳检测机制是指在分布式环境中，不同机器之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们 通常是通过主机之间是否可以互相PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现上层机器的心跳检测， 这些确实都是一些非常常见的心跳检测方法。而ZooKeeper基于ZooKeeper的临时节点特性，可以让不同的机器都在ZooKeeper的一个指定节点下创建临时子节点，不同的机器 之间可以根据这个临时节点来判断对应的客户端机器是否存活。通过这种方式，检测系统和被检测系统之间并不需要直接相关联，而是通过ZooKeeper上的 某个节点进行关联，大大减少了系统耦合。</p><h3 id="4-9-2-工作进度汇报"><a href="#4-9-2-工作进度汇报" class="headerlink" title="4.9.2 工作进度汇报"></a>4.9.2 工作进度汇报</h3><p>在一个常见的任务分发系统中，通常任务被分发到不同的机器上执行后，需要实时地将自己的任务执行进度汇报给分发系统。这个时候就可以通过ZooKeeper来实现。 在ZooKeeper上选择一个节点，每个任务客户端都在这个节点下面创建临时子节点，这样便可以实现两个功能：</p><p>通过判断临时节点是否存在来确定任务机器是否存活；<br>各个任务机器会实时地将自己的任务执行进度写到这个临时节点上去，以便中心系统能够实时地获取到任务的执行进度。</p><h3 id="4-9-3-系统调度"><a href="#4-9-3-系统调度" class="headerlink" title="4.9.3 系统调度"></a>4.9.3 系统调度</h3><p>使用ZooKeeper，能够实现另一种调度模式：一个分布式系统由控制台和一些客户端系统两部分组成，控制台的职责就是需要将一些指令信息发送给所有的 客户端，以控制它们进行相应的业务逻辑。后台管理人员在控制台上做的一些操作，实际上就是修改了ZooKeeper上某些节点的数据，而ZooKeeper进一步 把这些数据变更以事件通知的形式发送给了对应的订阅客户端。</p><p>总之，使用ZooKeeper来实现分布式系统机器间的通信，不仅能省去大量底层网络通信和协议设计上重复的工作，更为重要的一点是大大降低了系统之间的耦合， 能够非常方便地实现异构系统之间的灵活通信。</p><h1 id="5-集群管理"><a href="#5-集群管理" class="headerlink" title="5 集群管理"></a>5 集群管理</h1><p>随着分布式系统规模的日益扩大，集群中的机器规模也随之变大，因此，如何更好地进行集群管理也显得越来越重要了。</p><p>所谓集群管理，包括集群监控与集群控制两大块、前者侧重对集群运行时状态的收集，后者则是对集群进行操作与控制。在日常开发和运维过程中，我们经常会有 类似于如下的需求。</p><p>希望知道当前集群中究竟有多少机器在工作。<br>对集群中每台机器的运行时状态进行数据收集。<br>对集群中机器进行上下线操作。<br>在传统的基于Agent的分布式集群管理体系中，都是通过在集群中的每台机器上部署一个Agent，由这个Agent负责主动向指定的一个监控中心系统（监控中心 系统负责将所有数据进行集中处理，形成一系列报表，并负责实时报警，以下简称“监控中心”）汇报自己所在机器的状态。在集群规模适中的场景下，这确实 是一种在生产实践中广泛使用的解决方案，能够快速有效地实现分布式环境集群监控，但是一旦系统的业务场景增多，集群规模变大，该解决方案的弊端也就显现出来了:</p><p>大规模升级困难：以客户端形式存在的Agent，在大规模使用后，一旦遇到需要大规模升级的情况，就非常麻烦，在升级成本和升级进度的控制上面临巨大的挑战。<br>统一的Agent无法满足多样的需求：对于机器的CPU使用率、负载（Load）、内存使用率、网络吞吐以及磁盘容量等机器基本的物理状态，使用统一的Agent 来进行监控或许都可以满足。但是，如果需要深入应用内部，对一些业务状态进行监控，例如，在一个分布式消息中间件中，希望监控到每个消费者对消息的消费状态； 或者在一个分布式任务调度系统中，需要对每个机器上任务的执行情况进行监控。很显然，对于这些业务耦合紧密的监控需求，不适合由一个统一的Agent来提供。<br>编程语言多样性：随着越来越多编程语言的出现，各种异构系统层出不穷。如果使用传统的Agent方式，那么需要提供各种语言的Agent客户端。另一方面， “监控中心”在对异构系统的数据进行整合上面临巨大挑战。<br>ZooKeeper具有以下两大特性：</p><p>客户端如果对ZooKeeper的一个数据节点注册Watcher监听，那么当该数据节点的内容或是其子节点列表发生变更时，ZooKeeper服务器就会向订阅的 客户端发送变更通知。<br>对在ZooKeeper上创建的临时节点，一旦客户端与服务器之间的会话失效，那么该临时节点也就被自动清除。<br>利用ZooKeeper的这两大特性，就可以实现另一种集群机器存活性监控的系统。例如，监控系统在/clusterServers节点上注册一个Watcher监听， 那么但凡进行动态添加机器的操作，就会在/clusterServers节点下创建一个临时节点/clusterServers/[Hostname]。这样一来监控系统就能够实时 检测到机器的变动情况，至于后续处理就是监控系统的业务了。下面我们就通过分布式日志收集系统和在线云主机管理这两个典型例子来看看如何使用ZooKeeper 实现集群管理。</p><h2 id="5-1-分布式日志收集系统"><a href="#5-1-分布式日志收集系统" class="headerlink" title="5.1 分布式日志收集系统"></a>5.1 分布式日志收集系统</h2><p>分布式日志收集系统的核心工作就是收集分布在不同机器上的系统日志，在这里我们重点来看分布式日志系统的收集器模块。</p><p>在一个典型的日志系统的架构设计中，整个日志系统会把所有需要收集的日志机器（下文以“日志源机器”代表此类机器）分为多个组别，每个组别对应一个收集器， 这个收集器其实就是一个后台机器（下文以“收集器机器”代表此类机器），用于收集日志。对于大规模的分布式日志收集系统场景，通常需要解决如下两个问题。</p><p>变化的日志源机器：在生产环境中，伴随着机器的变动，每个应用的机器几乎每天都是在变化的（机器硬件问题、扩容、机房迁移或是网络问题都会导致一个应用的机器变化）， 也就是说每个组别中的日志源机器通常是在不断变化的。<br>变化的收集器机器：日志收集系统自身也会有机器的变更或扩容，于是会出现新的收集器加入或是老的收集器机器退出的情况。<br>上面两个问题，无论是日志源机器还是收集器机器的变更，最终都归结为一点：如何快速、合理、动态地为每个收集器分配对应的日志源机器，这也成为了整个 日志系统正确稳定运转的前提，也是日志收集过程中最大的技术挑战。在这种情况下，引入ZooKeeper是个不错的选择，下面我们来看ZooKeeper在这个 场景中的使用。</p><h3 id="5-1-1-注册收集器机器"><a href="#5-1-1-注册收集器机器" class="headerlink" title="5.1.1 注册收集器机器"></a>5.1.1 注册收集器机器</h3><p>使用ZooKeeper来进行日志系统收集器的注册、典型做法是在ZooKeeper上创建一个节点作为收集器的根节点，例如/logs/collector（下文我们以“收集器 节点”代表该数据节点），每个收集器机器在启动的时候，都会在收集器节点下创建自己的节点，例如logs/collector/[Hostname]。</p><h3 id="5-1-2-任务分发"><a href="#5-1-2-任务分发" class="headerlink" title="5.1.2 任务分发"></a>5.1.2 任务分发</h3><p>待所有收集器机器都创建好自己对应的节点后，系统根据收集器节点下子节点的个数，将所有日志源机器分成对应的若干组，然后将分组后的机器列表分别写到 这些收集器机器创建的子节点（例如/logs/collector/host1）上去。这样一来，每个收集器机器都能够从自己对应的收集器节点获取日志源机器列表， 进而开始进行日志收集工作。</p><h3 id="5-1-3-状态汇报"><a href="#5-1-3-状态汇报" class="headerlink" title="5.1.3 状态汇报"></a>5.1.3 状态汇报</h3><p>完成收集器机器的注册以及任务分发后，我们还要考虑到这些机器随时都有挂掉的可能。因此，针对这个问题，我们需要有一个收集器的状态汇报机制： 每个收集器机器在创建完自己的专属节点后，还需要在对应的子节点上创建一个状态子节点，例如/logs/collector/host1/status，每个收集器都需要定期向 该节点写入自己的状态信息。我们可以把这种策略看作是一种检测机制，通常收集器机器都会在这个节点写入日志收集进度信息。日志系统根据该状态子节点的最后更新时间 来判断对应的收集器机器是否存活。</p><h3 id="5-1-4-动态分配"><a href="#5-1-4-动态分配" class="headerlink" title="5.1.4 动态分配"></a>5.1.4 动态分配</h3><p>如果收集器机器挂掉或是扩容了，就需要动态地进行收集任务的分配。在运行过程中，日志系统始终关注着/logs/collector这个节点下所有子节点的变更， 一旦检测到有收集器机器停止汇报或是有新的收集器机器加入，就要开始进行任务的重新分配。无论是针对收集器机器停止汇报还是新机器加入的情况， 日志系统都需要将之前分配给该收集器的所有任务转移。为了解决这个问题，通常有两种做法。</p><h4 id="5-1-4-1-全局动态分配"><a href="#5-1-4-1-全局动态分配" class="headerlink" title="5.1.4.1 全局动态分配"></a>5.1.4.1 全局动态分配</h4><p>这是一种简单粗暴的做法，在出现收集器机器挂掉或是新机器加入的时候，日志系统需要根据新的收集器机器列表，立即对所有的日志源机器重新进行一次分组， 然后将其分配给剩下的收集器机器。</p><h4 id="5-1-4-2-局部动态分配"><a href="#5-1-4-2-局部动态分配" class="headerlink" title="5.1.4.2 局部动态分配"></a>5.1.4.2 局部动态分配</h4><p>全局动态分配方式虽然策略简单，但是存在一个问题：一个或部分收集器机器的变更，就会导致全局动态任务的分配，影响面比较大，因此风险也就比较大。 所谓局部动态分配，顾名思义就是在小范围内进行任务的动态分配。在这种策略中，每个收集器机器在汇报自己日志收集状态的同时，也会把自己的负载汇报上去。 请注意，这里提到的负载并不仅仅只是简单地指机器CPU负载（Load），而是一个对当前收集器任务执行的综合评估。</p><p>在这种策略中，如果一个收集器机器挂了，那么日志系统就会把之前分配给这个机器的任务重新分配到那些负载较低的机器上去。同样，如果有新的收集器机器加入， 会从那些负载高的机器上转移部分任务给这个新加入的机器。</p><h3 id="5-1-5-注意事项"><a href="#5-1-5-注意事项" class="headerlink" title="5.1.5 注意事项"></a>5.1.5 注意事项</h3><h4 id="5-1-5-1-节点类型"><a href="#5-1-5-1-节点类型" class="headerlink" title="5.1.5.1 节点类型"></a>5.1.5.1 节点类型</h4><p>首先看/logs/collector这个节点下面子节点的节点类型。这个节点下面的所有子节点都代表了每个收集器机器，那么初步认为这些子节点必须选择临时节点， 原因是日志系统可以根据这些临时节点来判断收集器机器的存活性。但是，同时还需要注意的一点是：在分布式日志收集这个场景中，收集器节点上还会存放所有 已经分配给该收集器机器的日志源机器列表，如果只是简单地依靠ZooKeeper自身的临时节点机制，那么当一个收集器挂掉或是当这个收集器机器中断“心跳汇报” 的时候，待该收集器节点的会话失效后，ZooKeeper就会立即删除该节点，于是，记录在该节点上的所有日志源机器列表也就随之被清除掉了。</p><p>从上面的描述中可以知道，临时节点显然无法满足这里的业务需求，所以我们选择了使用持久节点来标识每一个收集器机器，同时在这个持久节点下面分别创建 /logs/collector/[Hostname]/status节点来表征每一个收集器机器的状态。这样一来，既能实现日志系统对所有收集器的监控，同时在收集器机器挂掉 后，依然能够准确地将分配于其中的任务还原。</p><h4 id="5-1-5-2-日志系统节点监听"><a href="#5-1-5-2-日志系统节点监听" class="headerlink" title="5.1.5.2 日志系统节点监听"></a>5.1.5.2 日志系统节点监听</h4><p>在实际生产运行过程中，每一个收集器机器更改自己状态节点的频率可能非常高（如每秒1次或更短），而且收集器的数量可能非常大，如果日志系统监听所有 这些节点变化，那么通知的消息量可能会非常大。另一方面，在收集器机器正常工作的情况下，日志系统没有必要去实时地接收每次节点状态变更，因此大部分 这些变更通知都是无用的。因此我们考虑放弃监听设置，而是采用日志系统主动轮询收集器节点的策略，这样就节省了不少网卡流量，唯一的缺陷就是有 一定的延时（考虑到分布式日志收集系统的定位，这个延时是可以接受的）。</p><h2 id="5-2-在线云主机管理"><a href="#5-2-在线云主机管理" class="headerlink" title="5.2 在线云主机管理"></a>5.2 在线云主机管理</h2><p>在线云主机管理通常出现在那些虚拟主机提供商的应用场景中。在这类集群管理中，有很重要的一块就是集群机器的监控。这个场景通常对于集群中的机器状态， 尤其是机器在线率的统计有较高的要求，同时需要能够快速地对集群中机器的变更做出响应。</p><p>在传统的实现方案中，监控系统通过某种手段（比如检测主机的指定端口）来对每台机器进行定时检测，或者每台机器自己定时向监控系统汇报“我还活着”。 但是这种方式需要每个业务系统的开发人员自己来处理网络通信、协议设计、调度和容灾等诸多琐碎的问题。下面来看看使用ZooKeeper实现的另一种集群机器 存活性监控系统。针对这个系统，我们的需求点通常如下。</p><p>如何快速地统计当前生产环境一共有多少台机器？<br>如何快速地获取到机器上/下线的情况？<br>如何实时监控集群中每台主机的运行时状态？</p><h3 id="5-2-1-机器上-下线"><a href="#5-2-1-机器上-下线" class="headerlink" title="5.2.1 机器上/下线"></a>5.2.1 机器上/下线</h3><p>为了实现自动化的线上运维，我们必须对机器的上/下线情况有一个全局的监控。通常在新增机器的时候，需要首先将指定的Agent部署到这些机器上去。 Agent部署启动之后，会首先向ZooKeeper的指定节点进行注册，具体的做法就是在机器列表节点下面创建一个临时子节点，例如/XAE/machine/[Hostname] （下文以“主机节点”代表这个节点），如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-12.png" alt></p><p>当Agent在ZooKeeper上创建完这个临时子节点后，对/XAE/machines节点关注的监控中心就会接收到“子节点变更”事件，即上线通知，于是就可以对这个 新加入的机器开启相应的后台管理逻辑。另一方面，监控中心同样可以获取到机器下线的通知，这样便实现了对机器上/下线的检测，同时能够很容易地获取 到在线的机器列表，对于大规模的扩容和容量评估都有很大的帮助。</p><h3 id="5-2-2-机器监控"><a href="#5-2-2-机器监控" class="headerlink" title="5.2.2 机器监控"></a>5.2.2 机器监控</h3><p>对于一个在线云主机系统，不仅要对机器的在线状态进行检测，还需要对机器的运行时状态进行监控。在运行的过程中，Agent会定时将主机的运行状态信息 写入ZooKeeper上的主机节点，监控中心通过订阅这些节点的数据变更通知来间接地获取主机的运行时信息。</p><p>随着分布式系统规模变得越来越庞大，对集群机器的监控和管理显得越来越重要。上面提到的这种借助ZooKeeper来实现的方式，不仅能够实时地检测到集群 中机器的上/下线情况，而且能够实时地获取到主机的运行时信息，从而能够构建出一个大规模集群的主机图谱。</p><h1 id="6-Master选举"><a href="#6-Master选举" class="headerlink" title="6 Master选举"></a>6 Master选举</h1><p>Master选举是一个在分布式系统中非常常见的应用场景。分布式最核心的特性就是能够将具有独立计算能力的系统单元部署在不同的机器上，构成一个完整的 分布式系统。而与此同时，实际场景中往往也需要在这些分布在不同机器上的独立系统单元中选出一个所谓的“老大”，在计算机科学中，我们称之为“Master”。</p><p>在分布式系统中，Master往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权。例如，在一些读写分离的应用场景中，客户端的写请求往往 是由Master来处理的；而在另一些场景中，Master则常常负责处理一些复杂的逻辑，并将处理结果同步给集群中其它系统单元。Master选举可以说是ZooKeeper 最典型的应用场景了，在本节中，我们就结合“一种海量数据处理与共享模型”这个具体例子来看看ZooKeeper在集群Master选举中的应用场景。</p><p>在分布式环境中，经常会碰到这样的应用场景：集群中的所有系统单元需要对前端业务提供数据，比如一个商品ID，或者是一个网站轮播广告的广告ID（通常 出现在一些广告投放系统中）等，而这些商品ID或是广告ID往往需要从一系列的海量数据处理中计算得到————这通常是一个非常耗费I/O和CPU资源的过程。 鉴于该计算过程的复杂性，如果让集群中的所有机器都执行这个计算逻辑的话，那么将耗费非常多的资源。一种比较好的方法就是只让集群中的部分，甚至只 让其中的一台机器去处理数据计算，一旦计算出数据结果，就可以共享给整个集群中的其他所有客户端机器，这样可以大大减少重复劳动，提升性能。</p><p>这里我们以一个简单的广告投放系统后台场景为例来讲解这个模型。整个系统大体上可以分成客户端集群、分布式缓存系统、海量数据处理总线和ZooKeeper 四个部分，如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-13.png" alt></p><p>Client集群每天定时会通过ZooKeeper来实现Master选举。选举产生Master客户端之后，这个Master就会负责进行一系列的海量数据处理，最终计算得到 一个数据结果，并将其放置在一个内存/数据库中。同时，Master还需要通知集群中其它所有的客户端从这个内存/数据库中共享计算结果。</p><p>接下去，我们将重点来看Master选举的过程，首先来明确下Master选举的需求：在集群的所有机器中选举出一台机器作为Master。针对这个需求，通常情况 下，我们可以选择常见的关系型数据库中的主键特性来实现：集群中的所有机器都向数据库中插入一条相同主键ID的记录，数据库会帮助我们自动进行主键冲突 检查，也就是说，所有进行插入操作的客户端机器中，只有一台机器能够成功————那么，我们就认为向数据库中成功插入数据的客户端机器成为Master。</p><p>乍一看，这个方案确实可行，依靠关系型数据库的主键特性能够很好地保证在集群中选举出唯一的一个Master。但是我们需要考虑的另一个问题是，如果当前 选举出的Master挂了，那么该如何处理？谁来告诉我Master挂了呢？显然，关系型数据库没法通知我们这个事件。</p><p>ZooKeeper的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端无法重复创建一个已经存在 的数据节点。也就是说，如果同时有多个客户端请求创建同一个节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式 环境中进行Master选举了。</p><p>在这个系统中，首先会在ZooKeeper上创建一个日期节点，如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-14.png" alt></p><p>客户端集群每天都会定时往ZooKeeper上创建一个临时节点，例如/master_election/2017-09-03/binding。在这个过程中，只有一个客户端能够成功 创建这个节点，那么这个客户端所在机器就称为了Master。同时，其他没有在ZooKeeper上成功创建节点的客户端，都会在节点/master_ecection/2017-09-03 上注册一个子节点变更的Watcher，用于监控当前的Master机器是否存活，一旦发现当前的Master挂了，那么其余的客户端将会重新进行Master选举。</p><p>从上面的讲解中，我们可以看到，如果仅仅只是想实现Master选举的话，那么其实只需要有一个能够保证唯一性的组件即可，例如关系型数据库的主键模型 就是不错的选择。但是，如果希望能够快速地进行集群Master动态选举，那么基于ZooKeeper来实现是一个不错的新思路。</p><h1 id="7-分布式锁"><a href="#7-分布式锁" class="headerlink" title="7 分布式锁"></a>7 分布式锁</h1><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的 时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，就需要使用分布式锁了。</p><p>在平时的实际项目开发中，我们往往很少会去在意分布式锁，而是依赖于关系型数据库固有的排他性来实现不同进程之间的互斥。这确实是一种非常简便且被 广泛使用的分布式锁实现方式。然而有一个不争的事实是，目前绝大多数大型分布式系统的性能瓶颈都集中在数据库操作上。因此，如果上层业务再给数据库 添加一些额外的锁，例如行锁、表锁甚至是繁重的事务处理，那么是不是会让数据库更加不堪重负呢？下面我们来看看使用ZooKeeper如何实现分布式锁， 这里主要讲解排他锁和共享锁两类分布式锁。</p><h2 id="7-1-排他锁"><a href="#7-1-排他锁" class="headerlink" title="7.1 排他锁"></a>7.1 排他锁</h2><p>排他锁（Exclusive Locks，简称X锁），又称为写锁或独占锁，是一种基本的锁类型。如果事务T1对数据对象O1加上了排他锁，那么在整个加锁期间，只允许 事务T1对O1进行读取和更新操作，其他任何事务都不能再对这个数据对象进行任何类型的操作————直到T1释放了排他锁。</p><p>从上面讲解的排他锁的基本概念中，我们可以看到，排他锁的核心是如何保证当前有且仅有一个事务获得锁，并且锁被释放后，所有正在等待获取锁的事务都 能够被通知到。下面我们就看看如何借助ZooKeeper实现排他锁。</p><h3 id="7-1-1-定义锁"><a href="#7-1-1-定义锁" class="headerlink" title="7.1.1 定义锁"></a>7.1.1 定义锁</h3><p>有两种常见的方式可以用来定义锁，分别是synchronized机制和JDK5提供的ReentrantLock。然而，在ZooKeeper中，没有类似于这样的API可以直接使用， 而是通过ZooKeeper上的数据节点来表示一个锁，例如/exclusive_lock/lock节点就可以被定义为一个锁，如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-15.png" alt></p><h3 id="7-1-2-获取锁"><a href="#7-1-2-获取锁" class="headerlink" title="7.1.2 获取锁"></a>7.1.2 获取锁</h3><p>在需要获取排他锁时，所有的客户端都会试图通过调用create()接口，在/exclusive_lock节点下创建临时子节点/exclusive_lock/lock。而ZooKeeper 会保证在所有的客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获取了锁。同时，所有没有获取到锁的客户端就需要到/exclusive_lock 节点上注册一个子节点变更的Watcher监听，以便实时监听到lock节点的变更情况。</p><h3 id="7-1-3-释放锁"><a href="#7-1-3-释放锁" class="headerlink" title="7.1.3 释放锁"></a>7.1.3 释放锁</h3><p>由于是临时节点，有下面两种情况，可能释放锁：  </p><ul><li>当前获取锁的客户端机器发生宕机</li><li>正常执行完业务逻辑后，客户端主动将临时节点删除。<br>无论在上面情况下移除了lock节点，ZooKeeper都会通知所有在/exclusive_lock节点上注册了子节点变更Watcher监听的客户端。这些客户端在接收到通知后， 再次重新发起分布式锁获取，即重复“获取锁”过程。如下图： </li></ul><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-16.png" alt></p><h2 id="7-2-共享锁"><a href="#7-2-共享锁" class="headerlink" title="7.2 共享锁"></a>7.2 共享锁</h2><p>共享锁（Shared Locks，简称S锁），又称读锁，同样是一种基本的锁类型。如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作， 其他事务也只能对这个数据对象加共享锁————直到该数据对象上的所有共享锁都被释放。</p><p>共享锁和排他锁最根本的区别在于，加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。</p><h3 id="7-2-1-定义锁"><a href="#7-2-1-定义锁" class="headerlink" title="7.2.1 定义锁"></a>7.2.1 定义锁</h3><p>和排他锁一样，同样是通过ZooKeeper上的数据节点来表示一个锁，是一个类似于/shared_lock/[Hostname]-请求类型-序号的临时顺序节点，例如 /shared_lock/192.168.0.1-R-0000000001，那么，这个节点就代表了一个共享锁，如下图：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-17.png" alt></p><h3 id="7-2-2-获取锁"><a href="#7-2-2-获取锁" class="headerlink" title="7.2.2 获取锁"></a>7.2.2 获取锁</h3><p>在需要获取共享锁时，所有客户端都会到/shared_lock这个节点下面创建一个临时顺序节点，如果当前是读请求，那么就创建例如/shared_lock/192.168.0.1-R-000000001/ 的节点；如果是写请求，那么就创建例如/shared_lock/192.168.0.1-W-000000001的节点。</p><h3 id="7-2-3-判断读写顺序"><a href="#7-2-3-判断读写顺序" class="headerlink" title="7.2.3 判断读写顺序"></a>7.2.3 判断读写顺序</h3><p>根据共享锁的定义，不同的事务都可以同时对同一数据对象进行读取操作，而更新操作必须在当前没有任何事务进行读写操作的情况下进行。基于这个原则， 我们来看看如何通过ZooKeeper的节点来确定分布式读写顺序，大致可以分为如下4个步骤。</p><p>创建完节点后，获取/shared_lock节点下的所有子节点，并对该节点注册子节点变更的Watcher监听。<br>确定自己的节点序号在所有子节点中的顺序。<br>如果当前节点业务为读请求：如果没有比自己序号小的子节点，或是所有比自己序号小的子节点都是读请求，那么表明自己已经成功获取到了共享锁，同时 开始执行读取逻辑。如果比自己序号小的子节点有写请求，那么就需要进入等待。<br>如果当前节点业务为写请求：如果自己不是序号最小的子节点， 那么就需要进入等待。<br>接收到Watcher通知后，重复步骤1。</p><h3 id="7-2-4-释放锁"><a href="#7-2-4-释放锁" class="headerlink" title="7.2.4 释放锁"></a>7.2.4 释放锁</h3><p>释放锁的逻辑和排他锁是一致的。</p><h3 id="7-2-5-羊群效应"><a href="#7-2-5-羊群效应" class="headerlink" title="7.2.5 羊群效应"></a>7.2.5 羊群效应</h3><p>上面讲解的这个共享锁实现，大体上能够满足一般的分布式集群竞争锁的需求，并且性能都还可以————这里说的一般场景是指集群规模不是特别大，一般是在 10台机器以内。但是如果机器规模扩大之后，会有什么问题呢？我们着重来看上面“判断读写顺序”过程的步骤3，如下图，看看实际运行中的情况。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-18.png" alt></p><p>192.168.0.1这台机器首先进行读操作，完成读操作后将节点/192.168.0.1-R-000000001删除。<br>余下的4台机器均收到了这个节点被移除的通知，然后重新从/shared_lock/节点上获取一份新的子节点列表。<br>每个机器判断自己的读写顺序。其中192.168.0.2这台机器检测到自己已经是序号最小的机器了，于是开始进行写操作，而余下的其他机器发现没有轮到 自己进行读取或更新操作，于是继续等待。<br>继续……<br>上面这个过程就是共享锁在实际运行中最主要的步骤了，我们着重看下上面步骤3中提到的：“而余下的其他机器发现没有轮到自己进行读取或更新操作，于是继续等待。” 很明显，我们看到，192.168.0.1这个客户端在移除自己的共享锁后，ZooKeeper发送了子节点变更Watcher通知给所有机器，然而这个通知除了给192.168.0.2 这台机器产生实际影响外，对于余下的其他所有机器都没有任何作用。</p><p>相信读者也已经意思到了，在这整个分布式锁的竞争过程中，大量的“Watcher通知”和“子节点列表获取”两个操作重复运行，并且绝大多数的运行结果都是 判断出自己并非是序号最小的节点，从而继续等待下一次通知————这个看起来显然不怎么科学。客户端无端地接收到过多和自己并不相关的事件通知，如果在集群 规模比较大的情况下，不仅会对ZooKeeper服务器造成巨大的性能影响和网络冲击，更为严重的是，如果同一时间有多个节点对应的客户端完成事务或是事务 中断引起节点消息，ZooKeeper服务器就会在短时间内向其余客户端发送大量的事件通知————这就是所谓的羊群效应。</p><p>上面这个ZooKeeper分布式共享锁实现中出现羊群效应的根源在于，没有找准客户端真正的关注点。我们再来回顾一下上面的分布式锁竞争过程，它和核心 逻辑在于：判断自己是否是所有子节点中序号最小的。于是，很容易可以联想到，每个节点对应的客户端只需要关注比自己序号小的那个相关节点的变更情况 就可以了————而不需要关注全局的子列表变更情况。</p><h3 id="7-2-6-改进后的分布式锁实现"><a href="#7-2-6-改进后的分布式锁实现" class="headerlink" title="7.2.6 改进后的分布式锁实现"></a>7.2.6 改进后的分布式锁实现</h3><p>现在我们来看看如何改进上面的分布式锁实现。首先，我们需要肯定的一点是，上面提到的共享锁实现，从整体思路上来说完全正确。这里主要的改动在于： 每个锁竞争者，只需要关注/shared_lock/节点下序号比自己小的那个节点是否存在即可，具体实现如下：</p><ol><li>客户端调用create()方法创建一个类似于/shared_lock/[Hostname]-请求类型-序号的临时顺序节点。</li><li>客户端调用getChildren()接口来获取所有已经创建的子节点列表，注意，这里不注册任何Watcher。</li><li>如果无法获取共享锁，那么就调用exist()来对比自己小的那个节点注册Watcher。注意，这里“比自己小的节点”只是一个笼统的说法，具体对于读请求和写请求不一样。<br>读请求：向比自己序号小的最后一个写请求节点注册Watcher监听。<br>写请求：向比自己序号小的最后一个节点注册Watcher监听。</li><li>等待Watcher通知，继续进入步骤2。<br>流程图如下： </li></ol><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-19.png" alt></p><h3 id="7-2-7-注意"><a href="#7-2-7-注意" class="headerlink" title="7.2.7 注意"></a>7.2.7 注意</h3><p>看到这里，相信很多读者都会觉得改进后的分布式锁实现相对来说比较麻烦。确实如此，如同在多线程并发编程实践中，我们会去尽量缩小锁的范围————对于 分布式锁实现的改进其实也是同样的思路。那么对于开发人员来说，是否必须按照改进后的思路来设计实现自己的分布式锁呢？答案是否定的。在具体的实际开发 过程中，我们提倡根据具体的业务场景和集群规模来选择适合自己的分布式锁实现：在集群规模不大、网络资源丰富的情况下，第一种分布式锁实现方式是 简单实用的选择；而如果集群规模达到一定程度，并且希望能够精细化地控制分布式锁机制，那么不妨试试改进版的分布式锁实现。</p><h1 id="8-分布式队列"><a href="#8-分布式队列" class="headerlink" title="8 分布式队列"></a>8 分布式队列</h1><p>业界有不少分布式队列产品，不过绝大多数都是类似于ActiveMQ、Kafka等的消息中间件。在本节中，我们主要介绍基于ZooKeeper实现的分布式队列。 分布式队列，简单地讲分为两大类，一种是常规的先入先出队列，另一种则是要等到队列元素集聚之后才统一安排执行的Barrier模型。</p><h2 id="8-1-FIFO-先进先出"><a href="#8-1-FIFO-先进先出" class="headerlink" title="8.1 FIFO:先进先出"></a>8.1 FIFO:先进先出</h2><p>使用ZooKeeper实现FIFO队列，和共享锁的实现非常类似。FIFO队列就类似于一个全写的共享锁模型，大体的设计思想其实非常简单：所有客户端都会到 /queue_fifo这个节点下面创建一个临时顺序节点，例如/queue_fifo/192.168.0.1-0000000001，如下图： </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-20.png" alt></p><p>创建完节点之后，根据如下4个步骤来确定执行顺序。</p><p>通过调用getChildren()接口来获取/queue_fifo节点下的所有子节点，即获取队列中所有的元素。<br>确定自己的节点序号在所有子节点中的顺序。<br>如果自己不是序号最小的子节点，那么就需要进入等待，同时向比自己序号小的最后一个节点注册Watcher监听。<br>接收到Watcher通知到，重复步骤1。<br>整个FIFO队列的工作流程，如下图： </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-21.png" alt></p><h2 id="8-2-Barrier-分布式屏障"><a href="#8-2-Barrier-分布式屏障" class="headerlink" title="8.2 Barrier:分布式屏障"></a>8.2 Barrier:分布式屏障</h2><p>Barrier原意是指障碍物、屏障，而在分布式系统中，特指系统之间的一个协调条件，规定了一个队列的元素必须都集聚后才能统一进行安排，否则一直等待。 这往往出现在那些大规模分布式并行计算的应用场景了：最终的合并计算需要基于很多并行计算的子结果来进行。这些队列其实是FIFO队列的基础上进行了 增强，大致的设计思想如下：开始时，/queue_barrier节点是一个已经存在的默认节点，并且将其节点的数据内容赋值为一个数字n来代表Barrier值， 例如n=10表示只有当/queue_barrier节点下的子节点个数达到10后，才会打开Barrier。之后，所有的客户端都会到/queue_barrier节点下创建一个 临时节点，例如/queue_barrier/192.168.0.1，如下图： </p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-22.png" alt></p><p>创建完节点之后，根据如下5个步骤来确定执行顺序。</p><ol><li>通过调用getDate()接口获取/queue_barrier节点的数据内容：10。</li><li>通过调用getChildren()接口获取/queue_barrier节点下的所有子节点，即获取队列中所有元素，同时注册对子节点列表变更的Watcher监听。</li><li>统计子节点的个数。</li><li>如果子节点个数还不足10个，那么就需要进入等待。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-6-1-23.png" alt></li><li>接收到Watcher通知后，重复步骤2。  </li></ol><p>博主理解为，如果在很少的时间内，同时超过了10个以上的业务机创建了临时节点，那么业务处理的速度并不是恒定的，因为有可能这个业务被11个机器处理， 下一个被12个业务机处理？</p><h1 id="9-小结"><a href="#9-小结" class="headerlink" title="9 小结"></a>9 小结</h1><p>数据发布/订阅（配置中心）、负载均衡（DNS解析）、命名服务（顺序节点特性）、分布式协调/通知（Watcher机制），集群管理（子节点）、Master选举 （同时创建节点）、分布式锁（同时创建节点）、分布式队列（创建顺序节点）</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 从Paxos到Zookeeper分布式一致性原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、Zookeeper与Paxos</title>
      <link href="/2017/08/25/paxos2zookeeper/4.html/"/>
      <url>/2017/08/25/paxos2zookeeper/4.html/</url>
      
        <content type="html"><![CDATA[<p>本章概要：<br>首先对ZooKeeper进行一个整体上的介绍，包括ZooKeeper的设计目标、由来以及它的基本概念，然后将会重点介绍ZAB这一ZooKeeper中非常重要的一致性协议。</p><h1 id="1-初识ZooKeeper"><a href="#1-初识ZooKeeper" class="headerlink" title="1. 初识ZooKeeper"></a>1. 初识ZooKeeper</h1><h2 id="1-1-ZooKeeper介绍"><a href="#1-1-ZooKeeper介绍" class="headerlink" title="1.1 ZooKeeper介绍"></a>1.1 ZooKeeper介绍</h2><p>ZooKeeper由雅虎创建，是Chubby的开源实现。设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><h3 id="1-1-1-ZooKeeper是什么"><a href="#1-1-1-ZooKeeper是什么" class="headerlink" title="1.1.1 ZooKeeper是什么"></a>1.1.1 ZooKeeper是什么</h3><p>ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举 、分布式锁和分布式队列等功能。ZooKeeper可以保证如下分布式一致性特性。</p><h4 id="1-顺序一致性"><a href="#1-顺序一致性" class="headerlink" title=".1 顺序一致性"></a>.1 顺序一致性</h4><p>从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到ZooKeeper中去。</p><h4 id="2-原子性"><a href="#2-原子性" class="headerlink" title=".2 原子性"></a>.2 原子性</h4><p>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定 不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</p><h4 id="3-单一视图（Single-System-Image）"><a href="#3-单一视图（Single-System-Image）" class="headerlink" title=".3 单一视图（Single System Image）"></a>.3 单一视图（Single System Image）</h4><p>无论客户端连接的是哪ZooKeeper服务器，其看到的服务端数据模型都是一致性。</p><h4 id="4-可靠性"><a href="#4-可靠性" class="headerlink" title=".4 可靠性"></a>.4 可靠性</h4><p>一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p><h4 id="5-实时性"><a href="#5-实时性" class="headerlink" title=".5 实时性"></a>.5 实时性</h4><p>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是， ZooKeeper仅仅保证在一定额时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p><h3 id="1-1-2-ZooKeeper的设计目标"><a href="#1-1-2-ZooKeeper的设计目标" class="headerlink" title="1.1.2 ZooKeeper的设计目标"></a>1.1.2 ZooKeeper的设计目标</h3><p>ZooKeeper致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务。高性能使得ZooKeeper能够应用于 那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于ZooKeeper实现 一些复杂的同步原语。下面我们来具体看一下ZooKeeper的四个设计目标。</p><h4 id="1-目标一：简单的数据模型"><a href="#1-目标一：简单的数据模型" class="headerlink" title=".1 目标一：简单的数据模型"></a>.1 目标一：简单的数据模型</h4><p>ZooKeeper使得分布式程序能够通过一个共享的、树型结构的名字空间来进行相互协调。</p><p>这里所说的树型结构的名字空间，是指ZooKeeper服务器内存中的一个数据模型，其由一系列被称为ZNode的数据节点组成，总的来说，其数据模型类似于一个文件系统， 而ZNode之间的层级关系，就像文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是，ZooKeeper将全量数据存储在内存中，以此来实现提高 服务器吞吐、减少延迟的目的。</p><h4 id="2-目标二：可以构建集群"><a href="#2-目标二：可以构建集群" class="headerlink" title=".2 目标二：可以构建集群"></a>.2 目标二：可以构建集群</h4><p>一个ZooKeeper集群通常由一组机器组成，一般3~5台机器就可以组成一个可用的ZooKeeper集群了（2n+1）。</p><p>组成ZooKeeper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持着通信。值得一提的，只要集群中存在超过一半的机器 能够正常工作，那么整个集群就能够正常对外服务。</p><p>ZooKeeper的客户端程序会选择和集群中任意一台机器共同来创建一个TCP连接，而一旦客户端和某台ZooKeeper服务器之间的连接断开后，客户端会自动连接 到集群中的其他机器。</p><h4 id="3-顺序访问"><a href="#3-顺序访问" class="headerlink" title=".3 顺序访问"></a>.3 顺序访问</h4><p>对于来自客户端的每个更新请求，ZooKeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用ZooKeeper 的这个特性来实现更高层次的同步原语。</p><h4 id="4-高性能"><a href="#4-高性能" class="headerlink" title=".4 高性能"></a>.4 高性能</h4><p>由于ZooKeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。</p><h2 id="1-2-ZooKeeper从何而来"><a href="#1-2-ZooKeeper从何而来" class="headerlink" title="1.2 ZooKeeper从何而来"></a>1.2 ZooKeeper从何而来</h2><p>ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是 这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人眼将精力集中在处理业务逻辑上。</p><p>关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目），雅虎 的工程师希望给合格项目也取一个动物的名字，大家纷纷表示就叫动物园管理员吧————因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看 上去就像一个大型的动物园了，而ZooKeeper正好要用来进行分布式环境的协调————于是，ZooKeeper的名字也就由此诞生了。</p><h2 id="1-3-ZooKeeper的基本概念"><a href="#1-3-ZooKeeper的基本概念" class="headerlink" title="1.3 ZooKeeper的基本概念"></a>1.3 ZooKeeper的基本概念</h2><h3 id="1-3-1-集群角色"><a href="#1-3-1-集群角色" class="headerlink" title="1.3.1 集群角色"></a>1.3.1 集群角色</h3><p>通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最典型的集群模式就是Master/Slave模式（主备模式）。在这种模式下，我们把能够处理所有 写操作的机器称为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器称为Slave机器。</p><p>而在ZooKeeper中，这些概念被颠覆了。它没有沿用传统的Master/Slave概念，而是引入了Leader、Follower和Observer三种角色。ZooKeeper集群中的所有 机器通过一个Leader选举过程来选定一台被称为“Leader”的机器，Leader服务器为客户端提供读和写服务。除Leader外，其他机器包括Follower和Observer。 Follower和Observer都能够提供读服务，唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以 在不影响写性能的情况下提升集群的读性能。</p><h3 id="1-3-2-会话（Session）"><a href="#1-3-2-会话（Session）" class="headerlink" title="1.3.2 会话（Session）"></a>1.3.2 会话（Session）</h3><p>Session是指客户端会话，在讲解会话之前，我们首先来了解一下客户端连接。在ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。 ZooKeeper对外的服务端口默认是2181，客户端启动的时候，首先会服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了， 通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时， 只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><h3 id="1-3-3-数据节点（Znode）"><a href="#1-3-3-数据节点（Znode）" class="headerlink" title="1.3.3 数据节点（Znode）"></a>1.3.3 数据节点（Znode）</h3><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然后，在ZooKeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点； 第二类则是指数据模型中的数据单元，我们称之为数据几点————Znode。ZooKeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree），由/进行分割 的路径，就是一个Znode，例如/foo/path1。每个Znode上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><p>在ZooKeeper中，Znode可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个Znode被创建了，除非主动进行Znode的移除操作，否则这个Znode将一直保存在ZooKeeper 上。临时节点生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点 添加一个特殊的属性：SEQUENTIAL。一旦节点被标注上这个属性，那么在这个节点被创建的时候，ZooKeeper会自动在其节点名后面追上一个整型数字，这个 整型数字是一个由父节点维护的自增数字。</p><h3 id="1-3-4-版本"><a href="#1-3-4-版本" class="headerlink" title="1.3.4 版本"></a>1.3.4 版本</h3><p>在前面我们已经提到，ZooKeeper的每个Znode上都会存储数据，对应于每个Znode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个Znode 的三个数据版本，分别是version（当前Znode的版本）、cversion（当前Znode字节点的版本）、aversion（当前Znode的ACL版本）。</p><h3 id="1-3-5-Watcher"><a href="#1-3-5-Watcher" class="headerlink" title="1.3.5 Watcher"></a>1.3.5 Watcher</h3><p>Watcher（事件监听器），是ZooKeeper中得意一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端 会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p><h3 id="1-3-6-ACL"><a href="#1-3-6-ACL" class="headerlink" title="1.3.6 ACL"></a>1.3.6 ACL</h3><p>ZooKeeper采用ACL（Access Control Lists）策略来进行权限控制。</p><ul><li>CREATE：创建子节点的权限。</li><li>READ：获取节点数据和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE：删除子节点的权限。</li><li>ADMIN：设置节点ACL的权限。</li></ul><p>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</p><h2 id="1-4-为什么选择ZooKeeper"><a href="#1-4-为什么选择ZooKeeper" class="headerlink" title="1.4 为什么选择ZooKeeper"></a>1.4 为什么选择ZooKeeper</h2><p>在解决分布式数据一致性上，除了ZooKeeper之外，目前还没有一个成熟稳定且被大规模应用的解决方案。ZooKeeper无论从性能、易用性还是稳定性上来说， 都已经达到了一个工业级产品的标准。并且开发源码、免费。</p><h1 id="2-ZooKeeper的ZAB协议"><a href="#2-ZooKeeper的ZAB协议" class="headerlink" title="2 ZooKeeper的ZAB协议"></a>2 ZooKeeper的ZAB协议</h1><h2 id="2-1-ZAB协议"><a href="#2-1-ZAB协议" class="headerlink" title="2.1 ZAB协议"></a>2.1 ZAB协议</h2><p>事实上，ZooKeeper并没有完全采用Paxos算法，而是使用了一种称为ZooKeeper Atomic Broadcast（ZAB，ZooKeeper原子消息广播协议）的协议作为其数据一致性的核心算法。</p><p>ZAB协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。ZAB协议的开发设计人员在协议设计之初并没有要求其具有很好的扩展性， 最初只是为雅虎公司内部那些高吞吐量、低延迟、健壮、简单的分布式系统场景设计的。在ZooKeeper的官方文档也指出，ZAB协议不像Paxos算法那样，是一种 通用的分布式一致性算法，它是一种特别为ZooKeeper设计的崩溃可恢复的原子消息广播算法。</p><p>在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体的， ZooKeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程上去。 ZAB协议的这个主备模型架构保增乐同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求。另一方面，考虑到在分布式环境中， 顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更，例如变更C需要依赖变更A和变更B。这样的依赖关系 也对ZAB协议提出了一个要求：ZAB协议必须能够保证一个全局的变更序列被顺序应用，也就是说，ZAB协议需要保证如果一个状态变更已经被处理了，那么所有其 依赖的状态变更都应该已经被提前处理掉了。最后，考虑到主进程在任何时候都有可能出现崩溃退出或重启现象。因此，ZAB协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作。</p><p>ZAB协议的核心是定义了哪些会改变ZooKeeper服务器数据状态的事务请求的处理方式，即：</p><p>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则成为Follower服务器。 Leader服务器负责将一个客户端事务请求转换成一个事务Proposal（提议），并将该Proposal分发给集群中所有的Follower服务器。之后Leader 服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower 服务器分发Commit消息，要求其将前一个Proposal进行提交。</p><h2 id="2-2-协议介绍"><a href="#2-2-协议介绍" class="headerlink" title="2.2 协议介绍"></a>2.2 协议介绍</h2><p>ZAB协议包括两种基本的模式，分别是崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况时， ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后， ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p><p>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台同样遵守ZAB协议的服务器启动后加入到 集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器， 并与其进行数据同步，然后一起参与到消息广播流程中区。正如上文介绍所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求和处理。 Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求， 那么这些非Leader服务器首先将这个事务请求转发给Leader服务器。</p><p>当Leader服务器出现崩溃退出或机器重启，亦或是集群中已经不存在过半的服务器与该Leader服务器保持正常通信时，那么在重新开始新一轮的原子广播事务操作之前， 所有进程首先会使用崩溃恢复协议来使彼此达到一个一致的状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。</p><p>一个机器要称为新的Leader，必须获得过半进程的支持，同时由于每个进程都有可能会崩溃，因此，在ZAB协议运行过程中，前后会出现多个Leader，并且每个进程也有可能 会多次成为Leader。进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的Leader并再次进入消息广播模式。 举个例子来说，一个由3台机器组成的AZB服务，通常由1个Leader、2个Follower服务器组成。某一时刻，加入其中一个Follower服务器挂了，整个ZAB是 不会中断服务的，这是因为Leader服务器依然能够获得过半机器（包括Leader自己）的支持。</p><h3 id="2-2-1-消息广播"><a href="#2-2-1-消息广播" class="headerlink" title="2.2.1 消息广播"></a>2.2.1 消息广播</h3><p>ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并 将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-4-1-1.png" alt></p><p>在ZAB协议的二阶段提交过程中，移除了中断逻辑，所有的Follower服务器要么正常反馈Leader提出的事务Proposal，要么就抛弃Leader服务器。同时，ZAB协议将二阶段 提交中的中断逻辑移除意味着我们可以在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal了，而不需要等待集群中所有的Follower服务器都 反馈响应。当然，在这种简化了的二阶段提交模型下，是无法处理Leader服务器崩溃退出而带来的数据不一致问题，因此在ZAB协议中添加了另一个模式， 即采用崩溃恢复模式来解决这个问题。另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中 消息接收与发送的顺序性。</p><p>在整个消息广播过程中，Leader服务器会为每个事务请求对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个 全局单调递增的唯一ID，我们称之为事务ID（即ZXID）。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的 先后顺序来进行排序与处理。</p><p>具体的，在消息广播过程中，Leader服务器会为每一个Follower服务器都各自分配一个单独的队列，然后将需要广播的事务Proposal依次放入这些队列中，并且根据FIFO 策略进行消息发送。每一个Follower服务器在接收到这个事务Proposal之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给Leader 服务器一个Ack响应。当Leader服务器接收到超过半数Follower的Ack响应后，就会广播一个Comit消息给所有的Follower服务器以通知其进行事务提交，同时Leader自身 也会完成对事务的提交，而每一个Follower服务器在接收到Commit消息后，也会完成对事务的提交。</p><h3 id="2-2-2-崩溃恢复"><a href="#2-2-2-崩溃恢复" class="headerlink" title="2.2.2 崩溃恢复"></a>2.2.2 崩溃恢复</h3><p>一旦Leader服务器出现奔溃，或者说由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。在ZAB协议中，为了保证程序的正确运行， 整个恢复过程后需要选举出一个新的Leader服务器。因此，AZB协议需要一个高效且可靠的Leader选举算法，从而确保能够快速地选举出新的Leader。同时， Leader选举算法不仅仅需要让Leader自己知道其自身已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。</p><h4 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title=".1 基本特性"></a>.1 基本特性</h4><p>ZAB协议规定了如果一个事务Proposal在一台机器上被处理成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。接下来我们看看在崩溃恢复过程中， 可能会出现的两个数据不一致性的隐患及针对这些情况ZAB协议所需要保证的特性。</p><p>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。</p><p>假设一个事务在Leader服务器上被提交了，并且已经得到过半Follower服务器的Ack反馈，但是它将Commit消息发送给所有Follower机器之前，Leader服务器挂了。 例如，在集群正常运行过程中的某一个时刻，Server1是Leader服务器，其先后广播了消息P1、P2、C1、P3、C2，其中，当Leader服务器将消息C2（Commit Of Proposal2） 发出后就立即崩溃退出了。针对这种情况，ZAB协议就需要确保事务Proposal2最终能够在所有的服务器上都被提交成功，否则将出现不一致。</p><p>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。</p><p>假设初始的Leader服务器Server1在提出了一个事务Proposal3之后就崩溃退出了，从而导致集群中的其它服务器都没有收到这个事务Proposal。于是，当Server1 恢复过来再次加入到集群中的时候，ZAB协议需要确保丢弃Proposal3这个事务。</p><p>结合上面的这两个崩溃恢复过程中需要处理的特殊情况，就决定了ZAB协议必须设计这样一个Leader选举算法：能够确保提交已经被Leader提交的事务Proposal， 同时丢弃已经被跳过的事务Proposal。针对这个要求，如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（即ZXID）的事务 Proposal，那么就可以保证这个新选举出来的Leader一定具有所有已经提交的提案。更为重要的是，如果让具有最高编号事务Proposal的机器来成为Leader，就 可以省去Leader服务器检查Proposal提交和丢弃工作的这一步操作了。</p><h4 id="2-数据同步"><a href="#2-数据同步" class="headerlink" title=".2 数据同步"></a>.2 数据同步</h4><p>完成Leader选举之后，在正式开始工作（即接收客户端的事务请求，然后提出新的提案）之前，Leader服务器会首先确认事务日志中的所有Proposal是否都已经 被集群中过半的机器提交了，即是否完成数据同步。下面我们就来看看ZAB协议的数据同步过程。</p><p>所有正常运行的服务器，要么称为Leader，要么称为Follower并和Leader保持同步。Leader服务器需要确保所有的Follower服务器能够接收每一条事务Proposal， 并且能够正确地将所有已经提交了的事务Proposal应用到内存数据中去。具体的，Leader服务器会为每一个Follower服务器都准备一个队列，并将那些没有被 各Follower服务器同步的事务以Proposal消息的形式逐个发送给Follower服务器，并在每一个Proposal消息后面紧接着再发送一个Commit消息，以表示该事务 已经被提交。等到Follower服务器将所有其尚未同步的事务Proposal都从Loeader服务器上同步过来并成功应用到本地数据库中后，Leader服务器就会将 Follower服务器加入到真正的可用Follower列表中，并开始之后的其它流程。</p><p>上面讲到的是正常情况下的数据同步逻辑，下面来看ZAB协议是如何处理那些需要被丢弃的事务Proposal的。在ZAB协议的事务编号ZXID设计中，ZID是一个64位的数字， 其中低32位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal的时候，都会对该计数器进行加1操作； 而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader服务器，就会从这个Leader服务器上取出本地日志中最大事务Proposal的ZXID，并从 该ZXID中解析出对应的epoch值，然后再对其进行加1操作，之后就会以此编号作为新的epoch，并将低32位置0来开始生成新的ZXID。ZAB协议中的这一通过epoch编号 来区分Leader周期变化的策略，能够有效地避免不同的Leader服务器错误地使用相同的ZXID编号提出不一样的事务Proposal的异常情况，这对于识别在Leader崩溃恢复前后 生成的Proposal非常有帮助，大大简化和提升了数据恢复流程。</p><p>基于这样的策略，当一个包含了上一个Leader周期尚无提交过的事务Proposal的服务器启动时，其肯定无法成为Leader，原因很简单，因为当前集群中一定包含一个Quorum集合， 该集合中的机器一定包含了更好epoch的事务Proposal，因此这台机器的事务Proposal肯定不是最高，也就无法成为Leader了。当这台机器加入到集群中，以 Follower角色连接上Leader服务器之后，Leader服务器会根据自己服务器上最后被提交的Proposal来和Follower服务器的Proposal进行比对，比对的结果 当然是Leader会要求Follower进行一个回退操作————回退到一个确实已经被集群中过半机器提交的最新的事务Proposal。（ZXID的高32位是纪元，当已经挂了 的Leader重新恢复变成Leader时，其纪元一定小于当前一直在运行的服务器，因此老的Leader就算恢复了也不会成为Leader。大清亡了，新的时代，）</p><h2 id="2-3-ZAB与Paxos算法的联系"><a href="#2-3-ZAB与Paxos算法的联系" class="headerlink" title="2.3 ZAB与Paxos算法的联系"></a>2.3 ZAB与Paxos算法的联系</h2><p>ZAB协议并不是Paxos算法的一个典型实现，在讲解ZAB和Paxos之间的区别之前，我们首先来看下两者的联系。</p><p>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。<br>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。<br>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，只是名字变成了Ballot。<br>在Paxos算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其它进程进程通信的方式来收集上一个主进程提出 的提案，并将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在Paxos算法设计的基础上，ZAB协议额外添加了一个同步阶段。 在同步阶段之前，ZAB协议也存在一个和Paxos算法中的读阶段非常类似的过程，称为发现（Discovery）阶段。在同步阶段中，新的Leader会确保存在 过半的Follower已经提交了之前Leader周期中的所有事务Proposal。这一同步阶段的引入，能够有效地保证Leader在新的周期中提出事务Proposal之前，所有的 进程都已经完成了对之前所有事务Proposal的提交。一旦完成同步阶段后，那么ZAB就会执行和Paxos算法类似的写阶段。</p><p>总的来说，ZAB协议和Paxos算法的本质区别在于，两者的设计目标不太一样。ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKeeper， 而Paxos算法则是用于构建一个分布式的一致性状态机系统。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>ZooKeeper的设计目标、由来以及基本概念。另外还有它的一致性协议————ZAB，并将其与Paxos算法进行了比对。</p><p>ZooKeeper为了保证状态的一致性，提出了两个安全属性：  </p><ul><li>全序（消息a和消息b发送的顺序Client和Server看的都是一样的），通过TCP协议的FIFO队列特性实现。</li><li>因果顺序（消息a先于消息b发送，则消息a先于消息b执行）。通过Leader消息先到先执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 从Paxos到Zookeeper分布式一致性原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、Paxos 的工程实践</title>
      <link href="/2017/08/22/paxos2zookeeper/3.html/"/>
      <url>/2017/08/22/paxos2zookeeper/3.html/</url>
      
        <content type="html"><![CDATA[<p>前章提要：<br>主要从理论上讲解了Paxos算法，如何在保证数据一致性的情况下兼顾稳定性和性能也是一个巨大的挑战。从本章开始，我们将结合实际工程实际中的Paxos实现， 来讲解如何真正地使用Paxos算法来解决分布式一致性问题。</p><h1 id="1-Chubby"><a href="#1-Chubby" class="headerlink" title="1. Chubby"></a>1. Chubby</h1><p>Google Chubby是一个大名鼎鼎的分布式锁服务，GFS和Big Table等大型系统多用它来解决分布式协作、元数据存储和Master选举等一系列与分布式锁服务相关的问题。 Chubby的底层一致性实现就是以Paxos算法为基础的，这给Paxos算法的学习者提供了一个理论联系的范例，从而可以了解到Paxos算法是如何在实际工程中得到应用的。</p><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>Chubby是一个面向松耦合分布式系统的锁服务，通常用于为一个由大量小型计算机构成的松耦合分布式系统提供高可用的分布式锁服务。一个分布式锁服务的目的是 允许它的客户端进程同步彼此的操作，并对当前所处环境的基本状态信息达成一致。针对这个目的，Chubby提供了粗粒度的分布式锁服务，开发人员不需要使用复杂的同步协议。 而是直接调用Chubby的锁服务接口即可实现分布式系统中多个进程之间粗粒度的同步控制，从而保证分布式数据的一致性。</p><p>Chubby的客户端接口设计非常类似于UNIX文件系统结构，应用程序通过Chubby的客户端接口，不仅能够对Chubby服务器上的整个文件进行读写操作，还能够添加对文件节点的锁控制， 并且能够订阅Chubby服务端发出的一些列文件变动的事件通知。</p><h2 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a>1.2 应用场景</h2><p>在Chubby的众多应用场景中，最为典型的就是集群中服务器的Master选举。例如在Google文件系统（Google File System，GFS）中使用Chubby锁服务来实现对 GFS Master服务器的选举。而在BigTable（用于结构化数据存储与管理的大型分布式存储系统）中，同样被用于Master选举，并且借助Chubby， Master能够非常方便地的感知到其所控制的那些服务器。同时，通过Chubby，BigTable的哭护短还能够方便地定位到当前BitTable集群的Master服务器。 此外，在GFS和BigTable中，都使用Chubby来进行系统运行时元数据的存储。</p><h2 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h2><p>对于Chubby的设计，有的开发人员觉得作为Paxos算法的实现者，Chubby应该构建成一个包含Paxos算法的协议库，从而使应用程序能够便捷地使用Paxos算法。 但是，Chubby的最初设计者并没有选择这么做，而是将Chubby设计成一个需要访问中心化节点的分布式锁服务。</p><p>Chubby之所以设计成这样一个完整的分布式锁服务，是因为锁服务具有以下4个传统算法库所不具有的优点。</p><h3 id="1-对上层应用程序的侵入性更小"><a href="#1-对上层应用程序的侵入性更小" class="headerlink" title="1. 对上层应用程序的侵入性更小"></a>1. 对上层应用程序的侵入性更小</h3><p>对于应用程序开发初期，开发人员都是从一个只需要支撑较小的负载，并且只需要保证大体可用的原型开始的，往往并没有在代码层面为分布式一致性协议的实现留有余地。 于是，集群中副本复制和Master选举等一系列提高分布式系统可用性的措施，就通过一个封装了分布式一致性协议的客户端来完成，但相比之下， 使用一个分布式锁服务的接口方式对上层应用程序的侵入性会更小。</p><h3 id="2-便于提供数据的发布与订阅"><a href="#2-便于提供数据的发布与订阅" class="headerlink" title="2. 便于提供数据的发布与订阅"></a>2. 便于提供数据的发布与订阅</h3><p>几乎在所有使用Chubby进行Master选举的应用场景中，都需要一种广播结果的机制，用来向所有的客户端公布当前的Master服务器。这就意味着Chubby应该 允许其客户端在服务器上进行少量数据的存储与读取————也就是对小文件的读写操作。虽然这个特性也能够通过分布式命名服务来实现，但是根据实际的经验来看， 分布式锁服务本身也非常适合提供这个功能，这一方面能够大大减少客户端依赖的外部服务，另一方面，数据的发布与订阅功能和锁服务在分布式一致性特性上是想通的。</p><h3 id="3-开发人员对基于锁的接口更为熟悉"><a href="#3-开发人员对基于锁的接口更为熟悉" class="headerlink" title="3. 开发人员对基于锁的接口更为熟悉"></a>3. 开发人员对基于锁的接口更为熟悉</h3><p>对于绝大部分的开发人员来说，Chubby为其提供了一套近乎和单机锁机制一致的分布式锁服务接口，比提供一个一致性协议的库来得更为友好。</p><h3 id="4-更便捷地构建更可靠的服务"><a href="#4-更便捷地构建更可靠的服务" class="headerlink" title="4. 更便捷地构建更可靠的服务"></a>4. 更便捷地构建更可靠的服务</h3><p>通常一个分布式一致性算法都需要使用Quorum机制来进行数据项值的选定。Quorum机制是分布式系统中实现数据一致性的一个比较特殊的策略，它指的是在 一个由若干个机器组成的急群众，在一个数据项值的选定过程中，要求急群众存在过半的机器达成一致，因此Quorum机制也被称作“过半机制”。 在Chubby中通常使用5台服务器来组成一个集群单元，根据Quorum机制，只要整个急群众有3台服务器是正常运行的，那么整个集群就可以对外提供正常的服务。 相反的，如果仅提供一个分布式一致性协议的客户端库，那么这些高可用性的系统部署都将交给开发人员自己来处理，提高了成本。</p><p>因此，Chubby被设计成了一个需要访问中心化节点的分布式锁服务。同时，在Chubby的设计过程中，提出了以下几个设计目标。</p><ol><li><p>提供一个完整的、独立的分布式锁服务，而非仅仅是一个一致性协议的客户端库：<br>例如，对于Master选举同时将Master信息登记并广播的场景，应用程序只需要向Chubby请求一个锁，并且在获得锁之后向相应的锁文件写入Master信息即可， 其余的客户端就可以通过读取这个锁文件来获取Master信息。</p></li><li><p>提供粗粒度的锁服务<br>Chubby锁服务针对的应用场景是客户端获得锁之后会进行长时间的持有（数小时或数天），而非用于短暂获取锁的场景。针对这种应用场景，当锁服务短暂失效时 （例如服务器宕机），Chubby需要保持所有锁的持有状态，以避免持有锁的客户端出现问题。这和细粒度锁的设计方式有很大的区别，细粒度锁通常设计为锁 服务一旦失效就释放所有锁，因为细粒度锁的持有时间很短，相比而言放弃锁带来的代价较小。</p></li><li><p>在提供锁服务的同时提供对小文件的读写功能<br>Chubby提供对小文件的读写服务，以使得被选举出来的Master可以在不依赖额外服务的情况下，非常方便地向所有客户端发布自己的状态信息。具体的， 当一个客户端成功获取到一个Chubby文件锁而成为Master之后，就可以继续向这个文件里写入Master信息，其他客户端就可以通过读取这个文件得知当前的Master信息。</p></li><li><p>高可用、高可靠<br>在Chubby的架构设计中，允许运维人员通过部署多台机器（一般是5台机器）来组成一个Chubby集群，从而保证集群的高可用，基于Paxos算法的实现， 只要保证在3台正常运行的机器，整个集群对外服务就能保持可用。</p></li><li><p>提供事件通知机制<br>Chubby客户单需要实时地感知到Master的变化情况，当然这可以通过让客户端反复轮询来实现，但是在客户端规模不断增大的情况下，客户端主动轮询的实时性效果并不理想， 且对服务器性能和网络带宽压力都非常大。因此，Chubby需要由能力将服务端的数据变化情况（如文件内容变更）以事件的形式通知到所有订阅的客户端。</p></li></ol><h2 id="1-4-Chubby技术架构"><a href="#1-4-Chubby技术架构" class="headerlink" title="1.4 Chubby技术架构"></a>1.4 Chubby技术架构</h2><h3 id="1-4-1-系统结构"><a href="#1-4-1-系统结构" class="headerlink" title="1.4.1 系统结构"></a>1.4.1 系统结构</h3><p>Chubby的整个系统结构主要由服务端和客户端两部分组成，客户端通过RPC调用与服务端进行通信</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-3-1-1.png" alt></p><p>一个典型的Chubby集群，或称为Chubby cell，通常由5台服务器组成。这些副本服务器采用Paxos协议，通过投票的方式来选举产生一个获得过半投票的 服务器作为Master。一旦某台服务器成为了Master，Chubby就会保证在一段时期内不会再有其他服务器成为Master————这段时期称为Master租期（Master lease）。 在运行过程中，Master服务器会通过不断续租的方式来延长Master租期，而如果Master服务器出现故障，那么余下的服务器就会进行新一轮的Master选举， 最终产生新的Master服务器，开始新的Master租期。</p><p>集群中的每个服务器都维护着一份服务端数据库的副本，但在实际运行过程中，只有Master服务器才能对数据库进行写操作，而其它服务器都是使用Paxos协议从 Master服务器上同步数据库数据的更新。</p><p>现在，我们再来看下Chubby的客户端是如何定位到Master服务器的。Chubby客户端通过向记录有Chubby服务端机器列表的DNS来请求获取所有的Chubby服务器列表， 然后逐个发起请求询问该服务器是否是Master。在这个询问过程中，那些非Master的服务器，则会将当前Master所在的服务器标识反馈给客户端，这样 客户端就能够非常快速地定位到Master服务器了。</p><p>一旦客户端定位到Master服务器之后，只要该Master正常运行，那么客户端就会将所有的请求都发送到该Master服务器上。针对写请求，Chubby Master 会采用一致性协议将其广播给集群中所有的副本服务器，并且在过半的服务器接受了该写请求之后，再响应给客户端正确的应答。而对于读请求， 则不需要在集群内部进行广播处理，直接由Master服务器单独处理即可。</p><p>在Chubby运行过程中，服务器难免会发生故障。如果当前的Master服务器崩溃了，那么集群中的其他服务器会在Master租期到期后，重新开启新一轮的Master 选举。通常，进行一次Master选举大概需要花费几秒钟的时间。而如果是集群中任意一台非Master服务器崩溃，那么整个集群是不会停止工作的， 这个崩溃的服务器会在恢复之后自动加入到Chubby集群中去。新加入的服务器首先需要同步Chubby最新的数据库数据，完成数据同步之后，新的服务器就可以 加入到正常的Paxos运作流程中与其它服务器副本一起协同工作。</p><p>如果集群中的一个服务器发生崩溃并在几个小时后仍无法恢复正常，那么就需要加入新的机器，并同时更新DNS列表。Chubby服务器的更换方式非常简单， 只需要启动Chubby服务端程序，然后更新DNS上的机器列表（即使用新机器的IP地址替换老机器的IP地址）即可。在Chubby运行过程中， Master服务器会周期性地轮询DNS列表因此其很快就会感知服务器地址列表的变更，然后Master就会将集群数据库中的地址列表做相应的变更， 集群内部的其他副本服务器通过复制方式就可以获取到最新的服务器地址列表了。</p><h3 id="1-4-2-目录与文件"><a href="#1-4-2-目录与文件" class="headerlink" title="1.4.2 目录与文件"></a>1.4.2 目录与文件</h3><p>Chubby对外提供了一套与Unix文件系统非常相近但是更简单的访问接口。Chubby的数据结构可以看作是一个由文件和目录组成的树，其中每一个节点都可以表示为一个 使用斜杠分割的字符串，典型的节点路径表示如下：</p><p>/ls/foo/wombat/pouch<br>其中，ls是所有Chubby节点所共有的前缀，代表着锁服务，是Lock Service的缩写；foo则指定了Chubby集群的名字，从DNS可以查询到由一个或多个 服务器组成该Chubby集群；剩余部分的路径wombat/pouch则是一个真正包含业务含义的节点名字，由Chubby服务器内部解析并定位到数据节点。</p><p>Chubby的命名空间，包括文件和目录，我们称之为节点（nodes，在本书后面的内容中，我们以数据节点来泛指Chubby的文件或目录）。在同一个Chubby 集群数据库中，每一个节点都是全局唯一的。和Unix系统一样，每个目录都可以包含一系列的子文件和子目录列表，而每个文件中则会包含文件内容。当然， Chubby并非模拟一个完整的文件系统，因此没有符号链接和硬连接的概念。</p><p>由于Chubby的命名结构组成了一个近似标准文件系统的视图，因此Chubby的客户端应用程序也可以通过自定义的文件系统访问接口来访问Chubby服务端数据， 比如可以使用GFS的文件系统访问接口，这就大大减少了用户使用Chubby的成本。</p><p>Chubby上的每个数据节点都分为持久节点和临时节点两大类，其中持久节点需要显式地调用接口API来进行删除，而临时节点则会在其对应的客户端会话失效后被自动删除。 （zk中的EPHEMERAL）也就是说，临时节点的生命周期和客户端会话绑定，如果该临时节点对应的文件没有被任何客户端打开的话，那么它就会被删除掉。 因此，临时节点通常可以用来进行客户端会话有效性的判断依据。</p><p>另外，Chubby上的每个数据节点都包含了少量的元数据信息，其中包括用于权限控制的访问控制列表（ACL）信息。同时，每个节点的元数据中还包括4个单调 递增的64编号，分别如下。</p><p>实例编号：实例编号用于标识Chubby创建该数据节点的顺序，节点的创建顺序不同，其实例编号也不同，因此，通过实例编号，即使针对两个名字相同的数据节点， 客户端也能够非常方便地识别出是否是同一个数据节点————因此创建时间晚的数据节点，其实例编号必定大于任意先前创建的同名节点。<br>文件内容编号（只针对文件）：文件内容编号用于标识文件内容的变化情况，该编号会在文件内容被写入时增加。<br>锁编号：锁编号用于标识节点锁状态变更情况，该编号会在节点锁从自由（free）状态转换到被持有（held）状态时增加。<br>ACL编号：ACL编号用于标识节点的ACL信息变更情况，该编号会在节点的ACL配置信息被写入时增加。<br>同时，Chubby还会标识一个64位的文件内容校验码，以便客户端能够识别出文件是否变更。</p><h3 id="1-4-3-锁与锁序列器"><a href="#1-4-3-锁与锁序列器" class="headerlink" title="1.4.3 锁与锁序列器"></a>1.4.3 锁与锁序列器</h3><p>在分布式系统中，锁是一个非常复杂的问题，由于网络通信的不确定性，导致在分布式系统中锁机制变得非常复杂，消息的延迟或是乱序都有可能会引起锁的失效。 一个典型的分布式锁错乱案例是，一个客户端C1获取到了互斥锁L，并且在锁L的保护下发出请求R，但请求R迟迟没有到达服务端（可能出现网络延时或 反复重发等），这时应用程序会认为该客户端进程已经失败，于是便会为另一个客户端C2分配锁L，然后再重新发起之前的请求R，并成功地应用到了服务器 上。此时，不幸的事情发生了，客户端C1发起的请求R在经过一波三折之后也到达了服务端，此时，它有可能会在不受任何锁控制的情况下被服务端处理， 从而覆盖了客户端C2的操作，于是导致系统数据出现不一致。当然，诸如此类消息接收顺序紊乱引起的数据不一致问题已经在人们对分布式计算的长期 研究过程中得到了很好的解决，典型的解决方案包括虚拟时间和虚拟同步。</p><p>在Chubby中，任意一个数据节点都可以充当一个读写锁来使用：一种是单个客户端以排他（写）模式持有这个锁，另一种则是任意数目的客户端以共享（读）模式 持有这个锁。同时，在Chubby的锁机制中需要注意的一点是，Chubby舍弃了严格的强制锁，客户端可以在没有获取任何锁的情况下访问Chubby的文件，也就是说， 持有锁F既不是访问文件F的必要条件，也不会阻止其它客户端访问文件F。</p><h4 id="1-锁延迟"><a href="#1-锁延迟" class="headerlink" title=".1 锁延迟"></a>.1 锁延迟</h4><p>在Chubby中，主要采用锁延迟和锁序列器两种策略来解决上面我们提到的由于消息延迟和重排序引起的分布式锁问题。其中锁延迟是一种比较简单的策略， 使用Chubby的应用几乎不需要进行任何的代码修改。具体的，如果一个客户端以正常的方式主动释放了一个锁，那么Chubby服务端将会允许其它客户端能够 立即获得该锁。而如果一个锁是因为客户端的异常情况（如客户端无响应）而被释放的话，那么Chubby服务器会为该锁保留一定的时间，我们称之为“锁延迟”（lock-delay） 在这段时间内，其它客户端无法获取这个锁。锁延迟措施能够很好地防止一些客户端由于网络闪断等原因而与服务器暂时断开的场景出现。总的来说， 该方案尽管不完美，但是锁延时能够有效地保护在出现消息延时情况下发生的数据不一致现象。</p><h4 id="2-锁序列器"><a href="#2-锁序列器" class="headerlink" title=".2 锁序列器"></a>.2 锁序列器</h4><p>Chubby提供的另一种方式是使用锁序列器，当然该策略需要Chubby的上层应用配合在代码中加入相应的修改逻辑。任何时候，锁的持有者都可以向Chubby请求一个锁 序列器，其包括锁的名字、锁模式（排他或共享模式），以及锁序号。当客户端应用程序在进行一些需要锁机制保护的操作时，可以将该锁序列器一并发送给服务端。 Chubby服务端接收到这样的请求后，会首先检测该序列器是否有效，以及检查客户端是否处于恰当的锁模式；如果没有通过检查，那么服务端就会拒绝该客户端请求。</p><h3 id="1-4-4-Chubby中的事件通知机制"><a href="#1-4-4-Chubby中的事件通知机制" class="headerlink" title="1.4.4 Chubby中的事件通知机制"></a>1.4.4 Chubby中的事件通知机制</h3><p>为了避免大量客户端轮询Chubby服务端状态所带来的压力，Chubby提供了事件通知机制。Chubby的客户端可以向服务端注册事件通知，当触发这些事件的时候， 服务端就会向客户端发送对应的事件通知。在Chubby的事件通知机制中，消息通知都是通过异步的方式发送给客户端的，常见的Chubby事件如下。</p><h4 id="1-文件内容变更"><a href="#1-文件内容变更" class="headerlink" title=".1 文件内容变更"></a>.1 文件内容变更</h4><p>例如，BigTable集群使用Chubby锁来确定集群中的哪台BitTable机器是Master；获得锁的BitTable Master会将自身信息写入Chubby上对应的文件中。 BitTable集群中的其他客户端可以通过监视这个Chubby文件的变化来确定新的BitTable Master机器。</p><h4 id="2-节点删除"><a href="#2-节点删除" class="headerlink" title=".2 节点删除"></a>.2 节点删除</h4><p>当Chubby上指定节点被删除的时候，会产生“节点删除”事件，这通常在临时节点中比较常见，可以利用该特性来间接判断该临时节点对应的客户端会话是否有效。</p><h4 id="3-子节点新增、删除"><a href="#3-子节点新增、删除" class="headerlink" title=".3 子节点新增、删除"></a>.3 子节点新增、删除</h4><p>当Chubby上指定的节点的子节点新增或是删除时，会产生“子节点新增、删除”事件。（还有更新）</p><h4 id="4-Master服务器转移"><a href="#4-Master服务器转移" class="headerlink" title=".4 Master服务器转移"></a>.4 Master服务器转移</h4><p>当Chubby服务器发生Master转移时，会以事件的形式通知客户端。</p><h3 id="1-4-5-Chubby中的缓存"><a href="#1-4-5-Chubby中的缓存" class="headerlink" title="1.4.5 Chubby中的缓存"></a>1.4.5 Chubby中的缓存</h3><p>为了提高Chubby的性能，同时也是为了减少客户端和服务端之间频繁的读请求对服务端的压力，Chubby除了提供事件通知机制之外，还在客户端中实现了缓存， 会在客户端对文件内容和元数据信息进行缓存。使用缓存机制在提高系统整体性能的同时，也为系统带来了一定的复杂性，其中最主要的问题就是应该如何保证缓存的一致性。 在Chubby中，通过租期机制来保证缓存的一致性。</p><p>Chubby缓存的生命周期和Master租期机制紧密相关，Master会维护每个客户端的数据缓存情况，并通过向客户端发送过期信息的方式来保证客户端数据的一致性。 在这种机制下，Chubby就能够保证客户端要么能够从缓存中访问到一致的数据，要么访问出错，而一定不会访问到不一致的数据。具体的，每个客户端的缓存 都有一个租期，一旦该租期到期，客户端就需要向服务端续订租期以继续维持缓存的有效性。当文件数据或元数据被修改时，Chubby服务端首先会阻塞该修改操作， 然后由Master向所有可能缓存了该数据的客户端发送缓存过期信号，以使其缓存失效，等到Master在接收到所有相关客户端针对该过期信息的应答（应答包括两类， 一类是客户端明确要求更新缓存，另一类则是客户端允许缓存租期过期）后，再继续进行之前的修改操作。</p><p>通过上面这个缓存机制的介绍，相信读者都已经明白了，Chubby的缓存数据保证了强一致性。尽管要保证严格的数据一致性对于性能的开销和系统的吞吐影响很大， 但由于弱一致性模式在实际使用过程中极容易出现问题，因此Chubby在设计之初就决定了强一致性模型。</p><h3 id="1-4-6-会话和会话激活（KeepAlive）"><a href="#1-4-6-会话和会话激活（KeepAlive）" class="headerlink" title="1.4.6 会话和会话激活（KeepAlive）"></a>1.4.6 会话和会话激活（KeepAlive）</h3><p>Chubby客户端和服务端之间通过创建一个TCP连接来进行所有的网络通信操作，我们将这一连接称为会话（Session）。会话是有生命周期的，存在一个超时时间， 在超时时间内，Chubby客户端和服务端之间可以通过心跳检测来保持会话的活性，以使会话周期得到延续，我们将这个过程称为KeepAlive（会话激活）。如果 能够成功地通过KeepAlive过程将Chubby会话一直延续下去，那么客户端创建的句柄（引用）、锁和缓存数据等都依然有效。</p><h3 id="1-4-7-KeepAlive请求"><a href="#1-4-7-KeepAlive请求" class="headerlink" title="1.4.7 KeepAlive请求"></a>1.4.7 KeepAlive请求</h3><p>下面我们就重点来看看Chubby Master是如何处理客户端的KeepAlive请求的。Master在接收到客户端的KeepAlive请求时，首先会将该请求阻塞住，并等到 该客户端的当前会话租期即将过期时，才为其续租该客户端的会话租期，之后再向客户端响应这个KeepAlive请求，并同时将最新的会话租期超时时间反馈给客户端。 Master对于会话续租时间的设置，默认是12秒，但这不是一个固定的值，Chubby会根据实际的运行情况，自行调节该周期的长短。举个例子来说， 如果当前Master处于高负载运行状态的话，那么Master会适当地延长会话租期的长度，以减少客户端KeepAlive请求的发送频率。客户端在接收到来自Master的续租 响应后，会立即发起一个新的KeepAlive请求，再由Master进行阻塞。因此我们可以看出，在正常运行过程中，每一个Chubby客户端总是会有一个KeepAlive 请求阻塞在Master服务器上。</p><p>除了为客户端进行会话续租外，Master还将通过KeepAlive响应来传递Chubby事件通知和缓存过期通知给客户端。具体的，如果Master发现服务端已经触发了 针对该客户端的事件通知或缓存过期通知，那么会提前将KeepAlive响应反馈给客户端。</p><h3 id="1-4-8-会话超时"><a href="#1-4-8-会话超时" class="headerlink" title="1.4.8 会话超时"></a>1.4.8 会话超时</h3><p>谈到会话租期，Chubby的客户端也会维持一个和Master端近似相同的会话租期。为什么是近似相同呢？这是因为客户端必须考虑两方面的因素：一方面，KeepAlive 响应在网络传输过程中会花费一定的时间；另一方面，Master服务端和Chubby客户端存在时钟不一致性现象。因此在Chubby会话中，存在Master端会话租期和客户端本地 会话租期。</p><p>如果Chubby客户端在运行过程中，按照本地的会话租期超时时间，检测到期会话租期已经过期却尚未接收到Master的KeepAlive响应，那么这个时候，它将无法确定Master 服务端是否已经中止了当前会话，我们称这个时候客户端处于“危险状态”。此时，Chubby客户端会清空其本地缓存，并将其标记为不可用。同时，客户端还会等待一个被 称作“宽限期”的时间周期，这个宽限期默认是45秒。如果在宽限期到期前，客户端和服务端成功地进行了KeepAlive，那么客户端就会再次开启本地缓存，否则，客户端就会 认为当前会话已经过期了，从而中止本次会话。</p><p>我们再着重来看看上面提到的“危险状态”。当客户端进入上述提到的危险状态时，Chubby的客户端库会通过一个“jeopardy”事件来通知上层应用程序。如果 恢复正常，客户端同样会以一个“safe”事件来通知应用程序可以继续正常运行了。但如果客户端最终没能从危险状态中恢复过来，那么客户端会以一个“expired” 事件来通知应用程序当前Chubby会话已经超时。Chubby通过这些不同的事件类型通知，能够很好地辅助上层应用程序在不明确Chubby会话状态的情况下， 根据不同的事件类型来做出不同的处理：等待或重启。有了这样的机制保证之后，对于那些在短时间内Chubby服务不可用的场景下，客户端应用程序可以选择等待，而不是重启， 这对于那些重启整个应用程序需要花费较大代价的系统来说非常有帮助。</p><h3 id="1-4-9-Chubby-Master故障恢复"><a href="#1-4-9-Chubby-Master故障恢复" class="headerlink" title="1.4.9 Chubby Master故障恢复"></a>1.4.9 Chubby Master故障恢复</h3><p>Chubby的Master服务器上运行着会话租期计时器，用来管理所有会话的生命周期。如果在运行过程中Master出现了故障，那么该计时器会停止，直到新的Master选举 产生后，计时器才会继续计时，也就是说，从旧的Master崩溃到新的Master选举产生所花费的时间将不计入会话超时的计算中，这等价于延长了客户端的会话租期。 如果新的Master在短时间内就选举产生了，那么客户端就可以在本地会话租期过期前与其创建连接。而如果Master的选举花费了较长的时间，就会导致客户端只能情况本地的缓存， 并进入宽限期进行等待。从这里我们可以看出，由于宽限期的存在，使得会话能够很好地在服务端Master转换额过程中得到维持。整个Chubby Master故障恢复过程中 服务端和客户端的交互情况：</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-3-1-2.png" alt></p><p>展示了一个完整的Chubby服务端Master故障恢复过程中所触发的所有事件序列。在这整个故障恢复过程中，客户端必须使用宽限期来保证在Master转换过程完成之后， 其会话依然有效。</p><p>一开始在旧的Master服务器上维持了会话租期“lease M1”，在客户端上维持了对应的“lease C1”，同时客户端的KeepAlive请求1一直被Master阻塞着。在一段时间之后， Master向客户端反馈了KeepAlive响应2，同时开始了新的会话租期“lease M2”，而客户端在接收到该KeepAlive响应之后，立即发送了新的KeepAlive请求3，并 同时也开始了新的会话租期“lease C2”。至此，客户端和服务吨Master之间的所有交互都是正常的。但是随后，Master发生了故障，从而无法反馈客户端的KeepAlive 请求3。在这个过程中，客户端检测到会话租期“lease C2”已经过期，它会清空本地缓存，并进入宽限期。在这顿时间内，客户端无法确定Master上的会话周期 是否也已经过期，因此，它不会销毁它的本地会话，而是将所有应用程序对它的API调用都阻塞主，以避免在这个期间进行的API调用导致数据不一致现象。 同时，在客户端宽限期开始时，Chubby客户端会向上层应用程序发送一个“jeopardy”事件。一段时间后，CHubby服务端选举产生了新的Master，并为该客户端初始化 了新的会话租期“lease M3”。当客户端向新的Master发送KeepAlive请求4时，Master检测到该客户端的Master周期号已经过期，因此会在KeepAlive响应5 中拒绝这个客户端请求，并将最新的Master周期号发送给客户端。之后，客户端会携带上新的Master周期号，再次发送KeepAlive请求6给Master，最终，整个 客户端和服务端之间的会话就会再次恢复正常。</p><p>通过上面的详细介绍，不难看出，在Master转换的这段时间内，只要客户端的宽限期是够长的，那么客户端应用程序可以在没有任何察觉的情况下，实现Chubby的故障恢复， 但如果客户端的宽限期设置得比较短，那么Chubby客户端就会丢弃当前会话，并将这个异常情况通知给上层应用程序。</p><p>一旦客户端与新的Master建立上连接之后，客户端和Master之间会通过互相配合来实现对故障的平滑恢复。新的Master会设法将上一个Master服务器的内存状态构造出来。 具体的，由于本地数据库记录了每个客户端的会话信息，以及其持有的锁和临时文件等信息，因此Chubby会通过读取本地磁盘上的数据来恢复一部分状态。 总的来讲，一个新的Chubby Master服务器选举产之后，会进行如下几个主要处理。</p><h4 id="1-确定Master周期"><a href="#1-确定Master周期" class="headerlink" title=".1 确定Master周期"></a>.1 确定Master周期</h4><p>Master周期用来唯一标识一个Chubby集群的Master统治轮次，以便区分不同的Master。一旦新的Master周期确定下来之后，Master就会拒绝所有携带其他Master 周期编号的客户端请求，同时告知其最新的Master周期编号，例如上述提到的KeepAlive请求4。需要注意的一点是，只要发生Master重新选举，就一定会产生新的 Master周期，即使是在选举前后Master都是同一台机器的情况下也是如此。</p><h4 id="2-新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。"><a href="#2-新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。" class="headerlink" title=".2 新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。"></a>.2 新Master能够立即对客户端的Master寻址请求进行响应，但是不会立即开始处理客户端会话相关的请求操作。</h4><h4 id="3-Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。"><a href="#3-Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。" class="headerlink" title=".3 Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。"></a>.3 Master根据本地数据库中存储的会话和锁信息，来构建服务器的内存状态。</h4><h4 id="4-到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。"><a href="#4-到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。" class="headerlink" title=".4 到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。"></a>.4 到现在为止，Master已经能够处理客户端的KeepAlive请求了，但依然无法处理其他会话相关的操作。</h4><h4 id="5-Master会发送一个“Master故障切换”事件给每一个会话。"><a href="#5-Master会发送一个“Master故障切换”事件给每一个会话。" class="headerlink" title=".5 Master会发送一个“Master故障切换”事件给每一个会话。"></a>.5 Master会发送一个“Master故障切换”事件给每一个会话。</h4><p>客户端接收到这个事件后，会清空它的本地缓存，并警告上层应用程序可能已经丢失了别的事件，之后再向Master反馈应答。</p><h4 id="6-此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。"><a href="#6-此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。" class="headerlink" title=".6 此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。"></a>.6 此时，Master会一直等待客户端的应答，知道每一个会话都应答了这个切换事件。</h4><h4 id="7-在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。"><a href="#7-在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。" class="headerlink" title=".7 在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。"></a>.7 在Master接收到了所有客户端的应答之后，就能够开始处理所有的请求操作了。</h4><h4 id="8-如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。"><a href="#8-如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。" class="headerlink" title=".8 如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。"></a>.8 如果客户端使用了一个在故障切换之前创建的引用，Master会重新为其创建这个引用的内存对象，并执行调用。</h4><p>而如果该引用在之前的Master周期中已经被关闭了，那么它聚不能在这个Master周期内再次被重建了————这一机制就确保了即使由于网络原因使得Master接收到那些延迟或重发的网络数据包， 也不会错误地重建一个已经关闭的引用。</p><h2 id="1-5-Paxos协议实现"><a href="#1-5-Paxos协议实现" class="headerlink" title="1.5 Paxos协议实现"></a>1.5 Paxos协议实现</h2><p>Chubby服务端的基本架构大致分为三层：</p><p>最底层是容错日志系统（Fault-Tolerant Log），通过Paxos算法能够保证集群中所有机器上的日志完全一致，同时具有较好的容错性。<br>日志层之上是Key-value类型的容错数据库（Fault-Tolerant DB），其通过下层的日志来保证一致性和容错性。<br>存储层之上就是Chubby对外提供的分布式锁服务和小文件存储服务。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-3-1-3.png" alt></p><p>Paxos算法的作用就在于保证集群内各个副本节点的日志能够保持一致。Chubby事务日志中的每一个Value对应Paxos算法中的一个Instance，由于Chubby需要对外提供 不间断的服务，因此事务日志无限增长，于是在整个Chubby巡行过程中，会存在多个Paxos Instance。同时，Chubby会为每一个Paxos Instance都按序分配一个全局唯一 的Instance编号，并将其顺序写入到事务日志中去。<br>在多Paxos Instance的模式下，为了提升算法执行的性能，就必须选举出一个副本节点作为Paxos算法的主节点，以避免因为每一个Paxos Instance都提出提案而陷入多个Paxos Round 并存的情况。同时，Paxos会保证在Master重启或出现故障而进行切换的时候，允许出现短暂的多个Master共存却不影响副本之间的一致性。</p><p>在Paxos中，每一个Paxos Instance都需要进行一轮或多轮“Prepare-&gt;Promise-&gt;Propose-&gt;Accept”这样完整的二阶段请求过程来完成对一个提案值的选定， 而多个Instance之间是完全独立的，每个Instance可以自己决定每一个Round的序号，仅仅只需要保证在Instance内部不会出现序号重复即可。为了在保证正确性的前提下尽可能 地的提高算法运行性能，可以让多个Instance共用一套序号分配机制，并将“Prepare-&gt;Promise”合并为一个阶段，具体做法如下。</p><p>当某个副本节点通过选举成为Master后，就会使用新分配的编号N来广播一个Prepare消息，该Prepare消息会被所有未达成一致的Instance和目前还未开始的Instance共用。<br>当Acceptor接收到Prepare消息后，必须对多个Instance同时做出回应，这通常可以通过将反馈信息封装在一个数据包中来实现。假设最多允许K个Instance同时进行提案值的选定，那么：</p><p>当前至多存在K个未达成一致的Instance，将这些未决的Instance各自最后接收的提案值（若该提案尚未接收任何值。则使用null来代替）封装进一个数据包，并作为Promise消息返回。 同时，判断N是否大于当前Acceptor的highestPromisedNum值（当前已经接受的最大提案编号值），如果大于该值的话，那么就标记这些未决Instance和 所有未来的Instance的highestPromisedNum值为N————这样，这些未决Instance和所有未来Instance都不能再接受任何编号小于N的提案。</p><p>然后Master就可以对所有未决Instance和所有未来Instance分别执行“Propose-&gt;Accept”阶段的处理。值得注意的是，如果当前Master能够一直稳定运行的话， 那么在接下来的算法运行过程中，就不再需要进行“Prepare-&gt;Promise”的处理了。但是，一但Master发现Acceptor返回了一个Reject消息，说明集群中存在另一个Master， 并且试图使用更大的编号发送了Prepare消息。碰到这种情况，当前Master就需要重新分配新的提案编号，并再次进行“Prepare-&gt;Promise”阶段的逻辑处理。</p><p>利用上述改进的Paxos算法，在Master稳定运行的情况下，只需要使用同一个编号来依次执行每一个Instance的“Promise-&gt;Accept”阶段逻辑处理。在每个Instance 的运行过程中，一旦接收到多数派的Accept反馈后，就可以将对应的提案值写入本地事务日志并广播COMMIT消息给集群中的其他副本节点，其他副本节点在接收到这个COMMIT消息之后也会 将提案值写入到事务日志中。如果某个副本节点因为宕机或者网络原因没有接收到COMMIT消息，可以主动向集群中的其他副本节点进行查询。因此，我们可以看到，在Chubby的Paxos 算法的实现中，只要维持集群中存在多数派的机器能够正常运行，即使其他机器在任意时刻发生宕机，也能保证已经提交的提案的安全性。</p><p>至此，我们已经实现了一套满足一致性的日志副本，在此基础上就可以在上层实现一个一致的状态机副本，即容错数据库层。初期，使用Berkeley DB作为容错数据库， 这个数据库底层实现了B树数据结构，即存储大量数据的HashMap，将每一个数据节点的节点路径名作为键，同时按照节点路径名进行排序，这就能够使得兄弟节点在排序顺序中相邻， 方便对数据节点的检索。</p><p>后来，Chubby自己实现了一套更为简单的、基于日志预写和数据快照技术的底层数据复制组件。</p><p>数据快照和事务日志回放机制：集群中的某台机器在宕机重启以后，为了恢复状态机的状态，最简单的方法就是将已经记录的所有事务日志重新执行一遍。但这 会有一个明显的问题，就是如果机器上的事务日志已经积累了很多，那么恢复的时间就会非常长，因此需要定期对状态机数据做一个数据快照并将其存入磁盘， 然后就可以将数据快照点之前的事务日志清除。</p><p>通常副本节点在进行宕机后的恢复过程中，会出现磁盘未损坏和损坏两种情况。前者最为常见，一般通过磁盘上保存的数据库快照和事务日志就可以恢复到之前某个时间点的状态， 之后再向集群中其他正常运行的副本节点索取宕机后缺失的部分数据变更记录，这样即可实现宕机后的数据恢复。另外一种则是磁盘损坏，无法直接从本地数据恢复的情况， 需要从其它副本节点索取全部的状态数据。</p><p>副本节点在完成宕机重启之后，为了安全起见，不会立即参与Paxos Instance流程，而是需要等待检测到K个Paxos Instance流程陈宫完成之后才能开始参与————这样就能够保证 新分配的提案编号不会和自己以前发过的重复。</p><p>最后，为了提高整个集群的性能，还有一个改进之处在于：得益于Paxos算法的容错机制，只要任意时刻保证多数派的机器能够正常运行，那么在宕机瞬间未能真正写入到 磁盘上（只有当真正调用操作系统Flush接口后，数据才能被真正写入物理磁盘中）的那一小部分事务日志也可以通过从其它正常运行的副本上复制来进行获取，因此 不需要实时地进行事务日志的Flush操作，这可以极大地提高事务写入的效率。</p><h2 id="1-6-Hypertable"><a href="#1-6-Hypertable" class="headerlink" title="1.6 Hypertable"></a>1.6 Hypertable</h2><h3 id="1-6-1-概述"><a href="#1-6-1-概述" class="headerlink" title="1.6.1 概述"></a>1.6.1 概述</h3><p>使用C++开发的开源、高性能、可伸缩的数据库。只支持增删改查，不支持事务。</p><p>支持对大量并发请求的处理。<br>支持对海量数据的管理。<br>扩展性良好，在保证可用性的前提下，能够通过随意添加集群中的机器来实现水平扩容。<br>可用性极高，具有非常好的容错性，任何节点的失效，既不会造成系统瘫痪也不会影响数据的完整性。</p><h3 id="1-6-2-算法实现"><a href="#1-6-2-算法实现" class="headerlink" title="1.6.2 算法实现"></a>1.6.2 算法实现</h3><p>选举Master是根据所有服务器上事务日志的更新时间来确定哪个服务器的数据最新，那么被选举的可能性就越大。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>列举了使用Paxos算法的工业实践应用，更好的理解Paxos算法。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 从Paxos到Zookeeper分布式一致性原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、一致性协议</title>
      <link href="/2017/08/18/paxos2zookeeper/3.html/"/>
      <url>/2017/08/18/paxos2zookeeper/3.html/</url>
      
        <content type="html"><![CDATA[<p>前章提要：<br>上章我们讲到分布式往往会在系统可用性和数据一致性之间反复权衡，于是就产生了一系列的一致性协议（为什么没有可用性协议？博主认为，数据才是王道）。</p><h1 id="1-2PC和3PC"><a href="#1-2PC和3PC" class="headerlink" title="1. 2PC和3PC"></a>1. 2PC和3PC</h1><p>在分布式系统总，每一个机器节点虽然都能够明确地知道自己在进行事务操作过程中的结果是成功或失败，但却无法直接获取到其他分布式节点的操作结果。 因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性（某个节点为单位），就需要引入一个称为“协调者（Coordinator）” 的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为“参与者（Participant）”。</p><p>Coordinator负责调度Participant的行为，并最终决定这些Participant是否要把事务真正的提交。基于这个思想，衍生除了二阶段提交和三阶段提交两种协议， 在本节中，我们将重点对这两种分布式事务中涉及的一致性协议进行讲解。</p><h2 id="1-1-2PC"><a href="#1-1-2PC" class="headerlink" title="1.1 2PC"></a>1.1 2PC</h2><p>2PC是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能保持 原子性和一致性而设计的算法。</p><h3 id="1-1-1-阶段一：提交事务请求"><a href="#1-1-1-阶段一：提交事务请求" class="headerlink" title="1.1.1 阶段一：提交事务请求"></a>1.1.1 阶段一：提交事务请求</h3><p>事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交曹组，并开始等待各参与者的响应。<br>执行事务：各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。<br>各参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，那么反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务， 那么就反馈给协调者No响应，表示事务不可以执行。<br>由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投票表态过程，因此二阶段提交协议的阶段一页被称为“投票阶段”，即各参与者投票 表明是否要继续执行接下去的事务提交操作。</p><h3 id="1-1-2-阶段二：执行事务提交"><a href="#1-1-2-阶段二：执行事务提交" class="headerlink" title="1.1.2 阶段二：执行事务提交"></a>1.1.2 阶段二：执行事务提交</h3><p>正常情况，包含以下两种可能：</p><h4 id="1-可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。"><a href="#1-可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。" class="headerlink" title=".1 可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。"></a>.1 可能一：执行事务提交：假如协调者从所有的参与者的反馈都是Yes响应，那么就会执行事务提交。</h4><h5 id="1-1-发送提交请求：协调者向所有参与者发出Commit请求。"><a href="#1-1-发送提交请求：协调者向所有参与者发出Commit请求。" class="headerlink" title=".1.1 发送提交请求：协调者向所有参与者发出Commit请求。"></a>.1.1 发送提交请求：协调者向所有参与者发出Commit请求。</h5><h5 id="1-2-事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。"><a href="#1-2-事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。" class="headerlink" title=".1.2 事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。"></a>.1.2 事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。</h5><h5 id="1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。"><a href="#1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。" class="headerlink" title=".1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。"></a>.1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。</h5><h5 id="1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。"><a href="#1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。" class="headerlink" title=".1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。"></a>.1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。</h5><h4 id="2-可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"><a href="#2-可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。" class="headerlink" title=".2 可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"></a>.2 可能二：执行事务中断：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</h4><h5 id="2-1-发送回滚请求：协调者向所有参与者节点发出Rollback请求。"><a href="#2-1-发送回滚请求：协调者向所有参与者节点发出Rollback请求。" class="headerlink" title=".2.1 发送回滚请求：协调者向所有参与者节点发出Rollback请求。"></a>.2.1 发送回滚请求：协调者向所有参与者节点发出Rollback请求。</h5><h5 id="2-2-事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"><a href="#2-2-事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。" class="headerlink" title=".2.2 事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"></a>.2.2 事务回滚：参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</h5><h5 id="2-3-反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。"><a href="#2-3-反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。" class="headerlink" title=".2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。"></a>.2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。</h5><h5 id="2-4-中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。"><a href="#2-4-中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。" class="headerlink" title=".2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。"></a>.2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断。</h5><p>以上就是二阶段提交过程中，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交将一个事务的处理分成了投票和执行两个阶段，其核心是对每个事务 都采用了先尝试后提交的处理方式，因此也可以将二阶段提交看作一个强一致性的算法。</p><h3 id="1-1-3-优缺点"><a href="#1-1-3-优缺点" class="headerlink" title="1.1.3 优缺点"></a>1.1.3 优缺点</h3><p>原理简单，实现方便；但是同步阻塞、单点问题、数据不一致、太过保守。</p><h4 id="1-同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，"><a href="#1-同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，" class="headerlink" title=".1 同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，"></a>.1 同步阻塞：在事务的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在登台其他参与者响应的过程中，</h4><p>将无法进行其他任何操作。</p><h4 id="2-单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，"><a href="#2-单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，" class="headerlink" title=".2 单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，"></a>.2 单点问题：一旦协调者出现问题，整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，</h4><p>那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。</p><h4 id="3-数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，"><a href="#3-数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，" class="headerlink" title=".3 数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，"></a>.3 数据不一致：当协调者向所有参与者发送Commit请求之后，发生了协调者在尚未发送完Commit请求之前自身发生了崩溃，</h4><p>导致最终只有部分参与者收到了Commit请求。于是，其他没有收到Commit请求的参与者没有进行事务提交，而收到Commit请求的参与者会进行事务提交，最终数据不一致。</p><h4 id="4-太过保守：任何一个节点的失败都会导致整个事务的失败。"><a href="#4-太过保守：任何一个节点的失败都会导致整个事务的失败。" class="headerlink" title=".4 太过保守：任何一个节点的失败都会导致整个事务的失败。"></a>.4 太过保守：任何一个节点的失败都会导致整个事务的失败。</h4><h2 id="1-2-3PC"><a href="#1-2-3PC" class="headerlink" title="1.2 3PC"></a>1.2 3PC</h2><p>研究者在二阶段提交协议的基础上进行了改进，提出了三阶段提交协议。<br>3PC是Three-Phase Commit的缩写，将二阶段提交协议的“提交事务请求”过程分为两个，形成了CanCommit、PreCommit和DoCommit。</p><h3 id="1-2-1-阶段一：CanCommit"><a href="#1-2-1-阶段一：CanCommit" class="headerlink" title="1.2.1 阶段一：CanCommit"></a>1.2.1 阶段一：CanCommit</h3><h4 id="1-事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。"><a href="#1-事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。" class="headerlink" title=".1 事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。"></a>.1 事务询问：协调者向所有的参与者发送一个包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</h4><h4 id="2-各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。"><a href="#2-各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。" class="headerlink" title=".2 各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。"></a>.2 各参与者向协调者反馈响应：如果自身可以顺序执行事务，反馈Yes响应，并进入预备状态，否则反馈No响应。</h4><h3 id="1-2-2-阶段二：PreCommit"><a href="#1-2-2-阶段二：PreCommit" class="headerlink" title="1.2.2 阶段二：PreCommit"></a>1.2.2 阶段二：PreCommit</h3><h4 id="1-执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。"><a href="#1-执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。" class="headerlink" title=".1 执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。"></a>.1 执行事务预提交：假如协调者从所有参与者获得的反馈都是Yes响应。</h4><h5 id="1-1-发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。"><a href="#1-1-发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。" class="headerlink" title=".1.1 发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。"></a>.1.1 发送预提交请求：协调者向所有参与者节点发出PreCommit的请求，并进入Prepared阶段。</h5><h5 id="1-2-事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。"><a href="#1-2-事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。" class="headerlink" title=".1.2 事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。"></a>.1.2 事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</h5><h5 id="1-3-各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。"><a href="#1-3-各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。" class="headerlink" title=".1.3 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。"></a>.1.3 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。</h5><h4 id="2-中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"><a href="#2-中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。" class="headerlink" title=".2 中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。"></a>.2 中断事务：假如任何一个参与者向协调者反馈了No响应，或等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</h4><h5 id="2-1-发送中断请求：协调者向所有参与者节点发出abort请求。"><a href="#2-1-发送中断请求：协调者向所有参与者节点发出abort请求。" class="headerlink" title=".2.1 发送中断请求：协调者向所有参与者节点发出abort请求。"></a>.2.1 发送中断请求：协调者向所有参与者节点发出abort请求。</h5><h5 id="2-2-中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。"><a href="#2-2-中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。" class="headerlink" title=".2.2 中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。"></a>.2.2 中断事务：无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务。</h5><h3 id="1-2-3-阶段三：DoCommit"><a href="#1-2-3-阶段三：DoCommit" class="headerlink" title="1.2.3 阶段三：DoCommit"></a>1.2.3 阶段三：DoCommit</h3><h4 id="1-可能一：执行提交"><a href="#1-可能一：执行提交" class="headerlink" title=".1 可能一：执行提交"></a>.1 可能一：执行提交</h4><h5 id="1-1-发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。"><a href="#1-1-发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。" class="headerlink" title=".1.1 发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。"></a>.1.1 发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送DoCommit请求。</h5><h5 id="1-2-事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。"><a href="#1-2-事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。" class="headerlink" title=".1.2 事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。"></a>.1.2 事务提交：参与者接收到DoCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</h5><h5 id="1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。-1"><a href="#1-3-反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。-1" class="headerlink" title=".1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。"></a>.1.3 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息。</h5><h5 id="1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。-1"><a href="#1-4-完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。-1" class="headerlink" title=".1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。"></a>.1.4 完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务。</h5><h4 id="2-可能二：中断事务"><a href="#2-可能二：中断事务" class="headerlink" title=".2 可能二：中断事务"></a>.2 可能二：中断事务</h4><h5 id="2-1-发送中断请求：协调者向所有参与者节点发送abort请求。"><a href="#2-1-发送中断请求：协调者向所有参与者节点发送abort请求。" class="headerlink" title=".2.1 发送中断请求：协调者向所有参与者节点发送abort请求。"></a>.2.1 发送中断请求：协调者向所有参与者节点发送abort请求。</h5><h5 id="2-2-事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"><a href="#2-2-事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。" class="headerlink" title=".2.2 事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。"></a>.2.2 事务回滚：参与者接收到abort请求后，利用Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</h5><p>#####.2.3 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。</p><p>#####.2.4 中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务。</p><p>需要注意的是，一旦进入阶段三，可能会存在以下两种故障：</p><p>协调者出现问题。<br>协调者和参与者之间的网络出现故障。 无论出现哪种情况，参与者都会在等待超时之后，继续进行事务提交。即，默认为允许提交。</p><h3 id="1-2-3-优缺点"><a href="#1-2-3-优缺点" class="headerlink" title="1.2.3 优缺点"></a>1.2.3 优缺点</h3><p>降低参与者的阻塞范围，出现单点故障后继续达成一致；但是在参与者接收到PreCommit消息后，如果协调者所在的节点和参与者无法正常通信， 该参与者仍然会进行事务的提交，这必然出现数据不一致性。</p><h1 id="2-Paxos算法"><a href="#2-Paxos算法" class="headerlink" title="2. Paxos算法"></a>2. Paxos算法</h1><p>我们将重点讲解另一种非常重要的分布式一致性协议：Paxos。Paxos算法是一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式 一致性问题最有效的算法之一。</p><p>我们现在已经知道，在常见的分布式系统中，总会发生诸如机器宕机或网络异常等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中， 快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常都不会破坏整个系统的一致性。</p><h2 id="2-1-追本溯源"><a href="#2-1-追本溯源" class="headerlink" title="2.1 追本溯源"></a>2.1 追本溯源</h2><p>1982年，Lamport与另两人提出了一种计算容错理论。在理论描述过程中，为了将要所描述的问题形象的表达出来，Lamport设想出了下面这样一个场景：</p><p>拜占庭帝国有许多支军队，不同军队的将军之间必须制定一个统一的行动计划，从而做出进攻或者撤退的决定，同时，各个将军在地理上都是被 分割开来的，只能依靠军队的通讯员来进行通讯。然而，在所有的通讯员中可能会存在叛徒，这些叛徒可以任意篡改消息，从而达到欺骗将军的目的。</p><p>这就是著名的“拜占庭将军问题”。从理论上来说，在分布式计算领域，试图在异步系统和不可靠的通道上来达到一致性状态是不可能的，因此在堆一致性的研究 过程中，都往往假设信道是可靠地。而事实上，大多数系统都是部署在同一个局域网中的，因此消息被篡改的情况非常罕见，另一方面，由于硬件和网络原因而 造成的消息不完整问题，只需一套简单的校验算法即可避免——因此，在实际工程实践中，可以假设不存在拜占庭问题，也即假设所有消息都是完整的，没有被 篡改的。那么，在这种情况下需要什么样的算法来保证一致性呢？</p><p>Lamport在1990年提出了一个理论上的一致性解决方案，同时给出了严格的数学证明。鉴于之前采用故事类比的方式成功的阐述了“拜占庭将军问题”，因此这次Lamport 同样用新娘库地设想除了一个场景来描述这种一致性算法需要解决的问题，及其具体的解决过程：</p><p>在古希腊有一个叫Paxos的小岛，岛上采用议会的形式来通过法令，议会中的议员通过信使进行消息的传递。值得注意的是，议员和信使都是兼职的， 他们随时有可能会离开议会厅，并且信使可能会重复的传递消息，也可能一去不复返。因此，议会协议要保证在这种情况下法令仍然能够正确的产生， 并且不会出现冲突。</p><p>这就是兼职议会，而Paxos算法名称的由来也是取自提到的Paxos小岛。</p><h2 id="2-2-Paxos算法详解"><a href="#2-2-Paxos算法详解" class="headerlink" title="2.2 Paxos算法详解"></a>2.2 Paxos算法详解</h2><p>Paxos作为一种提高分布式系统容错性的一致性算法，一直以来总是被很多人抱怨其算法理论太难理解。</p><h3 id="2-2-1-问题描述："><a href="#2-2-1-问题描述：" class="headerlink" title="2.2.1 问题描述："></a>2.2.1 问题描述：</h3><p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：</p><p>在这些被提出的提案中，只有一个会被选中。<br>如果没有提案被提出，那么就不会有被选定的提案。<br>当一个提案被选定后，进程应该可以获取被选定的提案信息。</p><p>对于一致性来说，安全性需求如下：</p><p>只有被提出的提案才能被选定。<br>只能由一个值被选定。<br>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个。</p><p>在对Paxos算法的讲解过程中，我们不去精确地定义其活性需求，从整体上来说，Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后， 进程最终也能获取到被选定的提案。</p><p>在该一致性算法中，有三种参与角色，我们用Proposer、Acceptor、Learner来表示，在具体的实现中，一个进程可能充当不止一种角色，在这里我们并 不关心进程如何映射到各种角色。假设不同参与者之间可以通过收发消息来进行通信，那么：</p><p>每个参与者以任意的速度执行，可能会因为出错而停止，也可能会重启。同时，即使一个提案被选定后，所有的参与者也都有可能失败或重启，因此除非 哪些失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。<br>消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏。</p><h3 id="2-2-2-提案的选定"><a href="#2-2-2-提案的选定" class="headerlink" title="2.2.2 提案的选定"></a>2.2.2 提案的选定</h3><p>要选定一个唯一提案的最简单方式莫过于只允许一个Accpetor存在，这样的话，Proposer只能发送提案给该Accpetor，Acceptor会选择它接收到的第一个 提案作为被选定的提案。这种解决方式尽管实现起来非常简单，但是却很难让人满意，因为一旦这个Accpetor出现问题，那么整个系统就无法工作了。<br>因此，应该寻找一种更好的解决方式，例如可以使用多个Acceptor来避免Accpetor的单点问题。现在我们就来看看，在存在多个Acceptor的情况下，如何 进行提案的选取：Proposer向一个Acceptor集合发送提案，同样，集合中的每个Acceptor都可能会批准该提案，当有足够多的Acceptor批准这个提案的时候， 我们就可以认为该提案被选定了。那么，什么是足够多呢？我们假定足够多的Acceptor是整个Acceptor集合的一个子集，并且让这个集合大得可以包含Acceptor 集合中的大多数成员，因为任意炼哥包含大多数Acceptor的子集至少有一个公共成员。另外我们再规定，每一个Acceptor最多只能批准一个提案，那么就能 保证只有一个提案被选定了。</p><h3 id="2-2-3-推导过程"><a href="#2-2-3-推导过程" class="headerlink" title="2.2.3 推导过程"></a>2.2.3 推导过程</h3><p>在没有失败和消息丢失的情况下，如果我们希望即使在只有一个提案被提出的情况下，仍然可以选出一个提案，这就暗示了如下的需求。</p><p>P1：一个Acceptor必须批准它收到的第一个提案。</p><p>上面这个需求就引出了另外一个问题：如果有多个提案被不同的Proposer同时提出，这可能会导致虽然每个Acceptor都批准了它收到的第一个提案，但是没有一个 提案是由多数人批准的。可能会现以下两种情况</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-1.png" alt><br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-2.png" alt></p><p>Acceptor接收的提案数量相同，此时无法选定最终的提案了。<br>因此，在P1的基础上，需要再加上一个提案被选定需要由半数以上的Acceptor批准的需求暗示着一个Acceptor必须能够批准不止一个提案。在这里，我们使用一个全局的编号 （这种全局唯一编号的生成并不是Paxos算法需要关注的地方，就算法本身而言，其假设当前已经具备这样的外部组件能够生成一个全局唯一的编号）来标识每一个 被Acceptor批准的提案，当一个具有某Value值的提案被半数以上的Acceptor批准后，我们就认为该Value被选定了，此时我们也认为该提案被选定了。需要注意的是， 此处讲到的提案和Value不是同一个概念了，提案变成了由编号和Value组成的组合体，因此我们以“[编号，Value]”来表示一个提案。（编号多少的提案被选中了，其中value是多少） 根据上面讲到的内容，我们虽然允许多个提案被选定，但同时必须保证所有被选定的提案都具有相同的Value值——这是一个关于提案Value的约定，结合提案 的编号，该约定可以定义如下：</p><p>P2：如果编号为M0、Value值为V0的提案（即[M0、V0]）被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须也是V0。</p><p>因为提案的编号是全序的，条件P2就保证了只有一个Value值被选定这一关键安全性属性。同时，一个提案要被选定，其首先必须至少一个Acceptor批准，因此 我们可以通过满足如下条件来满足P2。</p><p>P2a：如果编号为M0、Value值为V0的提案（即[M0、V0]）被选定了，那么所有比编号M0更高的，且被Acceptor批准的提案，其Value值必须也是V0。</p><p>至此，我们仍然需要P1来保证提案会被选定，但是因为通信是异步的，一个提案可能在某个Acceptor还未收到任何提案时就被选定了。</p><p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/paxos2zookeeper/Paxos2zookeeper-2-2-3.png" alt></p><p>如上图，在Acceptor1没有接收到任何提案的情况下，其他4个Acceptor已经批准了来自Proposer2的提案[M0,V1]，而此时，Proposer1产生了一个具有其他Value值的、 编号更高的提案[M1,V2]，并发送给了Acceptor1。根据P1，就需要Acceptor1批准该提案，但是这与P2a矛盾，因此如果要同时满足P1和P2a，需要对P2a进行如下强化：</p><p>P2b：如果一个提案[M0,V0]被选定后，那么之后任何Proposer产生的编号的提案，其Value值都为V0。</p><p>因为一个提案必须在被Proposer提出后才能被Acceptor批准，因此P2b包含了P2a，进而包含了P2。于是，接下去的重点就是论证P2b成立即可：</p><p>假设某个提案[M0,V0]已经被选定了，证明任何编号Mn &gt; M0的提案，其Value值都是V0。</p><h3 id="2-2-4-数学归纳法证明"><a href="#2-2-4-数学归纳法证明" class="headerlink" title="2.2.4 数学归纳法证明"></a>2.2.4 数学归纳法证明</h3><p>略过。</p><h3 id="2-2-5-Proposer生成提案"><a href="#2-2-5-Proposer生成提案" class="headerlink" title="2.2.5 Proposer生成提案"></a>2.2.5 Proposer生成提案</h3><p>对于一个Proposer来说，获取哪些已经被通过的提案远比预测未来可能会被通过的提案来得简单。因此，Proposer在产生一个编号为Mn的提案时， 必须要知道当前某一个将要或已经被半数以上Acceptor批准的、编号小于Mn但为最大编号的提案。并且，Proposer会要求所有的Acceptor都不要 再批准任何编号小于Mn的提案——这就引出了如下的提案生成算法。</p><p>.1 Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应。<br>向Proposer承诺，保证不再批准任何编号小于Mn的提案。<br>如果Acceptor已经批准过任何提案，那么其就向Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值。<br>我们将该请求称为编号为Mn的提案的Prepare请求。</p><p>.2 如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值的Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。<br>当然还存在另一种情况，就是半数以上的Acceptor都没有批准过任何提案，即响应不包含任何的提案，那么此时Vn值就可以 由Proposer任意选择。</p><p>在确定提案之后，Proposer就会将该提案再次发送给某个Acceptor集合，并期望获得它们的批准，我们称此请求为Accept请求。需要注意的一点是， 此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合——这点相信读者也能够明白，任意两个半数以上的Acceptor集合，必定 包含至少一个公共Acceptor。</p><h3 id="2-2-6-Acceptor批准提案"><a href="#2-2-6-Acceptor批准提案" class="headerlink" title="2.2.6 Acceptor批准提案"></a>2.2.6 Acceptor批准提案</h3><p>在上文中，我们已经讲解了Paxos算法中Proposer的处理逻辑，下面我们来看看Acceptor是如何批准提案的。</p><p>根据上面的内容，一个Acceptor可能会收到来自Proposer的两种请求，分别是Prepare请求和Accept请求，对这两类请求做出相应的条件分别如下。</p><p>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求。<br>Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求。因此，对Acceptor逻辑处理的约束条件，大体可以定义如下。<br>P1a：一个Acceptor只要尚未响应过任何编号大于Mn的prepare请求，那么它就可以接受这个编号为Mn的提案。</p><p>从上面这个约束条件中，我们可以看出，P1a包含了P1。同时，值得一提的是，Paxos算法允许Acceptor忽略任何请求而不用担心破坏其算法的安全性。</p><h3 id="2-2-7-算法优化"><a href="#2-2-7-算法优化" class="headerlink" title="2.2.7 算法优化"></a>2.2.7 算法优化</h3><p>在上面的内容中，我们分别从Proposer和Acceptor对提案的生成和批准两方面来讲解了Paxos算法在提案选定过程中的算法细节，同时也在提案的编号全局唯一 的前提下，获得了一个满足安全性需求的提案选定算法，接下来我们再对这个初步算法做一个小优化。尽可能地忽略Prepare请求：</p><p>假设一个Acceptor收到了一个编号为Mn的prepare请求，但此时该Acceptor已经对编号大于Mn的prepare请求做出了响应，因此它肯定不会再批准 任何新的编号为Mn的提案，那么狠显然，Acceptor就没有必要对这个Prepare请求做出响应，于是Acceptor可以炫册忽略这样的Prepare请求。同时 Acceptor也可以忽略掉那些它已经批准过的提案的Prepare请求。</p><p>通过这个优化，每个Acceptor只需要记住它已经批准的提案的最大编号以及它已经做出Prepare请求响应的提案的最大编号，以便在出现故障或节点重启的情况下， 也能保证P2c的不变性。而对于Proposer来说，只要它可以保证不会产生具有相同编号的提案，那么就可以丢弃任意的提案以及它所有的运行时状态信息。</p><h3 id="2-2-8-算法陈述"><a href="#2-2-8-算法陈述" class="headerlink" title="2.2.8 算法陈述"></a>2.2.8 算法陈述</h3><h4 id="1-阶段一："><a href="#1-阶段一：" class="headerlink" title=".1 阶段一："></a>.1 阶段一：</h4><p>Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。<br>如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案 作为响应反馈给Proposer，同时Acceptor会承诺不会再批准任何编号小于Mn的提案。<br>举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为1、2、…、5和7，那么该Acceptor在接收到一个编号为8的 Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。</p><h4 id="2-阶段二："><a href="#2-阶段二：" class="headerlink" title=".2 阶段二："></a>.2 阶段二：</h4><p>如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn，Vn]提案的Accept请求给Acceptor。 注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。<br>如果Acceptor收到这个针对[Mn，Vn]提案的Accep请求，只要改Acceptor尚未对编号大于Mn的Prepare请求做出响应，它就可以通过这个提案。<br>当然，在实际运行过程中，每一个Proposer都有可能会产生多个提案，但只要每个Proposer都遵循如上所述的算法运行，就一定能够保证算法执行的正确性。 值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证 其在提案选定上的正确性，事实上，如果某个Proposer已经在试图 生成编号更大的提案，那么丢弃一些旧的提案未尝不是一个好的选择。 因此，如果一个Acceptor因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer， 以便该Proposer也能够将该提案进行丢弃——这和上面“算法优化”部分中提到的提案丢弃是一致的。</p><h3 id="2-2-9-提案的获取"><a href="#2-2-9-提案的获取" class="headerlink" title="2.2.9 提案的获取"></a>2.2.9 提案的获取</h3><p>在上文中，我们已经介绍了如何来选定一个提案，下面我们再来看看如何让Learner获取提案，大体可以有以下几种方案。</p><h4 id="1-方案一："><a href="#1-方案一：" class="headerlink" title=".1 方案一："></a>.1 方案一：</h4><p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该 提案发送给所有的Learner。<br>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐个进行一次通信，通信的次数至少为二者个数的乘积。</p><h4 id="2-方案二："><a href="#2-方案二：" class="headerlink" title=".2 方案二："></a>.2 方案二：</h4><p>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（下文中我们将这样的Learner称为“主Learner”）， 在不考虑拜占庭奖金问题的前提下，我们假定Learner之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主learner被通知一个提案 已经被选定时，它会负责通知其它的Learner。</p><p>在这种方案中，Acceptor首先会将得到批准的提案发送给主Learner，再由其同步给其他Learner，因此较方案一而言，方案二虽然需要多一个步骤才能将 提案通知到所有的Learner，但其通信次数却大大减少了，通常只是Acceptor和Learner的个数总和。但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障。</p><h4 id="3-方案三："><a href="#3-方案三：" class="headerlink" title=".3 方案三："></a>.3 方案三：</h4><p>在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故障。因此，对方案二进行改进，可以将主Learner的范围扩大， 即Acceptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。 这个Learner集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。</p><h3 id="2-2-10-通过选取主Proposer保证算法的活性"><a href="#2-2-10-通过选取主Proposer保证算法的活性" class="headerlink" title="2.2.10 通过选取主Proposer保证算法的活性"></a>2.2.10 通过选取主Proposer保证算法的活性</h3><p>根据前面的内容坚决，我们已经基本了解Paxos算法的核心逻辑，下面我们再来看看Paxos算法在实际运作过程中的一些细节。假设存在这样一种极端情况， 有两个Proposer依次提出了一系列编号递增的议案，但是最终都无法被选定，具体流程如下：</p><p>Proposer P1提出了一个编号为M1的提案，并完成了上述阶段一的流程。但与此同时，另外一个Propoesr P2提出了一个编号为M2的提案，同样也完成了 阶段一的流程，于是Acceptor已经承诺不再批准编号小于M2的提案了。因此，当P1进入阶段二的时候，其发出的Accept请求将被Acceptor忽略， 于是P1再次进入阶段一并提出了一个编号为M3的提案，而这又导致P2在第二阶段的Accept请求被忽略，以此类推，提案的选定过程将陷入死循环。</p><p>为了保证Paxos算法流程的可持续性，以避免陷入上述提到的“死循环”，就必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来， 只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。当然，如果Proposer发现当前 算法流程中已经有一个编号更大的提案被提出或正在接受批准，那么它会丢弃当前这个编号较小的提案，并最终能够选出一个编号足够大的提案。因此， 如果系统中有足够多的组件（包括Propsoer、Acceptor和其他网络通信组件）能够正常工作，那么通过选择一个主Proposer，整套Paxos算法流程就能够保持活性。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>2PC和3PC：  </p><ol><li>牧师分别问新郎和新娘：你是否愿意……不管生老病死……（投票阶段）。</li><li>当新郎和新娘都回答愿意后（锁定一生的资源，只要有一个没有反应，这场结婚就失败）。（投票阶段）</li><li>牧师就会说：我宣布你们……（执行阶段）。</li></ol><p>存在的问题：  </p><ol><li>阻塞问题：如果新郎回答原意，新娘没反应，则整个结婚就阻塞。（投票阶段之后增加眼神交流阶段（3PC的额外阶段），之后才真正承诺一生一世不分离即锁定资源）。</li><li>单点问题：如果牧师没反应，整个结婚就失败。（3PC的超时机制，给牧师5秒反应时间）</li></ol><p>主要从协议设计和原理实现角度详细讲解了二阶段提交协议、三阶段提交协议和Paxos这三种典型的一致性算法。其中二阶段提交协议解决了分布式事务的原子性问题， 保证了分布式事务的多个参与者要么都执行成功，要么都执行失败。但是，在二阶段解决部分分布式事务问题的同时，依然存在一些难以解决的诸如同步阻塞、 无限期等待问题。三阶段提交协议则是在二阶段提交协议的基础上，添加了PreCommit过程，从而避免了二阶段提交协议中的无限期等待问题。而Paxos算法支持 分布式节点角色之间的轮换，这极大地避免了分布式单点的出现，因此Paxos算法既解决了无限期等待问题，是目前来说最优秀的分布式一致性协议之一。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 从Paxos到Zookeeper分布式一致性原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、分布式架构</title>
      <link href="/2017/08/17/paxos2zookeeper/1.html/"/>
      <url>/2017/08/17/paxos2zookeeper/1.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-从集中式到分布式"><a href="#1-从集中式到分布式" class="headerlink" title="1. 从集中式到分布式"></a>1. 从集中式到分布式</h1><h2 id="1-1-集中式的特点"><a href="#1-1-集中式的特点" class="headerlink" title="1.1 集中式的特点"></a>1.1 集中式的特点</h2><p>所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点，并且整个系统的所有业务单元都部署在这个中心节点上， 系统的所有功能均由其集中处理。也就是说，在集中式系统中，每个终端或客户端机器仅仅负责数据的录入和输出，而数据的存储与控制处理完全 交由主机来完成。</p><p>最大的特点就是部署结构简单。由于集中式系统往往基于底层性能卓越的大型主机，因此无须考虑如何对服务进行多个节点的部署，也就不用考虑多个 节点之间的分布式协作问题。</p><h2 id="1-2-分布式的特点"><a href="#1-2-分布式的特点" class="headerlink" title="1.2 分布式的特点"></a>1.2 分布式的特点</h2><p>分布式系统是一个硬件或者软件组成分布在不同的网络计算上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p><p>一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，都会有如下几个特征：</p><p>分布性：分布式系统中的多台计算机在空间上随意分布。<br>对等性：分布式系统中的计算机没有主/从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。 副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务， 我们往往会对数据和服务进行副本处理。不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取到该数据，另一类副本是 服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。<br>并发性：同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式 系统架构与设计中最大的挑战之一。<br>缺乏全局时钟：一个典型的分布式系统是由一系列在空间上随意分布的多个进程组成的，具有明显的分布性，这些进程之间通过交换下次来进行相互通信。 因此，在分布式系统中，很难定义两个时间的顺序，原因就是因为分布式系统缺乏一个全局的时钟序列控制。<br>故障总是会发生：组成分布式系统的所有计算机，都有可能发生任何形式的故障。任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生！</p><p>##1.3 分布式环境的各种问题</p><h3 id="1-3-1-通信异常"><a href="#1-3-1-通信异常" class="headerlink" title="1.3.1 通信异常"></a>1.3.1 通信异常</h3><p>分布式引入了网络因素，而由于网络本身的不可靠性，因此每次网络通信都会伴随网络不可用的风险，网络光纤、路由器和DNS等。因此消息丢失和消息延迟变得非常普遍。</p><h3 id="1-3-2-网络分区"><a href="#1-3-2-网络分区" class="headerlink" title="1.3.2 网络分区"></a>1.3.2 网络分区</h3><p>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信， 而另一些节点则不能——我们将这个现象称为网络分区。网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本 需要整个分布式系统才能完成的功能，包括对数据的事务处理，这就对分布式一致性提出了非常大的挑战（某个复杂业务原本需要多个机器完成，现在被一个机器 执行）。</p><h3 id="1-3-3-三态"><a href="#1-3-3-三态" class="headerlink" title="1.3.3 三态"></a>1.3.3 三态</h3><p>分布式系统的每一次请求与响应，存在特有的“三态”概念，即成功、失败与超时。超时的现象，通常有以下两种情况：</p><p>由于网络原因，请求并没有被成功地发送到接收方，在发送过程就发生了消息丢失现象。<br>请求成功的被接收方接收后，并进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象。（rabitMQ的解决方案是，消费者（接收方）开始处理消息前发送响应A， 消费者（接收方）处理完成消息后发送响应B，生产者（发送方）必须得到AB两个响应才能确定消息成功被处理了）</p><h1 id="2-从ACID到CAP-BASE"><a href="#2-从ACID到CAP-BASE" class="headerlink" title="2. 从ACID到CAP/BASE"></a>2. 从ACID到CAP/BASE</h1><h2 id="2-1-ACID"><a href="#2-1-ACID" class="headerlink" title="2.1 ACID"></a>2.1 ACID</h2><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元（Unit）。</p><h3 id="2-1-1-原子性（Atomicity）"><a href="#2-1-1-原子性（Atomicity）" class="headerlink" title="2.1.1 原子性（Atomicity）"></a>2.1.1 原子性（Atomicity）</h3><p>要么全部成功执行，要么全部不执行。</p><h3 id="2-1-2-一致性（Consistency）"><a href="#2-1-2-一致性（Consistency）" class="headerlink" title="2.1.2 一致性（Consistency）"></a>2.1.2 一致性（Consistency）</h3><p>事务的运行被迫中断时，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于不一致的状态。</p><h3 id="2-1-3-隔离性（Isolation）"><a href="#2-1-3-隔离性（Isolation）" class="headerlink" title="2.1.3 隔离性（Isolation）"></a>2.1.3 隔离性（Isolation）</h3><p>并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。SQL规范定义了4个事务隔离级别：</p><ol><li>读未提交（Read Uncommitted）：A事务更新过程中，从1更新到10，B事务能获取过程中间值，获取到2，3等值。（脏读）</li><li>读已提交（Read Committed）：A事务更新过程中，从1更新到10，B事务只能获取最终的值10。</li><li>可重复读（Repeatable Read）：A事务更新过程中，从1更新到10，B事务先获取了1，后来B事务中有个操作重新获取了一次值为10。（幻影读）</li><li>串行化（Serializable）：事务只能串行执行，不能并发。</li></ol><h3 id="2-1-4-持久性（Durability）"><a href="#2-1-4-持久性（Durability）" class="headerlink" title="2.1.4 持久性（Durability）"></a>2.1.4 持久性（Durability）</h3><p>事务一旦提交，对数据库对应数据的状态变更就应该被永久保存下来。</p><h2 id="2-1-分布式事务"><a href="#2-1-分布式事务" class="headerlink" title="2.1 分布式事务"></a>2.1 分布式事务</h2><p>设想一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款 服务，这两个服务本身是无状态并且是互相独立的，共同构成了一个完整的分布式事务。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么 就必须回滚到取款前的状态，否则用户可能会发现自己的钱不翼而飞了。</p><p>我们可以看到，一个分布式事务可以看作是由多个分布式的操作序列组成的，例如上面例子中的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为 子事务。因为，分布式事务也可以被定义为一种嵌套型的事务，同时也就具有了ACID事务特性。但由于在分布式事务中，各个子事务的执行时分布式的， 因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。</p><h2 id="2-3-CAP和BASE理论"><a href="#2-3-CAP和BASE理论" class="headerlink" title="2.3 CAP和BASE理论"></a>2.3 CAP和BASE理论</h2><p>ACID是属于单机系统的理论，分布式有属于自己的理论，即CAP和BASE。</p><h3 id="2-3-1-CAP定理"><a href="#2-3-1-CAP定理" class="headerlink" title="2.3.1 CAP定理"></a>2.3.1 CAP定理</h3><p>一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）这三个基本需求，最多只能同时 满足其中的两项。</p><h4 id="1-Consistency"><a href="#1-Consistency" class="headerlink" title=".1 Consistency"></a>.1 Consistency</h4><p>在分布式环境下，数据在多个副本之间是否能够保持一致性，当某个副本执行更新操作后，应该保证系统的数据仍然处于一致的状态。如果做到一个数据项的更新 操作执行成功后，所有的用户都可以读取到最新的值，那么这样的系统就被认为具有强一致性。</p><h4 id="2-Availability"><a href="#2-Availability" class="headerlink" title=".2 Availability"></a>.2 Availability</h4><p>对于用户的每一个操作请求总是能够在有限的时间内返回结果。划重点：有限的时间内、返回结果。</p><p>有限的时间内：对于用户的一个艹做请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。 比如，对于一个在线搜索引擎来说，通常在0.5秒内需要给出用户搜索关键词对应的检索结果，而对于一个面向HIVE的海量数据查询平台来说，正常一次数据 检索时间可能在20秒，这是正常的，系统必须存在一个合理的响应时间。<br>返回结果：要求系统在完成堆用户请求的处理后，返回一个正常的结果，而不是返回系统错误。</p><h4 id="3-Partition-tolerance"><a href="#3-Partition-tolerance" class="headerlink" title=".3 Partition tolerance"></a>.3 Partition tolerance</h4><p>分布式系统在遇到任何网络分区故障的时候（节点间的故障），仍然需要保证对外提供满足一致性和可用性的服务，除非整个网络环境发生了故障。</p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title=".4 总结"></a>.4 总结</h4><ul><li>AC：所有的数据都放在一个分布式节点上。（谈什么分布式？）</li><li>PC：系统正在维修，请等待。（要么可用，要么直接不能访问）</li><li>AP：放弃数据的强一致性，保留数据额最终一致性。（双11xx商品正在被5126人浏览，可能每个人看到的数字都不一样，但是系统最终会让所有人看到一样的数字）</li></ul><h3 id="2-3-2-BASE理论"><a href="#2-3-2-BASE理论" class="headerlink" title="2.3.2 BASE理论"></a>2.3.2 BASE理论</h3><p>基于CAP定理结合实际演化而来，即Basically Available（基本可用）、Soft state（软状态）、Eventually consistency（最终一致性）。</p><h4 id="1-Basically-Available"><a href="#1-Basically-Available" class="headerlink" title=".1 Basically Available"></a>.1 Basically Available</h4><p>分布式在出现不可预知故障的时候，允许损失部分可用性：</p><p>响应时间上的损失：搜索正常是0.5秒返回用户，出现故障变成2秒。<br>功能上的损失：网上购物在双11时选择购买可能会跳转到排队页面。</p><h4 id="2-Soft-state"><a href="#2-Soft-state" class="headerlink" title=".2 Soft state"></a>.2 Soft state</h4><p>允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h4 id="3-Eventually-consistency"><a href="#3-Eventually-consistency" class="headerlink" title=".3 Eventually consistency"></a>.3 Eventually consistency</h4><p>强调数据最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 在实际工程实践中，最终一致性存在以下五类主要变种。</p><h5 id="3-1-因果一致性（Causal-consistency）"><a href="#3-1-因果一致性（Causal-consistency）" class="headerlink" title=".3.1 因果一致性（Causal consistency）"></a>.3.1 因果一致性（Causal consistency）</h5><p>进程A更新完某个数据项后通知了进程B，那么进程B之后对该数据的访问都应该能够获取到进程A更新后的最新纸，并且如果进程B要对该数据项进行更新操作的话， 务必基于进程A更新后的最新值。而进程C的数据访问则没有这样的限制。</p><h5 id="3-2-读己之所写（Read-your-writes）"><a href="#3-2-读己之所写（Read-your-writes）" class="headerlink" title=".3.2 读己之所写（Read your writes）"></a>.3.2 读己之所写（Read your writes）</h5><p>进程A更新了一个数据项，它自己总是能够访问到更新过的最新值。特殊的因果一致性（A进程通知了A进程）。</p><h5 id="3-3-会话一致性（Session-consistency）"><a href="#3-3-会话一致性（Session-consistency）" class="headerlink" title=".3.3 会话一致性（Session consistency）"></a>.3.3 会话一致性（Session consistency）</h5><p>系统能保证在同一个有效的会话中实现“读己之所写”的一致性，即客户端能够在同一绘画中始终读取到该数据项的最新值。</p><h5 id="3-4-单调读一致性（Monotonic-read-consistency）"><a href="#3-4-单调读一致性（Monotonic-read-consistency）" class="headerlink" title=".3.4 单调读一致性（Monotonic read consistency）"></a>.3.4 单调读一致性（Monotonic read consistency）</h5><p>如果一个进程从系统读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</p><h5 id="3-5-单调写一致性（Monotonic-write-consistency）"><a href="#3-5-单调写一致性（Monotonic-write-consistency）" class="headerlink" title=".3.5 单调写一致性（Monotonic write consistency）"></a>.3.5 单调写一致性（Monotonic write consistency）</h5><p>系统保证来自同一个进程的写操作被顺序地执行。</p><h5 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title=".3.6 总结"></a>.3.6 总结</h5><p>最终一致性并不是只有那些大型分布式系统才涉及的特性，许多关系型数据库都采用了最终一致性模型，采用同步和异步方式来实现主备数据复制技术。</p><p>在同步方式中，数据的复制过程通常是更新事务的一部分，因此在书屋完成后，主备数据库的数据就会达到一致。<br>在异步方式中，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长达，如果传输时间过长或者甚至在日志传输过程中出现异常导致 无法及时将事务应用到备库上，那么很显然，从备库读取的数据将是旧的，就出现了数据不一致的情况。<br>但是，无论采用重试、人为修正，关系型数据库还是能够保证最终数据达到一致性——这就是系统提供最终一致性保证的经典案例。</p><p>总的来说，BASE理论面向大型高可用可扩展的分布式系统，和传统事务的ACID特性是相反的，不同于ACID的强一致性模型，而是通过强一致性和高可用性的 平衡，最终达到一致性。因此在具体的分布式系统架构设计过程中，ACID和BASE理论往往会结合一起使用用来面对不同的业务场景的要求。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><p>分布式架构发展过程中的ACID-&gt;CAP-&gt;BASE等分布式事务与一致性方面的经典理论。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 从Paxos到Zookeeper分布式一致性原理与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、深入分析Java Web中的中文编码问题</title>
      <link href="/2017/08/07/deepknowjavaweb/2_java_io.html/"/>
      <url>/2017/08/07/deepknowjavaweb/2_java_io.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2018-10-03%E5%B8%B8%E5%B7%9E%E5%A1%94.jpg" alt></p><a id="more"></a><h1 id="1-几种常见的编码格式"><a href="#1-几种常见的编码格式" class="headerlink" title="1 几种常见的编码格式"></a>1 几种常见的编码格式</h1><h2 id="1-1-为什么需要编码？"><a href="#1-1-为什么需要编码？" class="headerlink" title="1.1 为什么需要编码？"></a>1.1 为什么需要编码？</h2><ol><li>计算机中存储信息的最小单位是1个字节，即8个bit，所以能表示的字符范围是2^8=256个</li><li>人类符号过于复杂，至少一个几个字节才能满足人类的一个单位</li></ol><h2 id="1-2-常见编码"><a href="#1-2-常见编码" class="headerlink" title="1.2 常见编码"></a>1.2 常见编码</h2><p>编码即就是人类的字符-&gt;机器的字符的过程。</p><h3 id="1-2-1-ASCII码"><a href="#1-2-1-ASCII码" class="headerlink" title="1.2.1 ASCII码"></a>1.2.1 ASCII码</h3><p>总共有128个，用1个字节的低七位表示，0~31是控制字符，如换行、回车、删除，32~126是打印字符，可以通过键盘输入并且能够显示出来。</p><h3 id="1-2-2-ISO-8859-1"><a href="#1-2-2-ISO-8859-1" class="headerlink" title="1.2.2 ISO-8859-1"></a>1.2.2 ISO-8859-1</h3><p>128个字符显示是不够的，于是ISO组织在ASCII码基础上又制定了一系列标准来扩展ASCII编码，他们是ISO-8859-1至ISO-8859-15。ISO-8859-1仍然 是单字节编码，它总共能表示256个字符。</p><h3 id="1-2-3-GB2312"><a href="#1-2-3-GB2312" class="headerlink" title="1.2.3 GB2312"></a>1.2.3 GB2312</h3><p>GB2312全称是《信息技术·中文编码字符集》，总的编码范围是：A1~F7。它是双字节编码。包含了符号以及汉字。</p><h3 id="1-2-4-GBK"><a href="#1-2-4-GBK" class="headerlink" title="1.2.4 GBK"></a>1.2.4 GBK</h3><p>GBK全称是《汉字内码扩展规范》，是国家技术监督局为Windows95所制定新的汉字内码规范，它的出现是为了扩展GB2312，并加入更多的汉字。 编码范围是8140~FEFE，总共23940，表示21003个汉字，编码是和GB2312兼容，也就是GB2312编码的汉字可以用GBK解码，不会乱码。</p><h3 id="1-2-5-GB18030"><a href="#1-2-5-GB18030" class="headerlink" title="1.2.5 GB18030"></a>1.2.5 GB18030</h3><p>应用不广泛，与GB2312兼容</p><h3 id="1-2-6-UTF-16"><a href="#1-2-6-UTF-16" class="headerlink" title="1.2.6 UTF-16"></a>1.2.6 UTF-16</h3><ol><li>Unicode（Universal Code统一码），ISO试图创建一个全新的超语言字典，世界上所有的语言都可以通过这个字典来相互翻译。可想而知这个字典是多么 复杂。Unicode是Java和XML的基础</li><li>UTF-16具体定义了Unicode字符在计算机中的存取方法，UTF-16用两个字节来表示Unicode的转化格式，它采用定长的表示方法，即不论什么字符都可以用 两个字节表示</li><li>两个字节是16个bit，所以叫UTF-16。UTF-16表示字符非常方便，每两个字节表示一个字符，简化了字符串操作，这也是Java以UTF-16作为内存的字符存储格式的一个重要的原因</li></ol><h3 id="1-2-7-UTF-8"><a href="#1-2-7-UTF-8" class="headerlink" title="1.2.7 UTF-8"></a>1.2.7 UTF-8</h3><p>UTF-16统一采用两个字节表示一个字符，虽然表示上简单方便，但是也有其缺点，很大一部分字符用一个字节就可以表示的现在要用两个字节表示，存储空间放大了一倍。而UTF-8采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以由1~6个字节组成。  </p><ol><li>如果是一个字节。最高为为0，则表示这是一个ASCII字符，可见，所有ASCII编码已经是UTF-8了。</li><li>如果是一个字节，以11开头，则连续的1的个数暗示这个字符的字节数。例如：110xxxxx代表它是双字节UTF-8字符的首字节。</li><li>如果是一个字节，以10开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。</li></ol><h2 id="1-2-编码的场景"><a href="#1-2-编码的场景" class="headerlink" title="1.2 编码的场景"></a>1.2 编码的场景</h2><h3 id="1-2-1-I-O操作"><a href="#1-2-1-I-O操作" class="headerlink" title="1.2.1 I/O操作"></a>1.2.1 I/O操作</h3><p>Reader类和InputStream之间的InputStreamReader，通过StreamDecoder以及StreamEncoder进行字符和字节的转换，在解码过程必须指定编码格式， 否则按系统编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String file = <span class="string">"D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt"</span>;</span><br><span class="line">String charset = <span class="string">"UTF-8"</span>;</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fileOutputStream);</span><br><span class="line">writer.write(<span class="string">"这是要保存的中文字符"</span>);</span><br><span class="line">writer.close();</span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fileInputStream, charset);</span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span>((count = reader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    buffer.append(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(buffer.toString());</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></p><h3 id="1-2-2-在内存操作中的编码"><a href="#1-2-2-在内存操作中的编码" class="headerlink" title="1.2.2 在内存操作中的编码"></a>1.2.2 在内存操作中的编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种，通过字符串操作</span></span><br><span class="line">String s = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = s.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">String n = <span class="keyword">new</span> String(b, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.print(n);</span><br><span class="line"><span class="comment">// 第二种，通过nio中的Charset与Buffer实现编码解码。</span></span><br><span class="line">Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuffer buffer = charset.encode(s);       <span class="comment">//字符转字节</span></span><br><span class="line">CharBuffer buffer1 = charset.decode(buffer); <span class="comment">//字节转字符</span></span><br><span class="line"><span class="keyword">char</span>[] a = buffer1.array();</span><br><span class="line">System.out.print(a);</span><br><span class="line"><span class="comment">// 第三种，通过将16bit的char拆分为2个8bit的byte，没有编码解码，只是软转化</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer byteBuffer1 = byteBuffer.putChar(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><h1 id="3-在Java中如何编解码"><a href="#3-在Java中如何编解码" class="headerlink" title="3 在Java中如何编解码"></a>3 在Java中如何编解码</h1><ol><li>UTF_32，GBK等编码都是继承自Charset（查看GB18030类的源码，会让你大吃一惊）。</li><li>Java内存编码采用的UTF-16编码，编码效率高，虽然用双字节存储，但是不适合网络之间传输，因为网络传输容易损坏字节流，当一个字节损坏，就两个字节没用了，UTF-8更适合网络传输。</li><li>UTF-8对ASCII字符采用单字节存储，另外单个字符损坏也不会影响后面的其他字符，编码效率上介于GBK和 UTF-16之间，所以UTF-8在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。</li></ol><h1 id="4-在Java-Web中设计的编解码"><a href="#4-在Java-Web中设计的编解码" class="headerlink" title="4 在Java Web中设计的编解码"></a>4 在Java Web中设计的编解码</h1><ol><li>有I/O的地方就会涉及编码。网络传输都是以字节为单位的，所以所有的数据必须能够被序列化，即继承Serializable</li><li>一个文本的实际大小应该怎么计算。例如：把整型数字1234567当做字符哎存储，则采用UTF-8编码会占用7个字节，采用UTF-16编码<br>会占用14个字节，但是当把它当成int类型的数字来存储则只需要4个字节<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-1.png" alt></li></ol><h2 id="4-1-URL的编码"><a href="#4-1-URL的编码" class="headerlink" title="4.1 URL的编码"></a>4.1 URL的编码</h2><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-2.png" alt>  </p><ol><li>其中浏览器对PathInfo和QueryString是编码不同的，因此服务器分别在不同的地方对其进行解码</li><li>例如Tomcat先判断URIEncoding是否有定义，如果没有则默认使用ISO-8859-1解析</li><li>而QueryString，无论POST请求还是GET请求，对它们的解码都是在request.getParameters()方法中，当然内部对POST和GET解码是不同的</li><li>其中GET请求，是通过HTTP的Header传到服务端的，是通过useBodyEncodingForURL设置。因此在服务器最好设置URIEncoding和useBodyEncoding两个参数</li></ol><h2 id="4-2-HTTP-Header的编解码"><a href="#4-2-HTTP-Header的编解码" class="headerlink" title="4.2 HTTP Header的编解码"></a>4.2 HTTP Header的编解码</h2><p>如Cookie等，一些头信息，Tomcat对Header解码是在调用request.getHeader()方法时进行的。如果有非ASCII字符，使用URLEncoder进行编码，网络传输。</p><h2 id="4-3-POST表单的编解码"><a href="#4-3-POST表单的编解码" class="headerlink" title="4.3 POST表单的编解码"></a>4.3 POST表单的编解码</h2><p>提交时，浏览器先根据ContentType的Charset编码进行参数编码，然后再提交到服务端，服务端同样也用ContentType中的字符集进行解码。服务端可以通过 request.setCharacterEncoding(charset)来设置</p><blockquote><p>要在第一次调用request.getParameter()方法之前就设置request.setCharacterEncoding(charset)。<br>如果服务端没有设置request.setCharacterEncoding(charset)，那么表单提交的数据将会按照系统的默认编码方式解析。<br>另外，针对multipart/form-data类型的参数，即上传文件，也是通过ContentType定义的字符编码。上传文件是用字节流的方式传输到服务器的本地 临时目录，这个过程并没有涉及字符编码，而真正编码是在讲文件内容添加到parameters，如果用这个不能编码，则会使用默认的ISO-8859-1编码。</p></blockquote><h2 id="4-4-HTTP-BODY的编解码"><a href="#4-4-HTTP-BODY的编解码" class="headerlink" title="4.4 HTTP BODY的编解码"></a>4.4 HTTP BODY的编解码</h2><p>通过Response返回给客户端浏览器。这个过程要经过编码，即response.setCharcterEncoding()来设置，它将会覆盖request.getCharacterEncoding() 的值，并通过Header的Content-Type返回客户端，浏览器接收到返回的Socket流时将通过Content-Type的charset来解码。如果返回的HTTP Header中Content-Type 没有设置charset，那么浏览器将根据浏览器的中的charset来解码， 如果浏览器中没有定义，则使用默认的编码。<br>连接JDBC也是指定一致的编码：<code>jdbc:mysql://localhost:3306?DB?useUnicode=true&amp;characterEncoding=GBK</code></p><h1 id="5-在JS的编码"><a href="#5-在JS的编码" class="headerlink" title="5 在JS的编码"></a>5 在JS的编码</h1><h2 id="5-1-外部引入JS文件"><a href="#5-1-外部引入JS文件" class="headerlink" title="5.1 外部引入JS文件"></a>5.1 外部引入JS文件</h2><p><code>&lt;script scr=&quot;script.js&quot; charset=&quot;gbk&quot;&gt;&lt;/script&gt;</code><br>而script.js脚本中，有如下代码：<br><code>document.write(&quot;中国&quot;);</code><br>如果引入的时候没有设置charset，浏览器就会以当前页面的默认字符集解析这个JS文件。如果一致那就没问题，但是如果页面和js字符编码不一致，就会变成乱码。</p><h2 id="5-2-JS的URL编码"><a href="#5-2-JS的URL编码" class="headerlink" title="5.2 JS的URL编码"></a>5.2 JS的URL编码</h2><h3 id="5-2-1-escape"><a href="#5-2-1-escape" class="headerlink" title="5.2.1 escape()"></a>5.2.1 escape()</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-3.png" alt><br>这组函数已经从ECMAScript v3标准删除了，URL的编码可以用encodeURI和encodeURIComponent来代替。</p><h3 id="5-2-2-encodeURI"><a href="#5-2-2-encodeURI" class="headerlink" title="5.2.2 encodeURI()"></a>5.2.2 encodeURI()</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-4.png" alt><br>对某些特殊的字符不进行编码如 <code>!</code>、<code>a-z</code>、<code>A-Z</code>、<code>0-9</code>、<code>=</code>、<code>@</code>、<code>?</code>、<code>;</code>、<code>:</code>、<code>-</code>、<code>+</code>、<code>(</code>、<code>)</code>、<code>&amp;</code>、<code>#</code>、<code>.</code>、<code>~</code>、<code>*</code>。</p><h3 id="5-2-3-encodeURIComponent"><a href="#5-2-3-encodeURIComponent" class="headerlink" title="5.2.3 encodeURIComponent()"></a>5.2.3 encodeURIComponent()</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-5.png" alt><br>编码更加彻底，用于整个URL编码，因为它将&amp;也编码了。除了<code>!</code>、<code>a-z</code>、<code>A-Z</code>、<code>0-9</code>、<code>-</code>、<code>.</code>、<code>~</code>、<code>*</code></p><h3 id="5-2-4-Java与JS编解码问题"><a href="#5-2-4-Java与JS编解码问题" class="headerlink" title="5.2.4 Java与JS编解码问题"></a>5.2.4 Java与JS编解码问题</h3><ol><li>Java端处理URL编解码有两个类，分别是URLEncoder和URLDecoder。这两个类可以将所有“%”加UTF-8码值用UTF-8解码，从而得到原始的值</li><li>对应的前端JS是encodeURIComponent和decodeURLComponent。注意，前端用encodeURIComponent，服务端用URLDecoder解码可能会乱码， 可能是两个字符编码类型不一致，JS编码默认是UTF-8编码，而服务端中文解码一般都是GBK或者GB2312，所以encodeURIComponent编码后是 UTF-8，而Java用GBK去解码显然不对</li><li>解决方式是encodeURIComponent两次编码，服务端使用request.getParameter()用GBK解码后，再用UTF-8解码</li></ol><h1 id="6-常见编码问题"><a href="#6-常见编码问题" class="headerlink" title="6 常见编码问题"></a>6 常见编码问题</h1><h2 id="6-1-中文变成看不懂的字符"><a href="#6-1-中文变成看不懂的字符" class="headerlink" title="6.1 中文变成看不懂的字符"></a>6.1 中文变成看不懂的字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"淘！我喜欢！"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = a.getBytes(<span class="string">"GBK"</span>);  <span class="comment">//可以表示中文，占两个字节</span></span><br><span class="line">String c = <span class="keyword">new</span> String(b, <span class="string">"ISO-8859-1"</span>);  <span class="comment">//将两个字节分别作为一个单独的字符显示</span></span><br><span class="line">System.out.println(c); <span class="comment">// output: ÌÔ£¡ÎÒÏ²»¶£¡</span></span><br></pre></td></tr></table></figure><p>双字节变成单字节<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-6.png" alt></p><h2 id="6-2-中文变成一个问号"><a href="#6-2-中文变成一个问号" class="headerlink" title="6.2 中文变成一个问号"></a>6.2 中文变成一个问号</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"淘！我喜欢！"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = a.getBytes(<span class="string">"ISO-8859-1"</span>);    <span class="comment">//找不到对应的字符</span></span><br><span class="line">String c = <span class="keyword">new</span> String(b, <span class="string">"ISO-8859-1"</span>);</span><br><span class="line">System.out.println(c); <span class="comment">// ??????</span></span><br></pre></td></tr></table></figure><p>中文变成问号<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-7.png" alt></p><h2 id="6-3-中文变成两个问号"><a href="#6-3-中文变成两个问号" class="headerlink" title="6.3 中文变成两个问号"></a>6.3 中文变成两个问号</h2><p>经过了多次的编码解码<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-8.png" alt></p><h2 id="6-4-一种不正常的正确编码"><a href="#6-4-一种不正常的正确编码" class="headerlink" title="6.4 一种不正常的正确编码"></a>6.4 一种不正常的正确编码</h2><p>直接调用 String value = request.getParameter(name);会出现乱码。<br>但是 String value = new String(request.getParameter(name).getBytes(“ISO-8859-1”), “GBK”)会正常，为什么呢？<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-3-1-9.png" alt><br>网络通过GBK编码之后的字节数组进行传输，Tomcat没有配置useBodyEncodingForURI，造成第一次解析通过ISO-8859-1解析， 这时候我们手动通过ISO-8859-1编码，再通过GBK解码就可以获得正确的值，但是额外增加了一次编解码过程。</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>总结了几种常见编码格式的区别：  </p><ol><li>ISO-8859-1：单字节编码，最多能表示256个字符。</li><li>GBK、GB2312：双字节编码，前者兼容后者。</li><li>UTF-16：双字节编码，Java内部内存额字符存储格式，操作方便，全部都是两个字节，但是浪费空间。</li><li>UTF-8：动态字节编码。</li><li>以及IO的编码实现类：StreamEncoder/StreamDecoder，对char和byte的编解码。</li></ol><p>HTTP过程的编码，包括：  </p><ol><li>URL、URI的编码。</li><li>Header的编解码。</li><li>POST表单的编解码。Java使用request.getParameter()获取之前，先设置request.setCharacterEncoding(charset)。</li><li>BODY的编解码，即Response的编解码。</li><li>JS的编解码。</li><li>Tomcat编解码源码。以及常见乱码问题的原因。  </li></ol><p>注意一定要手动设置编码的格式，实现真正的跨平台。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 深入分析Java_Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、深入分析Java_IO的工作机制</title>
      <link href="/2017/08/07/deepknowjavaweb/2_java_io.html/"/>
      <url>/2017/08/07/deepknowjavaweb/2_java_io.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2015-04-29%E9%A3%9E%E6%9C%BA%E9%93%BE.jpg" alt></p><a id="more"></a><h1 id="1-JAVA的I-O类库的基本架构"><a href="#1-JAVA的I-O类库的基本架构" class="headerlink" title="1 JAVA的I/O类库的基本架构"></a>1 JAVA的I/O类库的基本架构</h1><ol><li>基于字节操作的I/O接口：InputStream和OutputStream。</li><li>基于字符操作的I/O操作：Writer和Reader。</li><li>基于磁盘操作的I/O操作：File。</li><li>基于网络操作的I/O操作：Socket。</li></ol><h1 id="2-字节字符的转换"><a href="#2-字节字符的转换" class="headerlink" title="2 字节字符的转换"></a>2 字节字符的转换</h1><p>低级的字节转字符，有InputStreamReader，以及OutputStreamWriter。 而字符转字节一般直接用new String(byte[])。</p><blockquote><p>注意：字符字节的转换在开发中一定要显示指明编码。 在OutputStreamWriter的官方注释中，错误的理解为从字符到字节，其实应该理解&gt;成字符与字节之间的桥梁。</p></blockquote><h1 id="3-访问文件的几种方式"><a href="#3-访问文件的几种方式" class="headerlink" title="3 访问文件的几种方式"></a>3 访问文件的几种方式</h1><p>前言：读取和写入都是调用操作系统的提供的接口，而操作系统调用就会存在内核空间地址和用户空间地址切换的问题，一般的IO都是数据从 磁盘复制到内核空间，然后再从内核空间复制到用户空间，操作系统为了加速IO访问，在内核空间使用了缓存，即如果是第二次访问同一段的磁盘地址，直接从内核缓存中取出。</p><h2 id="3-1-标准访问文件的方式"><a href="#3-1-标准访问文件的方式" class="headerlink" title="3.1 标准访问文件的方式"></a>3.1 标准访问文件的方式</h2><p>读取：调用操作系统的Read接口，操作系统先检查内核的高速缓存，如果有缓存则直接返回，如果没有则从磁盘中读取，缓存，返回。<br>写入：调用操作系统的Writer接口，写入到高速缓存中，则通知应用程序完成，什么时候写入磁盘由操作系统决定。当然你可以使用sync强制刷新。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-1.png" alt></p><h2 id="3-2-直接I-O的方式"><a href="#3-2-直接I-O的方式" class="headerlink" title="3.2 直接I/O的方式"></a>3.2 直接I/O的方式</h2><p>即应用程序直接访问磁盘数据，减少一次从内核缓冲区到用户空间的数据复制，例如数据库管理系统，数据库明确的知道哪些数据需要缓存哪些不需要，以及哪些数据需要先放到内存中预热，但是不好的地方在于，你接管了数据缓存，如果你没有命中，则每次都是IO磁盘，比较耗时，通常结合直接IO与异步IO。</p><h2 id="3-3-同步访问文件的方式"><a href="#3-3-同步访问文件的方式" class="headerlink" title="3.3 同步访问文件的方式"></a>3.3 同步访问文件的方式</h2><p>与标准访问文件不同点在于，写入了磁盘，操作系统才会应用程序返回成功的标志，用于安全性高的场景。</p><h2 id="3-4-异步访问文件的方式"><a href="#3-4-异步访问文件的方式" class="headerlink" title="3.4 异步访问文件的方式"></a>3.4 异步访问文件的方式</h2><p>访问文件的请求线程发出后，不会阻塞等待，继续做别的事，完成文件访问后回调某个方法，提高应用程序的效率而不是访问文件的效率。</p><h2 id="3-5-内存映射的方式"><a href="#3-5-内存映射的方式" class="headerlink" title="3.5 内存映射的方式"></a>3.5 内存映射的方式</h2><p>操作系统将内存中的某一块区域与磁盘中的文件关联，理解为快捷方式。这样中间加了一层地址映射，空间换时间，在实际开发中，多台业务 服务器对一个统一的路径下进行共享，方便数据的存储。例如A服务器下的data和B服务器下的data进行共享，便于文件的统一上传下载路径管理。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-2.png" alt></p><h1 id="4-访问磁盘文件"><a href="#4-访问磁盘文件" class="headerlink" title="4 访问磁盘文件"></a>4 访问磁盘文件</h1><p>前面介绍了操作数据，接着这里介绍数据写向何处，例如持久化到物理磁盘。<br>FileInputStream 对象是操作一个文件的接口，创建的同时会创建该文件的描述对象 FileDescriptor。操作文件对象的时候可以通过getFD() 方法获取真正与底层操作系统相关联的文件描述。例如调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。<br>byte-&gt;char是解码过程，因此读取文件都是需要StreamDecoder类帮助。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-3.png" alt></p><h2 id="4-1-Java序列化技术"><a href="#4-1-Java序列化技术" class="headerlink" title="4.1 Java序列化技术"></a>4.1 Java序列化技术</h2><p>将对象转化成一串二进制表示的字符数组，反序列化时需要原始类作为模板，原因在于序列化之后的文件不保存类的完整结构信息。<br>建议保存为通用的json/xml格式，比较耗的序列化工具：protobuf。序列化以及反序列需要注意一些常见的问题，例如serialVersionUID被修改，序列化对象中有属性为对象但是该属性对象没有实现Serializable等。</p><h1 id="5-网络I-O工作机制"><a href="#5-网络I-O工作机制" class="headerlink" title="5 网络I/O工作机制"></a>5 网络I/O工作机制</h1><h2 id="5-1-TCP状态"><a href="#5-1-TCP状态" class="headerlink" title="5.1 TCP状态"></a>5.1 TCP状态</h2><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-4.png" alt>  </p><ol><li>三次握手 客户端CLOSED、SYN-SEND、ESTABLISHED。<br>服务端LISTEN、SYN-RCVD、ESTABLISHED。</li><li>四次挥手<br>客户端ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT。<br>服务端ESTABLISHED、CLOSE_WAIT、LAST_ACK、CLOSE。</li></ol><h2 id="5-2-影响网络传输的因素"><a href="#5-2-影响网络传输的因素" class="headerlink" title="5.2 影响网络传输的因素"></a>5.2 影响网络传输的因素</h2><ol><li>网络带宽：物理链路在1s内传输的最大比特值，一般都是1.7Mb/s。</li><li>传输距离。</li><li>TCP拥塞控制：TCP传输是一个“停等停等”的过程，要步调一致则需要通过拥塞控制来调节。TCP在传输时会设定一个“窗口”，窗口大小由带宽和数据 在两端的来回时间，即响应时间决定的。</li></ol><h2 id="5-3-Java-Socket的工作机制"><a href="#5-3-Java-Socket的工作机制" class="headerlink" title="5.3 Java Socket的工作机制"></a>5.3 Java Socket的工作机制</h2><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-5.png" alt><br>客户端开始建立一个Socket实例时，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地地址、 远程地址和端口号的套接字数据结构，这个数据结构一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将进行TCP的三次握手协议， 三次握手，完成之后，Socket实例创建完成。<br>服务端将创建一个ServerSocket实例，只要指定的端口号没有被占用，一般实例都会创建成功，操作系统底层也会为ServerSocket实例创建一个底层 数据结构，这个数据结构中包含指定的端口号和包含监听地址的通配符，通常都是“*”，即监听所有地址。之后调用accept()方法，进入阻塞状态，等待 客户端的请求。当一个新的请求到达时，为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址 和端口，同时这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中。注意，此时服务端的与之对应的Socket实例 并没有完成创建，而是要等待与客户端的3次握手完成后，这个服务端的Socket实例才会返回，并从未连接数据结构列表移到已完成列表。所以与ServerSocket 所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接。</p><h2 id="5-4-数据传输"><a href="#5-4-数据传输" class="headerlink" title="5.4 数据传输"></a>5.4 数据传输</h2><p>服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，通过这两个对象来交换数据，同时操作系统会为 这两个对象分配一定大小的缓存区。</p><blockquote><p>写入：数据-&gt;OutputStream对应的SendQ队列，队列填满时，数据将会转移到另一端的InputStream的RecvQ队列中，如果RecvQ已经满了，那么 OuptStream的write方法将会阻塞，直到RecvQ队列可以容纳SendQ队列的数据。因此网络IO还需要一个协调的过程，如果两边同时传输数据则会产生死锁。</p></blockquote><h1 id="6-NIO的工作方式-建议先阅读课外学习：关于NIO"><a href="#6-NIO的工作方式-建议先阅读课外学习：关于NIO" class="headerlink" title="6 NIO的工作方式(建议先阅读课外学习：关于NIO)"></a>6 NIO的工作方式(建议先阅读课外学习：关于NIO)</h1><h2 id="6-1-BIO的缺点"><a href="#6-1-BIO的缺点" class="headerlink" title="6.1 BIO的缺点"></a>6.1 BIO的缺点</h2><p>阻塞IO，即BIO，在读取和写入时（InputStream、OutputStream）都有可能堵塞，一旦有堵塞，线程将会失去CPU的使用权，一些方法，例如：一个客户端 一个处理线程、线程池用来减少线程创建和回收的成本。但是，当需要大量的HTTP长连接，例如Web旺旺，虽然并不是每个连接都一直在传输数据，但是如果要 对某个客户端（VIP）提供更高的服务优先，很难通过线程本省的优先级完成，同时访问一些竞争资源时，也会有问题，因此需要同步。因此NIO应运而生。</p><h2 id="6-2-NIO的工作机制"><a href="#6-2-NIO的工作机制" class="headerlink" title="6.2 NIO的工作机制"></a>6.2 NIO的工作机制</h2><p>通过等待读以及等待写的轮询，在真正进行IO的时候才是使用CPU阻塞，但是由于是memory copy，在带宽足够大的1GB/s基本可以忽略。</p><h2 id="6-3-Buffer的工作方式"><a href="#6-3-Buffer的工作方式" class="headerlink" title="6.3 Buffer的工作方式"></a>6.3 Buffer的工作方式</h2><p>可以简单理解为操作一组基本数据类型的元素列表：capacity、position、limit、mark。<br>注意，通过Channel获取的IO数据首先经过操作系统的Socket缓冲区，再将数据复制到Buffer中，这个操作系统缓冲区就是底层的TCP所关联的RecvQ或者 SendQ队列。<br>Buffer提供了另一种直接操作操作系统缓冲区的方式，即ByteBuffer.allocateDirector()，这个方法直接返回底层存储空间关联的缓冲区，它通过 Native代码操作非JVM堆的内存空间，每次创建或者释放都要手动调用一次System.gc()。</p><blockquote><p>使用该方法直接操作非JVM堆空间会引起JVM内存泄漏问题。适用于数据量比较大，生命周期比较长的情况下，而普通的allocate()方法 适用并发连接少于1000。</p></blockquote><h2 id="6-4-FileChannel的数据访问"><a href="#6-4-FileChannel的数据访问" class="headerlink" title="6.4 FileChannel的数据访问"></a>6.4 FileChannel的数据访问</h2><h3 id="6-4-1-FileChannel-transferXXX"><a href="#6-4-1-FileChannel-transferXXX" class="headerlink" title="6.4.1 FileChannel.transferXXX"></a>6.4.1 FileChannel.transferXXX</h3><p>传统的数据访问方式：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-6.png" alt></p><p>FileChannel.transferXXX方式：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-7.png" alt></p><h3 id="6-4-2-FileChannel-map"><a href="#6-4-2-FileChannel-map" class="headerlink" title="6.4.2 FileChannel.map"></a>6.4.2 FileChannel.map</h3><p>将文件按照一定大小块映射为内存区域，当程序访问这个内存区域时将直接操作这个文件数据，省去了数据从内核空间向用户空间复制的损耗。 适用于对大文件的只读性操作，如大文件的MD5校验。</p><h1 id="7-IO调优"><a href="#7-IO调优" class="headerlink" title="7 IO调优"></a>7 IO调优</h1><h2 id="7-1-磁盘I-O优化"><a href="#7-1-磁盘I-O优化" class="headerlink" title="7.1 磁盘I/O优化"></a>7.1 磁盘I/O优化</h2><h3 id="7-1-1-性能检测"><a href="#7-1-1-性能检测" class="headerlink" title="7.1.1 性能检测"></a>7.1.1 性能检测</h3><p>在Linux下的iostat命令，查看I/O wait指标是否正常，即CPU等待I/O指标，如果是4核CPU，那么I、O wait参数不应该超过25%。</p><h3 id="7-1-2-提升I-O性能"><a href="#7-1-2-提升I-O性能" class="headerlink" title="7.1.2 提升I/O性能"></a>7.1.2 提升I/O性能</h3><ol><li>增加缓存，减少磁盘访问次数。</li><li>优化磁盘的管理系统</li><li>设计合理的磁盘存储数据块。</li></ol><h2 id="7-2-TCP网络参数调优"><a href="#7-2-TCP网络参数调优" class="headerlink" title="7.2 TCP网络参数调优"></a>7.2 TCP网络参数调优</h2><p>操作系统的端口号：2^16 = 65535个。 通过查看 <code>cat /proc/sys/net/ipv4/ip_local_port_range</code> 查看端口范围。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-8.png" alt><br>大量并发，端口号的数量就变成瓶颈，还有 <code>TIME_WAIT</code> 的数量，如果过多，需要将参数设小，提前释放。</p><h2 id="7-3-网络I-O优化"><a href="#7-3-网络I-O优化" class="headerlink" title="7.3 网络I/O优化"></a>7.3 网络I/O优化</h2><ol><li>减少网络交互的次数<br>SQL在客户端和数据库端设置缓存，请求css、js等可以合并为一个http链接，每个文件通过逗号隔开，服务端一次请求全部返回。</li><li>减少网络传输数据量的大小<br>通常Web服务器将请求的Web页面gzip压缩后再传输给浏览器。以及通过简单的协议，读取协议头来获取有用的价值信息。尽量避免读取整个通信数据，例如4层代理和7层代理，都是精良避免要读取整个通信数据。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-1-9.png" alt></li><li>尽量减少编码</li><li>尽量以字节形式发送</li></ol><h3 id="7-3-1-同步与异步"><a href="#7-3-1-同步与异步" class="headerlink" title="7.3.1 同步与异步"></a>7.3.1 同步与异步</h3><ol><li>同步<br>一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列，同生同死。 同步能保证程序的可靠性。</li><li>异步<br>不需要等待被依赖的任务完成只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行。 异步可以提高程序的性能，需要在同步与异步中保持平衡</li></ol><h3 id="7-3-2-阻塞和非阻塞"><a href="#7-3-2-阻塞和非阻塞" class="headerlink" title="7.3.2 阻塞和非阻塞"></a>7.3.2 阻塞和非阻塞</h3><p>阻塞和非阻塞主要从CPU的消耗上来说。</p><ol><li>阻塞<br>CPU停下等待一个慢的操作完成之后，CPU才接着完成其他的工作。  </li><li>非阻塞<br>这个慢操作执行时，CPU去做其他工作，这个慢操作完成时，CPU收到通知继续完成这个慢操作之后的事。</li><li>两种方式的组合<br><strong>同步阻塞</strong><br>常用，简单，但是IO性能差，CPU大部分处于空闲状态。<br><strong>同步非阻塞</strong><br>常用于网络IO是长连接同时传输数据不多的情况。提升IO性能的常用手段，会增加CPU消耗，要考虑增加的IO性能能不能补偿CPU的消耗，也就是系统的瓶颈是在IO还是CPU上。<br><strong>异步阻塞</strong><br>常用于分布式数据库中。例如一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份备份记录会写到 其他机器上，这些备份记录通常都采用异步阻塞的方式写IO，异步阻塞对网络IO能够提升效率，尤其像上面这种同时写多份 相同数据的情况。<br><strong>异步非阻塞</strong><br>比较复杂，只有在非常负载的分布式情况下使用，集群之间的消息同步机制一般使用这种IO组合方式。如Cassandra的Gossip通信机制就采用 异步非阻塞的方式。适用于同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大但非常频繁的情况。<br><strong>虽然异步和非阻塞能够提高IO整体性能，但是会增加性能成本，以及程序设计复杂的上升，需要经验丰富的人去设计，如果设计的不合理反而会导致性能下降。</strong><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></li></ol><h1 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8 适配器模式"></a>8 适配器模式</h1><p>博主做一个Integer转化为String的例子，仿造InputStream转化Reader的简单例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputInteger_</span> <span class="keyword">implements</span> <span class="title">Integer_</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputInteger_</span><span class="params">(Integer a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Integer_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_</span> <span class="keyword">implements</span> <span class="title">InputString_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputString_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputInteger2String</span> <span class="keyword">implements</span> <span class="title">InputString_</span> </span>&#123;</span><br><span class="line">    Integer_ s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputInteger2String</span><span class="params">(Integer_ s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// StreamDecoder</span></span><br><span class="line">        Integer r = Integer.valueOf(s.getInteger());</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputInteger2String s = <span class="keyword">new</span> InputInteger2String(<span class="keyword">new</span> InputInteger_(<span class="number">4</span>));</span><br><span class="line">        s.readString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-装饰器模式"><a href="#9-装饰器模式" class="headerlink" title="9 装饰器模式"></a>9 装饰器模式</h1><p>赋予被装饰的类更多的功能，就像IO中的BufferedInputStream有缓冲的功能，LineNumberInputStream有提高按行读取数据的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream_</span> <span class="keyword">extends</span> <span class="title">InputStream_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream_</span> <span class="keyword">extends</span> <span class="title">InputStream_</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> InputStream_ inputStream_;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterInputStream_</span><span class="params">(InputStream_ inputStream_)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inputStream_ = inputStream_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inputStream_.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferInputStream_</span> <span class="keyword">extends</span> <span class="title">FilterInputStream_</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferInputStream_</span><span class="params">(InputStream_ inputStream_)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputStream_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bufferFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bufferEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bufferFirst();</span><br><span class="line">        <span class="keyword">super</span>.read();</span><br><span class="line">        bufferEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InputStream_ inputStream_ = <span class="keyword">new</span> FileInputStream_();</span><br><span class="line">        BufferInputStream_ bufferInputStream_ = <span class="keyword">new</span> BufferInputStream_(inputStream_);</span><br><span class="line">        bufferInputStream_.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-适配器模式与装饰器模式区别"><a href="#10-适配器模式与装饰器模式区别" class="headerlink" title="10 适配器模式与装饰器模式区别"></a>10 适配器模式与装饰器模式区别</h1><p>它们有个别名，叫包装模式，都起到了包装一个类或对象的作用，但是作用不同。适配器通过改变接口来达到重复使用的目的（如果系统在设计初期，就尽量不要用 适配器模式），而装饰器模式保持原有的接口，增强原有对象的功能。</p><h1 id="11-总结"><a href="#11-总结" class="headerlink" title="11 总结"></a>11 总结</h1><p>Java中IO的基本库结构，磁盘IO和网络IO的工作方式。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 深入分析Java_Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NIO的学习</title>
      <link href="/2017/08/07/prac/sum/nio_learn.html/"/>
      <url>/2017/08/07/prac/sum/nio_learn.html/</url>
      
        <content type="html"><![CDATA[<p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2016-08-26%E6%97%A5%E7%85%A7%E6%B5%B7%E8%BE%B9.jpg" alt></p><a id="more"></a><h1 id="1-跑个Channel实例"><a href="#1-跑个Channel实例" class="headerlink" title="1 跑个Channel实例"></a>1 跑个Channel实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 源目标，春运的100W人</span></span><br><span class="line">    RandomAccessFile aFile=<span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    <span class="comment">// 获得源目标的运载交通工具，例如动车，同时动车的站台也站了100W人。</span></span><br><span class="line">    FileChannel inChannel=aFile.getChannel();</span><br><span class="line">    <span class="comment">// 分配buffer，这次春运，这辆D8888，每次跑两个字节单位的座位</span></span><br><span class="line">    ByteBuffer buf=ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 把动车的站台人和座位连接在一起，得到一个返回值，即该动车和两个字节单位座位的车票信息。</span></span><br><span class="line">    <span class="keyword">int</span> bytesRead=inChannel.read(buf);</span><br><span class="line">    <span class="comment">// 车票如果是-1说明车票没了，载完了，动车就去保养了。</span></span><br><span class="line">    <span class="keyword">while</span>(bytesRead!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 座位的保险带绑上，人不能下座位或者上座位了，只能被车站人员检查</span></span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="comment">// 车站人员检查座位是否有对应的人的信息</span></span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印出以两个字节为单位的座位的人的信息</span></span><br><span class="line">            System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 座位保险带放开，人下车，座位就被清空</span></span><br><span class="line">        buf.clear();</span><br><span class="line">        <span class="comment">// 动车继续拉两个字节座位的人，又得到了座位的车票信息</span></span><br><span class="line">        bytesRead=inChannel.read(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    aFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的Buffer作为一个顶层抽象类，下面有不止八个子类，对应八种数据类型以及其他一些类型。 当Buffer，即座位在调用flip()方法之前，是写模式，即保险带是放开的，想上就上想下就下。</p><blockquote><p>Buffer只是在一个改变capacity、position、limit三个值的方法（还有mark，用于临时标记position，通常用于 发送某个指定位置之后，返回到发送指定位置之前的position，因为内部提供了方法用于这个需求）。</p></blockquote><h2 id="1-1-写模式"><a href="#1-1-写模式" class="headerlink" title="1.1 写模式"></a>1.1 写模式</h2><ol><li>capacity：固定的大小</li><li>position：初始值为0，写一单位数据就移动下一个可插入数据的单位，最大为capacity-1</li><li>limit：额外的变量，用于读写分离。此时limit=capacity，写入的最大值</li></ol><h2 id="1-2-读模式"><a href="#1-2-读模式" class="headerlink" title="1.2 读模式"></a>1.2 读模式</h2><ol><li>capacity：固定的大小</li><li>position：重置为0，读一单位数据就移动下一个可插入数据的单位</li><li>limit：重置为position，你只能读你写了多少单位的数据。（flip()方法其实，就是将limit重置为position，position重置为0）</li></ol><h1 id="2-Buffer读写数据以及常用方法"><a href="#2-Buffer读写数据以及常用方法" class="headerlink" title="2. Buffer读写数据以及常用方法"></a>2. Buffer读写数据以及常用方法</h1><p>除了通过Channel写入数据，还可以使用Buffer.put()，写入执行某个位置。<br>也可以通过Buffer.get()，读取某个位置的数据。</p><h2 id="2-1-Buffer-clear"><a href="#2-1-Buffer-clear" class="headerlink" title="2.1 Buffer.clear()"></a>2.1 Buffer.clear()</h2><p>limit设置为capacity，position重置为0。</p><h2 id="2-2-Buffer-compact"><a href="#2-2-Buffer-compact" class="headerlink" title="2.2 Buffer.compact()"></a>2.2 Buffer.compact()</h2><p>释放缓存区无用数据。当源目标为Mellow，我们已经读取了Me，现在缓存区还是Mellow，但是Me是无用的，这时候就可以调用该方法。 你可以使用 Buffer.put()以及Buffer.get()方法达到这个效果。<br>底层其实是将position-limit数据复制到开始的位置，并重置position = limit - position。<br>WHY？这个position是什么意思？其实原因在于这个方法用于：我读了Me，position为2，此时我想开始写数据，但是我以后会在某个时间点回来继续读， 则position就变成4，以后不管你写了多少，都正好不会覆盖未读数据。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-2-1.png" alt></p><h2 id="2-3-Buffer-rewind"><a href="#2-3-Buffer-rewind" class="headerlink" title="2.3 Buffer.rewind()"></a>2.3 Buffer.rewind()</h2><p>用于position重置为0，即重新开始写，或者读</p><h2 id="2-4-Buffer-mark-和Buffer-reset"><a href="#2-4-Buffer-mark-和Buffer-reset" class="headerlink" title="2.4 Buffer.mark()和Buffer.reset()"></a>2.4 Buffer.mark()和Buffer.reset()</h2><p>mark默认为-1。 mark()：将当前position赋值给mark变量。<br>reset()：将mark赋值给position变量。</p><h2 id="2-5-Buffer-equals-和Buffer-compareTo"><a href="#2-5-Buffer-equals-和Buffer-compareTo" class="headerlink" title="2.5 Buffer.equals()和Buffer.compareTo()"></a>2.5 Buffer.equals()和Buffer.compareTo()</h2><p>相等的条件：类型相同、剩余的单位数量相同、剩余的单位类型相同。<br>比较的条件：第一个不相同的元素的大小，如果都相同，则看数量的多少。</p><h1 id="3-scatter与gather"><a href="#3-scatter与gather" class="headerlink" title="3 scatter与gather"></a>3 scatter与gather</h1><h2 id="3-1-scatter"><a href="#3-1-scatter" class="headerlink" title="3.1 scatter"></a>3.1 scatter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] byteBuffers = &#123;header, body&#125;;</span><br><span class="line">FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">channel.read(byteBuffers);</span><br></pre></td></tr></table></figure><p>不适用与动态消息，第一个Buffer被填充完毕之后才会填充第二个。</p><h2 id="3-2-gather"><a href="#3-2-gather" class="headerlink" title="3.2 gather"></a>3.2 gather</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] buffers = &#123;header, body&#125;;</span><br><span class="line">FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">channel.write(buffers);</span><br></pre></td></tr></table></figure><p>只会有position-limit的数据会被写入。</p><h1 id="4-Channel之间进行数据传输"><a href="#4-Channel之间进行数据传输" class="headerlink" title="4 Channel之间进行数据传输"></a>4 Channel之间进行数据传输</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile sourceFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"SourceData.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel sourceChannel = sourceFile.getChannel();</span><br><span class="line">RandomAccessFile targetFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"TargetData.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel targetChannel = targetFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = sourceChannel.size();</span><br><span class="line">targetChannel.transferFrom(sourceChannel, position, count);</span><br></pre></td></tr></table></figure><p>还有一个Channel.transferTo()方法，和上面的方法相反的作用。  </p><blockquote><p>目标文件如果本来大于源文件，目标文件只会被覆盖源文件要传输的数据，剩余的数据还会存在。 如果count传入的时候实际大于size，则被当做count，如果小于size，则会按小于的值覆盖。查看源码即可知。</p></blockquote><h1 id="5-Selector"><a href="#5-Selector" class="headerlink" title="5 Selector"></a>5 Selector</h1><h2 id="5-1-为什么使用Selector？"><a href="#5-1-为什么使用Selector？" class="headerlink" title="5.1 为什么使用Selector？"></a>5.1 为什么使用Selector？</h2><p>Selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。 这样一个单独的线程可以管理多个Channel，从而管理多个网络连接。<br>可以使用一个线程处理所有的通道，而对于操作系统来说，线程之间上下文切换的开销很大，Selector则是 可以处理多个Channel。</p><h2 id="5-2-Selector使用"><a href="#5-2-Selector使用" class="headerlink" title="5.2 Selector使用"></a>5.2 Selector使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Seletor</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// channel注册到selector</span></span><br><span class="line"><span class="comment">// 继承自AbstractSelectableChannel的方法</span></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>与Selector一起使用时，Channel必须处于费阻塞模式下，而FileChannel只能是阻塞模式，套接字可以切换。<br>监听的第二个参数是不同类型的事件：</p><ol><li>Connect：SelectionKey.OP_CONNECT</li><li>Accept：SelectionKey.OP_ACCEPT</li><li>Read：SelectionKey.OP_READ</li><li>Write：SelectionKey.OP_WRITE<br>监听多个事件：第二个参数输入：SelectionKey.OP_CONNECT | SelectionKey.OP_CONNECT</li></ol><h2 id="5-3-SelectionKey"><a href="#5-3-SelectionKey" class="headerlink" title="5.3 SelectionKey"></a>5.3 SelectionKey</h2><h3 id="5-3-1-interset属性"><a href="#5-3-1-interset属性" class="headerlink" title="5.3.1 interset属性"></a>5.3.1 interset属性</h3><p>其中包含了一些你感兴趣的属性，即注册的事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = (interestSet &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = (interestSet &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = (interestSet &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><h3 id="5-3-2-ready属性"><a href="#5-3-2-ready属性" class="headerlink" title="5.3.2 ready属性"></a>5.3.2 ready属性</h3><p>ready集合是通道已经准备九局的操作的集合，你可以通过int readySet = selectionKey.readyOps()进行分别的访问， 也可以使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p><h3 id="5-3-3-Selector获得Channel"><a href="#5-3-3-Selector获得Channel" class="headerlink" title="5.3.3 Selector获得Channel"></a>5.3.3 Selector获得Channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h3 id="5-3-4-附加的对象（可选）"><a href="#5-3-4-附加的对象（可选）" class="headerlink" title="5.3.4 附加的对象（可选）"></a>5.3.4 附加的对象（可选）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><h3 id="5-3-5-通过Selector选择通道"><a href="#5-3-5-通过Selector选择通道" class="headerlink" title="5.3.5 通过Selector选择通道"></a>5.3.5 通过Selector选择通道</h3><ol><li>int select() 该方法会让Selector阻塞，直到至少有一个Channel在你注册的事件上就绪。</li><li>int select(long timeout) 设置最长阻塞的毫秒数</li><li>int selectNow() 直接返回，无论什么Channel。<br>返回值表示从上次select()方法调用之后，又有多少符合要求的Channel，不叠加。</li></ol><h3 id="5-3-6-wakeUp"><a href="#5-3-6-wakeUp" class="headerlink" title="5.3.6 wakeUp()"></a>5.3.6 wakeUp()</h3><p>某个线程调用select()让某个Selector阻塞后，使用该方法可以立马返回，如果没有阻塞，但是提前调用了wakeUp方法， 那么下个调用select方法的线程会立即wake up。</p><h3 id="5-3-7-遍历SelectorKeys"><a href="#5-3-7-遍历SelectorKeys" class="headerlink" title="5.3.7 遍历SelectorKeys"></a>5.3.7 遍历SelectorKeys</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">Set selectionKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要手动将事件给移除</p><h2 id="5-4-完整的示例"><a href="#5-4-完整的示例" class="headerlink" title="5.4 完整的示例"></a>5.4 完整的示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> port = <span class="number">9999</span>; </span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>); </span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port)); </span><br><span class="line">Selector selector = Selector.open(); </span><br><span class="line">SelectionKey selKey = channel.register(selector, SelectionKey.OP_ACCEPT); </span><br><span class="line"><span class="keyword">int</span> interestSet = selKey.interestOps(); </span><br><span class="line"><span class="keyword">boolean</span> is_accept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</span><br><span class="line">System.out.print(<span class="string">"isAccept:"</span>+ is_accept);</span><br></pre></td></tr></table></figure><h1 id="6-FileChannel"><a href="#6-FileChannel" class="headerlink" title="6 FileChannel"></a>6 FileChannel</h1><p>文件通道，用于文件的读写，常用，由于FileChannel无法设置非阻塞模式，它总是运行在阻塞模式下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"112中国"</span>;</span><br><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(</span><br><span class="line">        <span class="string">"D:\\source\\eclipse\\liwen\\src\\main\\java\\liwen\\com\\io\\data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel channel = file.getChannel();</span><br><span class="line">channel.position(channel.position() + file.length());  <span class="comment">//这行代码设置写入文件的最后</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buffer.put(str.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有用于截取通道的方法：truncate()，以字节为单位。还有一个force()方法，用于强行将数据写入磁盘， 操作系统一般先将数据写入内存，再从内存写入磁盘，设置为True即可。</p><h1 id="7-SocketChannel"><a href="#7-SocketChannel" class="headerlink" title="7 SocketChannel"></a>7 SocketChannel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端连接，最后使用close关闭。</span></span><br><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="number">8989</span>));</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">channel.read(buffer);</span><br><span class="line"><span class="comment">// 从buffer中写入数据到channel</span></span><br><span class="line">String data = <span class="string">"what ? "</span>;</span><br><span class="line">buffer.clear();</span><br><span class="line">buffer.put(data.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h1 id="8-ServerSocketChannel"><a href="#8-ServerSocketChannel" class="headerlink" title="8 ServerSocketChannel"></a>8 ServerSocketChannel</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端开启监听：</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8777</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">// 如果设置为非阻塞，则上面的代码会立马返回，需要判空，是否有连接。</span></span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        String ip = serverSocketChannel.socket().getInetAddress().getHostAddress();</span><br><span class="line">        System.out.println(ip);</span><br><span class="line">        <span class="comment">// 此时你得到了channel，就可以使用Buffer对数据进行读取操作了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-DatagramChannel"><a href="#9-DatagramChannel" class="headerlink" title="9 DatagramChannel"></a>9 DatagramChannel</h1><p>用于UDP数据的发送和接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">channel.receive(buffer); <span class="comment">//将得到的UDP数据写入buffer中</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">String data = <span class="string">"中国"</span>;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buffer.put(data.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">channel.send(buffer, <span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h1 id="10-Pipe"><a href="#10-Pipe" class="headerlink" title="10 Pipe"></a>10 Pipe</h1><p>作为两个线程之间的单向数据连接连接（Channel本身是双向，但是通过两个双向的管道一起组合实现成一个单向的，即Sink-&gt;Source）<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-2-2.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向管道写数据</span></span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buffer.put(<span class="string">"中国人"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">    sinkChannel.write(buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从管道读数据</span></span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">buffer.clear();</span><br><span class="line">sourceChannel.read(buffer);</span><br></pre></td></tr></table></figure></p><h1 id="11-NIO和IO"><a href="#11-NIO和IO" class="headerlink" title="11 NIO和IO"></a>11 NIO和IO</h1><h2 id="11-1-面向流和面向缓冲"><a href="#11-1-面向流和面向缓冲" class="headerlink" title="11.1 面向流和面向缓冲"></a>11.1 面向流和面向缓冲</h2><p>IO面向流，每次从流中读取一个或多个字节，直至读取所有的字节，没有被缓存再任何地方，另外，也不能移动流中的数据， 如果想移动，需要手动将流中的数据缓存在一个第三方缓冲区变量中。而NIO则本身就将数据放入到缓冲区中，可以在缓冲区 中前后移动，只是加多了对缓冲区的判断以及更多数据进入缓冲区时，不能覆盖原来的数据。</p><h2 id="11-2-阻塞和非阻塞"><a href="#11-2-阻塞和非阻塞" class="headerlink" title="11.2 阻塞和非阻塞"></a>11.2 阻塞和非阻塞</h2><p>本质区别，IO在读写直接阻塞。而NIO的读写的操作会直接返回值，进入下一步操作不会阻塞，并通过Selector来实现一个线程 对多个Channel，即多个读写进行管理。</p><h2 id="11-3-数据的处理"><a href="#11-3-数据的处理" class="headerlink" title="11.3 数据的处理"></a>11.3 数据的处理</h2><p>IO的设计逐字节读取数据。例如你正在处理基于行的文本数据流：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-2-3.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>)));</span><br><span class="line">String nameLine   = reader.readLine();</span><br><span class="line">String ageLine    = reader.readLine();</span><br><span class="line">String emailLine  = reader.readLine();</span><br><span class="line">String phoneLine  = reader.readLine();</span><br></pre></td></tr></table></figure></p><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-2-4.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>).getChannel();</span><br><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buffer);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">    channel.read(buffer);</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure></p><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12 总结"></a>12 总结</h1><ol><li>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。  </li><li>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样， 如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-2-5.png" alt></li><li>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：<br><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-2-2-6.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、深入Web请求过程</title>
      <link href="/2017/08/03/deepknowjavaweb/1_web.html/"/>
      <url>/2017/08/03/deepknowjavaweb/1_web.html/</url>
      
        <content type="html"><![CDATA[<p><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/background/2018-12-16%E5%85%AC%E5%8F%B8%E7%A4%BC%E7%89%A9%E7%9B%92.jpg" alt></p><a id="more"></a><h1 id="1-DNS域名解析"><a href="#1-DNS域名解析" class="headerlink" title="1 DNS域名解析"></a>1 DNS域名解析</h1><p>使用浏览器输入网址后，浏览器会检查缓存对应的IP地址，如果没有，浏览器会查找操作系统，即host文件。 所以很多墙外比较慢的网址，可以手动编写host文件对应的IP地址以及对应的网址，可以加快访问速度。 如果实在没有就发送给LDNS，这个LDNS在不同的情况是不一样的，在学校，大部分都是学校的DNS服务器， 家庭的一般都是联通或者电信的DNS服务器，最最最后实在解析不出来，就抛给Root Server域名服务器， 它会返回给本地域名服务器的主域名服务器的地址，即域名空间提供商的域名解析服务器，就像阿里域名解析加速。</p><h1 id="2-清除缓存的域名"><a href="#2-清除缓存的域名" class="headerlink" title="2 清除缓存的域名"></a>2 清除缓存的域名</h1><p>主要在两个地方缓存：Local DNS Server, 另一个是用户的本机，当然，重启也是更好的方法。</p><p><code>ipconfig /flushdns</code></p><p>在java中，JVM也会缓存DNS的解析结果，分两种，即正确的解析结果，以及错误的解析结果，InetAddress，实际中 InetAddress 使用必须是单例模式，因为每次创建 InetAddress 实例都要进行一次完整的域名解析。</p><h1 id="3-CDN工作机制"><a href="#3-CDN工作机制" class="headerlink" title="3 CDN工作机制"></a>3 CDN工作机制</h1><p>CDN也就是内容分布网络(Content Delivery Network)。通过在现有的Internet中增加一层新的网络架构，比镜像更智能。 比喻：CDN=镜像Mirror+缓存Cache+整体负载均衡GSLB。 目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态页面等，用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech_1_1.png" alt="Web请求过程"></p><h1 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4 负载均衡"></a>4 负载均衡</h1><p>负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，提高服务器响应速度，实现地理位置无关性。 通常有三种负载均衡架构：链路负载均衡、集群负载均衡、操作系统负载均衡。</p><p>链路：用户最终访问哪个Web Server是由DNS Server来控制的，优点在于用户直接访问目标服务器，不需要经过其它的代理服务器，通常访问速度更快，缺点在于DNS在用户本地和LDNS都有缓存，一旦某台Web Server挂掉，就难及时更新用户的域名解析结构。<br>集群：硬件负载以及软件负载均衡，前者需要贵的硬件作为中心，而软件则是成本低，但是需要多次代理服务器转发，从而增加了网络延时。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech_1_2.png" alt="集群负载均衡"></p><p>操作系统：如设置多队列网卡。</p><h1 id="5-CDN动态加速"><a href="#5-CDN动态加速" class="headerlink" title="5 CDN动态加速"></a>5 CDN动态加速</h1><p>原理在于CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，通过DNS的调度将所有请求到选定的路径上回源，一个简单的原则就是在每个CDN节点上从源站下载一个一定大小文件，看哪个链路的总耗时最短，这样可以构成一个链路列表，然后绑定到DNS解析上，更新到CDN的Local DNS。以及网络成本等。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><ol><li>域名的请求处理</li><li>CDN=镜像Mirror+缓存Cache+整体负载均衡GSLB</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> 深入分析Java_Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>九、线程与同步的性能</title>
      <link href="/2017/01/18/java_performance_the_definitive_guide/9.html/"/>
      <url>/2017/01/18/java_performance_the_definitive_guide/9.html/</url>
      
        <content type="html"><![CDATA[<p>如何挖掘出 Java 线程和同步设施的最大性能</p><hr><h1 id="1-线程池与-ThreadPollExecutor"><a href="#1-线程池与-ThreadPollExecutor" class="headerlink" title="1 线程池与 ThreadPollExecutor"></a>1 线程池与 ThreadPollExecutor</h1><p>Java EE 应用服务器就是围绕用一个或多个线程池处理请求这一概念构建的：对服务器上 Servlet 的每个调用都是通过池中的线程处理的（也有可能不同）。类似的，其它应用可以使用 Java 的 ThreadPoolExecutor 并行执行任务。  </p><p>所有线程池的工作方法本质是一样的：有一个队列，任务被提交到这个队列中。（可以有不止一个队列，概念是一样的。）一定数量的线程会从该队列中取任务，然后执行。任务的结果可以发回客户端（比如应用服务器的情况下），或保存到数据库中。但是在执行完任务后，这个线程会返回任务队列，检索另一个任务并执行（如果没有更多任务要执行，该线程会等待下一个任务）。  </p><p>线程池有最小线程数和最大线程数。池中会有最小数目的线程随时待命，等待任务指派给它们。因为创建线程的成本非常高昂，这样可以提高任务提交时的整体性能。另一方面，线程需要一些系统次元，包括栈所需的原生内存，如果空闲线程太多，就会消耗本来可以分配给其它金恒的资源。  </p><blockquote><p>ThreadPoolExecutor 和相关的类将最小线程数称为核心池大小。</p></blockquote><h2 id="1-1-设置最大线程数"><a href="#1-1-设置最大线程数" class="headerlink" title="1.1 设置最大线程数"></a>1.1 设置最大线程数</h2><p>使用 CPU 的最大线程数</p><h2 id="1-2-设置最小线程数"><a href="#1-2-设置最小线程数" class="headerlink" title="1.2 设置最小线程数"></a>1.2 设置最小线程数</h2><p>也可称为初始线程数和核心线程数，尽量能做到刚好能满足基本的任务需要，同时，如果线程运行完任务后，他作为空闲线程需要保留 10~30 分钟，来应对可能的新任务。</p><blockquote><p>注意：线程局部变量</p></blockquote><h2 id="1-3-线程池任务大小"><a href="#1-3-线程池任务大小" class="headerlink" title="1.3 线程池任务大小"></a>1.3 线程池任务大小</h2><p>如果当前任务队列有 30,000 个任务，有 4 个 CPU 可用，执行一个任务需要 50 毫秒，则清空任务队列需要 6 分钟。当任务列队达到阈值，需要返回合理的错误。</p><h2 id="1-4-设置-ThreadPoolExecutor-的大小"><a href="#1-4-设置-ThreadPoolExecutor-的大小" class="headerlink" title="1.4 设置 ThreadPoolExecutor 的大小"></a>1.4 设置 ThreadPoolExecutor 的大小</h2><p>标准线程池：创建时准备最小数目的线程，来一个任务，并且当前所有的线程都在忙碌，则启动一个新线程，任务就立即执行。否则加入等待队列，如果队列满了，则拒绝。<br>ThreadPoolExecuter 表现则不同：</p><ol><li>SynchronousQueue<br>来一个任务则创建线程执行任务，没有等待队列。建议将最大线程数指定为一个非常大的值，同时任务是<br>完全 CPU 密集型最合适。</li><li>无界队列<br>如果 ThreadPoolExecutor 搭配的是无界队列（例如 LinkedBlockedingQueue，链表阻塞队列，默认   Integer.MAX，包括 take 操作和 put 操作，FIFO 队列）。</li><li>无界队列<br>有界队列，例如 ArrayBlockingQueue（FIFO）。  假如 coreThread 为 4，maxThread 为 8，用的 ArrayBlockingQueue 为 10。任务先占满 4 个 coreThread，接着占用 10 个 queue，最后才会启动 maxThread-coreThread 的 4 个线程。<blockquote><p>这个算法的背后理念在于：池大部分时间使用核心线程，只有当积压到一定的阈值后，才启动线程执行。</p></blockquote></li></ol><h1 id="2-ForkJoinPool"><a href="#2-ForkJoinPool" class="headerlink" title="2 ForkJoinPool"></a>2 ForkJoinPool</h1><p>  使用 fork 和 join 对任务进行分、并操作， 大任务变成两个小任务，由两个线程执行这两个小任务，另一个线程用于合并这两个任务的结果， 还有另一个特性是工作窃取：每个线程有自己的任务队列，当某个线程完成了自己的任务队列，就会执行另一个未执行完的任务队列的尾部任务。 </p><blockquote><p>Java 8 中使用了自动并行化的特性，用到的就是一个公共的 ForkJoinPool 实例，其中的 forEach 会并行的计算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = arrayList.parallelStream();</span><br><span class="line">stream.forEach(a -&gt; &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3 线程同步"></a>3 线程同步</h1><h2 id="3-1-线程的代价"><a href="#3-1-线程的代价" class="headerlink" title="3.1 线程的代价"></a>3.1 线程的代价</h2><p>同步的目的是保护对内存中的值的访问。变量有可能临时保存在寄存器中，这比直接在主内存中访问更高效。寄存器值对其它线程是不可见的，<br>而当一个线程离开某个同步块时，必须将任何修改的值刷新到主内存中。</p><h2 id="3-2-避免同步"><a href="#3-2-避免同步" class="headerlink" title="3.2 避免同步"></a>3.2 避免同步</h2><ol><li>使用线程局部变量 ThreadLocal</li><li>使用 CAS 无锁操作，atomic 包</li></ol><h2 id="3-3-伪共享"><a href="#3-3-伪共享" class="headerlink" title="3.3 伪共享"></a>3.3 伪共享</h2><ol><li>伪共享：加载内存时，同时会加载邻接的值，作为缓存行， 因此 会出现伪共享问题：当程序更新本地缓存中的某个值，需要通知其它核作废缓存行中的所有涉及的值，重新从缓存行中加载。</li><li>在 volatile  中问题比较突出， 频繁的修改 volatile  以及退出同步块的代码。</li><li>使用 @Contentded 进行宽度填充（ J默认情况下仅在 JVM 内部使用，Doug Lea 使用多余的变量进行宽度填充）</li></ol><h1 id="4-JVM-线程调优"><a href="#4-JVM-线程调优" class="headerlink" title="4 JVM 线程调优"></a>4 JVM 线程调优</h1><h2 id="4-1-调节线程栈大小"><a href="#4-1-调节线程栈大小" class="headerlink" title="4.1 调节线程栈大小"></a>4.1 调节线程栈大小</h2><p>64位机器默认线程栈大小为 1MB，栈的异常：StackOverflowError</p><blockquote><p>调节线程栈大小：<code>-Xss=256k</code></p></blockquote><h2 id="4-2-偏向锁"><a href="#4-2-偏向锁" class="headerlink" title="4.2 偏向锁"></a>4.2 偏向锁</h2><p>如果一个线程最近使用了某个锁，那么该线程下一次执行由同一把锁保护的代码所需的代码可能仍然保存在处理器的缓存中。使用对象头<br>的某个空间来记录该线程的  id，下次访问直接进入该锁。</p><h2 id="4-3-自旋锁"><a href="#4-3-自旋锁" class="headerlink" title="4.3 自旋锁"></a>4.3 自旋锁</h2><p> JVM 处理同步锁的竞争问题，有两种选择：</p><ol><li>死循环+检查该锁</li><li>将该线程放入线程等待池队列，在锁可用时通知该队列。</li></ol><p>而 JVM 会自动调整将线程从循环到通知队列的时间。</p><h1 id="5-监控线程与锁"><a href="#5-监控线程与锁" class="headerlink" title="5 监控线程与锁"></a>5 监控线程与锁</h1><h2 id="5-1-查看线程"><a href="#5-1-查看线程" class="headerlink" title="5.1 查看线程"></a>5.1 查看线程</h2><p>使用 Jstack、jcmd</p><blockquote><p>注意：JVM 只能在特定的位置（safepoint，安全点）转储出一个线程的栈，每次只能针对一个线程转储出栈的纤细。</p></blockquote><h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h1><ol><li>ThreadPollExecutor 三种队列</li><li>避免同步的两种方式：ThreadLocal、CAS</li><li>伪共享</li><li>偏向锁和自旋锁</li><li>使用死循环 +检查锁的状态、将线程放入线程池中来处理锁的竞争问题</li><li>jstack 命令</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java性能权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三四、Java 性能调优工具箱|JIT编译器：概述</title>
      <link href="/2017/01/10/java_performance_the_definitive_guide/3_4.html/"/>
      <url>/2017/01/10/java_performance_the_definitive_guide/3_4.html/</url>
      
        <content type="html"><![CDATA[<h1 id="0-CPU-使用率"><a href="#0-CPU-使用率" class="headerlink" title="0 CPU 使用率"></a>0 CPU 使用率</h1><p>使用 vmstat 命令查看 CPU 使用率，即 us\sy\id 三个参数，用户、系统、空闲使用 CPU 的时间。  </p><blockquote><ol><li>检查应用性能时，首先应该审查 CPU 时间（尤其是多线程，CPU 的上下文切换报告）</li><li>优化代码的目的是提升而不是降低（更短时间段内的）CPU 使用率。</li><li>在试图深入优化应用前，应该先弄清楚为何 CPU 使用率低。</li></ol></blockquote><h1 id="1-JIT-编译器"><a href="#1-JIT-编译器" class="headerlink" title="1 JIT 编译器"></a>1 JIT 编译器</h1><p>java文件-&gt;编译-&gt;class字节码文件-&gt;JVM编译解释成平台相关的二进制文件。<br><strong>而 JIT 编译器属于最后的 JVM 编译过程，也可以称为后端编译器，这样便于理解</strong>。<br>Java 应用汇被编译——但不是编译成特定 CPU 所专用的二进制代码，而是被编译成一种理想化的汇编语言（即 .class 字节码文件），它专用于 JVM 所执行。这个编译时在程序执行时进行的，即编译同时执行，（C 这种编译语言会先编译成 .o 或者 .obj 再执行），而 Java 是直接执行编译代码（JVM 执行）。Java 是一种半编译半解释语言（先编译成 .class，再让 JVM 解释成特定 CPU 的指令），而 Java 的表面直接执行其实内部 JVM 帮我们做了编译解释，不像 C 用户手动编译再执行，因为 C 的编译后的 .o 文件是针对特定的 CPU ，也许在下个 CPU 就需要重新编译了。参见：<a href="https://www.zhihu.com/question/21486706" target="_blank" rel="noopener">https://www.zhihu.com/question/21486706</a>  </p><p>由于编译成 .class 这个行为是在程序执行的时候进行的，因为被称为“即时编译”（即JIT，just in time）。你也可以先 javac 编译后，再 java 命令 执行。</p><h2 id="1-热点编译"><a href="#1-热点编译" class="headerlink" title="1.热点编译"></a>1.热点编译</h2><p>官方的 java 实现是 Oracle 的 HotSpot JVM。HotSpot 的名字来与它看待代码编译的方式。对于程序来说，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行得有多快。这些关键代码段被称为应用的热点，代码执行得越多就被认为是越热。  </p><p>因此 JVM 执行代码时，并不会立即编译代码。原因1：如果代码只执行一次，那编译完全就是浪费精力。对于只执行一次的代码，解释执行 Java 字节码比先编译然后执行的速度快。原因2：JVM 执行特定方法或者循环的次数越多，它就会越了解这段代码，使得 JVM 可以在编译代码时进行大量优化。  </p><p>例，<code>equals()</code> 方法，存在每个 Java 对象中，并且经常被子类重写。当解释器遇到 <code>b = obj1.equals(obj2)</code> 语句时，为了知道该执行哪个 <code>equals()</code> ，必须先查找 obj1 的类。这个动态查找的过程有点消耗时间。</p><blockquote><p>寄存器和主内存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterTest</span> </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">&gt;            sum += i;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>实例变量如果一直存在主内存中，但是从主内存获取数据是非常昂贵的操作，需要花费多个时钟周期才能完成，这样性能就会比较低，编译器就不会这么做，它会将 sum 的初始值装入寄存器，用寄存器中的值执行循环，然后（某个不确定时刻）将最终的结果从寄存器写回主内存。<br>使用寄存器是编译器普遍采用的优化方法，当开启逃逸分析（escape analysis）时，寄存器的使用更为频繁（详见本章尾）。</p></blockquote><p>比如，随着时间流逝， JVM 发现每次执行这条语句时，obj1 的类型都是 <code>java.lang.String</code>。于是 JVM 就可以生成直接调用 <code>String.equals()</code> 的编译代码。现在代码更快乐，不仅是因为被编译，也是因为跳过了查找该调用哪个方法的步骤。<br>不过没那么简单，下次执行代码时，obj1 完全有可能是别的类型而不是 <code>String</code> ，所以 JVM 必须生成编译代码处理这种可能，尽管如此，由于跳过了方法查找的步骤，这里的编译代码整体性能仍然要快（至少和 obj1 一直是 String时同样快）。这种优化只有在代码运行过一段时间观察它如何做之后才能使用：这是为何 JIT 编译器等待代码编译的第二个原因。</p><h1 id="2-调优入门：选择编译器类型（client-server或两者同用）"><a href="#2-调优入门：选择编译器类型（client-server或两者同用）" class="headerlink" title="2 调优入门：选择编译器类型（client/server或两者同用）"></a>2 调优入门：选择编译器类型（client/server或两者同用）</h1><p>有两种 JIT 编译器，client 和 server。两者编译器的最主要的差别在于编译代码的时机不同。<br>client 编译器开启编译比 server 编译器要早。意味着在代码执行的开始阶段，client 编译器比 server 编译器要快，因为它编译代码相比 server 编译器而言要多。<br>server 编译器等待编译的时候是否还能做更有价值的事：server 编译器在编译代码时可以更好地进行优化。最终，server 编译器生成的代码要比 client 编译器快。<br>此处的问题：为什么需要人来做这种选择？为什么 JVM 不能在启动用 client 编译器，然后随着代码变热使用 server 编译器？这种技术被称为<strong>分层编译</strong>。java7 的分层编译容易超出 JVM 代码缓存的大小，默认关闭。在 java8 分层编译默认为开启。<br>即时应用永远运行， server 编译器也不可能编译它的所有代码，但是任何程序都有一小部分代码很少执行，最好是编译这些代码——即便编译不是最好的方法——而不是以解释模式运行。</p><blockquote><p>对于长时间运行的应用来说，应该一直使用 server 编译器，最好配合分层编译器。</p></blockquote><h1 id="3-Java-和-JIT-编译器版本"><a href="#3-Java-和-JIT-编译器版本" class="headerlink" title="3 Java 和 JIT 编译器版本"></a>3 Java 和 JIT 编译器版本</h1><p>JIT 编译器有 3 种版本：  </p><ol><li>32位 client 编译器（-client）</li><li>32位 server 编译器（-server）</li><li>64位 server 编译器（-d64）</li></ol><h1 id="4-编译器中级调优"><a href="#4-编译器中级调优" class="headerlink" title="4 编译器中级调优"></a>4 编译器中级调优</h1><h2 id="1-调优代码缓存"><a href="#1-调优代码缓存" class="headerlink" title="1.调优代码缓存"></a>1.调优代码缓存</h2><p>JVM 编译代码时，会在代码缓存中保存编译之后的汇编语言指令集。代码缓存一旦填满，JVM 就不能编译更多代码了（只能解释执行其余代码了）。<br>但是，如果设置过多，例如设置代码缓存为 1GB，JVM 就会保留 1GB 的本地内存空间。然后这部分内存在需要时才会分配，但它仍然是保留的，这意味着为了满足保留内存，你的机器必须有足够的虚拟内存。<br>此外，如果是 32位 JVM，则进程占用的总内存不能超过 4GB。这包括 Java堆、JVM 自身所有嗲吗占用的空间（包括它的本地库和线程栈）、分配给应用的本地内存（或者 NIO 库的直接内存），当然还有代码缓存。<br>代码缓存： <code>-XX:ReservedCodeCacheSize=N</code> ，可以设置代码缓存的最大值。<br><img src="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/4_1.png" alt></p><h2 id="2-编译阈值"><a href="#2-编译阈值" class="headerlink" title="2.编译阈值"></a>2.编译阈值</h2><p>编译时基于两种 JVM 计数器的：方法调用计数器和方法中的循环回边计数器。回边实际上可看作是循环完成执行的次数。<br>JVM 执行某个 Java 方法时，会检查该方法的两种计数器总数，然后判定该方法是否适合编译。如果适合就进入编译队列。被称为标准编译。<br>如果循环真的很长——或因包含所有程序逻辑而永远不退出，JVM 不等方法被调用就会编译循环。所以循环每完成一轮，回边计数器就会增加并被检测。如果循环的回边计数器超过阈值，那这个循环（不是整个方法）就可以被编译。被称为栈上替换（On-Stack Replacement，OSR）。  </p><p>标准编译由： <code>-XX:CompileThreshold=N</code> 标志触发。</p><h1 id="5-高级编译器调优"><a href="#5-高级编译器调优" class="headerlink" title="5 高级编译器调优"></a>5 高级编译器调优</h1><p>前面说道，当方法（或循环）适合编译时，就会进入到编译队列。队列则由一个或多个后台线程处理。这是件好事，意味着编译过程是异步的，这使得即便是代码正在编译的时候，程序也能持续执行。如果是用标准编译所编译的方法，那下次调用该方法时就会执行编译后的方法；如果是用 OSR 编译的循环，那下次循环迭代时就会执行编译后的代码。  </p><p>编译队列并不严格遵守先进先出的原则：调用次数多的方法有更高的优先级（非公平更好使）。</p><h2 id="5-1-逃逸分析"><a href="#5-1-逃逸分析" class="headerlink" title="5.1 逃逸分析"></a>5.1 逃逸分析</h2><p>开启逃逸分析： <code>-XX:DoEscapeAnalysis</code>，默认为 true。server 编译器将会执行一些非常激进的优化措施，例如， for 循环中的新建变量，如果对象只在循环中引用，JVM 会毫不犹豫地对这个对象进行一系列优化。<br>包括，锁去除，值存储在寄存器而不是内存中，甚至不需要分配实际的对象，可以只追踪这个对象的个别字段。</p><h1 id="6-逆优化"><a href="#6-逆优化" class="headerlink" title="6 逆优化"></a>6 逆优化</h1><p>有两种逆优化的情形：代码状态分别为“made not entrant”（代码被丢弃）和“made zombie”（产生僵尸代码）时。  </p><h2 id="6-1-代码被丢弃"><a href="#6-1-代码被丢弃" class="headerlink" title="6.1 代码被丢弃"></a>6.1 代码被丢弃</h2><p>当一个接口有多重实现，在使用switch 进行工厂模式的创建时，可能上次的编译器内联，在下次就必须使用解释执行了，因为对象变了，要开始新的编译，而上次的编译代码就属于丢弃代码。<br>另一种情况就是，分层编译。先使用 client 编译，再使用 server 编译，那么在第二次编译时，第一次编译的一些代码就要被丢弃，属于丢弃代码。</p><h2 id="6-2-逆优化僵尸代码"><a href="#6-2-逆优化僵尸代码" class="headerlink" title="6.2 逆优化僵尸代码"></a>6.2 逆优化僵尸代码</h2><ol><li>逆优化使得编译器可以回到之前版本的编译代码。  </li><li>先前的优化不再有效时（例，所设计的对象类型发生了更改），才会发生代码逆优化。</li><li>代码逆优化时，会对性能产生一些小而短暂的影响。</li></ol><h1 id="7-小结"><a href="#7-小结" class="headerlink" title="7 小结"></a>7 小结</h1><ol><li>不用担心小方法，特别是 getter 和 setter ，因为它们很容易内联。编译器会修复这些问题。</li><li>需要编译的代码在编译队列中。队列中代码越多，程序达到最佳性能的时间越久。</li><li>虽然代码缓存的大小（也应该）调整，但它仍然是有限的资源。</li><li>代码越简单，优化越多。分析反馈和逃逸分析可以使代码更快，但复杂的循环结果和大方法限制了它的有效性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java性能权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、垃圾收集入门</title>
      <link href="/2017/01/10/java_performance_the_definitive_guide/5.html/"/>
      <url>/2017/01/10/java_performance_the_definitive_guide/5.html/</url>
      
        <content type="html"><![CDATA[<p>很多时候，我们没有机会重写代码，又要面临需要提高 Java 应用性能的压力，这种情况下对垃圾收集器的调优就变得至关重要。  </p><blockquote><ol><li>Serial 收集器（常用于单 CPU环境）。</li><li>Throughput（或者 Parallel）收集器。</li><li>Concurrent 收集器（CMS）。</li><li>G1 收集器。</li></ol></blockquote><hr><h1 id="1-垃圾收集概述"><a href="#1-垃圾收集概述" class="headerlink" title="1 垃圾收集概述"></a>1 垃圾收集概述</h1><p>简单来说，垃圾收集由两步构成：查找不再使用的对象，以及释放这些对象所管理的内存。 JVM 从查找不再使用的对象（垃圾对象）入手。有时，这也被称为查找不再有任何对象引用的对象（暗指采用“引用计数”的方式统计对象引用）。  </p><p>例，如下场景：一个程序要分配大小为 1000 字节的数组，紧接着又分配一个大小为 24 字节的数组，并在一个循环中持续进行这样的分配。最终程序会耗尽整个堆，结果如下图的<strong>第一行</strong>所示：堆空间被沾满，分配的数组间隔地分布于整个堆内：<br>![][1]<br>堆内存用尽会触发 JVM 回收不再使用的数组空间。假设所有大小为 24 字节的数组都不再被使用，而大小为 1000 字节的数组还继续使用，这样就形成了上图的<strong>第二行</strong>的场景。<br>虽然堆内部有足够的空闲空间，却找不到任何一个大于 24 字节的连续空间，除非 JVM 移动所有大小为 1000 字节的数组，让它们连续存储，把空闲的空间整合成一块更大的连续空间，供其他的内存分配使用（如上图的<strong>第三行</strong>）。  </p><p>而垃圾收集的性能就是由这些基本操作所决定的：找到不再使用的对象、回收它们使用的内存、对堆的内存布局进行压缩整理。完成这些操作时不同的收集器采用了不同的方法，这也是不同垃圾收起表现出不同性能特征的原因。<br>通常垃圾收集器自身往往也是多线程的。接下来的讨论中，我们从逻辑上将县城分成了两组，分别是应用程序线程和处理垃圾收集的线程。垃圾收集器回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。这一点在收集器移动对象时尤其重要：<strong>在操作过程中，对象的内存地址会发生变化，因此这个过程中任何应用线程都不应再访问该对象。</strong>  </p><p>所有应用线程都停止运行所产生的停顿被称为时空停顿（stop-the-world）。通常这些停顿对应用的性能影响对打，调优垃圾收集时，尽量减少这种停顿是最为关键的考量因素。</p><h2 id="1-1-分代垃圾收集器"><a href="#1-1-分代垃圾收集器" class="headerlink" title="1.1 分代垃圾收集器"></a>1.1 分代垃圾收集器</h2><p>虽然实现的细节千差万别，但所有的垃圾收集器都遵循了同一个方式，即根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步划分为不同的区段，分别称为 Eden 空间和 survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。  </p><p>新生代被填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其它地方。这种操作被称为 Minor GC。<br>采用这种设计有两个性能上的优势：  </p><ol><li>新生代仅是堆的一部分，这意味着应用线程停顿的时间更短。但是更加频繁。</li><li>对象分配与 Eden 空间，垃圾收集时，新生代空间被清空，Eden 空间的对象要么被移走，要么移动到另一个 Survivor 空间，要么被移动到老年代。这就相当于自动的进行了一次压缩整理。  </li></ol><p>所有的垃圾收集算法在对新生代回收时都存在“时空停顿”现象。  </p><p>JVM 需要找出老年代中不再使用的对象，并对它们进行回收。而这便是垃圾收集算法差异最大的地方。简单的：停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对对空间进行整理。这个过程称为 Full GC。这通常会导致应用线程长时间的停顿。  </p><p>另，通过更复杂的计算，我们还有可能在应用线程运行的同时找出不再使用的对象；<br>CMS 和 G1 收集器就是通过这种方式进行垃圾收集的。由于它们不需要停止应用线程就能找出不再用的对象， CMS 和 G1 收集器被称为 Concurrent 垃圾收集器。同时，由于它们将停止应用程序的可能降到了最小，也被称为低停顿（Low-Pause）收集器。Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。  </p><p>使用 CMS 和 G1 收集器时，应用程序经历的停顿会更少（也更短），代价是会消耗更多的 CPU。</p><blockquote><ol><li>所有的 GC 算法都将堆划分成了老年代和新生代。</li><li>所有的 GC 算法在清理新生代对象时，都使用了“时空停顿”（stop-the-world）方式的垃圾收集方法。</li></ol></blockquote><h2 id="1-2-GC-算法"><a href="#1-2-GC-算法" class="headerlink" title="1.2 GC 算法"></a>1.2 GC 算法</h2><p>JVM 提供了以下四种不同的垃圾收集算法。</p><h3 id="1-Serial-垃圾收集器"><a href="#1-Serial-垃圾收集器" class="headerlink" title="1.Serial 垃圾收集器"></a>1.Serial 垃圾收集器</h3><p>它是单线程清理堆的内容。使用 Serial 垃圾收集器，无论是进行 Minor GC 还是 Full GC ，清理堆空间时，所有的应用线程都会被暂停。</p><h3 id="2-Throughput-垃圾收集器"><a href="#2-Throughput-垃圾收集器" class="headerlink" title="2.Throughput 垃圾收集器"></a>2.Throughput 垃圾收集器</h3><p>Throughput 收集器是 Server 级虚拟机（多 CPU）的默认收集器。<br>使用多线程回收新生代空间， Minoc GC 的速度比使用 Serial 收集器快得多。处理老年代在 JDK7 之后默认也是多线程。因为其使用多线程，也被称为 Parallel 收集器。<br>在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。</p><h3 id="3-CMS-收集器"><a href="#3-CMS-收集器" class="headerlink" title="3.CMS 收集器"></a>3.CMS 收集器</h3><p>CMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。 CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。<br>它不使用 Throughput 的收集算法（-XX:+UseParallelGC），而是用新的算法（-XX:+UseParNewGC）来收集新生代对象。<br>它在 Full GC 不再暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。这种算法使 CMS 成为一个低延迟的收集器：应用线程只在 Minor GC 以后后台线程扫描老年代时发生极其短暂的停顿。<br>代价是额外的 CPU 使用率。而且后台线程不再进行任何压缩整理的工作，这意味着逐渐碎片化，碎片化一定程度， CMS 会降级为 Serial 收集器：暂停所有应用线程，使用单线程回收。之后再恢复到并发回收。（这种思想在写锁降级为读锁也有体现）。</p><h3 id="4-G1-收集器"><a href="#4-G1-收集器" class="headerlink" title="4.G1 收集器"></a>4.G1 收集器</h3><p>G1 垃圾收集器（垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4 GB）时产生的停顿。G1 收集算法将老年堆划分为若干个区域（Region），不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然采用暂停所有应用线程的方法，将存活对象移动到老年代或者 Survivor 空间，这也是多线程完成的。  </p><p>G1 收集器属于 Concurrent 收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。因此，使用G1 收集器的堆不大容易发生碎片化——虽然这种问题无法避免。  </p><blockquote><p>通常情况下垃圾收集是由 JVM 在需要的时候触发：新生代用尽时会触发 Minor GC，老年代用尽时会触发 Full GC，或者堆空间即将填满时会触发 Concurrent 垃圾收集。<br><code>System.gc()</code> 让应用程序强制进行 GC， Full GC。应用程序线程会因此而停顿相当长的一段时间。同时，调用这个方法也不会让应用程序更高效，它会让 GC 更早的开始，但那实际只是将性能的影响往后推迟而已。</p></blockquote><h1 id="2-GC-调优基础"><a href="#2-GC-调优基础" class="headerlink" title="2 GC 调优基础"></a>2 GC 调优基础</h1><h2 id="2-1-调整堆的大小"><a href="#2-1-调整堆的大小" class="headerlink" title="2.1 调整堆的大小"></a>2.1 调整堆的大小</h2><p>如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上。<br>如果分配的过于大也不行，GC 停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长，这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。还有一个风险是，操作系统使用虚拟内存机制管理机器的物理内存。一台机器可能有 8G 的物理内存，不过操作系统可能让你感觉有更多的可用内存。虚拟内存的数量取决于操作系统的设置，譬如操作系统可能让你感觉它的内存达到了 16G 。操作系统通过名为“交换”（swapping）（或者称之为分页，虽然两者技术存在差异）。你可以载入需要 16G 内存的应用程序，操作系统在需要时会将程序运行时不活跃的数据由内存复制到磁盘。再次需要这部分内存的内容时，操作系统再将它们由磁盘重新载入到内存（为了腾出空间，通常它会先将另一部分内存的内容复制到磁盘）。  </p><p>系统中运行着大量不同的应用程序时，这个流程工作的很顺畅，因为大多数的应用程序不会同时处于活跃状态。但是，对于 Java 应用，它工作得并不那么好。如果一个 Java 应用使用了这个系统上大约 12G 的堆，操作系统可能在 RAM 上分配了 8G 的堆空间，另外 4G 的空间存在于磁盘。这样操作系统需要将相当一部分的数据由磁盘交换到内存，而发生 Full GC 时，因为 JVM 必须访问整个堆的内容，如果系统发生内存交换，停顿时间会更长。  </p><p>堆的大小由 2 个参数值控制：初始值（-Xms）、最大值（-Xmx）。</p><h2 id="2-2-代空间的调整"><a href="#2-2-代空间的调整" class="headerlink" title="2.2 代空间的调整"></a>2.2 代空间的调整</h2><p>一旦堆的大小确定下来，JVM 就需要决定分配多少堆给新生代空间，多少给老年代空间。<br>必须清楚：如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少。但是老年代相对比较小，容易填满，会更频繁的触发 Full GC。  </p><ol><li>-XX:NewRatio=N：设置新生代与老年代的空间占用比率</li><li>-XX:NewSize=N：设置新生代空间的初始大小</li><li>-XX:MaxNewSize=N:设置新生代空间的最大大小</li><li>-XmnN：将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。</li></ol><h2 id="2-3-永久代和元空间的调整"><a href="#2-3-永久代和元空间的调整" class="headerlink" title="2.3 永久代和元空间的调整"></a>2.3 永久代和元空间的调整</h2><p>JVM 载入类的时候，它需要记录这些类的元数据。这部分数据被保存在一个单独的堆空间中。在 Java7 里，这部分空间被称为永久代（Permgen），在 Java8 中，它们被称为元空间（Metaspace）。<br>永久代和元空间并不完全一样。Java7 中永久代还保存了一些与类数据无关的杂项对象；这些对象在 Java8 中被挪到了普通的堆空间内。它们保存的信息只对编译器或者 JVM 的运行时有用。<br>通过 -XX:PermSize=N、-XX:MaxPerSize=N 来调整永久代大小。<br>通过 -XX:MetaspaceSize=N、-XX:MaxMetaspaceSize=N 来调整元空间的大小。  </p><p>调整这些区间会触发 Full GC ，所以是一种代价昂贵的操作。如果程序在启动时发生大量的 Full GC（因为需要载入数量巨大的类），通常都是由于永久代或者元空间发生了大小调整。</p><h1 id="3-垃圾回收工具"><a href="#3-垃圾回收工具" class="headerlink" title="3 垃圾回收工具"></a>3 垃圾回收工具</h1><p>开启 GC 的日志功能：使用 -verbose:gc 或 -XX:+PrintGC 的任意一个能创建基本的 GC 日志。使用 -XX:+PrintGCDetails 创建更详细的 GC 日志。</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h1><p>多说无益，多尝试。</p><p>![1]: <a href="http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png" target="_blank" rel="noopener">http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/Java_performance_definitive_guide/5_1.png</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java性能权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、性能测试方法</title>
      <link href="/2017/01/01/java_performance_the_definitive_guide/2.html/"/>
      <url>/2017/01/01/java_performance_the_definitive_guide/2.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原则1：测试真实应用"><a href="#1-原则1：测试真实应用" class="headerlink" title="1 原则1：测试真实应用"></a>1 原则1：测试真实应用</h1><p>应该在产品实际使用的环境中进行性能测试。</p><h2 id="1-1-微基准测试"><a href="#1-1-微基准测试" class="headerlink" title="1.1 微基准测试"></a>1.1 微基准测试</h2><h3 id="1-必须使用被测的结果"><a href="#1-必须使用被测的结果" class="headerlink" title="1. 必须使用被测的结果"></a>1. 必须使用被测的结果</h3><p>例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nLoops =  <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">double</span> l;</span><br><span class="line">    <span class="keyword">long</span> then = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class="line">        l = fibImpl1(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"Elapsed time:"</span> + (now - then));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">fibImpl1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be &gt; 0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>d;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>d;</span><br><span class="line">    <span class="keyword">double</span> d = fibImpl1(n - <span class="number">2</span>) + fibImpl1(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (Double.isInfinite(d)) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Overflow"</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的问题在于，它实际永远都不会改变程序的任何状态。因为斐波那契的计算结果从来没有被使用，所以编译器可以很放心地去除计算结果。智能的编译器（包括当前的 Java7 和 Java8）最终执行的以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> then = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"Elapsed time:"</span> + (now - then));</span><br></pre></td></tr></table></figure></p><p>解决在于，确保读取被测结果，而不只是简单地写。实际上，将局部变量 l 的定义改为实例变量（并用关键字 volatile 声明）就能测试这个方法的性能了。（必须声明 volatile 的原因参见第九章）。</p><h3 id="2-不要包括无关的操作"><a href="#2-不要包括无关的操作" class="headerlink" title="2. 不要包括无关的操作"></a>2. 不要包括无关的操作</h3><p>多余的循环迭代的多余的，如果编译器足够智能的话，就能发现这个问题，从而只执行一遍循环。<br>另外，fibImpl(1000) 的性能可能与 fibImpl(1) 相差很大。如果目的是为了比较不同实现的性能，测试的输入就应该考虑用一系列数据。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class="line">    l = fibImpl1(random.nextInteger());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，微基准测试中的输入值必须事先计算好。</p><h3 id="3-必须输入合理的参数"><a href="#3-必须输入合理的参数" class="headerlink" title="3. 必须输入合理的参数"></a>3. 必须输入合理的参数</h3><p>此时还有第三个隐患：任意选择的随机输入值对于这段被测代码的用法来说并不具有代表性，实际用户可能只输入 100 以下的值。输入参数大于 1476 时，会抛出异常，因为此时计算出的是 double 类所能表示的最大斐波那契数。考虑如下实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fibImplSlow</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be &gt; 0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1476</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Must be &lt; 1476"</span>);</span><br><span class="line">    <span class="keyword">return</span> verySlowImpl(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然很难想象会有比原先用递归更慢的实现，但我们假定有这个实现。通过大量输入值比较这两种实现（fibImplSlow 和 verySlowImpl），发现前者比后者快得多——仅仅因为在方法开始时进行了范围检查。<br>如果在真实场景中，用户只会传入小于 100 的值，那这个比较就是不正确的。（仅仅在原先的实现上添加了边界测试就使得性能变好，通常这是不可能的）。</p><blockquote><p>Java 的一个特点就是代码执行的越多性能越好，第四章详解。基于这点，微基准测试应该包括热身期，使得编译器能生成优化的代码。<br>微基准测试需要热身期，否则测量的是编译而不是被测代码的性能了。</p></blockquote><p>综上，正确的微基准测试代码可能是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> l;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nLoops;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] input;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FibonacciTest ft = <span class="keyword">new</span> FibonacciTest(Integer.parseInt(args[<span class="number">0</span>]));</span><br><span class="line">        ft.doTest(<span class="keyword">true</span>);</span><br><span class="line">        ft.doTest(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FibonacciTest</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nLoops = n;</span><br><span class="line">        input = <span class="keyword">new</span> <span class="keyword">int</span>[nLoops];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class="line">            input[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">boolean</span> isWarmup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> then = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLoops; i++) &#123;</span><br><span class="line">            l = fibImpl1(input[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isWarmup) &#123;</span><br><span class="line">            <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"Elapsed time:"</span> + (now - then));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">fibImpl1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be &gt; 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>d;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>d;</span><br><span class="line">        <span class="keyword">double</span> d = fibImpl1(n - <span class="number">2</span>) + fibImpl1(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Double.isInfinite(d)) <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Overflow"</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用 fibImpl1() 的循环和方法开销，将每个结果都写入 volatile 变量中的额外开销导致测量结果有出入。<br>此外还要留意编译效应：频繁调用的方法、调用时的栈深度、方法参数的实际类型等，它还依赖代码实际运行的环境。<br>这里的基准测试，有大量的循环，整体时间以秒计，但每轮循环迭代通常是纳秒级。纳秒累计起来，“极少成都”就会成为频繁出现的性能问题。<br>特别是在做回归测试的时候，追踪级别设为纳秒很有意义。如果集合操作每次都节约几纳秒，日积月累下来意义就很重大了（第十二章详解），但是，对于那些不频繁的操作来说，例，同时只需要处理一个请求的 servlet ，修复微基准测所发现的纳秒级性能衰弱就是浪费时间（<strong>后者才是过度优化！</strong>）。</p><h1 id="2-原则2：理解批处理流逝时间，吞吐量和响应时间"><a href="#2-原则2：理解批处理流逝时间，吞吐量和响应时间" class="headerlink" title="2 原则2：理解批处理流逝时间，吞吐量和响应时间"></a>2 原则2：理解批处理流逝时间，吞吐量和响应时间</h1><p>在客户端——服务器的吞吐量测试中，并不考虑客户端的思考时间。客户端向服务器发送请求，当它收到响应时，立刻发送新的请求。<br>指标常常被称为每秒事务数（TPS）、每秒请求数（RPS）、每秒操作数（OPS）。</p>]]></content>
      
      
      <categories>
          
          <category> 读书总结 </category>
          
          <category> Java性能权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八股文</title>
      <link href="/1970/01/01/tech/other_love/dead_knowledge.html/"/>
      <url>/1970/01/01/tech/other_love/dead_knowledge.html/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#知识梳理">知识梳理</a><ul><li><a href="#java-基础">Java 基础</a><ul><li><a href="#java-的异常有哪几种throwble-的子类有哪些">Java 的异常有哪几种？Throwble 的子类有哪些？</a></li><li><a href="#描述一下-java8-哪些新特性你是如何使用-stream-流操作的知道-stream-底层原理吗">描述一下 Java8 哪些新特性？你是如何使用 Stream 流操作的？知道 Stream 底层原理吗？</a></li><li><a href="#hashmap-和-hashset-的底层实现原理">HashMap 和 HashSet 的底层实现原理</a></li><li><a href="#死锁及打破方式互斥-请求与保持-循环等待-阻塞超时-银行家算法">死锁及打破方式；（互斥、请求与保持、循环等待、阻塞；超时、银行家算法）</a></li><li><a href="#线程协程blabla">线程&amp;协程；（blabla…）</a></li><li><a href="#阻塞-io-非阻塞-io-同步-io-异步-io-io-多路复用区别及内部流程-用户态内核态-blablabla">阻塞 IO、非阻塞 IO、同步 IO、异步 IO、IO 多路复用（区别及内部流程、用户态内核态 blablabla…）</a></li><li><a href="#请描述一下从浏览器输入一行请求-url-开始springmvc-的整个处理过程">请描述一下从浏览器输入一行请求 url 开始，SpringMVC 的整个处理过程</a></li><li><a href="#请求是先-filter-还是先经过-servletservlet-处理完后还会经过-filter-吗">请求是先 Filter 还是先经过 Servlet？Servlet 处理完后，还会经过 Filter 吗？</a></li><li><a href="#maven-是-compile-package-install-啥区别">maven 是 compile、package、install 啥区别</a></li></ul></li><li><a href="#2-并发基础">2. 并发基础</a><ul><li><a href="#1-公平锁和非公平锁的区别">1. 公平锁和非公平锁的区别</a></li><li><a href="#2-java-有哪些同步机制说一下-volatile-关键字">2. Java 有哪些同步机制？说一下 volatile 关键字</a></li><li><a href="#3-java-线程有几种状态">3. Java 线程有几种状态</a></li><li><a href="#4-说一下-sleep-和-wait-方法的区别">4. 说一下 sleep() 和 wait() 方法的区别</a></li><li><a href="#5-如何唤醒处于睡眠状态的线程">5. 如何唤醒处于睡眠状态的线程</a></li><li><a href="#6-如何释放处于等待中的线程">6. 如何释放处于等待中的线程</a></li><li><a href="#7-executor-创建的线程池有哪几种类型">7. Executor 创建的线程池，有哪几种类型？</a></li><li><a href="#8-executor-创建线程池的构造方法的参数都有哪些线程池的关闭线程池使用-interrupt-怎么样">8. Executor 创建线程池的构造方法的参数都有哪些，线程池的关闭，线程池使用 interrupt 怎么样？</a></li><li><a href="#9-corepoolsize-5maximumpoolsize-10那么现在有-4-个任务同时进来这时会创建几条线程如果还没处理完又进来-2-个任务此时又会创建几条线程还是不会创建">9. corePoolSize = 5，maximumPoolSize = 10，那么现在有 4 个任务同时进来，这时会创建几条线程？如果还没处理完又进来 2 个任务，此时又会创建几条线程还是不会创建？</a></li><li><a href="#10-还有哪些最原生最简单使用多线程的方法">10. 还有哪些最原生最简单使用多线程的方法？</a></li><li><a href="#11-blockqueue-原理condition-和普通-wait-的区别">11. blockqueue 原理，condition 和普通 wait 的区别</a></li><li><a href="#12-new-一个对象都经历了那几个过程考反射">12. new 一个对象都经历了那几个过程？（考反射）</a></li><li><a href="#13-锁膨胀过程和锁的优化">13. 锁膨胀过程和锁的优化</a></li></ul></li><li><a href="#3-消息基础">3. 消息基础</a><ul><li><a href="#在哪里使用过消息队列不使用消息队列可以吗使用过哪些消息队列有哪些优劣势顺序性如何保证事务消息如何保证消息重复了怎么办消息丢失了怎么办-消息队列的常见解决方案消息队列引入之后的缺点mq-挂了怎么办">在哪里使用过消息队列？不使用消息队列可以吗？使用过哪些消息队列？有哪些优劣势？（顺序性如何保证？事务消息如何保证？消息重复了怎么办？消息丢失了怎么办-&gt; 消息队列的常见解决方案：）消息队列引入之后的缺点？MQ 挂了怎么办？</a></li><li><a href="#消息重复发送怎么办即幂等性">消息重复发送怎么办？（即幂等性）</a></li><li><a href="#消息丢失怎么办">消息丢失怎么办？</a></li><li><a href="#消息的顺序性保证">消息的顺序性保证</a></li><li><a href="#消息的延迟和消息积压的过期恢复">消息的延迟和消息积压的过期恢复？</a></li><li><a href="#消息位点重置原理">消息位点重置原理</a></li><li><a href="#事务消息原理">事务消息原理</a></li><li><a href="#如何设计一个消息中间件">如何设计一个消息中间件？</a></li><li><a href="#消息的重复处理">消息的重复处理</a></li><li><a href="#消息可靠性保证">消息可靠性保证</a></li></ul></li><li><a href="#搜索基础">搜索基础</a></li><li><a href="#springmybatis">Spring/Mybatis</a><ul><li><a href="#spring-如何加载注解">Spring 如何加载注解</a></li><li><a href="#spring-启动流程-bean-实例化">Spring 启动流程、bean 实例化</a></li><li><a href="#mybatis-如何防止-sql-穿透">MyBatis 如何防止 SQL 穿透</a></li><li><a href="#spring-的-postprocessor-接口起到什么作用">Spring 的 PostProcessor 接口起到什么作用</a></li><li><a href="#spring-如何实现事务">Spring 如何实现事务</a></li><li><a href="#如何在-bean-对象中获取-apllicationcontext-上下文对象">如何在 Bean 对象中获取 ApllicationContext 上下文对象？</a></li><li><a href="#动态代理有哪些jdk-动态代理和-cglib-有什么不同">动态代理有哪些？JDK 动态代理和 cglib 有什么不同？</a></li><li><a href="#为什么用-spring-data-jpa-而不用-mybatismq-的选型-注册中心的选型-配置中心的选型-分库分表的选型-数据传输的选型主要针对我的项目来问的">为什么用 Spring data JPA 而不用 MyBatis，MQ 的选型、注册中心的选型、配置中心的选型、分库分表的选型、数据传输的选型（主要针对我的项目来问的）</a></li></ul></li><li><a href="#6-rpc-框架">6. RPC 框架</a><ul><li><a href="#1-dubbo序列化默认的序列化各个序列化区别">1. Dubbo序列化，默认的序列化，各个序列化区别</a></li><li><a href="#2-dubbo泛化调用实现的网关优劣点">2. Dubbo泛化调用实现的网关优劣点</a></li><li><a href="#3-dubbo-消费者到提供者执行涉及的模块">3. Dubbo 消费者到提供者执行涉及的模块</a></li><li><a href="#4-dubbo-spi">4. Dubbo SPI</a></li><li><a href="#5-spring-cloud-的-eureka">5. Spring Cloud 的 Eureka</a></li></ul></li><li><a href="#7-jvm-基础">7. JVM 基础</a><ul><li><a href="#jvm-内存结构介绍-代码调用过程中的内存流程">jvm 内存结构介绍、代码调用过程中的内存流程</a></li><li><a href="#java-如何分配内存多线程呢">Java 如何分配内存，多线程呢？</a></li><li><a href="#jvm-的内存模型">JVM 的内存模型</a></li><li><a href="#类加载机制">类加载机制</a></li><li><a href="#oom-定位-解决方式流程">OOM 定位、解决方式，流程</a></li><li><a href="#gc-算法-扫描算法优劣-内存分区">gc 算法、扫描算法（优劣）、内存分区</a></li><li><a href="#jvm-中如何扫描对象root-hotspot-算法-cardtable">JVM 中如何扫描对象；（root、hotspot 算法)、cardTable）</a></li><li><a href="#gc-算法复制-标记清除-标记整理-内存碎片及解决方式">GC 算法（复制、标记清除、标记整理、内存碎片及解决方式）</a></li><li><a href="#gc-异常">GC 异常</a></li><li><a href="#什么情况下类被初始化什么情况下类不会被初始化">什么情况下类被初始化，什么情况下类不会被初始化</a></li></ul></li><li><a href="#8-缓存基础">8. 缓存基础</a><ul><li><a href="#1-你在公司怎么用的缓存为什么用缓存那会出现什么问题缓存击穿-穿透-雪崩">1. 你在公司怎么用的缓存，为什么用缓存？那会出现什么问题（缓存击穿、穿透、雪崩）？</a></li><li><a href="#2-redis-为什么这么快它的过期和淘汰策略是什么以及手写一个-lru-算法">2. Redis 为什么这么快，它的过期和淘汰策略是什么以及手写一个 LRU 算法</a></li><li><a href="#3-redis-高并发和高可用的集群原理">3. Redis 高并发和高可用的集群原理</a></li><li><a href="#4-redis-持久化机制-底层原理是什么有什么优劣">4. Redis 持久化机制、底层原理是什么，有什么优劣？</a></li><li><a href="#5-集群中-redis-key-如何寻址寻址算法hash-一致性算法">5. 集群中 Redis key 如何寻址，寻址算法？hash 一致性算法</a></li><li><a href="#6-缓存-数据库双写不一致问题">6. 缓存、数据库双写不一致问题</a></li><li><a href="#7-redis-并发写的问题即顺序问题">7. Redis 并发写的问题，即顺序问题</a></li><li><a href="#8-公司的-redis-架构多少台多少内存多少核cpu主从架构qps">8. 公司的 Redis 架构，多少台，多少内存，多少核，CPU，主从架构，QPS？</a></li><li><a href="#9-热点-key-的缓存以及大对象的缓存问题解决">9. 热点 key 的缓存，以及大对象的缓存问题解决。</a></li><li><a href="#10-redis-pipline-是全双工还是半双工">10. Redis pipline 是全双工还是半双工</a></li><li><a href="#11-jedis-是否使用连接池如何处理有序数据">11. jedis 是否使用连接池，如何处理有序数据</a></li><li><a href="#12-redis-数据结构类型及源码简述">12. Redis 数据结构类型及源码简述；</a></li><li><a href="#string-hash-zset-set-dict-geo-hyperloglog-bloomfilter-stream-bitmap-等">（String、Hash、ZSet、Set、Dict、GEO、HyperLogLog、BloomFilter、Stream、Bitmap 等）</a></li><li><a href="#13-redis-并发竞争-key-问题">13. Redis 并发竞争 Key 问题</a></li><li><a href="#14-redis-replication-全量复制过程">14. Redis Replication 全量复制过程</a></li><li><a href="#15-redis-sentinel-机制">15. Redis sentinel 机制</a></li><li><a href="#16-redis-的数据丢失和脑裂问题">16. Redis 的数据丢失和脑裂问题</a></li><li><a href="#17-redis-实现分布式锁的几种方式优劣">17. Redis 实现分布式锁的几种方式，优劣</a></li><li><a href="#18-redis-分片">18. Redis 分片</a></li><li><a href="#19-sentinel-的作用以及选举-slave-为-master-过程">19. sentinel 的作用，以及选举 slave 为 master 过程</a></li></ul></li><li><a href="#9-数据库">9. 数据库</a><ul><li><a href="#1-mysql-索引类型有多少种">1. MySQL 索引类型有多少种</a></li><li><a href="#2-mysql-索引的使用与优化">2. MySQL 索引的使用与优化</a></li><li><a href="#3-mybatis-是如何执行-sql-语句的">3. MyBatis 是如何执行 SQL 语句的</a></li><li><a href="#4-jdbc-获取数据库连接的大概过程从-getconnection-开始">4. JDBC 获取数据库连接的大概过程（从 getConnection 开始）</a></li><li><a href="#5-preparedstatement-和-statement-区别">5. PreparedStatement 和 Statement 区别</a></li><li><a href="#6-mybatis-的一些-api-接口比如-sqlsession-sessionfactory-等等">6. MyBatis 的一些 API 接口，比如 SqlSession、sessionFactory 等等</a></li><li><a href="#7-线上为什么用-rr-级别">7. 线上为什么用 RR 级别</a></li><li><a href="#8-请问是不是每次连接数据库都创建一个连接线程池你都有哪些了解有接触过哪些线程池">8. 请问是不是每次连接数据库都创建一个连接？线程池你都有哪些了解？有接触过哪些线程池？</a></li><li><a href="#9-数据库联表查询时左连接和右连接的区别">9. 数据库联表查询时，左连接和右连接的区别</a></li><li><a href="#10-说说-mysql-的七种事务隔离级别">10. 说说 MySQL 的七种事务隔离级别</a></li><li><a href="#11-mvcc">11. MVCC</a></li></ul></li><li><a href="#10-apm">10. APM</a><ul><li><a href="#1-skywalking-基本架构">1. skywalking 基本架构</a></li></ul></li><li><a href="#分布式理论">分布式理论</a><ul><li><a href="#云原生是什么">云原生是什么</a></li><li><a href="#一致性-hash-算法详解">一致性 Hash 算法详解</a></li></ul></li><li><a href="#项目实战">项目实战</a><ul><li><a href="#你是通过什么方式进行学习的">你是通过什么方式进行学习的？</a></li><li><a href="#随便讲个源码组件源码结构及内部核心原理">随便讲个源码组件源码结构及内部核心原理</a></li><li><a href="#自己技术发展方向">自己技术发展方向</a></li><li><a href="#读过什么组件源码-redis-jvm-mybatis-spring-及相关基本都读过-sharding-jdbc-等">读过什么组件源码 Redis、JVM、MyBatis、Spring 及相关基本都读过、sharding-jdbc 等）</a></li><li><a href="#看什么书">看什么书</a></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="Java-的异常有哪几种？Throwble-的子类有哪些？"><a href="#Java-的异常有哪几种？Throwble-的子类有哪些？" class="headerlink" title="Java 的异常有哪几种？Throwble 的子类有哪些？"></a>Java 的异常有哪几种？Throwble 的子类有哪些？</h3><p>((20200916194439-4h97y6o “异常”))</p><h3 id="描述一下-Java8-哪些新特性？你是如何使用-Stream-流操作的？知道-Stream-底层原理吗？"><a href="#描述一下-Java8-哪些新特性？你是如何使用-Stream-流操作的？知道-Stream-底层原理吗？" class="headerlink" title="描述一下 Java8 哪些新特性？你是如何使用 Stream 流操作的？知道 Stream 底层原理吗？"></a>描述一下 Java8 哪些新特性？你是如何使用 Stream 流操作的？知道 Stream 底层原理吗？</h3><p>Java8 支持如下特性：</p><ol><li>Lambda 表达式和函数式接口，<a href="/FunctionalInterface">@FunctionalInterface </a> 修饰的接口只能由一个函数的接口，不包括默认方法和静态方法 </li><li>接口支持默认方法和静态方法</li><li>方法引用，支持四种 类型引用：构造器引用（<strong>Class::new</strong>）、静态方法引用（<strong>Class::static_method</strong>）、类的成员方法引用（<strong>Class::method</strong>）、实例的成员方法引用（<strong>instance::method</strong>）。示例如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scratch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造器引用</span></span><br><span class="line">        Car car = Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">        List&lt;Car&gt; list = Arrays.asList(car);</span><br><span class="line">        <span class="comment">// 静态方法引用，入参为自己</span></span><br><span class="line">        list.forEach(Car::collide);</span><br><span class="line">        <span class="comment">// 类的成员方法的引用，没有入参</span></span><br><span class="line">        list.forEach(Car::repair);</span><br><span class="line">        <span class="comment">// 实例对象的成员方法的引用，入参为自己</span></span><br><span class="line">        Car car2 = Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">        list.forEach(car2::follow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collided "</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Following the "</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>支持重复注解</li><li>可以获取参数名称，需要编译增加 -parameters 参数，可以在 maven 的 compile 过程增加该参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// javac -parameters Java8Test.java</span></span><br><span class="line">    <span class="comment">// java scratch 输出 args，不带 -parameters 参数则输出 arg0</span></span><br><span class="line">    Method method = scratch.class.getMethod( <span class="string">"main"</span>, String[].class );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">final</span> Parameter parameter: method.getParameters() ) &#123;</span><br><span class="line">        System.out.println( <span class="string">"Parameter: "</span> + parameter.getName() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Optional、Streams、Date/Time API、并行数组</li><li>ConcurrentHashMap（((20200930172816-sf88c8v “ConcurrentHashMap 的实现原理与使用”))）、concurrentForkJoinPool、StampedLock（((20200925172739-4h7jrms “StampedLock 详解”))）、原子变量（((20200925175233-ur4xqzv “原子变量详解”))）</li><li>类依赖分析工具 jdeps</li><li>Metaspace 代替 PermGen space（((20200925231449-p5eetg4 “JVM 运行机制”))）</li></ol><p>详情参考：((20201005234154-te3yj73 “Java8 的新特性”))</p><h3 id="HashMap-和-HashSet-的底层实现原理"><a href="#HashMap-和-HashSet-的底层实现原理" class="headerlink" title="HashMap 和 HashSet 的底层实现原理"></a>HashMap 和 HashSet 的底层实现原理</h3><ol><li>put 过程</li><li>get 过程，其中的效率红黑树优化</li><li>hash 过程</li><li>resize 过程，其中的死锁问题</li></ol><p>((20200915004102-t3x94b1 “5.1 HashMap”))</p><h3 id="死锁及打破方式；（互斥、请求与保持、循环等待、阻塞；超时、银行家算法）"><a href="#死锁及打破方式；（互斥、请求与保持、循环等待、阻塞；超时、银行家算法）" class="headerlink" title="死锁及打破方式；（互斥、请求与保持、循环等待、阻塞；超时、银行家算法）"></a>死锁及打破方式；（互斥、请求与保持、循环等待、阻塞；超时、银行家算法）</h3><h3 id="线程-amp-协程；（blabla…）"><a href="#线程-amp-协程；（blabla…）" class="headerlink" title="线程&amp;协程；（blabla…）"></a>线程&amp;协程；（blabla…）</h3><h3 id="阻塞-IO、非阻塞-IO、同步-IO、异步-IO、IO-多路复用（区别及内部流程、用户态内核态-blablabla…）"><a href="#阻塞-IO、非阻塞-IO、同步-IO、异步-IO、IO-多路复用（区别及内部流程、用户态内核态-blablabla…）" class="headerlink" title="阻塞 IO、非阻塞 IO、同步 IO、异步 IO、IO 多路复用（区别及内部流程、用户态内核态 blablabla…）"></a>阻塞 IO、非阻塞 IO、同步 IO、异步 IO、IO 多路复用（区别及内部流程、用户态内核态 blablabla…）</h3><h3 id="请描述一下从浏览器输入一行请求-url-开始，SpringMVC-的整个处理过程"><a href="#请描述一下从浏览器输入一行请求-url-开始，SpringMVC-的整个处理过程" class="headerlink" title="请描述一下从浏览器输入一行请求 url 开始，SpringMVC 的整个处理过程"></a>请描述一下从浏览器输入一行请求 url 开始，SpringMVC 的整个处理过程</h3><p>DispatcherServlet 调用 handlermapper，根据 url 映射到 controller 处理器。最后通过参数解析，返回包装到 view。</p><h3 id="请求是先-Filter-还是先经过-Servlet？Servlet-处理完后，还会经过-Filter-吗？"><a href="#请求是先-Filter-还是先经过-Servlet？Servlet-处理完后，还会经过-Filter-吗？" class="headerlink" title="请求是先 Filter 还是先经过 Servlet？Servlet 处理完后，还会经过 Filter 吗？"></a>请求是先 Filter 还是先经过 Servlet？Servlet 处理完后，还会经过 Filter 吗？</h3><p>拦截器是全局生效，包括静态资源也拦截，常用于字符串编码，cros 拦截</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929870-aef77b9e-a680-4269-925e-3b7176b31b63.png#align=left&amp;display=inline&amp;height=1130&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1130&amp;originWidth=2112&amp;size=0&amp;status=done&amp;style=none&amp;width=2112" alt></p><h3 id="maven-是-compile、package、install-啥区别"><a href="#maven-是-compile、package、install-啥区别" class="headerlink" title="maven 是 compile、package、install 啥区别"></a>maven 是 compile、package、install 啥区别</h3><p>他们属于同一个生命周期，一共三生命周期：clean、defaul、site。其中 compile 是编译代码、package 是打成包到当前 target 目录，install 是将包上传到本地仓库</p><h2 id="2-并发基础"><a href="#2-并发基础" class="headerlink" title="2. 并发基础"></a>2. 并发基础</h2><h3 id="1-公平锁和非公平锁的区别"><a href="#1-公平锁和非公平锁的区别" class="headerlink" title="1. 公平锁和非公平锁的区别"></a>1. 公平锁和非公平锁的区别</h3><p>非公平锁进来时先进行 state 的 CAS 公平锁要判断是否有线程在队列中等待</p><p>非公平锁 CAS 失败后，执行 tryAcquire 时，没有判断线程队列是否有等待，直接再进行 state 的 CAS，如果失败后，再和公平锁一样，进队列等前节点唤醒</p><h3 id="2-Java-有哪些同步机制？说一下-volatile-关键字"><a href="#2-Java-有哪些同步机制？说一下-volatile-关键字" class="headerlink" title="2. Java 有哪些同步机制？说一下 volatile 关键字"></a>2. Java 有哪些同步机制？说一下 volatile 关键字</h3><p>ReentrantLock、Synchronized、volatile、final、wait/notify、Semaphore、Condition</p><p>同步要求保证：有序性、可见性、原子性。其中 volatile 保证了可见性和原子性。</p><h3 id="3-Java-线程有几种状态"><a href="#3-Java-线程有几种状态" class="headerlink" title="3. Java 线程有几种状态"></a>3. Java 线程有几种状态</h3><ol><li>New</li><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>timed_waiting</li><li>terminated</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929893-806377e5-1b10-44fd-be82-6527d17da84d.png#align=left&amp;display=inline&amp;height=1420&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1420&amp;originWidth=2064&amp;size=0&amp;status=done&amp;style=none&amp;width=2064" alt></p><h3 id="4-说一下-sleep-和-wait-方法的区别"><a href="#4-说一下-sleep-和-wait-方法的区别" class="headerlink" title="4. 说一下 sleep() 和 wait() 方法的区别"></a>4. 说一下 sleep() 和 wait() 方法的区别</h3><ol><li>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁</li><li>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去</li><li>Thread.sleep()到时间了会自动唤醒，然后继续执行</li><li>Object.wait()不带时间的，需要另一个线程使用 Object.notify()唤醒</li><li>Object.wait()带时间的，假如没有被 notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁</li></ol><h3 id="5-如何唤醒处于睡眠状态的线程"><a href="#5-如何唤醒处于睡眠状态的线程" class="headerlink" title="5. 如何唤醒处于睡眠状态的线程"></a>5. 如何唤醒处于睡眠状态的线程</h3><p>通过 interrupt 方式</p><h3 id="6-如何释放处于等待中的线程"><a href="#6-如何释放处于等待中的线程" class="headerlink" title="6. 如何释放处于等待中的线程"></a>6. 如何释放处于等待中的线程</h3><p>notify</p><h3 id="7-Executor-创建的线程池，有哪几种类型？"><a href="#7-Executor-创建的线程池，有哪几种类型？" class="headerlink" title="7. Executor 创建的线程池，有哪几种类型？"></a>7. Executor 创建的线程池，有哪几种类型？</h3><ol><li>newCachedThreadPool：0，MAX，60，SynchronousQueue</li><li>newFixedThreadPool：core，core，0，LinkedBlockingQueue</li><li>newScheduledThreadPool：core，MAX，0，DelayedWorkQueue</li><li>newSingleThreadExecutor：1，1，0，LinkedBlockingQueue</li><li>newWorkStealingPool：parallelism，asyncMode ? FIFO_QUEUE : LIFO_QUEUE</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929901-042c4dba-9b8f-4372-a39a-603afdc9cab6.png#align=left&amp;display=inline&amp;height=998&amp;margin=%5Bobject%20Object%5D&amp;originHeight=998&amp;originWidth=1342&amp;size=0&amp;status=done&amp;style=none&amp;width=1342" alt></p><p>((20200919140157-d41qw7t “线程池”))</p><h3 id="8-Executor-创建线程池的构造方法的参数都有哪些，线程池的关闭，线程池使用-interrupt-怎么样？"><a href="#8-Executor-创建线程池的构造方法的参数都有哪些，线程池的关闭，线程池使用-interrupt-怎么样？" class="headerlink" title="8. Executor 创建线程池的构造方法的参数都有哪些，线程池的关闭，线程池使用 interrupt 怎么样？"></a>8. Executor 创建线程池的构造方法的参数都有哪些，线程池的关闭，线程池使用 interrupt 怎么样？</h3><p>core, max, keepalive, timeunit, blockqueue, threadfactory, rejecthandler</p><h3 id="9-corePoolSize-5，maximumPoolSize-10，那么现在有-4-个任务同时进来，这时会创建几条线程？如果还没处理完又进来-2-个任务，此时又会创建几条线程还是不会创建？"><a href="#9-corePoolSize-5，maximumPoolSize-10，那么现在有-4-个任务同时进来，这时会创建几条线程？如果还没处理完又进来-2-个任务，此时又会创建几条线程还是不会创建？" class="headerlink" title="9. corePoolSize = 5，maximumPoolSize = 10，那么现在有 4 个任务同时进来，这时会创建几条线程？如果还没处理完又进来 2 个任务，此时又会创建几条线程还是不会创建？"></a>9. corePoolSize = 5，maximumPoolSize = 10，那么现在有 4 个任务同时进来，这时会创建几条线程？如果还没处理完又进来 2 个任务，此时又会创建几条线程还是不会创建？</h3><p>不会创建。</p><p>创建 1 个。</p><h3 id="10-还有哪些最原生最简单使用多线程的方法？"><a href="#10-还有哪些最原生最简单使用多线程的方法？" class="headerlink" title="10. 还有哪些最原生最简单使用多线程的方法？"></a>10. 还有哪些最原生最简单使用多线程的方法？</h3><ol><li>继承 Thread</li><li>实现 Runnable</li><li>tiimer</li><li>future/callable</li></ol><h3 id="11-blockqueue-原理，condition-和普通-wait-的区别"><a href="#11-blockqueue-原理，condition-和普通-wait-的区别" class="headerlink" title="11. blockqueue 原理，condition 和普通 wait 的区别"></a>11. blockqueue 原理，condition 和普通 wait 的区别</h3><h3 id="12-new-一个对象都经历了那几个过程？（考反射）"><a href="#12-new-一个对象都经历了那几个过程？（考反射）" class="headerlink" title="12. new 一个对象都经历了那几个过程？（考反射）"></a>12. new 一个对象都经历了那几个过程？（考反射）</h3><p>new：</p><ol><li>new 关键字创建一个 Java 对象时，JVM 首先会检查这个 new 指令的参数能否在常量池中定位到一个类的符号引用</li><li>然后检查与这个符号引用相对应的类是否已经成功经历加载、解析和初始化等步骤，里面会对静态变量初始化，重新赋值</li><li>类完成装载步骤之后，就已经完全确定出创建对象实例时所需的内存空间大小，接下来 JVM 将会对其进行内存分配，以存储所生成的对象实例（分配可能在栈上分配，否则在堆上使用指针碰撞或空闲列表方式创建）</li><li>调用构造方法生成一个对象</li></ol><p>反射：</p><ol><li>class.forName()指定了 ClassLoader 后，就可以在指定的环境中查找某些类，即加载类可以在编译时不存在，运行时存在</li><li>实例</li></ol><h3 id="13-锁膨胀过程和锁的优化"><a href="#13-锁膨胀过程和锁的优化" class="headerlink" title="13. 锁膨胀过程和锁的优化"></a>13. 锁膨胀过程和锁的优化</h3><p>锁优化：自旋锁、锁粗化、锁消除、偏向锁和轻量级锁<br>偏向锁：</p><h2 id="3-消息基础"><a href="#3-消息基础" class="headerlink" title="3. 消息基础"></a>3. 消息基础</h2><h3 id="在哪里使用过消息队列？不使用消息队列可以吗？使用过哪些消息队列？有哪些优劣势？（顺序性如何保证？事务消息如何保证？消息重复了怎么办？消息丢失了怎么办-gt-消息队列的常见解决方案：）消息队列引入之后的缺点？MQ-挂了怎么办？"><a href="#在哪里使用过消息队列？不使用消息队列可以吗？使用过哪些消息队列？有哪些优劣势？（顺序性如何保证？事务消息如何保证？消息重复了怎么办？消息丢失了怎么办-gt-消息队列的常见解决方案：）消息队列引入之后的缺点？MQ-挂了怎么办？" class="headerlink" title="在哪里使用过消息队列？不使用消息队列可以吗？使用过哪些消息队列？有哪些优劣势？（顺序性如何保证？事务消息如何保证？消息重复了怎么办？消息丢失了怎么办-&gt; 消息队列的常见解决方案：）消息队列引入之后的缺点？MQ 挂了怎么办？"></a>在哪里使用过消息队列？不使用消息队列可以吗？使用过哪些消息队列？有哪些优劣势？（顺序性如何保证？事务消息如何保证？消息重复了怎么办？消息丢失了怎么办-&gt; 消息队列的常见解决方案：）消息队列引入之后的缺点？MQ 挂了怎么办？</h3><p>参考：</p><ol><li>MQ 的设计概要：<a href="https://zhuanlan.zhihu.com/p/21649950" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21649950</a>，这个地址搞通可以回答 80%。</li><li>还需要看其它的消息队列，进行优劣势对比。</li><li>rocketmq 的 example：<a href="http://rocketmq.apache.org/docs/transaction-example/" target="_blank" rel="noopener">http://rocketmq.apache.org/docs/transaction-example/</a></li></ol><p>答：短信使用过，我在钉钉开发的时候，审批通过回调需要调用短信项目来给审批人发送短信，实际调用的就是消息队列，放在消息队列中，等待短信中台去消费来实际发送短信。消息队列本身是用来解耦、异步和削峰。但是系统可用性就会降低，MQ 中间件挂掉怎么办？复杂性，重复数据和丢失数据的处理，幂等性。一致性，多个系统同时需要处理数据，如果只有某个系统失败，那么数据就会出现不一致。</p><blockquote><p>回答中透露出三个点：<br>解耦：如果不使用，你单独 A 系统对接 B、C 系统还要分别考虑重试机制。<br>异步：发送多个消息，快速返回，消息系统异步的执行任务。<br>削峰：A 业务系统只能接受每秒 5K 条消息，但是中午达到了 1W 条每秒，可以使用 MQ，接受 1W 条消息，然后 A 业务系统以每秒 5K 条消息慢慢进行消费，虽然会有消息堆积，但是不会持续时间很长</p></blockquote><p>我们用的 push 方式、使用过顺序消息、重置位点。</p><h3 id="消息重复发送怎么办？（即幂等性）"><a href="#消息重复发送怎么办？（即幂等性）" class="headerlink" title="消息重复发送怎么办？（即幂等性）"></a>消息重复发送怎么办？（即幂等性）</h3><p>例如 kafka 的重复消费场景<img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929915-0398573e-11e4-40d0-9922-14126c9a688a.png#align=left&amp;display=inline&amp;height=1192&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1192&amp;originWidth=2936&amp;size=0&amp;status=done&amp;style=none&amp;width=2936" alt></p><h3 id="消息丢失怎么办？"><a href="#消息丢失怎么办？" class="headerlink" title="消息丢失怎么办？"></a>消息丢失怎么办？</h3><p>现在你要设计一个广告计费，用户点击一次发送消息进行计费结算，如何保证？（涉及金额）</p><ol><li>生产者消息发送到 MQ 过程中由于网络问题， MQ 没收到，消息丢失。这需要发送消息的时候需要回调：MQ 收到了消息。</li><li>MQ 突然宕机停电，这需要开启持久化。（有可能还没持久化到磁盘就挂了）。</li><li>消费者消费到一半自己挂掉，MQ 以为消费已经被消费了。这需要消费者每次消费完之后手动发送消费成功的 ACK。</li><li>例如 kafka，消费者在写入数据到 broker 中，broker 的 leader 在同步该消息到 follower 时，自己挂掉，重新选举了 leader 就会导致之前的消息丢失。解决方案是每次只有 leader 同步到 follower 时，才会返回生产者消息发送成功！其中 kafka 的 topic 是有首领副本的概念。</li></ol><h3 id="消息的顺序性保证"><a href="#消息的顺序性保证" class="headerlink" title="消息的顺序性保证"></a>消息的顺序性保证</h3><p>例如 MySQL 主从同步，是通过 binlog 来实现，从数据库通过复制主数据库的 binlog 来同步，对一条记录进行增删改，对应生成了三个 binlog 有三条记录增删改，这时将 binlog 使用 MQ 发送，就需要保证顺序性。</p><ol><li>生产者生产消息于同一个 queue/partition：将需要保证顺序的消息发送在同一个 queue 中，这样消费者消费 queue 就会按照顺序消费。在 kafka 中就是一个 partition。</li><li>消费者消费消息：消费者使用多线程消费就会出现消费顺序不一致，因此消费者需要在消费的时候使用内存队列，例如订单的生成创建发送短信等顺序业务，可以在同一个内存队列中落盘。即使用内存队列 + 多线程来即保证了多线程性能也保证了消息的顺序性。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929965-3ad670f4-716e-4283-bd93-d5f4eb3ad3c3.png#align=left&amp;display=inline&amp;height=1114&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1114&amp;originWidth=2738&amp;size=0&amp;status=done&amp;style=none&amp;width=2738" alt></p><h3 id="消息的延迟和消息积压的过期恢复？"><a href="#消息的延迟和消息积压的过期恢复？" class="headerlink" title="消息的延迟和消息积压的过期恢复？"></a>消息的延迟和消息积压的过期恢复？</h3><p>几百万消息在 MQ 中积压了几小时怎么办？<br>这时候先让 3 个消费者恢复正常，然后再部署 10 倍的消费者专门消费 topic 为 consu 的消费，将 3 个消费者修改逻辑，让原来的消费者中转到 consu 中进行消费落盘，这样能快速的消费也不会对落盘数据库造成影响。<br>几百万消息在 MQ 中积压了几个小时，由于过期失效策略导致消息没了怎么办？<br>晚上凌晨在消息的源头补数据重新导入到 MQ 中。（不要设置过期失效策略）<br>几百万消息 在 MQ 快满了怎么办？<br>消费者快速消费，消费完就丢掉不做处理，然后再使用方案 2。或者导入到其它的 MQ 中进行中转消费。</p><h3 id="消息位点重置原理"><a href="#消息位点重置原理" class="headerlink" title="消息位点重置原理"></a>消息位点重置原理</h3><h3 id="事务消息原理"><a href="#事务消息原理" class="headerlink" title="事务消息原理"></a>事务消息原理</h3><h3 id="如何设计一个消息中间件？"><a href="#如何设计一个消息中间件？" class="headerlink" title="如何设计一个消息中间件？"></a>如何设计一个消息中间件？</h3><ol><li>支持分布式（可用性）</li><li>落盘顺序写（持久化）</li><li>消息多个副本，并使用 zk 做 leader follower</li><li>数据丢失，内部每次写都进行落盘（每秒）或者写入 MQ 就持久化</li><li>消息顺序性，使用单个线程。</li><li>消息堆积能力</li><li>两次 RPC + 消息存储。</li><li>计算存储分离</li><li>弹性扩容缩容</li><li>网络、存储、复制、高可用、刷盘、堆积、顺序、幂等、事务</li><li>元数据中心同步</li><li>生产者消费者模型设计（缓冲队列），推拉模式</li></ol><h3 id="消息的重复处理"><a href="#消息的重复处理" class="headerlink" title="消息的重复处理"></a>消息的重复处理</h3><ol><li>依赖 Exactly-once 语义，根据消息消费表 + 事务来做状态的更新，局限在于，如果有非 MySQL 操作或跨库就有问题，而且引入了事务</li><li>插入消息消费状态表，插入失败再稍后重试。</li><li>根据消息内容做重试（messageKey）。为了解决 md5 可能重复，messageKey 为 topic+tag+md5(body)做 Redis 锁一段时间，我们是锁两天，方便重置位点和解决问题的时间</li><li>机器重启过程的消息重复几率很大，因此需要在 bean 初始化后启动 consumer，bean 销毁前关停 consumer。producer 直接在 initmethod 使用 init/destory 即可。</li></ol><h3 id="消息可靠性保证"><a href="#消息可靠性保证" class="headerlink" title="消息可靠性保证"></a>消息可靠性保证</h3><p>数据幂等、高可用镜像集群、Confirm 机制、事务机制、持久性</p><h2 id="搜索基础"><a href="#搜索基础" class="headerlink" title="搜索基础"></a>搜索基础</h2><h2 id="Spring-Mybatis"><a href="#Spring-Mybatis" class="headerlink" title="Spring/Mybatis"></a>Spring/Mybatis</h2><h3 id="Spring-如何加载注解"><a href="#Spring-如何加载注解" class="headerlink" title="Spring 如何加载注解"></a>Spring 如何加载注解</h3><h3 id="Spring-启动流程、bean-实例化"><a href="#Spring-启动流程、bean-实例化" class="headerlink" title="Spring 启动流程、bean 实例化"></a>Spring 启动流程、bean 实例化</h3><h3 id="MyBatis-如何防止-SQL-穿透"><a href="#MyBatis-如何防止-SQL-穿透" class="headerlink" title="MyBatis 如何防止 SQL 穿透"></a>MyBatis 如何防止 SQL 穿透</h3><p>使用 # 而不是 $，底层使用 PreparedStatement，基于 SQL 预编译的替换</p><h3 id="Spring-的-PostProcessor-接口起到什么作用"><a href="#Spring-的-PostProcessor-接口起到什么作用" class="headerlink" title="Spring 的 PostProcessor 接口起到什么作用"></a>Spring 的 PostProcessor 接口起到什么作用</h3><p>bean 初始化后回调，包括初始化前和初始化后的回调，例如 Apollo 的 ApolloConfig 注解，就是在初始化前增加监听器</p><h3 id="Spring-如何实现事务"><a href="#Spring-如何实现事务" class="headerlink" title="Spring 如何实现事务"></a>Spring 如何实现事务</h3><ol><li>ACID</li><li>隔离级别：读未提交、读已提交、可重复读、串行读</li><li>传播机制：require、support、mandatory、requires_new、not_support、never、nested</li><li>事务行为：事务开启、事务提交、事务回滚</li><li>事务切面：根据 ThreadLocal 获取是否有事务</li></ol><h3 id="如何在-Bean-对象中获取-ApllicationContext-上下文对象？"><a href="#如何在-Bean-对象中获取-ApllicationContext-上下文对象？" class="headerlink" title="如何在 Bean 对象中获取 ApllicationContext 上下文对象？"></a>如何在 Bean 对象中获取 ApllicationContext 上下文对象？</h3><p>实现 ApplicationContextAware，原理是读取配置文件（注解扫描）后调用 refresh()</p><p>refresh：调用 FactorypostProcessors，初始化事件、注册事件监听器、通知子类刷新容器、初始化单例对象。</p><h3 id="动态代理有哪些？JDK-动态代理和-cglib-有什么不同？"><a href="#动态代理有哪些？JDK-动态代理和-cglib-有什么不同？" class="headerlink" title="动态代理有哪些？JDK 动态代理和 cglib 有什么不同？"></a>动态代理有哪些？JDK 动态代理和 cglib 有什么不同？</h3><ol><li>JDK 代理：继承 Proxy，实现目标实现类的接口，将代理的方法都加上 final 修饰。在动态生成的实现类里面去调用 <code>InvocationHandler</code> 的 invoke 方法。</li><li>cglib：继承目标类，实现 Factory，通过回调钩子方法调用</li></ol><h3 id="为什么用-Spring-data-JPA-而不用-MyBatis，MQ-的选型、注册中心的选型、配置中心的选型、分库分表的选型、数据传输的选型（主要针对我的项目来问的）"><a href="#为什么用-Spring-data-JPA-而不用-MyBatis，MQ-的选型、注册中心的选型、配置中心的选型、分库分表的选型、数据传输的选型（主要针对我的项目来问的）" class="headerlink" title="为什么用 Spring data JPA 而不用 MyBatis，MQ 的选型、注册中心的选型、配置中心的选型、分库分表的选型、数据传输的选型（主要针对我的项目来问的）"></a>为什么用 Spring data JPA 而不用 MyBatis，MQ 的选型、注册中心的选型、配置中心的选型、分库分表的选型、数据传输的选型（主要针对我的项目来问的）</h3><h2 id="6-RPC-框架"><a href="#6-RPC-框架" class="headerlink" title="6. RPC 框架"></a>6. RPC 框架</h2><h3 id="1-Dubbo序列化，默认的序列化，各个序列化区别"><a href="#1-Dubbo序列化，默认的序列化，各个序列化区别" class="headerlink" title="1. Dubbo序列化，默认的序列化，各个序列化区别"></a>1. Dubbo序列化，默认的序列化，各个序列化区别</h3><h3 id="2-Dubbo泛化调用实现的网关优劣点"><a href="#2-Dubbo泛化调用实现的网关优劣点" class="headerlink" title="2. Dubbo泛化调用实现的网关优劣点"></a>2. Dubbo泛化调用实现的网关优劣点</h3><h3 id="3-Dubbo-消费者到提供者执行涉及的模块"><a href="#3-Dubbo-消费者到提供者执行涉及的模块" class="headerlink" title="3. Dubbo 消费者到提供者执行涉及的模块"></a>3. Dubbo 消费者到提供者执行涉及的模块</h3><h3 id="4-Dubbo-SPI"><a href="#4-Dubbo-SPI" class="headerlink" title="4. Dubbo SPI"></a>4. Dubbo SPI</h3><h3 id="5-Spring-Cloud-的-Eureka"><a href="#5-Spring-Cloud-的-Eureka" class="headerlink" title="5. Spring Cloud 的 Eureka"></a>5. Spring Cloud 的 Eureka</h3><p>内部服务注册表有双缓存：ReadWrite 缓存和 ReadOnly 缓存，会存在短时间内服务上线不可见的情况</p><h2 id="7-JVM-基础"><a href="#7-JVM-基础" class="headerlink" title="7. JVM 基础"></a>7. JVM 基础</h2><h3 id="jvm-内存结构介绍、代码调用过程中的内存流程"><a href="#jvm-内存结构介绍、代码调用过程中的内存流程" class="headerlink" title="jvm 内存结构介绍、代码调用过程中的内存流程"></a>jvm 内存结构介绍、代码调用过程中的内存流程</h3><p>堆 虚拟机栈 本地方法栈 程序计数器 元空间<br>栈帧的入栈出栈过程，与线程绑定，操作数栈用来记录操作位点<br>Java 文件被跨平台的虚拟机编译为 .class 二进制文件，接着加载类信息到方法区，验证，准备阶段初始化类变量为默认值，解析初始化卸载</p><h3 id="Java-如何分配内存，多线程呢？"><a href="#Java-如何分配内存，多线程呢？" class="headerlink" title="Java 如何分配内存，多线程呢？"></a>Java 如何分配内存，多线程呢？</h3><p>分为堆栈（栈上分配），每个线程一个线程栈，里面独立的有本地变量，共同引用了来自堆的对象</p><h3 id="JVM-的内存模型"><a href="#JVM-的内存模型" class="headerlink" title="JVM 的内存模型"></a>JVM 的内存模型</h3><ol><li>程序计数器</li><li>虚拟机栈</li><li>虚拟机堆</li><li>本地方法栈：栈上分配和逃逸分析以及 TLAB</li><li>元空间：取代了方法区，而且改为了直接内存，其中运行时常量池是其部分</li></ol><p>常见异常：OutOfMemoryError: GC Overhead Limit Exceeded/Java heap space/MetaSpace</p><p>方法区是接口，永久代是实现。</p><p>内存分配：指针碰撞、空闲列表。内存回收：引用计数、可达性分析</p><p>((20200925230314-cidbmyl “【11】JVM 基础入门”))</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类的加载过程：</p><ol><li>加载：指 JVM 读取 Class 文件，并且根据 Class 文件描述创建 java.lang.Class 对象的过程</li><li>验证：验证文件</li><li>准备：这时候进行内存分配的仅包括类变量（static），而不包括实例变量</li><li>解析：JVM 会将常量池中的符号引用替换为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量</li><li>初始化：执行类构造器 <code>&lt;clinit&gt; ()</code> 方法的过程</li><li>卸载：所有实例被回收、加载该类的 ClassLoader 被回收、Class 对象无法通过任何途径访问(包括反射)</li></ol><p>加载类的加载器：</p><ol><li>BootstrapClassLoader(启动类加载器)：最顶层的加载类，由 C++ 实现，负责加载 <code>%JAVA_HOME%/lib</code> 目录下的 jar 包和类或者或被 <code>-Xbootclasspath</code> 参数指定的路径中的所有类。</li><li>ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li>AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><p>双亲委派模型</p><p>((20200925230314-cidbmyl “【11】JVM 基础入门”))</p><h3 id="OOM-定位、解决方式，流程"><a href="#OOM-定位、解决方式，流程" class="headerlink" title="OOM 定位、解决方式，流程"></a>OOM 定位、解决方式，流程</h3><h3 id="gc-算法、扫描算法（优劣）、内存分区"><a href="#gc-算法、扫描算法（优劣）、内存分区" class="headerlink" title="gc 算法、扫描算法（优劣）、内存分区"></a>gc 算法、扫描算法（优劣）、内存分区</h3><h3 id="JVM-中如何扫描对象；（root、hotspot-算法-、cardTable）"><a href="#JVM-中如何扫描对象；（root、hotspot-算法-、cardTable）" class="headerlink" title="JVM 中如何扫描对象；（root、hotspot 算法)、cardTable）"></a>JVM 中如何扫描对象；（root、hotspot 算法)、cardTable）</h3><h3 id="GC-算法（复制、标记清除、标记整理、内存碎片及解决方式）"><a href="#GC-算法（复制、标记清除、标记整理、内存碎片及解决方式）" class="headerlink" title="GC 算法（复制、标记清除、标记整理、内存碎片及解决方式）"></a>GC 算法（复制、标记清除、标记整理、内存碎片及解决方式）</h3><h3 id="GC-异常"><a href="#GC-异常" class="headerlink" title="GC 异常"></a>GC 异常</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929880-bdb9096e-9d50-4414-ad6f-c4610b7b3f85.png#align=left&amp;display=inline&amp;height=1572&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1572&amp;originWidth=3010&amp;size=0&amp;status=done&amp;style=none&amp;width=3010" alt></p><h3 id="什么情况下类被初始化，什么情况下类不会被初始化"><a href="#什么情况下类被初始化，什么情况下类不会被初始化" class="headerlink" title="什么情况下类被初始化，什么情况下类不会被初始化"></a>什么情况下类被初始化，什么情况下类不会被初始化</h3><p>类被初始化：</p><ol><li>反射</li></ol><p>类不会被初始化：</p><ol><li>定义对象数组</li></ol><h2 id="8-缓存基础"><a href="#8-缓存基础" class="headerlink" title="8. 缓存基础"></a>8. 缓存基础</h2><h3 id="1-你在公司怎么用的缓存，为什么用缓存？那会出现什么问题（缓存击穿、穿透、雪崩）？"><a href="#1-你在公司怎么用的缓存，为什么用缓存？那会出现什么问题（缓存击穿、穿透、雪崩）？" class="headerlink" title="1. 你在公司怎么用的缓存，为什么用缓存？那会出现什么问题（缓存击穿、穿透、雪崩）？"></a>1. 你在公司怎么用的缓存，为什么用缓存？那会出现什么问题（缓存击穿、穿透、雪崩）？</h3><ol><li>在获取钉钉 token 时，使用的缓存，2 个小时过期，缓存 1 个小时 45 分钟，不用每次都去请求钉钉的 API。</li><li>在大规模情况下，会出现数据不一致以及缓存穿透、缓存雪崩。</li></ol><h3 id="2-Redis-为什么这么快，它的过期和淘汰策略是什么以及手写一个-LRU-算法"><a href="#2-Redis-为什么这么快，它的过期和淘汰策略是什么以及手写一个-LRU-算法" class="headerlink" title="2. Redis 为什么这么快，它的过期和淘汰策略是什么以及手写一个 LRU 算法"></a>2. Redis 为什么这么快，它的过期和淘汰策略是什么以及手写一个 LRU 算法</h3><p>IO 多路复用 + 队列 + 事件分发（单线程） + 多线程操作 + 纯内存操作</p><h3 id="3-Redis-高并发和高可用的集群原理"><a href="#3-Redis-高并发和高可用的集群原理" class="headerlink" title="3. Redis 高并发和高可用的集群原理"></a>3. Redis 高并发和高可用的集群原理</h3><ol><li>高并发：一主多从架构。</li><li>高可用：主从架构 + 哨兵。</li></ol><h3 id="4-Redis-持久化机制、底层原理是什么，有什么优劣？"><a href="#4-Redis-持久化机制、底层原理是什么，有什么优劣？" class="headerlink" title="4. Redis 持久化机制、底层原理是什么，有什么优劣？"></a>4. Redis 持久化机制、底层原理是什么，有什么优劣？</h3><ol><li>RDB：还可以做冷备，通过 runid 做 slave 的备份全量复制。按时间间隔全量备份写入磁盘。</li><li>AOF：后者保证数据不丢失（1 秒）。每次操作都会写入 os cache，然后每隔一段时间写入磁盘。当 AOF 大到一定程度会执行 rewrite 操作，基于当前内存数据重新构造一个 aof 文件，将旧的 aof 文件删掉。</li></ol><p>当同时开启了 RDB 和 AOF。重启时默认使用 AOF 恢复数据。因为 AOF 比 RDB 数据更完整。</p><p>RDB 优点：</p><ol><li>基于 fork 子进程，对于主进程影响小。</li><li>基于 RDB 恢复数据时速度更快。</li><li>而且生成的 RDB 文件可以放在分布式存储中。方便做冷热备份</li></ol><p>RDB 缺点：</p><ol><li>丢数据会更多</li><li>fork 子进程时，当快照文件过大时，会严重影响主进程。</li></ol><p>AOF 优点：</p><ol><li>默认间隔 1s ，丢失数据会更少</li><li>基于 append-only 写入，写入性能高</li></ol><p>AOF 缺点：</p><ol><li>因为 AOF 记录指令日志。所以AOF 文件比 RDB 文件大</li><li>影响写 QPS</li></ol><h3 id="5-集群中-Redis-key-如何寻址，寻址算法？hash-一致性算法"><a href="#5-集群中-Redis-key-如何寻址，寻址算法？hash-一致性算法" class="headerlink" title="5. 集群中 Redis key 如何寻址，寻址算法？hash 一致性算法"></a>5. 集群中 Redis key 如何寻址，寻址算法？hash 一致性算法</h3><p>寻址算法基于 hash slot 寻址。固定 16739 取余。</p><p>使用 redis cluster，而不是 replication + sentinel。redis cluster 针对海量数据+高并发+高可用场景。</p><p>redis cluster：自动将数据进行分片，每个 master 上放一部分数据。内部支持当 master 不可用时还可以继续工作。</p><p>redis cluster 不仅有 6379 端口，还有 16379 端口，用于集群间的通信。</p><p>hash 算法演进：hash-&gt;一致性hash（自动缓存迁移）+虚拟节点（解决负载均衡问题），当某个机器宕机，会影响部分机器-&gt;redis cluster的hash slot，固定有 16739 个 slot，直接基于这个 16739 取余，就算有机器宕机，还是基于 16739 取模，这样对其它机器无影响。</p><p>redis cluster 的节点通信：内部使用 gossip 协议进行通信，元数据分布式存储，好处在于每个节点都存储了元数据，缺点在于会通信同步的的延迟。</p><h3 id="6-缓存、数据库双写不一致问题"><a href="#6-缓存、数据库双写不一致问题" class="headerlink" title="6. 缓存、数据库双写不一致问题"></a>6. 缓存、数据库双写不一致问题</h3><p>先修改数据库、再删除缓存失败怎么办？这个时候先删缓存、再写数据。</p><ol><li>删缓存成功、写数据库失败。这样其它的请求过来虽然请求的数据库是旧数据，但是写入缓存之后，是一致的。</li><li>线程 1 在删缓存成功、写数据库减少过程中，线程 2 读缓存为空，读数据库为 1000，这时候就设置了缓存为 1000。线程 1 数据库减少 1，变成 999。使用内存队列，同一个商品 id、订单 id 取模进行分发操作缓存和数据库，实现原子化。</li><li>分布式，多机器下，内存队列单点热化，在 ng 层就实现负载。</li></ol><h3 id="7-Redis-并发写的问题，即顺序问题"><a href="#7-Redis-并发写的问题，即顺序问题" class="headerlink" title="7. Redis 并发写的问题，即顺序问题"></a>7. Redis 并发写的问题，即顺序问题</h3><p>解决方案在于分布式锁和数据库中的时间戳版本号，不要用旧版本号覆盖新的版本号即可。<img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929926-1a7b4c6a-1879-4de7-933e-a557ab014234.png#align=left&amp;display=inline&amp;height=851&amp;margin=%5Bobject%20Object%5D&amp;originHeight=851&amp;originWidth=1723&amp;size=0&amp;status=done&amp;style=none&amp;width=1723" alt></p><h3 id="8-公司的-Redis-架构，多少台，多少内存，多少核，CPU，主从架构，QPS？"><a href="#8-公司的-Redis-架构，多少台，多少内存，多少核，CPU，主从架构，QPS？" class="headerlink" title="8. 公司的 Redis 架构，多少台，多少内存，多少核，CPU，主从架构，QPS？"></a>8. 公司的 Redis 架构，多少台，多少内存，多少核，CPU，主从架构，QPS？</h3><h3 id="9-热点-key-的缓存，以及大对象的缓存问题解决。"><a href="#9-热点-key-的缓存，以及大对象的缓存问题解决。" class="headerlink" title="9. 热点 key 的缓存，以及大对象的缓存问题解决。"></a>9. 热点 key 的缓存，以及大对象的缓存问题解决。</h3><h3 id="10-Redis-pipline-是全双工还是半双工"><a href="#10-Redis-pipline-是全双工还是半双工" class="headerlink" title="10. Redis pipline 是全双工还是半双工"></a>10. Redis pipline 是全双工还是半双工</h3><h3 id="11-jedis-是否使用连接池，如何处理有序数据"><a href="#11-jedis-是否使用连接池，如何处理有序数据" class="headerlink" title="11. jedis 是否使用连接池，如何处理有序数据"></a>11. jedis 是否使用连接池，如何处理有序数据</h3><h3 id="12-Redis-数据结构类型及源码简述；"><a href="#12-Redis-数据结构类型及源码简述；" class="headerlink" title="12. Redis 数据结构类型及源码简述；"></a>12. Redis 数据结构类型及源码简述；</h3><h3 id="（String、Hash、ZSet、Set、Dict、GEO、HyperLogLog、BloomFilter、Stream、Bitmap-等）"><a href="#（String、Hash、ZSet、Set、Dict、GEO、HyperLogLog、BloomFilter、Stream、Bitmap-等）" class="headerlink" title="（String、Hash、ZSet、Set、Dict、GEO、HyperLogLog、BloomFilter、Stream、Bitmap 等）"></a>（String、Hash、ZSet、Set、Dict、GEO、HyperLogLog、BloomFilter、Stream、Bitmap 等）</h3><h3 id="13-Redis-并发竞争-Key-问题"><a href="#13-Redis-并发竞争-Key-问题" class="headerlink" title="13. Redis 并发竞争 Key 问题"></a>13. Redis 并发竞争 Key 问题</h3><ol><li>分布式锁</li><li>写入数据库的时候，需要保存一个时间戳。假设时间戳如下<br>系统 A key 1 {valueA 3:00}<br>系统 B key 1 {valueB 3:05}<br>系统 C key 1 {valueC 3:10}<br>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了</li></ol><h3 id="14-Redis-Replication-全量复制过程"><a href="#14-Redis-Replication-全量复制过程" class="headerlink" title="14. Redis Replication 全量复制过程"></a>14. Redis Replication 全量复制过程</h3><ol><li>master 执行 bgsave，本地生成 rdb 快照文件（通过配置可以设置文件是否落盘）</li><li>master -&gt; slave</li><li>master 在生成 rdb 过程中，期间的命令写入内存</li><li>如果复制过程中，内存写入数据过多（可配置）那么复制失败</li><li>slave 收到 rdb，清空旧数据，然后加载 rdb 到内存，并提供服务（此时是旧数据）</li><li>如果 slave 开启了 aof，那么会立即执行 bgrewriteaof，重写 aof。</li></ol><p>slave 第一次连接 master，会执行全复制。它们都会维护自己的 offset，slave 会上报到 master。<br>master 维护了 backlog，大约 1M，用来解决复制过程中的断传，后面进行增量。<br>当 master 回滚数据时，slave 会通过 run id 和 master 不同来发去全量复制。</p><h3 id="15-Redis-sentinel-机制"><a href="#15-Redis-sentinel-机制" class="headerlink" title="15. Redis sentinel 机制"></a>15. Redis sentinel 机制</h3><p>类似 zk 的功能，sentinel 自身高可用集群，用来监控 master 和 slave，负责 Redis 整体集群的高可用。</p><h3 id="16-Redis-的数据丢失和脑裂问题"><a href="#16-Redis-的数据丢失和脑裂问题" class="headerlink" title="16. Redis 的数据丢失和脑裂问题"></a>16. Redis 的数据丢失和脑裂问题</h3><p>问题：由于 master-&gt;slave 异步，可能会丢失<br>解决：min-salves-write 和 min-slaves-max-log 配置，如果 slave 复制和 ack 延迟太长，master 拒绝写请求，保证数据不会丢，此时客户端可以将数据临时写入 MQ，定时任务将 MQ 刷入 Redis<br>问题：由于网络分区，多个 Redsi 集群互不通信，有多个 Master 接收写入，当脑裂恢复后，其它 Master 的数据会丢失。<br>问题：和丢失数据解决方案相同，如果 slave 和 master ack 延迟过大，直接拒绝请求，不会导致消息丢失过多。</p><h3 id="17-Redis-实现分布式锁的几种方式，优劣"><a href="#17-Redis-实现分布式锁的几种方式，优劣" class="headerlink" title="17. Redis 实现分布式锁的几种方式，优劣"></a>17. Redis 实现分布式锁的几种方式，优劣</h3><h3 id="18-Redis-分片"><a href="#18-Redis-分片" class="headerlink" title="18. Redis 分片"></a>18. Redis 分片</h3><ol><li>客户端分片</li><li>代理分片</li><li>一致性hash</li><li>虚拟节点分片</li></ol><h3 id="19-sentinel-的作用，以及选举-slave-为-master-过程"><a href="#19-sentinel-的作用，以及选举-slave-为-master-过程" class="headerlink" title="19. sentinel 的作用，以及选举 slave 为 master 过程"></a>19. sentinel 的作用，以及选举 slave 为 master 过程</h3><p>sentinel 三大作用：</p><ol><li>集群监控：监控 master 和 slave 进程是否正常工作</li><li>消息通知：某个实例有问题，可以报警给管理员</li><li>故障转移：master 故障则转移到 slave 中</li></ol><ol><li>sentinel 觉得 master 宕机，主观宕机</li><li>大多数 sentienl 觉得 master 宕机，客观宕机</li><li>选举 master 的考虑优先级：<ol><li>跟 master 断开时长</li><li>slave 优先级（配置文件slave priority）</li><li>复制的 offset（复制进度）</li><li>run id</li></ol></li></ol><h2 id="9-数据库"><a href="#9-数据库" class="headerlink" title="9. 数据库"></a>9. 数据库</h2><h3 id="1-MySQL-索引类型有多少种"><a href="#1-MySQL-索引类型有多少种" class="headerlink" title="1. MySQL 索引类型有多少种"></a>1. MySQL 索引类型有多少种</h3><ol><li>主键索引：alter table table_name add primary key_name(<code>column</code>)</li><li>唯一索引：alter table table_name add unique(<code>column</code>)</li><li>普通索引：alter table table_name add index index_name (<code>column</code> )</li><li>全文索引：alter table table_name add fulltext (<code>column</code>)</li></ol><p>聚簇索引：索引结构和数据一起存放，例如主键索引叶子节点就存了数据，其中 innodb 的 .ibd 文件就包含了该表的索引和数据。</p><p>非聚簇索引：索引结构和数据分开存放，例如 MYISAM 的 .MYI 文件包含了表的索引，叶子节点存储索引和索引对应数据的指针，指向 .MYD 文件的数据。</p><blockquote><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong><br>聚簇索引缺点：依赖有序数据，更新代价大（数据被修改索引也被修改）<br>非聚簇索引缺点：依赖有序数据，回表查（回查 .MYD 数据文件）</p></blockquote><p>其中主键索引叶子节点存 data（聚簇索引，），二级索引叶子节点存主键 key，再回查主键索引树</p><h3 id="2-MySQL-索引的使用与优化"><a href="#2-MySQL-索引的使用与优化" class="headerlink" title="2. MySQL 索引的使用与优化"></a>2. MySQL 索引的使用与优化</h3><p>覆盖索引、不回表、最左前缀、索引字段选择、数据量大时，优化器可能会使用不好的索引需要使用 force index</p><h3 id="3-MyBatis-是如何执行-SQL-语句的"><a href="#3-MyBatis-是如何执行-SQL-语句的" class="headerlink" title="3. MyBatis 是如何执行 SQL 语句的"></a>3. MyBatis 是如何执行 SQL 语句的</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/203689/1608223929891-e6c0b11d-444b-46fc-8ec8-f5530553c8cf.png#align=left&amp;display=inline&amp;height=1114&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1114&amp;originWidth=1076&amp;size=0&amp;status=done&amp;style=none&amp;width=1076" alt></p><p>SQLSessionFactory-&gt;SqlSession-&gt;Executor-&gt;StatementHandler-&gt;ParameterHandler-&gt;TypeHandler-&gt;ResultSetHandler</p><p>其中二级缓存在解析 mapper 标签时创建，接着再 CachingExecutor 里面的 <code>TransactionalCacheManager</code> 中保存了这个引用，也就是跨 sqlsession（同时也是跨 executor 的，因为创建 sqlsession 时 executor 也会创建新的）。</p><h3 id="4-JDBC-获取数据库连接的大概过程（从-getConnection-开始）"><a href="#4-JDBC-获取数据库连接的大概过程（从-getConnection-开始）" class="headerlink" title="4. JDBC 获取数据库连接的大概过程（从 getConnection 开始）"></a>4. JDBC 获取数据库连接的大概过程（从 getConnection 开始）</h3><ol><li>导包</li><li>反射注册驱动</li><li>打开连接获取 connection</li><li>执行查询，statement</li><li>获取结果集</li><li>释放资源</li></ol><h3 id="5-PreparedStatement-和-Statement-区别"><a href="#5-PreparedStatement-和-Statement-区别" class="headerlink" title="5. PreparedStatement 和 Statement 区别"></a>5. PreparedStatement 和 Statement 区别</h3><p>prepareStatement 继承自 Statement，会先初始化 SQL，先把这个 SQL 提交到数据库中进行预处理，prepareStatement 可以在 SQL 中用？替换变量；</p><p>而 Statement 直接 SQL 编译，执行一次编译一次，而且存在 SQL 注入风险</p><h3 id="6-MyBatis-的一些-API-接口，比如-SqlSession、sessionFactory-等等"><a href="#6-MyBatis-的一些-API-接口，比如-SqlSession、sessionFactory-等等" class="headerlink" title="6. MyBatis 的一些 API 接口，比如 SqlSession、sessionFactory 等等"></a>6. MyBatis 的一些 API 接口，比如 SqlSession、sessionFactory 等等</h3><ol><li>参数处理：ParameterHandler</li><li>结果集处理：ResultSetHandler</li><li>statement 实例：StatementHandler（PreparedStatment/Statement/CallableStatement），例如设置超时时间返回行数</li><li>执行器：Executor，模板模式，例如 缓存，事务，连接</li></ol><h3 id="7-线上为什么用-RR-级别"><a href="#7-线上为什么用-RR-级别" class="headerlink" title="7. 线上为什么用 RR 级别"></a>7. 线上为什么用 RR 级别</h3><h3 id="8-请问是不是每次连接数据库都创建一个连接？线程池你都有哪些了解？有接触过哪些线程池？"><a href="#8-请问是不是每次连接数据库都创建一个连接？线程池你都有哪些了解？有接触过哪些线程池？" class="headerlink" title="8. 请问是不是每次连接数据库都创建一个连接？线程池你都有哪些了解？有接触过哪些线程池？"></a>8. 请问是不是每次连接数据库都创建一个连接？线程池你都有哪些了解？有接触过哪些线程池？</h3><h3 id="9-数据库联表查询时，左连接和右连接的区别"><a href="#9-数据库联表查询时，左连接和右连接的区别" class="headerlink" title="9. 数据库联表查询时，左连接和右连接的区别"></a>9. 数据库联表查询时，左连接和右连接的区别</h3><h3 id="10-说说-MySQL-的七种事务隔离级别"><a href="#10-说说-MySQL-的七种事务隔离级别" class="headerlink" title="10. 说说 MySQL 的七种事务隔离级别"></a>10. 说说 MySQL 的七种事务隔离级别</h3><h3 id="11-MVCC"><a href="#11-MVCC" class="headerlink" title="11. MVCC"></a>11. MVCC</h3><h2 id="10-APM"><a href="#10-APM" class="headerlink" title="10. APM"></a>10. APM</h2><h3 id="1-skywalking-基本架构"><a href="#1-skywalking-基本架构" class="headerlink" title="1. skywalking 基本架构"></a>1. skywalking 基本架构</h3><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="云原生是什么"><a href="#云原生是什么" class="headerlink" title="云原生是什么"></a>云原生是什么</h3><h3 id="一致性-Hash-算法详解"><a href="#一致性-Hash-算法详解" class="headerlink" title="一致性 Hash 算法详解"></a>一致性 Hash 算法详解</h3><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h3 id="你是通过什么方式进行学习的？"><a href="#你是通过什么方式进行学习的？" class="headerlink" title="你是通过什么方式进行学习的？"></a>你是通过什么方式进行学习的？</h3><h3 id="随便讲个源码组件源码结构及内部核心原理"><a href="#随便讲个源码组件源码结构及内部核心原理" class="headerlink" title="随便讲个源码组件源码结构及内部核心原理"></a>随便讲个源码组件源码结构及内部核心原理</h3><h3 id="自己技术发展方向"><a href="#自己技术发展方向" class="headerlink" title="自己技术发展方向"></a>自己技术发展方向</h3><h3 id="读过什么组件源码-Redis、JVM、MyBatis、Spring-及相关基本都读过、sharding-jdbc-等）"><a href="#读过什么组件源码-Redis、JVM、MyBatis、Spring-及相关基本都读过、sharding-jdbc-等）" class="headerlink" title="读过什么组件源码 Redis、JVM、MyBatis、Spring 及相关基本都读过、sharding-jdbc 等）"></a>读过什么组件源码 Redis、JVM、MyBatis、Spring 及相关基本都读过、sharding-jdbc 等）</h3><h3 id="看什么书"><a href="#看什么书" class="headerlink" title="看什么书"></a>看什么书</h3>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
          <category> 其它爱好 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
